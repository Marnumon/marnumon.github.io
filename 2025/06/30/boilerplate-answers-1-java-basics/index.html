<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Courgette:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"marnumon.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.23.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>



<link rel="canonical" href="https://marnumon.github.io/2025/06/30/boilerplate-answers-1-java-basics/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://marnumon.github.io/2025/06/30/boilerplate-answers-1-java-basics/","path":"2025/06/30/boilerplate-answers-1-java-basics/","title":"八股文笔记 #1 Java 基础"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>八股文笔记 #1 Java 基础 | marnu's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>





  <script src="/js/third-party/pace.js" defer></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">marnu's blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%AF%B4%E4%B8%80%E4%B8%8B-Java-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">1# 说一下 Java 的特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Java-%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E5%8A%A3%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">2# Java 的优势和劣势是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Java-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84%EF%BC%9F"><span class="nav-text">3# Java 为什么是跨平台的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-JVM%E3%80%81JDK%E3%80%81JRE-%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-text">4# JVM、JDK、JRE 三者关系？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88-Java-%E8%A7%A3%E9%87%8A%E5%92%8C%E7%BC%96%E8%AF%91%E9%83%BD%E6%9C%89%EF%BC%9F"><span class="nav-text">5# 为什么 Java 解释和编译都有？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-JVM-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">6# JVM 是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">7# 编译型语言和解释型语言的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-Java-%E5%92%8C-Python-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">8# Java 和 Python 的区别是什么？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-8-%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">1# 8 种基本的数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-long-%E5%92%8C-int-%E5%8F%AF%E4%BB%A5%E4%BA%92%E8%BD%AC%E5%90%97%EF%BC%9F"><span class="nav-text">2# long 和 int 可以互转吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">3# 数据类型转换的方式有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%B1%BB%E5%9E%8B%E4%BA%92%E8%BD%AC%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">4# 类型互转可能会出现什么问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-BigDecimal-%E4%B8%8D%E7%94%A8-double%EF%BC%9F"><span class="nav-text">5# 为什么用 BigDecimal 不用 double？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">6# 装箱和拆箱是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%9F"><span class="nav-text">Java 为什么要有包装类？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E4%BF%9D%E7%95%99%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="nav-text">7# 为什么还要保留基本数据类型？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E8%AF%B4%E4%B8%80%E4%B8%8B-Integer-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BC%93%E5%AD%98"><span class="nav-text">8# 说一下 Integer 的基本缓存</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9F%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81"><span class="nav-text">1# 怎么理解面向对象？简单说说封装、继承、多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%A4%9A%E6%80%81%E4%BD%93%E7%8E%B0%E5%9C%A8%E5%93%AA%E5%87%A0%E4%B8%AA%E6%96%B9%E9%9D%A2%EF%BC%9F"><span class="nav-text">2# 多态体现在哪几个方面？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%A4%9A%E6%80%81%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">3# 多态解决了什么问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">4# 面向对象的设计原则有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%99%AE%E9%80%9A%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">5# 抽象类和普通类的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">6# 抽象类和接口的区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%83%BD%E5%8A%A0-final-%E4%BF%AE%E9%A5%B0%E5%90%97%EF%BC%9F"><span class="nav-text">7# 抽象类能加 final 修饰吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E6%8E%A5%E5%8F%A3%E9%87%8C%E9%9D%A2%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="nav-text">8# 接口里面可以定义哪些方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%90%97%EF%BC%9F"><span class="nav-text">9# 抽象类可以被实例化吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E6%8E%A5%E5%8F%A3%E5%8F%AF%E4%BB%A5%E5%8C%85%E5%90%AB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F"><span class="nav-text">10# 接口可以包含构造函数吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E8%A7%A3%E9%87%8A-Java-%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-text">11# 解释 Java 中的静态变量和静态方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">12# 非静态内部类和静态内部类的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95%EF%BC%8C%E7%BC%96%E8%AF%91%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E5%88%B0%E7%9A%84%EF%BC%9F"><span class="nav-text">13# 非静态内部类可以直接访问外部类的实例变量和方法，编译器是怎么做到的？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Java-%E4%B8%AD-final-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">1# Java 中 final 的作用是什么？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-text">浅拷贝和深拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">1# 浅拷贝和深拷贝的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">2# 实现深拷贝的三种方法是什么?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%EF%BC%9F"><span class="nav-text">1# 什么是泛型？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B3%9B%E5%9E%8B%EF%BC%9F"><span class="nav-text">2# 为什么需要泛型？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1"><span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Java-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-text">1# Java 创建对象有哪些方式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-new-%E5%87%BA%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="nav-text">2# new 出的对象什么时候回收？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E7%A7%81%E6%9C%89%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="nav-text">3# 如何获取私有对象？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F"><span class="nav-text">1# 什么是反射？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%8F%8D%E5%B0%84%E5%9C%A8%E4%BD%A0%E5%B9%B3%E6%97%B6%E5%86%99%E4%BB%A3%E7%A0%81%E6%88%96%E8%80%85%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">2# 反射在你平时写代码或者框架中的应用场景有哪些？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-text">注解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%83%BD%E8%AE%B2%E4%B8%80%E8%AE%B2%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9F"><span class="nav-text">1# 能讲一讲注解的原理吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%AF%B9%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-text">2# 对注解解析的底层实现了解吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%B3%A8%E8%A7%A3%E7%9A%84%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4%EF%BC%88Target%EF%BC%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">3# 注解的适用范围（Target）是什么？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-Java-%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="nav-text">1# 介绍一下 Java 的异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Java-%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">2# Java 的异常处理方式有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8-throws%EF%BC%9F"><span class="nav-text">3# 抛出异常为什么不用 throws？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-try-catch-%E4%B8%AD%E7%9A%84%E8%AF%AD%E5%8F%A5%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5"><span class="nav-text">4# try-catch 中的语句运行情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-try-return-%E2%80%9Ca%E2%80%9D-finally-return-%E2%80%9Cb%E2%80%9D-%E8%BF%94%E5%9B%9E%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">5# try { return “a” } finally { return “b” } 返回什么？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Object"><span class="nav-text">Object</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%B8%8E-equals-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">1# &#x3D;&#x3D; 与 equals() 有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-hashCode-%E5%92%8C-equals-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-text">2# hashCode() 和 equals() 方法有什么关系？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-String%E3%80%81StringBuilder%E3%80%81StringBuffer-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="nav-text">3# String、StringBuilder、StringBuffer 的区别和联系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text">Java 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Java-8-%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="nav-text">1# Java 8 有什么新特性？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-text">2# Lambda 表达式了解吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-Stream-API"><span class="nav-text">3# 介绍一下 Stream API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Stream-%E6%B5%81%E7%9A%84%E5%B9%B6%E8%A1%8C-API-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">4# Stream 流的并行 API 是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-CompletableFuture-%E6%80%8E%E4%B9%88%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="nav-text">5# CompletableFuture 怎么用的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Java-21-%E6%96%B0%E7%89%B9%E6%80%A7%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">6# Java 21 新特性知道哪些？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-text">序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%80%8E%E4%B9%88%E6%8A%8A%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%BB%8E%E4%B8%80%E4%B8%AA-JVM-%E8%BD%AC%E7%A7%BB%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA-JVM"><span class="nav-text">1# 怎么把一个对象从一个 JVM 转移到另一个 JVM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%AE%A9%E4%BD%A0%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%81%9A"><span class="nav-text">2# 让你自己实现序列化和反序列化，你会怎么做?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%B0%86%E5%AF%B9%E8%B1%A1%E8%BD%AC%E4%B8%BA%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E8%8A%82%E6%B5%81%E5%85%B7%E4%BD%93%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="nav-text">3# 将对象转为二进制字节流具体怎么实现?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-volatile-%E5%92%8C-sychronized-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-text">1# volatile 和 sychronized 如何实现单例模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">2# 代理模式和适配器模式有什么区别？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IO"><span class="nav-text">IO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Java-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C-IO-%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9F"><span class="nav-text">1# Java 怎么实现网络 IO 高并发编程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-BIO%E3%80%81NIO%E3%80%81AIO%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">2# BIO、NIO、AIO区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-NIO-%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="nav-text">3# NIO 是怎么实现的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%BD%A0%E7%9F%A5%E9%81%93%E6%9C%89%E5%93%AA%E4%B8%AA%E6%A1%86%E6%9E%B6%E7%94%A8%E5%88%B0-NIO-%E4%BA%86%E5%90%97%EF%BC%9F"><span class="nav-text">4# 你知道有哪个框架用到 NIO 了吗？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AD%A6%E7%94%9F%E7%B1%BB%EF%BC%8C%E6%83%B3%E6%8C%89%E7%85%A7%E5%88%86%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%86%8D%E6%8C%89%E5%AD%A6%E5%8F%B7%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="nav-text">1# 有一个学生类，想按照分数排序，再按学号排序，应该怎么做？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B-native-%E6%96%B9%E6%B3%95"><span class="nav-text">2# 解释一下 native 方法</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Marnumon"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Marnumon</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Marnumon" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Marnumon" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/84063541" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;84063541" rel="noopener me" target="_blank"><i class="fab fa-bilibili fa-fw"></i>Bilibili</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://bobnlp.site/" title="https:&#x2F;&#x2F;bobnlp.site" rel="noopener" target="_blank">bobnlp</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://marnumon.github.io/2025/06/30/boilerplate-answers-1-java-basics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Marnumon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="marnu's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="八股文笔记 #1 Java 基础 | marnu's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          八股文笔记 #1 Java 基础
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-06-30 11:45:37" itemprop="dateCreated datePublished" datetime="2025-06-30T11:45:37+00:00">2025-06-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-08 01:12:14" itemprop="dateModified" datetime="2025-09-08T01:12:14+00:00">2025-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>19k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:10</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p><del>再好的项目，也敌不过 HashMap 的 resize 过程没讲清楚</del></p>
<span id="more"></span>

<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="1-说一下-Java-的特点"><a href="#1-说一下-Java-的特点" class="headerlink" title="1# 说一下 Java 的特点"></a>1# 说一下 Java 的特点</h2><ol>
<li><strong>平台无关性</strong>：Java 的 “编写一次，运行无处不在” 哲学是其最大的特点之一。Java 编译器将源代码编译成字节码，该字节码可以在任何安装了 JVM 的系统上运行</li>
<li><strong>面向对象</strong>：Java 是一门严格的面向对象的编程语言，几乎一切都是对象。OOP 特性使得代码更易于维护和复用，包括类、对象、继承、多态、抽象和封装</li>
<li><strong>内存管理</strong>：Java 有自己的垃圾回收机制，自动管理内存和回收不再使用的对象</li>
</ol>
<h2 id="2-Java-的优势和劣势是什么？"><a href="#2-Java-的优势和劣势是什么？" class="headerlink" title="2# Java 的优势和劣势是什么？"></a>2# Java 的优势和劣势是什么？</h2><p><strong>优势</strong>：</p>
<ol>
<li><strong>跨平台</strong>：因为 JVM 的存在，一次编写到处运行</li>
<li><strong>面向对象</strong>：虽然现在很多语言都支持面向对象，但是 Java 的设计从一开始就是 OPP 的</li>
<li><strong>强大的生态</strong>：比如 Spring 框架，各种库和工具，社区支持大，企业应用广泛</li>
<li><strong>内存管理</strong>：自动垃圾回收机制，减少了内存泄漏的问题，对开发者友好</li>
<li><strong>多线程支持</strong>：内置的线程机制，方便并发编程</li>
<li><strong>安全性</strong>：Java 有安全模型，比如沙箱机制，适合网络环境</li>
<li><strong>稳定性</strong>：企业级应用长期使用，版本更新也比较注重向后兼容</li>
</ol>
<p><strong>劣势</strong>：</p>
<ol>
<li><strong>性能</strong>：虽然 JVM 优化了很多，但相比 CPP 和 Rust 这种原生编译语言，还是有一定开销</li>
<li><strong>启动时间</strong>：比如微服务场景下，可能不如 Go 之类的快</li>
<li><strong>语法繁琐</strong>：样板代码多，之前没有 lambda 的时候更麻烦，现在有了但是相比 Python 还是不够简洁</li>
<li><strong>内存消耗</strong>：JVM 本身占内存，对于资源有限的环境可能不太友好</li>
<li><strong>面向对象过于严格</strong>：有时候写简单程序反而麻烦，虽然 Java 8 引入了函数式编程，但是不如其他语言自然</li>
<li><strong>开发效率</strong>：相比动态语言如 Python，Java需要更多代码，编译过程也可能拖慢开发节奏</li>
</ol>
<h2 id="3-Java-为什么是跨平台的？"><a href="#3-Java-为什么是跨平台的？" class="headerlink" title="3# Java 为什么是跨平台的？"></a>3# Java 为什么是跨平台的？</h2><p>主要依赖于 JVM。JVM也是一个软件，不同平台有不同的版本。编写的 Java 源码在编译后生成一种 <code>.class</code> 文件，称为字节码文件。JVM 就是负责将机器码文件翻译成特定平台下的机器码然后运行</p>
<p>也就是说，只要在不同平台上安装对应的 JVM，就可以运行字节码文件，运行我们编写的 Java 程序</p>
<p>PS：不同平台下编译生成的字节码是一样的，但是由 JVM 翻译成的机器码是不一样的；即使将 Java 程序打包成可执行文件（如 <code>.exe</code>），仍然需要 JVM 的支持；跨平台的是 Java 程序，不是 JVM，JVM 是用 C&#x2F;CPP 开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的 JVM</p>
<h2 id="4-JVM、JDK、JRE-三者关系？"><a href="#4-JVM、JDK、JRE-三者关系？" class="headerlink" title="4# JVM、JDK、JRE 三者关系？"></a>4# JVM、JDK、JRE 三者关系？</h2><img src="https://cdn.xiaolincoding.com//picgo/image-20240725230247664.png" alt="JVM、JDK、JRE 关系图" style="zoom: 33%;" />

<ul>
<li>JDK 是 Java 开发工具包，是开发 Java 程序所需的工具集合。它包含了 JVM、编译器（javac）、调试器（jdb）等开发工具，以及一系列的类库（如 Java 标准库和开发工具库）。JDK 提供了开发、编译、调试和运行 Java 程序所需的全部工具和环境</li>
<li>JRE 是 Java 运行时环境，是 Java 程序运行所需的最小环境。它包含了 JVM 和 一组 Java 类库，用于支持 Java 程序的执行。JRE 不包含开发工具，只提供 Java 程序运行所需的运行环境</li>
<li>JVM 是 Java 虚拟机，是 Java 程序运行的环境。它负责将 Java 字节码（由 Java 编译器生成）解释或编译成机器码，并执行程序。JVM 提供了内存管理、垃圾回收、安全性等功能，使得 Java 程序具备跨平台性</li>
</ul>
<h2 id="5-为什么-Java-解释和编译都有？"><a href="#5-为什么-Java-解释和编译都有？" class="headerlink" title="5# 为什么 Java 解释和编译都有？"></a>5# 为什么 Java 解释和编译都有？</h2><p>在 Java 经过编译之后生成字节码文件，接下来进入 JVM 中，就有两个步骤编译和解释，如图：</p>
<img src="https://cdn.xiaolincoding.com//picgo/1715928000183-44fc6130-8abc-4f0b-8f6d-79de0ab09509.webp" alt="Java 源码执行过程" style="zoom: 67%;" />

<ul>
<li><p><strong>编译性</strong>：Java 源码（<code>.java</code> 文件）通过 <code>javac</code> 编译，生成字节码文件（<code>.class</code>）</p>
</li>
<li><p><strong>解释性</strong>：早期 JVM 使用<strong>解释器</strong>，逐行解释执行字节码。现代 JVM 引入 <strong>JIT（Just-In-Time）编译器</strong>，热点代码会被编译为本地机器码提高执行效率</p>
</li>
</ul>
<p>所以 Java 既是编译型语言，也是解释型语言，默认采用的是解释器和编译器混合的模式</p>
<h2 id="6-JVM-是什么？"><a href="#6-JVM-是什么？" class="headerlink" title="6# JVM 是什么？"></a>6# JVM 是什么？</h2><p>JVM 是 Java 虚拟机，主要工作是解释自己的指令集（即字节码）并映射到本地的 CPU 指令集和 OS 的系统调用</p>
<p>JVM 屏蔽了与操作系统平台相关的信息，使得 Java 程序只需要生成在 Java 虚拟机上运行的目标代码（字节码），就可在多种平台上不加修改地运行，这也是 Java 能够 “一次编译，到处运行” 的原因</p>
<h2 id="7-编译型语言和解释型语言的区别？"><a href="#7-编译型语言和解释型语言的区别？" class="headerlink" title="7# 编译型语言和解释型语言的区别？"></a>7# 编译型语言和解释型语言的区别？</h2><ul>
<li><p><strong>编译型语言</strong>：在程序执行之前，整个源码会被编译成字节码或机器码，生成可执行文件。执行时直接运行编译后的代码，速度快，但跨平台性较差</p>
</li>
<li><p><strong>解释型语言</strong>：在程序执行时，逐行解释执行源码，不生成独立的可执行文件。通常由解释器动态解释并执行代码，跨平台性好，但执行速度相对较慢</p>
</li>
</ul>
<p>典型的编译型语言如 C、CPP，典型的解释型语言如 Python、JavaScript</p>
<h2 id="8-Java-和-Python-的区别是什么？"><a href="#8-Java-和-Python-的区别是什么？" class="headerlink" title="8# Java 和 Python 的区别是什么？"></a>8# Java 和 Python 的区别是什么？</h2><ul>
<li>Java 是一种先编译后解释的混合型语言，Java 编译器将源码编译为字节码，而字节码则由 Java 虚拟机执行</li>
<li>Python 是一种解释型语言，会在执行程序的同时进行解释</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="1-8-种基本的数据类型"><a href="#1-8-种基本的数据类型" class="headerlink" title="1# 8 种基本的数据类型"></a>1# 8 种基本的数据类型</h2><ul>
<li><strong>数值型</strong>：整数类型（<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>）和浮点类型（<code>float</code>、<code>double</code>）</li>
<li><strong>字符型</strong>：<code>char</code></li>
<li><strong>布尔型</strong>：<code>boolean</code></li>
</ul>
<p>8 种基本数据类型的占用大小、取值范围、默认值，如下表所示：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>占用大小（字节）</th>
<th>取值范围</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>byte</code></td>
<td>1</td>
<td><code>-2^7</code> 到 <code>2^7 - 1</code></td>
<td>0</td>
<td>最小的整数类型，适合用于节省内存，例如在处理文件或网络流时存储小范围整数数据</td>
</tr>
<tr>
<td><code>short</code></td>
<td>2</td>
<td><code>-2^15</code> 到 <code>2^15 - 1</code></td>
<td>0</td>
<td>较少使用，通常用于在需要节省内存且数据范围在该区间的场景</td>
</tr>
<tr>
<td><code>int</code></td>
<td>4</td>
<td><code>-2^31</code>到 <code>2^31 - 1</code></td>
<td>0</td>
<td>最常用的整数类型，可满足大多数日常编程种整数计算的需求</td>
</tr>
<tr>
<td><code>long</code></td>
<td>8</td>
<td><code>-2^63</code>到 <code>2^63 - 1</code></td>
<td>0L</td>
<td>用于表示非常大的整数，当 <code>int</code> 类型无法满足需求时使用，定义时数值后需加 <code>L</code> 或 <code>l</code></td>
</tr>
<tr>
<td><code>float</code></td>
<td>4</td>
<td><code>-2^31</code>到 <code>2^31 - 1</code></td>
<td>0.0f</td>
<td>单精度浮点数，用于表示小数，定义时数值后需加 <code>F</code> 或 <code>f</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td>8</td>
<td><code>-2^63</code>到 <code>2^63 - 1</code></td>
<td>0.0d</td>
<td>双精度浮点数，精度比 <code>float</code> 高，是 Java 种表示小数的默认类型</td>
</tr>
<tr>
<td><code>char</code></td>
<td>2</td>
<td><code>-2^15</code> 到 <code>2^15 - 1</code></td>
<td>‘\u0000’</td>
<td>用于表示单个字符，采用 Unicode编码，可表示各种语言的字符</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>不确定（理论上1位）</td>
<td><code>true</code> 或 <code>false</code></td>
<td><code>false</code></td>
<td>用于逻辑判断，只有两个取值，常用于条件判断和循环控制等逻辑场景</td>
</tr>
</tbody></table>
<p><code>float</code> 和 <code>double</code> 的最小值和最大值是以科学计数法的形式输出的，比如 3.14E3 表示 3.14 * 10^3，3.14E-3 表示 3.14 &#x2F; 10^3</p>
<p>注意：</p>
<ul>
<li>浮点数的默认类型是 <code>double</code>，声明 <code>float</code> 时必须在末尾加上 <code>F</code> 或 <code>f</code></li>
<li>整数的默认类型为 <code>int</code>，声明 <code>long</code> 时必须在末尾加上 <code>L</code> 或 <code>l</code></li>
<li><code>char</code> 的包装类是 <code>Character</code>，<code>int</code> 的是 <code>Integer</code>，其他都是首字母大写</li>
<li><code>char</code> 是无符号的，不能为负，所以是 0 开始的</li>
</ul>
<h2 id="2-long-和-int-可以互转吗？"><a href="#2-long-和-int-可以互转吗？" class="headerlink" title="2# long 和 int 可以互转吗？"></a>2# long 和 int 可以互转吗？</h2><p><strong>可以</strong>。由于 <code>long</code> 的范围比 <code>int</code> 大，因此将 <code>int</code> 转换为 <code>long</code> 是安全的，而将 <code>long</code> 转换为 <code>int</code> 可能会导致数据丢失或溢出</p>
<p>将 <code>int</code> 转换为 <code>long</code> 可以通过直接赋值或强制类型转换来实现。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">longValue</span> <span class="operator">=</span> intValue; <span class="comment">// 自动转换，安全的</span></span><br></pre></td></tr></table></figure>

<p>将 <code>long</code> 转换为 <code>int</code> 需要使用强制类型转换，但需要注意潜在的数据丢失或溢出问题。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">longValue</span> <span class="operator">=</span> <span class="number">100L</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> (<span class="type">int</span>) longValue; <span class="comment">// 强制类转换，可能会有数据丢失或溢出</span></span><br></pre></td></tr></table></figure>

<p>如果 <code>longValue</code> 的值超出了 <code>int</code> 的范围，转换结果是截断后的低位部分。因此，在转换之前，建议先检查 <code>longValue</code> 的值是否在 <code>int</code> 范围内，以避免数据丢失或溢出的问题</p>
<h2 id="3-数据类型转换的方式有哪些？"><a href="#3-数据类型转换的方式有哪些？" class="headerlink" title="3# 数据类型转换的方式有哪些？"></a>3# 数据类型转换的方式有哪些？</h2><ol>
<li><strong>自动类型转换（隐式转换）</strong>：当目标类型的范围大于源类型时，Java 会自动将源类型转换为目标类型，不需要显示的类型转换。例如：将 <code>int</code> 转换为 <code>long</code>、将 <code>float</code> 转换为 <code>double</code> 等</li>
<li><strong>强制类型转换（显示转换）</strong>：当目标类型的范围小于源类型时，需要使用强制类型转换将源类型转换为目标类型。这可能导致数据丢失或溢出。例如：将 <code>long</code> 转换为 <code>int</code> 、将 <code>double</code> 转换为 <code>float</code> 等。语法为：目标类型 变量名 &#x3D; (目标类型) 源类型</li>
<li><strong>字符串转换</strong>：Java 提供了将字符串表示的数据转换为其他类型数据的方法。例如，将字符串转换为整型 <code>int</code>，可以使用 <code>Integer.parseInt()</code> 方法；将字符串转换为浮点型 <code>double</code>，可以使用 <code>Double.parseDouble()</code> 方法等</li>
<li><strong>数值之间的转换</strong>：Java 提供了一些数据类型之间的转换方法，如将整型转换为字符型、将字符型转换为整型等。这些转换方式可以通过类型的包装类来实现，例如：将 <code>int</code> 转换为 <code>char</code>，可以使用 <code>Character.forDigit()</code> 方法；将 <code>char</code> 转换为 <code>int</code>，可以使用 <code>Character.getNumericValue()</code> 方法</li>
</ol>
<h2 id="4-类型互转可能会出现什么问题？"><a href="#4-类型互转可能会出现什么问题？" class="headerlink" title="4# 类型互转可能会出现什么问题？"></a>4# 类型互转可能会出现什么问题？</h2><ol>
<li><strong>数据丢失</strong>：当将一个范围较大的数据类型转换为一个范围较小的数据类型时，可能会发生数据丢失。例如：将一个 <code>long</code> 转换为 <code>int</code> 时，如果 <code>long</code> 值超出了 <code>int</code> 类型的范围，转换结果将是截断后的低位部分，高位部分的数据丢失</li>
<li><strong>数据溢出</strong>：与数据丢失相反，当将一个范围较小的数据类型转换为一个范围较大的数据类型时，可能会发生数据溢出。例如：将一个 <code>int</code> 转换为 <code>long</code> 时，转换结果会填充额外的高位空间，但原始数据仍然保持不变</li>
<li><strong>精度损失</strong>：在进行浮点数类型的转换时，可能会发生精度损失。由于浮点数的表示方法不同，将一个双精度浮点数 <code>double</code> 转换为单精度浮点数 <code>float</code> 时，精度可能会损失</li>
<li><strong>类型不匹配导致的错误</strong>：在进行类型转换时，需要确保源类型和目标类型是兼容的。如果两者不兼容，会导致编译错误或运行时错误</li>
</ol>
<h2 id="5-为什么用-BigDecimal-不用-double？"><a href="#5-为什么用-BigDecimal-不用-double？" class="headerlink" title="5# 为什么用 BigDecimal 不用 double？"></a>5# 为什么用 BigDecimal 不用 double？</h2><p><code>double</code> 会出现精度丢失的问题，<code>dobule</code> 执行的是二进制浮点运算，二进制表示小数只能使用 1&#x2F;(2^n) 的和的组合，有些情况下不能准确地表示一个小数。</p>
<p>而 <code>BigDecimal</code> 是精确计算，一般牵扯到金钱的计算，都使用 <code>BigDecimal</code>。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.1&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">sum</span> <span class="operator">=</span> num1.add(num2); <span class="comment">// 0.3</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">product</span> <span class="operator">=</span> num1.multiply(num2); <span class="comment">// 0.02</span></span><br></pre></td></tr></table></figure>

<p>这样，<code>BigDecimal</code> 可以确保精确的十进制数值计算，避免了使用 <code>double</code> 可能出现的舍入误差。需要注意的是，在创建 <code>BigDecimal</code> 对象时，应该使用字符串作为参数，而不是直接使用浮点数值，以避免浮点数精度丢失</p>
<h2 id="6-装箱和拆箱是什么？"><a href="#6-装箱和拆箱是什么？" class="headerlink" title="6# 装箱和拆箱是什么？"></a>6# 装箱和拆箱是什么？</h2><p>装箱（Boxing）和拆箱（Unboxing）是将基本数据类型和对应的包装类之间进行转换的过程，自动装箱主要发送在赋值时和方法调用时，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值时</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i; <span class="comment">// 拆箱</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法调用时</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">show</span><span class="params">(Integer iParam)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;自动装箱&quot;</span> + iParam);</span><br><span class="line">    <span class="keyword">return</span> iParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">show(<span class="number">3</span>); <span class="comment">// 装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> show(<span class="number">3</span>); <span class="comment">// 返回类型是 Integer，拆箱</span></span><br></pre></td></tr></table></figure>

<p>在一个循环中进行自动装箱操作的情况下可能出现问题，会创建多余的对象，影响程序的性能，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123; sum += <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure>

<p><code>+</code> 这个操作符不适用于 <code>Integer</code> 对象，首先 <code>sum</code> 进行自动拆箱操作，进行数值相加操作，最后发生自动装箱操作转换成 <code>Integer</code> 对象。其内部变化如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> sum.intValue() + i;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(result);</span><br></pre></td></tr></table></figure>

<p>因为 <code>sum</code> 声明为 <code>Integer</code> 类型，上面的循环中会创建 1000 个无用的 <code>Integer</code> 对象，会降低程序的性能，加重垃圾回收的工作量。因此在编程的时候，需要正确地声明变量类型，避免因为自动装箱引起的性能问题</p>
<h2 id="Java-为什么要有包装类？"><a href="#Java-为什么要有包装类？" class="headerlink" title="Java 为什么要有包装类？"></a>Java 为什么要有包装类？</h2><p>包装类就是将基本数据类型包装成 <code>Object</code> 对象，对象封装有诸多好处：</p>
<ol>
<li>可以把属性和方法结合在一起，比如 <code>Integer</code> 有 <code>parseInte()</code> 方法来专门处理 <code>int</code> 相关的数据</li>
<li>Java 中大部分类和方法都是用来处理<strong>引用类型</strong>的。像 <code>ArrayList</code> 这样的集合类，不能直接存储基本类型（如 <code>int</code>、<code>double</code>），而是必须使用其对应的包装类（如 <code>Integer</code>、<code>Double</code>）</li>
<li>在 Java 中，泛型只能使用<strong>引用类型</strong>，而不能使用<strong>基本数据类型</strong>。例如：对一个列表的元素进行排序，如果使用基本类型 <code>int</code>（实际上基本类型无法作为泛型参数，所以连 <code>List&lt;int&gt;</code> 都不合法），无法直接使用 <code>Collections.sort()</code> 方法，如果使用 <code>Integer</code> 包装类，则可以</li>
<li>在 Java 中，集合中只能存储引用类型，而不能存储基本类型。比如 <code>List&lt;int&gt;</code> 是不合法的，需要使用 <code>List&lt;Integer&gt;</code></li>
</ol>
<p>需要注意空指针异常。例如：<code>int</code> 可以赋值为 0，而 <code>Integer</code> 必须通过实例化对象来赋值，如果对一个未经初始化的 <code>Integer</code> 变量进行操作，就会出现 <code>NullPointerException</code>，这是因为它被赋值为 <code>null</code>，而 <code>null</code> 是无法进行自动拆箱的</p>
<h2 id="7-为什么还要保留基本数据类型？"><a href="#7-为什么还要保留基本数据类型？" class="headerlink" title="7# 为什么还要保留基本数据类型？"></a>7# 为什么还要保留基本数据类型？</h2><p>包装类是引用类型，对象的引用和对象本身是分开存储的，而对于基本数据类型，变量对应的内存块直接存储数据本身。因此，基本数据类型在读写效率方面，要比包装类高效</p>
<p>此外，在 64 位 JVM 上，在开启引用压缩的情况下，一个 <code>Integer</code> 对象占用 16 个字节的内存空间，而一个 <code>int</code> 类型数据只占用 4 字节的内存空间</p>
<p>不管在读写效率，还是存储效率，基本类型都比包装类高效</p>
<h2 id="8-说一下-Integer-的基本缓存"><a href="#8-说一下-Integer-的基本缓存" class="headerlink" title="8# 说一下 Integer 的基本缓存"></a>8# 说一下 Integer 的基本缓存</h2><p>Java 的 <code>Integer</code> 类内部实现了一个静态缓存池，用于存储特定范围内的整数值对应的 <code>Integer</code> 对象</p>
<p>默认情况下，这个范围是 -128 到 127。当通过 <code>Integer.valueOf(int)</code> 方法创建一个在这个范围内的整数对象时，并不会每次都生成新的对象实例，而是复用缓存中的对象，直接从内存中取出，不需要新建一个对象</p>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="1-怎么理解面向对象？简单说说封装、继承、多态"><a href="#1-怎么理解面向对象？简单说说封装、继承、多态" class="headerlink" title="1# 怎么理解面向对象？简单说说封装、继承、多态"></a>1# 怎么理解面向对象？简单说说封装、继承、多态</h2><p>面向对象是一种编程范式，它将现实世界中的事物抽象为对象，对象具有属性和方法。面向对象编程的设计思想是以对象为中心，通过对象之间的交互来完成程序的功能，具有灵活性和可扩展性</p>
<p>Java 面向对象的三大特性包括**：封装、继承、多态**</p>
<ul>
<li><strong>封装</strong>：封装是指将对象的属性（成员变量）和行为（方法）封装在一个类中，并通过访问控制符（如 <code>private</code>、<code>public</code> 等）隐藏内部实现细节，只暴露必要的接口供外部使用。封装的作用是<strong>增强安全性、提高模块独立性</strong>，防止外部对对象状态的非法访问或修改</li>
<li><strong>继承</strong>：继承是面向对象编程中实现代码复用的机制，它允许一个类（子类）继承另一个类（父类）的属性和方法。继承使得子类可以在父类基础上扩展功能，从而构建更清晰、更有层次的类结构</li>
<li><strong>多态</strong>：多态是指<strong>同一个方法调用，在不同对象上可以表现出不同的行为</strong>。它分为两种形式：<ul>
<li><strong>编译时多态（方法重载）</strong>：同一类中方法名相同、参数不同</li>
<li><strong>运行时多态（方法重写）</strong>：子类重写父类方法，并通过父类引用调用子类对象。<br> 多态使程序具备更好的<strong>扩展性和可维护性</strong>，是实现面向接口编程的关键</li>
</ul>
</li>
</ul>
<h2 id="2-多态体现在哪几个方面？"><a href="#2-多态体现在哪几个方面？" class="headerlink" title="2# 多态体现在哪几个方面？"></a>2# 多态体现在哪几个方面？</h2><ol>
<li><p><strong>方法重载</strong>：方法重载是指同一类中可以有多个同名方法，它们具有不同的参数列表。虽然方法名相同，但根据传入的不同参数，编译器会在编译时确定调用哪个方法。注意：方法返回值不同但参数相同，<strong>不构成重载</strong></p>
</li>
<li><p><strong>方法重写</strong>：方法重写是指子类能够提供对父类中同名方法的具体实现。在运行时，JVM 会根据对象的实际类型确定调用哪个版本的方法，这是实现多态的主要方式。注意：重写的方法必须具有<strong>相同的方法签名</strong>，且<strong>访问权限不能比父类更严格</strong></p>
</li>
<li><p><strong>接口与实现</strong>：Java 中的接口是一种行为规范，类通过 <code>implements</code> 关键字实现接口。多个类可以实现同一个接口，通过<strong>接口引用来调用方法</strong>，可以实现<strong>调用方与实现方的解耦</strong>，体现了多态特性</p>
</li>
<li><p><strong>向上转型和向下转型</strong>：</p>
<ul>
<li><p><strong>向上转型</strong>：子类对象可以被赋值给父类类型的引用（即：<code>Parent p = new Child()</code>），这在 Java 中是<strong>自动进行</strong>的，也是多态的前提。可以只调用父类中定义的方法，实际运行的是子类的重写实现（如果有）</p>
</li>
<li><p><strong>向下转型</strong>：将父类引用转换为子类类型（即：<code>Child c = (Child) p</code>），这通常需要<strong>强制类型转换</strong>，并应使用 <code>instanceof</code> 检查其实际类型，避免出现 <code>ClassCastException</code>。向下转型常用于访问子类特有的方法</p>
</li>
</ul>
</li>
</ol>
<h2 id="3-多态解决了什么问题？"><a href="#3-多态解决了什么问题？" class="headerlink" title="3# 多态解决了什么问题？"></a>3# 多态解决了什么问题？</h2><p>多态是指<strong>同一个方法调用，在不同对象上可以表现出不同的行为</strong>。多态的这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类</p>
<p>多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等</p>
<h2 id="4-面向对象的设计原则有哪些？"><a href="#4-面向对象的设计原则有哪些？" class="headerlink" title="4# 面向对象的设计原则有哪些？"></a>4# 面向对象的设计原则有哪些？</h2><ol>
<li><strong>单一职责原则（SRP）</strong>：一个类应该只有一个引起它变化的原因，即一个类应该只负责一项职责。例如：考虑一个员工类，它应该只负责管理员工信息，而不负责其他无关的工作</li>
<li><strong>开放封闭原则（OCP）</strong>：软件实体应该对扩展开放，对修改封闭。例如：定义一个图形类，然后让不同类型的图形继承这个类，而不需要修改图形类本身</li>
<li><strong>里式替换原则（LSP）</strong>：父类出现的地方，子类必须能够替代父类，并且保证原有功能不被破坏。例如：如果一个公司类包含部门类，应该考虑使用合成&#x2F;聚合关系，而不是将公司类继承自部门类</li>
<li><strong>接口隔离原则（ISP）</strong>：客户端不应该依赖那些它不需要的接口，即接口应该小而专。例如：你设计了一个 “多功能设备接口”，里面包含<strong>打印</strong>、<strong>扫描</strong>、<strong>传真</strong>、<strong>装订</strong>四个方法，结果，公司后来要做一款<strong>廉价入门级打印机</strong>，它只能打印，其余功能都没有。为了实现接口，这台打印机被迫提供空实现或抛异常</li>
<li><strong>依赖倒置原则（DIP）</strong>：高层模块不应该依赖低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。例如：假设有一个通知服务类 ，需要发送消息。错误的做法是它直接创建并依赖一个 <code>EmailSender</code> 类，这样如果以后要改用短信或微信，就必须修改通知服务的代码。正确的做法是先定义一个接口并实现它。通知服务类只依赖接口，而不是具体实现</li>
<li><strong>最少知识原则（Law of Demeter）</strong>：一个对象应当对其他对象有最少的了解，只与其直接的朋友交互。例如：你要点一杯咖啡，应该说：“服务员，请给我一杯拿铁。”，由服务员自己决定找谁、怎么做</li>
</ol>
<h2 id="5-抽象类和普通类的区别？"><a href="#5-抽象类和普通类的区别？" class="headerlink" title="5# 抽象类和普通类的区别？"></a>5# 抽象类和普通类的区别？</h2><ol>
<li><strong>实例化</strong>：普通类可以直接实例化对象，而抽象类不能被实例化，只能被继承</li>
<li><strong>方法实现</strong>：普通类中的方法可以有具体的实现，而抽象类中的方法可以有实现也可以没有实现</li>
<li><strong>实现限制</strong>：普通类可以被其他类继承和使用，而抽象类一般用于作为基类，被其他类继承和扩展使用</li>
</ol>
<h2 id="6-抽象类和接口的区别是什么？"><a href="#6-抽象类和接口的区别是什么？" class="headerlink" title="6# 抽象类和接口的区别是什么？"></a>6# 抽象类和接口的区别是什么？</h2><p><strong>两者的特点</strong>：</p>
<ul>
<li>抽象类用于描述类的共同特性和行为，可以有成员变量、构造方法和具体方法。适用于有明显继承关系的场景</li>
<li>接口用于定义行为规范，可以多实现，只能有常量和抽象方法（Java 8 以后可以有默认方法和静态方法）。适用于定义类的能力或功能</li>
</ul>
<p><strong>两者的区别:</strong></p>
<ol>
<li><strong>实现方式</strong>：实现接口的关键字为 <code>implements</code>，继承抽象类的关键字为 <code>extends</code>。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承</li>
<li><strong>方法方式</strong>：接口只有定义，不能有方法的实现，Java 8 中可以定义 <code>default</code> 方法体，而抽象类可以有定义与实现，方法可在抽象类中实现</li>
<li><strong>访问修饰符</strong>：接口成员变量默认为 <code>public static final</code>，必须赋初值，不能被修改；其所有的成员方法都是 <code>public abstract</code> 的。抽象类中成员变量默认 <code>default</code>，可在子类中被重新定义，也可被重新赋值；抽象方法被 <code>abstract</code> 修饰，不能被 <code>private</code>、<code>static</code>、<code>synchronized</code> 和 <code>native</code> 等修饰，必须以分号结尾，不带花括号</li>
<li><strong>变量</strong>：抽象类可以包含实例变量和静态变量，而接口只能包含常量（静态常量）</li>
</ol>
<h2 id="7-抽象类能加-final-修饰吗？"><a href="#7-抽象类能加-final-修饰吗？" class="headerlink" title="7# 抽象类能加 final 修饰吗？"></a>7# 抽象类能加 final 修饰吗？</h2><p><strong>不能</strong>。Java 中的抽象类是用来被继承的，而 <code>final</code> 修饰符用于禁止类被继承或方法被重写，因此，抽象类和 <code>final</code> 修饰符是互斥的，不能同时使用</p>
<h2 id="8-接口里面可以定义哪些方法"><a href="#8-接口里面可以定义哪些方法" class="headerlink" title="8# 接口里面可以定义哪些方法"></a>8# 接口里面可以定义哪些方法</h2><ol>
<li><strong>抽象方法</strong>：抽象方法是接口的核心部分，所有实现接口的类必须实现这些方法。抽象方法默认是 <code>public</code> 和 <code>abstract</code>，这些修饰符可以省略</li>
<li><strong>默认方法</strong>：默认方法是在 Java 8 引入的，允许接口提供具体实现，实现类可以选择重写默认方法</li>
<li><strong>静态方法</strong>：静态方法也是在 Java 8 引入的，它们属于接口本身，可以通过接口名直接调用，而不需要实现类的对象</li>
<li><strong>私有方法</strong>：私有方法是在 Java 9 引入的，用于在接口中为默认方法和其他私有方法提供辅助功能，这些方法不能被实现类访问，只能在接口内部使用</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sleeping...&quot;</span>);</span><br><span class="line">        logSleep();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method in interface&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logSleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logging sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="9-抽象类可以被实例化吗？"><a href="#9-抽象类可以被实例化吗？" class="headerlink" title="9# 抽象类可以被实例化吗？"></a>9# 抽象类可以被实例化吗？</h2><p><strong>不能</strong>。这意味着不能使用 <code>new</code> 关键字直接创建一个抽象类的对象。抽象类的存在主要是为了被继承，它通常包含一个或多个抽象方法（由 <code>abstract</code> 关键字修饰且无方法体），这些方法在子类中被实现</p>
<p>抽象类可以有构造器，这些构造器在子类实例化时会被调用，以便进行必要的初始化工作。然而，这个过程并不是直接实例化抽象类，而是创建了子类的实例，间接地使用了抽象类的构造器。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 构造器代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ConcreteClass &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 调用抽象类的构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实现抽象方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ConcreteClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass</span>();</span><br></pre></td></tr></table></figure>



<h2 id="10-接口可以包含构造函数吗？"><a href="#10-接口可以包含构造函数吗？" class="headerlink" title="10# 接口可以包含构造函数吗？"></a>10# 接口可以包含构造函数吗？</h2><p><strong>不能</strong>。接口不会有自己的实例，所以不需要有构造函数</p>
<p>这是因为，构造函数就是初始化类的属性或方法，在 new 的一瞬间自动调用，然而接口是不能 new 的</p>
<h2 id="11-解释-Java-中的静态变量和静态方法"><a href="#11-解释-Java-中的静态变量和静态方法" class="headerlink" title="11# 解释 Java 中的静态变量和静态方法"></a>11# 解释 Java 中的静态变量和静态方法</h2><p>在 Java 中，静态变量和静态方法是与类本身关联的，而不是与类的实例（对象）关联，它们在内存中只存在一份，可以被类的所有实例共享</p>
<ul>
<li><strong>静态变量</strong>：静态变量（类变量）是在类中使用 <code>static</code> 关键字声明的变量，他们属于类而不是任何具体的对象。常用于需要在所有对象间共享的数据，如计数器、常量等。主要的特点：<ul>
<li><strong>共享性</strong>：所有该类的实例共享同一个静态变量。如果一个实例修改了静态变量的值，其他实例也会看到这个更改</li>
<li><strong>初始化</strong>：静态变量在类被加载时初始化，只会对其进行一次内存分配</li>
<li><strong>访问方式</strong>：静态变量可以直接通过类名访问，也可以通过实例访问，但推荐使用类名</li>
</ul>
</li>
<li><strong>静态方法</strong>：静态方法是在类中使用 <code>static</code> 关键字声明的方法，类似于静态变量，静态方法也属于类而不是任何具体的对象。常用于助手方法、获取类级别的信息或者是没有依赖于实例的数据处理。主要的特点：<ul>
<li><strong>访问静态成员</strong>：静态方法可以直接调用其他静态变量和静态方法，但不能直接访问非静态成员</li>
<li><strong>无实例依赖</strong>：静态方法可以在没有创建类实例的情况下调用。对于静态方法来说，不能直接访问非静态的成员变量或方法，因为静态方法没有上下文的实例</li>
<li><strong>多态性</strong>：静态方法不支持重写（Override），但可以被隐藏（Hide）</li>
</ul>
</li>
</ul>
<h2 id="12-非静态内部类和静态内部类的区别？"><a href="#12-非静态内部类和静态内部类的区别？" class="headerlink" title="12# 非静态内部类和静态内部类的区别？"></a>12# 非静态内部类和静态内部类的区别？</h2><ol>
<li>非静态内部类依赖于外部类的实例，而静态内部类不依赖于外部类的实例</li>
<li>非静态内部类可以访问外部类的实例变量和方法，而静态内部类只能访问外部类的静态成员</li>
<li>非静态内部类不能定义静态成员，而静态内部类可以定义静态成员</li>
<li>非静态内部类在外部类实例化后才能实例化，而静态内部类可以独立实例化</li>
<li>非静态内部类可以访问外部类的私有成员，而静态内部类不能直接访问外部类的私有成员，需要通过实例化外部类来访问</li>
</ol>
<h2 id="13-非静态内部类可以直接访问外部类的实例变量和方法，编译器是怎么做到的？"><a href="#13-非静态内部类可以直接访问外部类的实例变量和方法，编译器是怎么做到的？" class="headerlink" title="13# 非静态内部类可以直接访问外部类的实例变量和方法，编译器是怎么做到的？"></a>13# 非静态内部类可以直接访问外部类的实例变量和方法，编译器是怎么做到的？</h2><p>这是因为编译器在生成字节码时，会为非静态内部类维护一个指向外部类实例的引用，将外部类实例作为参数传入，并在内部类的实例化过程中建立外部类实例与内部类实例之间的联系，从而实现直接访问外部方法的功能</p>
<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="1-Java-中-final-的作用是什么？"><a href="#1-Java-中-final-的作用是什么？" class="headerlink" title="1# Java 中 final 的作用是什么？"></a>1# Java 中 final 的作用是什么？</h2><ol>
<li><strong>装饰类</strong>：当 <code>final</code> 修饰一个类时，表示这个类不能被继承，是类继承体系中的最终形态。例如：Java 中的 <code>String</code> 类就是用 <code>final</code> 修饰的，着保证了 <code>String</code> 类的不可变性和安全性，防止其他类通过继承来改变 <code>String</code> 类的行为和特性</li>
<li><strong>修饰方法</strong>：用 <code>final</code> 修饰的方法不能在子类中被重写。例如：<code>java.lang.Object</code> 类中的 <code>getClass</code> 方法就是 <code>final</code> 的，因为这个方法的行为是由 JVM 底层实现来保证的，不应该被子类修改</li>
<li><strong>修饰变量</strong>：当 <code>final</code> 修饰基本数据类型的变量时，改变量一旦被赋值就不能再改变。例如：<code>final int num = 10</code>，这里的 <code>num</code> 就是一个常量，不能再对齐进行重新赋值操作，否则会导致编译错误。对于引用类型，<code>final</code> 修饰意味着这个引用变量不能再指向其他对象，但对象本身的内容是可以改变的。例如：<code>final StringBuilder sb = new StringBuilder(&quot;Hello&quot;);</code>，不能让 <code>sb</code> 再指向其他 <code>StringBuilder</code> 对象，但可以通过 <code>sb.append(&quot; World!&quot;);</code> 来修改字符串的内容</li>
</ol>
<h1 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h1><h2 id="1-浅拷贝和深拷贝的区别？"><a href="#1-浅拷贝和深拷贝的区别？" class="headerlink" title="1# 浅拷贝和深拷贝的区别？"></a>1# 浅拷贝和深拷贝的区别？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1720683675376-c5af6668-4538-479f-84e8-42d4143ab101.webp" alt="深拷贝和浅拷贝的区别"></p>
<ul>
<li><strong>浅拷贝</strong>：只复制对象本身以及其字段中的基本类型值和引用类型的引用地址，不会递归复制引用对象本身。也就是说，浅拷贝会创建一个新的对象，但其中引用类型的字段仍指向原对象中引用的<strong>同一内存地址</strong>，所以原对象和拷贝对象会<strong>共享</strong>这些引用</li>
<li><strong>深拷贝</strong>：不仅复制对象本身，还会递归复制对象中所有的引用类型字段，确保所有嵌套的对象也被复制一份。这样，深拷贝生成的是一个完全独立的对象及其所有内部对象，原对象和拷贝对象之间互不影响</li>
</ul>
<h2 id="2-实现深拷贝的三种方法是什么"><a href="#2-实现深拷贝的三种方法是什么" class="headerlink" title="2# 实现深拷贝的三种方法是什么?"></a>2# 实现深拷贝的三种方法是什么?</h2><ul>
<li><strong>实现 <code>Cloneable</code> 接口并重写 <code>clone()</code> 方法</strong>：在 <code>clone()</code> 方法中，通过递归克隆引用类型字段来实现深拷贝</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String field1;</span><br><span class="line">    <span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">cloned</span> <span class="operator">=</span> (MyClass) <span class="built_in">super</span>.clone();</span><br><span class="line">        cloned.nestedObject = (NestedClass) nestedObject.clone(); <span class="comment">// 深拷贝内部的引用对象</span></span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>使用序列化和反序列化</strong>：通过将对象序列化为字节流，再从字节流反序列化为对象来实现深拷贝。要求对象及其所有引用类型字段都实现 <code>Serializable</code> 接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String field1;</span><br><span class="line">    <span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Myclass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">			<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">			oos.writeObject(<span class="built_in">this</span>);</span><br><span class="line">			oos.flush();</span><br><span class="line">			oos.close();</span><br><span class="line">			<span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray());</span><br><span class="line">			<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">			<span class="keyword">return</span> (MyClass) ois.readObject();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>手动递归复制</strong>：针对特定对象结构，手动递归复制对象及其引用类型字段。适用于对象结构复杂度不高的情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String field1;</span><br><span class="line">	<span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> MyClass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">MyClass</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">		copy.setField1(<span class="built_in">this</span>.field1);</span><br><span class="line">		copy.setNestedObject(<span class="built_in">this</span>.nestedObject.deepCopy());</span><br><span class="line">		<span class="keyword">return</span> copy;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line">	<span class="keyword">public</span> NestedClass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">NestedClass</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NestedClass</span>();</span><br><span class="line">		copy.setNestedField(<span class="built_in">this</span>.nestedField);</span><br><span class="line">		<span class="keyword">return</span> copy;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="1-什么是泛型？"><a href="#1-什么是泛型？" class="headerlink" title="1# 什么是泛型？"></a>1# 什么是泛型？</h2><p>泛型是 Java 编程语言中的一个重要特性，它允许类、接口和方法在定义时使用一个或多个类型参数，这些类型参数在使用时可以被指定为具体的类型</p>
<p>泛型的主要目的是在编译时提供更强的类型检查，并且在编译后能够保留类型信息，避免了在运行时出现类型转换异常</p>
<h2 id="2-为什么需要泛型？"><a href="#2-为什么需要泛型？" class="headerlink" title="2# 为什么需要泛型？"></a>2# 为什么需要泛型？</h2><ul>
<li><strong>适用于多种数据类型执行相同的代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">	System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">add</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> &#123;</span><br><span class="line">	System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">	System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个 <code>add()</code> 方法；通过泛型，我们可以复用为一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="type">double</span> <span class="title function_">add</span> <span class="params">(T a, T b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a.doubleValue() + b.doubleValue()));</span><br><span class="line">    <span class="keyword">return</span> a.doubleValue() + b.doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）</strong></li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.add(<span class="number">123</span>); <span class="comment">// 添加的是 Integer</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) list.get(<span class="number">1</span>); <span class="comment">// 编译通过，但运行时抛出 CCE</span></span><br></pre></td></tr></table></figure>

<p><code>list</code> 中的元素都是 <code>Object</code> 类型（无法约束其中的类型），所以在取出集合元素时需要人为地强制类型转换到具体的目标类型，且很容易出现 <code>ClassCastException</code> 异常</p>
<p>引入泛型，它将提供类型的约束，提供编译前的检查：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">// list.add(123); // 编译错误，不允许添加非 String 类型</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> list.get(<span class="number">0</span>); <span class="comment">// 不需要强制类型转换</span></span><br></pre></td></tr></table></figure>



<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="1-Java-创建对象有哪些方式？"><a href="#1-Java-创建对象有哪些方式？" class="headerlink" title="1# Java 创建对象有哪些方式？"></a>1# Java 创建对象有哪些方式？</h2><ol>
<li><p><strong>使用 <code>new</code> 关键字</strong>：通过 <code>new</code> 关键字直接调用类的构造方法来创建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过反射创建对象</strong>：通过 Java 的反射机制可以再运行时动态地创建对象。可以使用 <code>Class</code> 类的 <code>newInstance()</code> 或者 <code>Constructor</code> 类的 <code>newInstance()</code> 方法创建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class 类</span></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>).newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Construcotr 类</span></span><br><span class="line">Constructor&lt;MyClass&gt; constructor = MyClass.class.getConstructor();</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>clone()</code> 方法</strong>：如果类实现了 <code>Cloneable</code> 接口，可以使用 <code>clone()</code> 方法复制对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj2</span> <span class="operator">=</span> (MyClass) obj1.clone();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用反序列化</strong>：通过将对象序列化到文件流中，然后再进行反序列化来创建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">	<span class="comment">// Class definition</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// Serialize object</span></span><br><span class="line">		<span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">		<span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> 					<span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.ser&quot;</span>))</span><br><span class="line">		out.writeObject(obj);</span><br><span class="line">		out.close();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// Deserialize object</span></span><br><span class="line">		<span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> 						<span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line">		<span class="type">MyClass</span> <span class="variable">newObj</span> <span class="operator">=</span> (MyClass) in.readObject();</span><br><span class="line">		in.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-new-出的对象什么时候回收？"><a href="#2-new-出的对象什么时候回收？" class="headerlink" title="2# new 出的对象什么时候回收？"></a>2# new 出的对象什么时候回收？</h2><p>通过关键字 <code>new</code> 创建的对象，由 Java 的**垃圾回收器（Garbage Collector）**负责回收。垃圾回收器的工作是在程序运行过程中自动进行的，它会周期性地检测不再被引用的对象，并将其回收释放内存</p>
<p>具体来说，Java 对象的回收时机是由垃圾回收器根据一些算法来决定的，主要有以下几种情况：</p>
<ol>
<li><strong>引用计数法</strong>：某个对象的引用计数为 0 时，表示该对象不再被引用，可以被回收</li>
<li><strong>可达性分析算法</strong>：从根对象（如方法区中的类静态属性、方法中的局部变量等）出发，通过对象之间的引用链进行遍历，如果存在一条引用链到达某个对象，则说明该对象是可达的，反之则不可达，不可达的对象将被回收</li>
<li><strong>终结器（Finalizer）</strong>：如果对象重写了 <code>finalize()</code> 方法，垃圾回收器会在回收该对象之前调用 <code>finalize()</code> 方法，对象可以在 <code>finalize()</code> 方法中进行一些清理操作。然而，终结器机制的使用不被推荐，因为它的执行时间是不确定的，可能会导致不可预测的性能问题</li>
</ol>
<h2 id="3-如何获取私有对象？"><a href="#3-如何获取私有对象？" class="headerlink" title="3# 如何获取私有对象？"></a>3# 如何获取私有对象？</h2><p>在 Java 中，私有对象通常指的是类中被声明为 <code>private</code>  的成员变量或方法。由于 <code>private</code> 访问修饰符的限制，这些成员只能在其所在的类内部被访问</p>
<p>不过，可以通过下面两种方式来间接获取私有对象</p>
<ol>
<li><p><strong>使用公共访问器方法（<code>getter</code> 方法）</strong>：如果类的设计者遵循良好的编程规范，通常会为私有成员变量提供公共的访问器方法（<code>getter</code> 方法），通过调用这些方法可以安全地获取私有对象</p>
</li>
<li><p><strong>反射机制</strong>：反射机制允许在运行时检查和修改类、方法、字段等信息，通过反射可以绕过 <code>private</code> 访问修饰符的限制来获取私有对象。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">privateField</span> <span class="operator">=</span> <span class="string">&quot;私有字段的值&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessExcept &#123;</span><br><span class="line">		<span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">		Class&lt;?&gt; clazz = obj.getClass(); <span class="comment">// 获取 Class 对象</span></span><br><span class="line">		<span class="type">Field</span> <span class="variable">privateField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;privateField&quot;</span>); <span class="comment">// 获取私有字段</span></span><br><span class="line">		privateField.setAccessible(<span class="literal">true</span>); <span class="comment">// 设置可访问性</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) privateField.get(obj); <span class="comment">// 获取私有字段的值</span></span><br><span class="line">		System.out.println(value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="1-什么是反射？"><a href="#1-什么是反射？" class="headerlink" title="1# 什么是反射？"></a>1# 什么是反射？</h2><p><strong>Java 反射机制</strong>是指在程序运行期间，能够动态地获取一个类的结构信息（如类名、属性、方法、构造函数等），并且可以在运行时操作这些信息，例如创建对象、访问属性、调用方法等。这使得 Java 拥有强大的动态性和灵活性，是实现诸如框架设计、依赖注入、动态代理等高级功能的重要基础</p>
<img src="https://cdn.xiaolincoding.com//picgo/1718957173277-863d2ec6-a754-423b-9066-9f28610d1a31.png" alt="反射机制" style="zoom: 67%;" />

<p><strong>反射具有以下特性</strong>：</p>
<ol>
<li><strong>运行时类信息访问</strong>：反射允许程序在运行时获取一个类的完整结构信息，包括类名、字段、方法、构造器等，即使在编译时并不知道具体的类</li>
<li><strong>动态创建对象</strong>：通过反射，可以在运行时动态地创建对象实例。即便类名是在运行时才确定，也可以使用 <code>Class.newInstance()</code> 或 <code>Constructor.newInstance()</code> 方法完成对象的创建</li>
<li><strong>动态方法调用</strong>：反射支持在运行时调用对象的方法，包括私有方法。这通常通过 <code>Method.invoke()</code> 实现，允许传入对象实例和参数，从而执行对应的方法</li>
<li><strong>字段访问与修改</strong>：反射还可以访问和修改对象的字段值，包括私有字段。可以使用 <code>Field.set()</code> 方法设置字段的值，必要时可通过 <code>setAccessible(true)</code> 打破访问限制</li>
</ol>
<h2 id="2-反射在你平时写代码或者框架中的应用场景有哪些？"><a href="#2-反射在你平时写代码或者框架中的应用场景有哪些？" class="headerlink" title="2# 反射在你平时写代码或者框架中的应用场景有哪些？"></a>2# 反射在你平时写代码或者框架中的应用场景有哪些？</h2><p><strong>一、加载数据库驱动</strong>：在使用 JDBC 连接数据库时，常常需要根据实际使用的数据库类型（如 MySQL、Oracle）动态加载对应的驱动类。此时可以使用 <code>Class.forName()</code> 方法通过反射机制加载指定的驱动类，而无需在代码中硬编码具体的驱动实现，从而提升系统的灵活性和可配置性。例如：</p>
  <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;db.properties&quot;</span>));</span><br><span class="line"><span class="type">String</span> <span class="variable">driverClass</span> <span class="operator">=</span> props.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">Class.forName(driverClass); <span class="comment">// 反射方式动态加载驱动</span></span><br></pre></td></tr></table></figure>

<p><strong>二、配置文件加载</strong>：在 Spring 框架中，IoC（控制反转）容器能够根据配置文件（如 XML 或 properties）动态加载和管理 Bean。你只需在配置文件中声明需要的类及其属性，Spring 就会自动通过反射机制实例化相应的对象并注入依赖，极大地提高了程序的可扩展性与解耦性</p>
<p>  下面以简单示例说明 Spring 通过配置文件和反射加载 Bean 的过程：</p>
<ul>
<li>将所有 XML 或 properties 配置文件加载到内存中</li>
<li>通过 Java 代码解析配置文件，提取类的全限定名（即类的完整包名路径）及其属性等配置信息</li>
<li>利用反射机制，根据提取的类名动态获取对应的 <code>Class</code> 实例，并创建对象或调用方法</li>
</ul>
<p>  配置文件（如 <code>config.properties</code>）</p>
  <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">className</span>=<span class="string">com.example.reflectdemo.TestInvoke</span></span><br><span class="line"><span class="attr">methodName</span>=<span class="string">printlnState</span></span><br></pre></td></tr></table></figure>

<p>  实体类（<code>TestInvoke.java</code>）</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInvoke</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printlnState</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;I am fine&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  配置读取工具方法</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getName</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\config.properties&quot;</span>);</span><br><span class="line">    properties.load(in);</span><br><span class="line">    in.close();</span><br><span class="line">    <span class="keyword">return</span> properties.getProperty(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  主方法：使用反射加载类并调用方法</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1. 通过配置文件读取类名和方法名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> getName(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> getName(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 加载类</span></span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取并访问方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(methodName);</span><br><span class="line">    method.setAccessible(<span class="literal">true</span>); <span class="comment">// 允许访问私有方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 实例化对象并调用方法</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">    method.invoke(instance); <span class="comment">// 输出：I am fine</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="1-能讲一讲注解的原理吗？"><a href="#1-能讲一讲注解的原理吗？" class="headerlink" title="1# 能讲一讲注解的原理吗？"></a>1# 能讲一讲注解的原理吗？</h2><p>在 Java 中，注解（Annotation）本质上是继承了 <code>java.lang.annotation.Annotation</code> 接口的特殊接口。每个注解类型在编译后都会生成一个 <code>.class</code> 文件，JVM 会根据字节码中的信息，在运行时动态创建该注解的<strong>代理对象</strong></p>
<p>当我们通过反射调用 <code>clazz.getAnnotation(MyAnnotation.class)</code> 获取注解时，返回的并不是一个普通对象，而是一个由 JVM 动态生成的代理实例。该代理实现了注解接口，并会将方法调用转发给 <code>AnnotationInvocationHandler</code> 的 <code>invoke()</code> 方法</p>
<p>在 <code>AnnotationInvocationHandler</code> 中维护了一个 <code>memberValues</code> 的 <code>Map</code>，它存储了注解的属性名与属性值。这个 Map 的内容来源于 <code>.class</code> 文件中的常量池，类加载时被 JVM 解析并缓存</p>
<p><strong>总结整个流程</strong>：</p>
<ol>
<li>注解被编写并编译后，相关信息存入 <code>.class</code> 文件的字节码结构中；</li>
<li>如果注解的保留策略为 <code>RUNTIME</code>，JVM 在加载类时会解析注解信息；</li>
<li>调用反射 API 获取注解对象时，JVM 返回的是一个动态代理实例；</li>
<li>调用注解方法（如 <code>value()</code>）时，方法会被代理对象拦截；</li>
<li>代理将调用转发至 <code>AnnotationInvocationHandler</code>，从 <code>memberValues</code> 中取出实际值并返回。</li>
</ol>
<h2 id="2-对注解解析的底层实现了解吗？"><a href="#2-对注解解析的底层实现了解吗？" class="headerlink" title="2# 对注解解析的底层实现了解吗？"></a>2# 对注解解析的底层实现了解吗？</h2><p>注解本质上是一个接口，继承自 <code>java.lang.annotation.Annotation</code>。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后，注解类型会被转换成一个普通接口的形式，并保留相关元数据到 <code>.class</code> 文件中</p>
<p>Java 中通过 <code>@Retention</code> 注解指定注解的保留策略，常见的三种为：</p>
<ul>
<li><code>SOURCE</code>：仅保留在源码中，编译后丢弃</li>
<li><code>CLASS</code>：编译时保留在 <code>.class</code> 文件中，运行时不可访问</li>
<li><code>RUNTIME</code>：编译后保留，并可通过反射访问（<strong>实际参与运行时行为</strong>）</li>
</ul>
<p>只有 <code>RUNTIME</code> 注解会被 JVM 加载并参与反射处理，JVM 会将注解元数据存储在 <code>.class</code> 文件的**属性表（Attribute Table）**中，包括：</p>
<ul>
<li><strong><code>RuntimeVisibleAnnotations</code></strong>：存储运行时可见的注解信息</li>
<li><strong><code>RuntimeInvisibleAnnotations</code></strong>：存储运行时不可见的注解信息</li>
<li><strong><code>RuntimeVisibleParameterAnnotations</code></strong>：存储方法参数上的注解信息</li>
</ul>
<p>通过反射 API 可以获取类、方法、字段等元素上的注解。反射的核心类 <code>AnnotatedElement</code>（如 <code>Class</code>、<code>Method</code>、<code>Field</code> 都实现了它）提供了访问注解的接口，如：</p>
<ul>
<li><strong><code>getAnnotation(Class&lt;T&gt; annotationClass)</code></strong>：获取指定类型的注解</li>
<li><strong><code>getAnnotations()</code></strong>：获取所有注解</li>
<li><strong><code>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</code></strong>：判断是否包含指定注解</li>
</ul>
<p>这些方法最终调用的是 JVM 的 native 方法，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">native</span> Annotation[] getDeclaredAnnotations0(<span class="type">boolean</span> publicOnly);</span><br></pre></td></tr></table></figure>

<p>这些 native 方法在类加载时解析 <code>.class</code> 文件中保存的注解字节码信息，并生成<strong>动态代理对象</strong>，用于运行时访问</p>
<p>因此，注解解析的底层实现主要依赖于 Java 的反射机制和字节码文件的存储。通过 <code>@Retention</code> 元注解可以控制注解的保留策略，当使用 <code>RetentionPolicy.RUNTIME</code> 时，可以在运行时通过反射 API 来解析注解信息。在 JVM 层面，会从字节码文件中读取注解信息，并创建注解的代理对象来获取注解的属性值</p>
<h2 id="3-注解的适用范围（Target）是什么？"><a href="#3-注解的适用范围（Target）是什么？" class="headerlink" title="3# 注解的适用范围（Target）是什么？"></a>3# 注解的适用范围（Target）是什么？</h2><p>Java 中注解的“适用范围”由 <code>@Target</code> 元注解指定，用于定义注解可以作用于哪些程序元素。常见的范围包括：</p>
<ul>
<li><code>ElementType.TYPE</code>：类、接口（包括注解类型）或枚举</li>
<li><code>ElementType.METHOD</code>：方法</li>
<li><code>ElementType.FIELD</code>：字段（包括枚举常量）</li>
<li><code>ElementType.CONSTRUCTOR</code>：构造方法</li>
<li><code>ElementType.PARAMETER</code>：参数</li>
<li><code>ElementType.LOCAL_VARIABLE</code>：局部变量</li>
<li><code>ElementType.ANNOTATION_TYPE</code>：注解类型本身</li>
<li><code>ElementType.PACKAGE</code>：包</li>
<li><code>ElementType.TYPE_USE</code>：任何使用类型的地方（如泛型、强转、注解类型参数等）</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个注解就只能用于类或方法</p>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="1-介绍一下-Java-的异常"><a href="#1-介绍一下-Java-的异常" class="headerlink" title="1# 介绍一下 Java 的异常"></a>1# 介绍一下 Java 的异常</h2><img src="https://cdn.xiaolincoding.com//picgo/1720683900898-1d0ce69d-4b5d-41a6-a5df-022e42f8f4c5.webp" alt="Java 异常类层次结构图" style="zoom:50%;" />

<p>Java 的异常体系是围绕 <code>Throwable</code> 类及其子类构建的。<code>Throwable</code> 有两个直接子类：<code>Error</code> 和 <code>Exception</code>，它们代表了两类不同性质的问题：</p>
<ol>
<li><p><strong>Error（错误）</strong>：表示 JVM 运行时出现的严重错误，通常是系统级的问题，程序无法控制和恢复。常见的错误包括 <code>OutOfMemoryError</code>、<code>StackOverflowError</code> 等，这类错误 <strong>不建议</strong> 程序捕获或处理，因为处理后也难以恢复</p>
</li>
<li><p><strong>Exception（异常）</strong>：表示程序本身可以<strong>感知并处理</strong>的问题，又细分为：</p>
<ul>
<li><p><strong>受检查异常</strong>：编译器会强制检查，必须显式处理（try-catch）或声明抛出（throws）。例如 <code>IOException</code>、<code>SQLException</code>、<code>ClassNotFoundException</code> 等，这些异常多与外部资源或环境因素有关（如文件、数据库、网络），处理它们可以提升程序的健壮性</p>
</li>
<li><p><strong>非受检查异常</strong>：<code>RuntimeException</code> 及其子类，编译器<strong>不会强制检查</strong>，通常由程序逻辑错误引起。例如 <code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code>、<code>ArithmeticException</code> 等。虽然不是强制处理，但良好的程序设计应尽量避免这类异常</p>
</li>
</ul>
</li>
</ol>
<h2 id="2-Java-的异常处理方式有哪些？"><a href="#2-Java-的异常处理方式有哪些？" class="headerlink" title="2# Java 的异常处理方式有哪些？"></a>2# Java 的异常处理方式有哪些？</h2><p>Java 提供了一套完整的异常处理机制，用于捕获和处理运行时可能出现的异常，以增强程序的健壮性和可维护性。主要包括以下几种方式：</p>
<p><strong>一、<code>try-catch-finally</code> 语句块</strong>：用于捕获并处理代码执行过程中可能抛出的异常</p>
<ul>
<li><code>try</code> 块包含可能抛出异常的代码</li>
<li><code>catch</code> 块用于捕获并处理特定类型的异常</li>
<li><code>finally</code> 块（可选）用于释放资源或执行善后操作，无论是否发生异常都会执行，常用于资源释放（如关闭文件流、数据库连接等）</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType1 e1) &#123;</span><br><span class="line">    <span class="comment">// 处理异常类型1</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType2 e2) &#123;</span><br><span class="line">    <span class="comment">// 处理异常类型2</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论是否发生异常，都会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二、<code>throw</code> 语句</strong>：用于<strong>手动抛出</strong>一个异常实例，抛出的对象必须是 <code>Throwable</code> 类型或其子类，通常用于业务逻辑判断，如参数校验失败时主动抛出异常</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>三、<code>throws</code> 关键字</strong>：用于在<strong>方法签名</strong>中声明该方法可能抛出的异常类型，通知调用者需要处理这些异常，如果是受检异常，必须显式处理或继续声明抛出</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 可能抛出 IOException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-抛出异常为什么不用-throws？"><a href="#3-抛出异常为什么不用-throws？" class="headerlink" title="3# 抛出异常为什么不用 throws？"></a>3# 抛出异常为什么不用 throws？</h2><p>在 Java 中，如果异常属于<strong>非受检异常</strong>，或者在方法内部已经<strong>被捕获并处理</strong>，那么就不需要在方法签名中使用 <code>throws</code> 关键字</p>
<ol>
<li><strong>非受检异常</strong>：非检查异常是指继承自 <code>RuntimeException</code> 或 <code>Error</code> 的异常类型。编译器<strong>不会强制要求</strong>开发者显式地处理这些异常，也不要求在方法签名中声明它们。包括 <code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code>、<code>IllegalArgumentException</code>、<code>ArithmeticException</code> 等，由于这类异常往往是由程序逻辑错误引起的，Java 更倾向于通过代码修复，而不是强制捕获或声明</li>
<li><strong>异常已被捕获并处理</strong>：如果在方法内部使用了 <code>try-catch</code> 块对异常进行了处理，那么该异常就<strong>不会继续向外抛出</strong>，因此也不需要在方法签名中使用 <code>throws</code></li>
</ol>
<h2 id="4-try-catch-中的语句运行情况"><a href="#4-try-catch-中的语句运行情况" class="headerlink" title="4# try-catch 中的语句运行情况"></a>4# try-catch 中的语句运行情况</h2><p>在 Java 中，<code>try</code> 块中的代码会按顺序执行：</p>
<ul>
<li>如果 <code>try</code> 块中<strong>未发生异常</strong>，则跳过所有 <code>catch</code> 块，<strong>直接执行 <code>finally</code>（如果有）</strong>，然后继续执行后续代码</li>
<li>如果 <code>try</code> 块中<strong>发生了异常</strong>，Java 会依次检查每个 <code>catch</code> 块，看是否有匹配的异常类型：<ul>
<li>如果匹配成功，对应的 <code>catch</code> 块会执行，然后进入 <code>finally</code>（如果有）</li>
<li>如果没有匹配的 <code>catch</code>，异常将<strong>向上抛出</strong>，由调用者处理，<code>finally</code> 块仍会执行</li>
</ul>
</li>
<li><strong><code>finally</code> 块始终会执行</strong>，无论是否发生异常，除非 JVM 退出或程序崩溃</li>
</ul>
<h2 id="5-try-return-“a”-finally-return-“b”-返回什么？"><a href="#5-try-return-“a”-finally-return-“b”-返回什么？" class="headerlink" title="5# try { return “a” } finally { return “b” } 返回什么？"></a>5# try { return “a” } finally { return “b” } 返回什么？</h2><p>该语句的返回值是 <code>&quot;b&quot;</code></p>
<p>在 Java 中，如果 <code>try</code> 和 <code>finally</code> 中都包含 <code>return</code> 语句，<strong><code>finally</code> 中的 <code>return</code> 会覆盖 <code>try</code> 中的返回值</strong>。即使 <code>try</code> 中已经准备好返回 <code>&quot;a&quot;</code>，在执行 <code>finally</code> 时仍会被 <code>&quot;b&quot;</code> 替代</p>
<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><h2 id="1-与-equals-有什么区别？"><a href="#1-与-equals-有什么区别？" class="headerlink" title="1# &#x3D;&#x3D; 与 equals() 有什么区别？"></a>1# &#x3D;&#x3D; 与 equals() 有什么区别？</h2><p>在 Java 中，<code>==</code> 和 <code>equals()</code> 都可用于比较两个对象，但它们的行为有本质上的不同：</p>
<ul>
<li><p><strong><code>==</code></strong>：比较的是引用是否相等</p>
<ul>
<li><p><code>==</code> 判断两个对象<strong>是否指向同一块内存地址</strong>，即它们是否是<strong>同一个对象的引用</strong></p>
</li>
<li><p>对于基本数据类型，<code>==</code> 比较的是<strong>数值本身是否相等</strong></p>
</li>
<li><p>对于引用类型（如字符串、对象等），<code>==</code> 比较的是两个引用是否指向<strong>同一对象</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(a == b); <span class="comment">// false：不同对象，地址不同</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>equals()</code></strong>：比较的是内容是否相等</p>
<ul>
<li><p><code>equals()</code> 是 <code>Object</code> 类中的方法，默认行为与 <code>==</code> 相同，即<strong>比较引用地址</strong></p>
</li>
<li><p>但很多类（如 <code>String</code>、<code>Integer</code>、<code>List</code> 等）都<strong>重写了 <code>equals()</code> 方法</strong>，改为比较对象的<strong>内容</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(a.equals(b)); <span class="comment">// true：内容相同</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>需要注意</strong>：字符串是 Java 中的特殊对象，字面量字符串会被放入<strong>字符串常量池</strong>，如果你写 <code>String s1 = &quot;abc&quot;; String s2 = &quot;abc&quot;;</code>，则 <code>s1 == s2</code> 会返回 <code>true</code>，因为它们引用的是常量池中的同一个对象</p>
<h2 id="2-hashCode-和-equals-方法有什么关系？"><a href="#2-hashCode-和-equals-方法有什么关系？" class="headerlink" title="2# hashCode() 和 equals() 方法有什么关系？"></a>2# hashCode() 和 equals() 方法有什么关系？</h2><p>在 Java 中，对于重写 <code>equals()</code> 方法的类，通常也需要重写 <code>hashCode()</code> 方法，并且需要遵循以下规定：</p>
<ul>
<li><strong>一致性</strong>：如果两个对象使用 <code>equals()</code> 方法比较结果为 <code>true</code>，那么它们的 <code>hashCode()</code> 的值必须相同。也就是说，如果 <code>obj1.equals(obj2)</code> 返回 <code>true</code>，那么 <code>obj1.hashCode()</code> 必须等于 <code>obj2.hashCode()</code></li>
<li><strong>非一致性</strong>：如果两个对象的 <code>hashCode()</code> 的值相同，它们使用 <code>equals()</code> 方法比较的结果不一定为 <code>true</code>。即 <code>obj1.hashCode() == obj2.hashCode()</code> 时，<code>obj1.equals(obj2)</code> 可能为 <code>false</code>，这种情况称为哈希冲突</li>
</ul>
<p><code>hashCode()</code> 和 <code>equals()</code> 方法是紧密相关的，重写 <code>equals()</code> 方法时必须重写 <code>hashCode()</code> 方法，以保证在使用哈希表等数据结构时，对象的相等性判断和存储查找操作能够正常工作。而重写 <code>hashCode()</code> 方法时，需要确保相等的对象具有相同的哈希码，但相同哈希码的对象不一定相等</p>
<h2 id="3-String、StringBuilder、StringBuffer-的区别和联系"><a href="#3-String、StringBuilder、StringBuffer-的区别和联系" class="headerlink" title="3# String、StringBuilder、StringBuffer 的区别和联系"></a>3# String、StringBuilder、StringBuffer 的区别和联系</h2><ol>
<li><p><strong>可变性</strong>： <code>String</code> 是不可变的（Immutable），一旦创建，内容无法修改，每次修改都会生成一个新的对象。<code>StringBuilder</code> 和 <code>StringBuffer</code> 是可变的（Mutable），可以直接对字符串内容进行修改而不会创建新对象</p>
</li>
<li><p>**线程安全性 **：<code>String</code> 因为不可变，天然线程安全。<code>StringBuilder</code> 不是线程安全的，适用于单线程环境。<code>StringBuffer</code> 是线程安全的，其方法通过 <code>synchronized</code> 关键字实现同步，适用于多线程环境</p>
</li>
<li><p>**性能 **：<code>String</code> 性能最低，尤其是在频繁修改字符串时会生成大量临时对象，增加内存开销和垃圾回收压力。<code>StringBuilder</code> 性能最高，因为它没有线程安全的开销，适合单线程下的字符串操作。<code>StringBuffer</code> 性能略低于 <code>StringBuilder</code>，因为它的线程安全机制引入了同步开销</p>
</li>
<li><p>**使用场景 **：如果字符串内容固定或不常变化，优先使用 <code>String</code>。如果需要频繁修改字符串且在单线程环境下，使用 <code>StringBuilder</code>。如果需要频繁修改字符串且在多线程环境下，使用 <code>StringBuffer</code></p>
</li>
</ol>
<p>对比总结如下：</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>String</strong></th>
<th><strong>StringBuilder</strong></th>
<th><strong>StringBuffer</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>不可变性</strong></td>
<td>不可变</td>
<td>可变</td>
<td>可变</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>是（因不可变）</td>
<td>否</td>
<td>是（同步方法）</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>低（频繁修改时）</td>
<td>高（单线程）</td>
<td>中（多线程安全）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>静态字符串</td>
<td>单线程动态字符串</td>
<td>多线程动态字符串</td>
</tr>
</tbody></table>
<h1 id="Java-新特性"><a href="#Java-新特性" class="headerlink" title="Java 新特性"></a>Java 新特性</h1><h2 id="1-Java-8-有什么新特性？"><a href="#1-Java-8-有什么新特性？" class="headerlink" title="1# Java 8 有什么新特性？"></a>1# Java 8 有什么新特性？</h2><p>下面是 Java 8 主要新特性的整理表格，包含关键改进和示例说明：</p>
<table>
<thead>
<tr>
<th><strong>特性名称</strong></th>
<th><strong>描述</strong></th>
<th><strong>示例或说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Lambda 表达式</strong></td>
<td>简化匿名内部类，支持函数式编程</td>
<td><code>(a, b) -&gt; a + b</code> 代替匿名类实现接口</td>
</tr>
<tr>
<td><strong>函数式接口</strong></td>
<td>仅含一个抽象方法的接口，可用 <code>@FunctionalInterface</code> 注解标记</td>
<td><code>Runnable</code>, <code>Comparator</code> 或自定义接口 <code>@FunctionalInterface interface MyFunc &#123; void run(); &#125;</code></td>
</tr>
<tr>
<td><strong>Stream API</strong></td>
<td>提供链式操作处理集合数据，支持并行处理</td>
<td><code>list.stream().filter(x -&gt; x &gt; 0).collect(Collectors.toList())</code></td>
</tr>
<tr>
<td><strong>Optional 类</strong></td>
<td>封装可能为 <code>null</code> 的对象，减少空指针异常</td>
<td><code>Optional.ofNullable(value).orElse(&quot;default&quot;)</code></td>
</tr>
<tr>
<td><strong>方法引用</strong></td>
<td>简化 Lambda 表达式，直接引用现有方法</td>
<td><code>System.out::println</code> 等价于 <code>x -&gt; System.out.println(x)</code></td>
</tr>
<tr>
<td><strong>接口的默认方法与静态方法</strong></td>
<td>接口可定义默认实现和静态方法，增强扩展性</td>
<td><code>interface A &#123; default void print() &#123; System.out.println(&quot;默认方法&quot;); &#125; &#125;</code></td>
</tr>
<tr>
<td><strong>并行数组排序</strong></td>
<td>使用多线程加速数组排序</td>
<td><code>Arrays.parallelSort(array)</code></td>
</tr>
<tr>
<td><strong>重复注解</strong></td>
<td>允许同一位置多次使用相同注解</td>
<td><code>@Repeatable</code> 注解配合容器注解使用</td>
</tr>
<tr>
<td><strong>类型注解</strong></td>
<td>注解可应用于更多位置（如泛型、异常等）</td>
<td><code>List&lt;@NonNull String&gt; list</code></td>
</tr>
<tr>
<td><strong>CompletableFuture</strong></td>
<td>增强异步编程能力，支持链式调用和组合操作</td>
<td><code>CompletableFuture.supplyAsync(() -&gt; &quot;result&quot;).thenAccept(System.out::println)</code></td>
</tr>
</tbody></table>
<h2 id="2-Lambda-表达式了解吗？"><a href="#2-Lambda-表达式了解吗？" class="headerlink" title="2# Lambda 表达式了解吗？"></a>2# Lambda 表达式了解吗？</h2><p>Lambda 表达式是一种简洁的语法，用于创建匿名函数，主要用于简化函数式接口（只有一个抽象方法的接口）的使用。其基本语法有以下两种形式：</p>
<ul>
<li><strong><code>(parameters) -&gt; expression</code></strong>：当 Lambda 体只有一个表达式时使用，表达式的结果会作为返回值</li>
<li><strong><code>(parameters) -&gt; &#123; statements; &#125;</code></strong>：当 Lambda 体包含多条语句时，需要使用大括号将语句括起来，若有返回值则需要使用 <code>return</code> 语句</li>
</ul>
<p>传统的匿名内部类实现方式代码较为冗长，<strong>而 Lambda 表达式可以用更简洁的语法实现相同的功能</strong>。例如，使用匿名内部类实现 <code>Runnable</code> 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousClassExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Running using anonymous class&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Lambda 表达式实现相同功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;Running using lambda expression&quot;</span>));</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Lambda 表达式能够更清晰地表达代码的意图</strong>，尤其是在处理集合操作时，如过滤、映射等。例如，过滤出列表中所有偶数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadabilityExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式结合 Stream API 过滤偶数</span></span><br><span class="line">        List&lt;Integer&gt; evenNumbers = numbers.stream()</span><br><span class="line">                                           .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                                           .collect(Collectors.toList());</span><br><span class="line">        System.out.println(evenNumbers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Lambda 表达式使得 Java 支持函数式编程范式</strong>，允许将函数作为参数传递，从而可以编写更灵活、可复用的代码。例如，定义一个通用的计算函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionalProgrammingExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">operate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, Calculator calculator)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> calculator.calculate(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式传递加法函数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> operate(<span class="number">3</span>, <span class="number">5</span>, (x, y) -&gt; x + y);</span><br><span class="line">        System.out.println(<span class="string">&quot;Sum: &quot;</span> + sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式传递乘法函数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> operate(<span class="number">3</span>, <span class="number">5</span>, (x, y) -&gt; x * y);</span><br><span class="line">        System.out.println(<span class="string">&quot;Product: &quot;</span> + product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然 Lambda 表达式优点蛮多的，不过也有一些缺点，比如会增加调试困难，因为 Lambda 表达式是匿名的，在调试时很难定位具体是哪个 Lambda 表达式出现了问题。尤其是当 Lambda 表达式嵌套使用或者比较复杂时，调试难度会进一步增加</p>
<h2 id="3-介绍一下-Stream-API"><a href="#3-介绍一下-Stream-API" class="headerlink" title="3# 介绍一下 Stream API"></a>3# 介绍一下 Stream API</h2><p>Java 8 引入了 Stream API，它提供了一种高效且易于使用的数据处理方式，特别适合集合对象的操作，如过滤、映射、排序等。Stream API 不仅可以提高代码的可读性和简洁性，还能利用多核处理器的优势进行并行处理</p>
<p><strong>案例1：过滤并收集满足条件的元素</strong></p>
<p><strong>问题场景</strong>：从一个列表中筛选出所有长度大于 3 的字符串，并收集到一个新的列表中</p>
<p><strong>没有 Stream API 的做法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; originalList = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;fig&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;kiwi&quot;</span>);</span><br><span class="line">List&lt;String&gt; filteredList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String item : originalList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.length() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        filteredList.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码需要显式地创建一个新的 <code>ArrayList</code>，并通过循环遍历原列表，手动检查每个元素是否满足条件，然后添加到新列表中</p>
<p><strong>使用 Stream API 的做法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; originalList = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;fig&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;kiwi&quot;</span>);</span><br><span class="line">List&lt;String&gt; filteredList = originalList.stream()</span><br><span class="line">                                        .filter(s -&gt; s.length() &gt; <span class="number">3</span>)</span><br><span class="line">                                        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>这里，我们直接在原始列表上调用 <code>stream()</code> 方法创建了一个流，使用 <code>filter()</code> 中间操作筛选出长度大于 3 的字符串，最后使用 <code>collect(Collectors.toList())</code> 终端操作将结果收集到一个新的列表中。代码更加简洁明了，逻辑一目了然</p>
<p><strong>案例2：计算列表中所有数字的总和</strong></p>
<p><strong>问题场景</strong>：计算一个数字列表中所有元素的总和</p>
<p><strong>没有 Stream API 的做法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Integer number : numbers) &#123;</span><br><span class="line">    sum += number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个传统的 for-each 循环遍历列表中的每一个元素，累加它们的值来计算总和</p>
<p><strong>使用 Stream API 的做法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers.stream()</span><br><span class="line">                 .mapToInt(Integer::intValue)</span><br><span class="line">                 .sum();</span><br></pre></td></tr></table></figure>

<p>通过 Stream API，我们可以先使用 <code>mapToInt()</code> 将 Integer 流转换为 IntStream（这是为了高效处理基本类型），然后直接调用 <code>sum()</code> 方法来计算总和，极大地简化了代码</p>
<h2 id="4-Stream-流的并行-API-是什么？"><a href="#4-Stream-流的并行-API-是什么？" class="headerlink" title="4# Stream 流的并行 API 是什么？"></a>4# Stream 流的并行 API 是什么？</h2><p><strong>是 ParallelStream</strong></p>
<p>并行流（ParallelStream）就是将源数据分为多个子流对象进行多线程操作，然后将处理的结果再汇总为一个流对象，底层是使用通用的 fork&#x2F;join 池来实现，即将一个任务拆分成多个 “小任务” 并行计算，再把多个 “小任务” 的结果合并成总的计算结果</p>
<p>Stream 串行流与并行流的主要区别：</p>
<p> <img src="https://cdn.xiaolincoding.com//picgo/1716365522454-4b56a07e-9b54-4cbb-9832-26b099fc35cd.png" alt="Stream 串行流与并行流的主要区别"></p>
<p>对 CPU 密集型的任务来说，并行流使用 ForkJoinPool 线程池，为每个 CPU 分配一个任务，这是非常有效率的，但是如果任务不是 CPU 密集的，而是 IO 密集的，并且任务数相对线程数比较大，那么直接用 ParallelStream 并不是很好的选择</p>
<h2 id="5-CompletableFuture-怎么用的？"><a href="#5-CompletableFuture-怎么用的？" class="headerlink" title="5# CompletableFuture 怎么用的？"></a>5# CompletableFuture 怎么用的？</h2><p><code>CompletableFuture</code> 是由 Java 8 引入的，在 Java 8 之前我们一般通过 Future 实现异步</p>
<ul>
<li><code>Future</code> 用于表示异步计算的结果，只能通过阻塞或者轮询的方式获取结果，而且不支持设置回调方法，Java 8 之前若要设置回调一般会使用 guava 的 <code>ListenableFuture</code> ，回调的引入又会导致臭名昭著的回调地狱</li>
<li><code>CompletableFuture</code> 对 <code>Future</code> 进行了扩展，可以通过设置回调的方式处理计算结果，同时也支持组合操作，支持进一步的编排，同时一定程度解决了回调地狱的问题</li>
</ul>
<p><code>Future</code>（<code>ListenableFuture</code>）的实现（回调地狱）如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="type">ListeningExecutorService</span> <span class="variable">guavaExecutor</span> <span class="operator">=</span> MoreExecutors.listeningDecorator(executor);</span><br><span class="line">ListenableFuture&lt;String&gt; future1 = guavaExecutor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//step 1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step1 result&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">ListenableFuture&lt;String&gt; future2 = guavaExecutor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//step 2</span></span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step2 result&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">ListenableFuture&lt;List&lt;String&gt;&gt; future1And2 = Futures.allAsList(future1, future2);</span><br><span class="line">Futures.addCallback(future1And2, <span class="keyword">new</span> <span class="title class_">FutureCallback</span>&lt;List&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(List&lt;String&gt; result)</span> &#123;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        ListenableFuture&lt;String&gt; future3 = guavaExecutor.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行step 3&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;step3 result&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        Futures.addCallback(future3, <span class="keyword">new</span> <span class="title class_">FutureCallback</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String result)</span> &#123;</span><br><span class="line">                System.out.println(result);</span><br><span class="line">            &#125;        </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, guavaExecutor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">    &#125;&#125;, guavaExecutor);</span><br></pre></td></tr></table></figure>

<p><code>CompletableFuture</code> 的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step1 result&quot;</span>;</span><br><span class="line">&#125;, executor);</span><br><span class="line">CompletableFuture&lt;String&gt; cf2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step2 result&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">cf1.thenCombine(cf2, (result1, result2) -&gt; &#123;</span><br><span class="line">    System.out.println(result1 + <span class="string">&quot; , &quot;</span> + result2);</span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 3&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step3 result&quot;</span>;</span><br><span class="line">&#125;).thenAccept(result3 -&gt; System.out.println(result3));</span><br></pre></td></tr></table></figure>

<p>显然，<code>CompletableFuture</code> 的实现更为简洁，可读性更好</p>
<img src="https://cdn.xiaolincoding.com//picgo/1713777049912-2268a5fc-c7f1-477d-8c9c-310aae18f51a.png" alt="CompletableFuture" style="zoom:50%;" />

<p><code>CompletableFuture</code> 实现了两个接口：<code>Future</code>、<code>CompletionStage</code></p>
<ul>
<li><code>Future</code> 表示异步计算的结果，<code>CompletionStage</code> 用于表示异步执行过程中的一个步骤（Stage），这个步骤可能是由另外一个 <code>CompletionStage</code> 触发的，随着当前步骤的完成，也可能会触发其他一系列 <code>CompletionStage</code> 的执行</li>
<li>从而我们可以根据实际业务对这些步骤进行多样化的编排组合，<code>CompletionStage</code> 接口正是定义了这样的能力，我们可以通过其提供的 <code>thenAppy</code>、<code>thenCompose</code> 等函数式编程方法来组合编排这些步骤</li>
</ul>
<h2 id="6-Java-21-新特性知道哪些？"><a href="#6-Java-21-新特性知道哪些？" class="headerlink" title="6# Java 21 新特性知道哪些？"></a>6# Java 21 新特性知道哪些？</h2><p><strong>新语言特性</strong>：</p>
<ol>
<li><strong>Switch 语句的模式匹配</strong>：该功能在 Java 21 中也得到了增强。它允许在 <code>switch</code> 的 <code>case</code> 标签中使用模式匹配，使操作更加灵活和类型安全，减少了样板代码和潜在错误。例如：对于不同类型的账户类，可以在 <code>switch</code> 语句中直接根据账户类型的模式来获取相应的余额，如 <code>case savingsAccount sa -&gt; result = sa.getSavings();</code></li>
<li><strong>数组模式</strong>：将模式匹配扩展到数组中，使开发者能够在条件语句中更高效地解构和检查数组内容。例如：<code>if (arr instanceof int[] &#123;1, 2, 3&#125;)</code>，可以直接判断数组 <code>arr</code> 是否匹配指定的模式</li>
<li><strong>字符串模板（预览版）</strong>：提供了一种更可读、更易维护的方式来构建复杂字符串，支持在字符串字面量中直接嵌入表达式。例如，以前可能需要使用 <code>&quot;hello &quot; + name + &quot;, welcome to the geeksforgeeks!&quot;</code> 这样的方式来拼接字符串，在 Java 21 中可以使用  <code>hello &#123;name&#125;, welcome to the geeksforgeeks!</code> 这种更简洁的写法</li>
</ol>
<p><strong>新并发特性方面</strong>：</p>
<ol>
<li><strong>虚拟线程</strong>：这是 Java 21 引入的一种轻量级并发的新选择。它通过共享堆栈的方式，大大降低了内存消耗，同时提高了应用程序的吞吐量和响应速度。可以使用静态构建方法、构建器或 <code>ExecutorService</code> 来创建和使用虚拟线程</li>
<li><strong>Scoped Values（范围值）</strong>：提供了一种在线程间共享不可变数据的新方式，避免使用传统的线程局部存储，促进了更好的封装性和线程安全，可用于在不通过方法参数传递的情况下，传递上下文信息，如用户会话或配置设置</li>
</ol>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><h2 id="1-怎么把一个对象从一个-JVM-转移到另一个-JVM"><a href="#1-怎么把一个对象从一个-JVM-转移到另一个-JVM" class="headerlink" title="1# 怎么把一个对象从一个 JVM 转移到另一个 JVM"></a>1# 怎么把一个对象从一个 JVM 转移到另一个 JVM</h2><ol>
<li><strong>使用序列化和反序列化</strong>：将对象序列化为字节流，并将其发送到另一个 JVM，然后在另一个 JVM 中反序列化字节流恢复对象。这可以通过 Java 的 <code>ObjectOutputStream</code> 和 <code>ObjectInputStream</code> 来实现。</li>
<li><strong>使用消息传递机制</strong>：利用消息传递机制，比如使用消息队列（如 RabbitMQ、Kafka）或者通过网络套接字进行通信，将对象从一个 JVM 发送到另一个。这需要自定义协议来序列化对象并在另一个 JVM 中反序列化</li>
<li><strong>使用远程方法调用（RPC）</strong>：可以使用远程方法调用框架，如 gRPC，来实现对象在不同 JVM 之间的传输。远程方法调用可以让你在分布式系统中调用远程 JVM 上的对象的方法</li>
<li><strong>使用共享数据库或缓存</strong>：将对象存储在共享数据库（如 MySQL、PostgreSQL）或共享缓存（如 Redis）中，让不同的 JVM 可以访问这些共享数据。这种方法适用于需要共享数据但不需要直接传输对象的场景</li>
</ol>
<h2 id="2-让你自己实现序列化和反序列化，你会怎么做"><a href="#2-让你自己实现序列化和反序列化，你会怎么做" class="headerlink" title="2# 让你自己实现序列化和反序列化，你会怎么做?"></a>2# 让你自己实现序列化和反序列化，你会怎么做?</h2><p>Java 默认的序列化虽然实现方便，但却存在安全漏洞、不跨语言以及性能差等缺陷：</p>
<ol>
<li><strong>无法跨语言</strong>： Java 序列化目前只适用基于 Java 语言实现的框架，其它语言大部分都没有使用 Java 的序列化框架，也没有实现 Java 序列化这套协议。因此，如果是两个基于不同语言编写的应用程序相互通信，则无法实现两个应用服务之间传输对象的序列化与反序列化</li>
<li><strong>容易被攻击</strong>：Java 序列化是不安全的，我们知道对象是通过在 <code>ObjectInputStream</code> 上调用 <code>readObject()</code> 方法进行反序列化的，这个方法其实是一个神奇的构造器，它可以将类路径上几乎所有实现了 <code>Serializable</code> 接口的对象都实例化。这也就意味着，在反序列化字节流的过程中，该方法可以执行任意类型的代码，这是非常危险的</li>
<li><strong>序列化后的流太大</strong>：序列化后的二进制流大小能体现序列化的性能。序列化后的二进制数组越大，占用的存储空间就越多，存储硬件的成本就越高。如果我们是进行网络传输，则占用的带宽就更多，这时就会影响到系统的吞吐量</li>
</ol>
<p>我会考虑用主流序列化框架，比如 FastJson、Protobuf 来替代 Java 序列化</p>
<p>如果追求性能的话，Protobuf 序列化框架会比较合适，Protobuf 的这种数据存储格式，不仅压缩存储数据的效果好， 在编码和解码的性能方面也很高效。Protobuf 的编码和解码过程结合 <code>.proto</code> 文件格式，加上 Protocol Buffer 独特的编码格式，只需要简单的数据运算以及位移等操作就可以完成编码与解码。可以说 Protobuf 的整体性能非常优秀</p>
<h2 id="3-将对象转为二进制字节流具体怎么实现"><a href="#3-将对象转为二进制字节流具体怎么实现" class="headerlink" title="3# 将对象转为二进制字节流具体怎么实现?"></a>3# 将对象转为二进制字节流具体怎么实现?</h2><p>其实，像序列化和反序列化，无论这些可逆操作是什么机制，都会有对应的<strong>处理和解析协议</strong>，例如加密和解密，TCP的粘包和拆包，序列化机制是通过序列化协议来进行处理的，和 <code>.class</code> 文件类似，它其实是定义了序列化后的字节流格式，然后对此格式进行操作，生成符合格式的字节流或者将字节流解析成对象</p>
<p>在 Java 中通过序列化对象流来完成序列化和反序列化：</p>
<ul>
<li><code>ObjectOutputStream</code>：通过 <code>writeObject()</code> 方法做序列化操作</li>
<li><code>ObjectInputStrean</code>：通过 <code>readObject()</code> 方法做反序列化操作</li>
</ul>
<p>只有实现了 <code>Serializable</code> 或 <code>Externalizable</code> 接口的类的对象才能被序列化，否则抛出异常</p>
<p><strong>一、实现对象序列化</strong></p>
<ul>
<li>让类实现 <code>Serializable</code> 接口：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// class code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建输出流并写入对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.ser&quot;</span>);</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOut);</span><br><span class="line">    out.writeObject(obj);</span><br><span class="line">    out.close();</span><br><span class="line">    fileOut.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二、实现对象反序列化</strong></p>
<ul>
<li>创建输入流并读取对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">newObj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>);</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileIn);</span><br><span class="line">    newObj = (MyClass) in.readObject();</span><br><span class="line">    in.close();</span><br><span class="line">    fileIn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上步骤，对象 <code>obj</code> 会被序列化并写入到文件 <code>object.ser</code> 中，然后通过反序列化操作，从文件中读取字节流并恢复为对象 <code>newObj</code>。这种方式可以方便地将对象转换为字节流用于持久化存储、网络传输等操作。需要注意的是，要确保类实现了 <code>Serializable</code> 接口，并且所有成员变量都是 <code>Serializable</code> 的才能被正确序列化</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="1-volatile-和-sychronized-如何实现单例模式"><a href="#1-volatile-和-sychronized-如何实现单例模式" class="headerlink" title="1# volatile 和 sychronized 如何实现单例模式"></a>1# volatile 和 sychronized 如何实现单例模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleTon</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止指令重排，保证可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">SingleTon</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleTon</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleTon <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingleTon.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">SingleTon</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>volatile</code> 的作用：</p>
<ol>
<li><strong>保证可见性</strong>：多个线程访问 <code>instance</code> 时，能看到最新的值</li>
<li><strong>禁止指令重排序</strong>：确保对象在完全构造前，其他线程不会看到它的引用，避免出现 “半初始化” 对象</li>
</ol>
<p>双重检查锁定（DCL）原理：</p>
<ul>
<li><strong>第一次检查</strong>：避免进入同步块（提升性能）</li>
<li><strong>同步块内部再次检查</strong>：保证线程安全，仅在首次创建对象时同步</li>
</ul>
<h2 id="2-代理模式和适配器模式有什么区别？"><a href="#2-代理模式和适配器模式有什么区别？" class="headerlink" title="2# 代理模式和适配器模式有什么区别？"></a>2# 代理模式和适配器模式有什么区别？</h2><ol>
<li><strong>目的不同</strong>：代理模式主要关注控制对对象的访问，而适配器模式则用于接口转换，使不兼容的类能够一起工作</li>
<li><strong>结构不同</strong>：代理模式一般包含抽象主题、真实主题和代理三个角色，适配器模式包含目标接口、适配器和被适配者三个角色</li>
<li><strong>应用场景不同</strong>：代理模式常用于添加额外功能或控制对对象的访问，适配器模式常用于让不兼容的接口协同工作</li>
</ol>
<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="1-Java-怎么实现网络-IO-高并发编程？"><a href="#1-Java-怎么实现网络-IO-高并发编程？" class="headerlink" title="1# Java 怎么实现网络 IO 高并发编程？"></a>1# Java 怎么实现网络 IO 高并发编程？</h2><p><strong>可以用 Java NIO</strong>，是一种同步非阻塞的 IO 模型，也是 IO 多路复用的基础</p>
<p>传统的 BIO 里面 <code>socket.read()</code>，如果 TCP RecvBuffer 里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据， 如果使用 BIO 要想要并发处理多个客户端的 IO，那么会使用多线程模式，一个线程专门处理一个客户端 IO，这种模式随着客户端越来越多，所需要创建的线程也越来越多，会急剧消耗系统的性能</p>
<img src="https://cdn.xiaolincoding.com//picgo/image-20240820112641716.png" alt="BIO" style="zoom:50%;" />

<p>NIO 是基于 IO 多路复用实现的，它可以只用一个线程处理多个客户端 IO，如果你需要同时管理成千上万的连接，但是每个连接只发送少量数据，例如一个聊天服务器，用NIO实现会更好一些</p>
<img src="https://cdn.xiaolincoding.com//picgo/image-20240820112656259.png" alt="NIO" style="zoom:50%;" />



<h2 id="2-BIO、NIO、AIO区别是什么？"><a href="#2-BIO、NIO、AIO区别是什么？" class="headerlink" title="2# BIO、NIO、AIO区别是什么？"></a>2# BIO、NIO、AIO区别是什么？</h2><table>
<thead>
<tr>
<th>模型</th>
<th>特点</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>BIO</strong></td>
<td>同步阻塞，每个连接一个线程，简单但性能差</td>
<td>适用于连接数少、对实时性要求不高的系统</td>
</tr>
<tr>
<td><strong>NIO</strong></td>
<td>同步非阻塞，使用 <code>Selector</code> 管理多个通道，一个线程可处理多个连接</td>
<td>适用于高并发、大量连接的服务端程序</td>
</tr>
<tr>
<td><strong>AIO</strong></td>
<td>异步非阻塞，基于回调通知，IO 操作完全由系统异步完成</td>
<td>适用于连接数非常多、IO 操作频繁的高性能场景</td>
</tr>
</tbody></table>
<ul>
<li><strong>BIO（Blocking IO）</strong>：传统 <code>java.io</code>，线程阻塞直至完成读写操作，编程简单但不适合高并发</li>
<li><strong>NIO（Non-blocking IO）</strong>：Java 1.4 引入，引入 <code>Channel</code>、<code>Selector</code>、<code>Buffer</code>，可以实现单线程处理多连接</li>
<li><strong>AIO（Asynchronous IO）</strong>：Java 1.7 引入，真正的异步非阻塞，系统完成 IO 后自动回调通知业务线程处理</li>
</ul>
<h2 id="3-NIO-是怎么实现的？"><a href="#3-NIO-是怎么实现的？" class="headerlink" title="3# NIO 是怎么实现的？"></a>3# NIO 是怎么实现的？</h2><p>NIO 是一种<strong>同步非阻塞</strong>的 IO 模型 </p>
<p>同步是指线程不断轮询 IO 事件是否就绪，同步的核心是 Selector（IO多路复用），Selector 代替了线程本身轮询 IO 事件，避免了阻塞，同时减少了不必要的线程消耗；非阻塞是指线程在等待 IO 的时候，可以同时做其他任务，非阻塞的核心就是通道和缓冲区，当 IO 事件就绪时，可以通过写到缓冲区，保证 IO 的成功，而无需线程阻塞式地等待</p>
<p>NIO 通常由一个专门的线程负责监听所有 IO 事件，并进行分发处理。它基于事件驱动机制：当感兴趣的事件（如连接就绪、数据可读）发生时，线程被唤醒进行处理，而不是长时间阻塞等待</p>
<p><strong>NIO 的核心组件</strong>：</p>
<ul>
<li><p><strong>Channel（通道）</strong><br> 类似传统 IO 的流，但既可读也可写，支持非阻塞模式</p>
</li>
<li><p><strong>Buffer（缓冲区）</strong><br> 所有数据读写都要通过 Buffer，Channel 与 Buffer 相互配合实现数据交换</p>
</li>
<li><p><strong>Selector（选择器）</strong><br> 允许单线程监听多个 Channel 的 IO 事件（如连接建立、数据可读），实现 <strong>IO 多路复用</strong></p>
</li>
</ul>
<img src="https://cdn.xiaolincoding.com//picgo/1716018476312-e5525ca7-acf8-46b1-8fff-8a7d22db5304.webp" alt="NIO 原理" style="zoom:67%;" />



<h2 id="4-你知道有哪个框架用到-NIO-了吗？"><a href="#4-你知道有哪个框架用到-NIO-了吗？" class="headerlink" title="4# 你知道有哪个框架用到 NIO 了吗？"></a>4# 你知道有哪个框架用到 NIO 了吗？</h2><p><strong>Netty</strong></p>
<p>Netty 的 IO 模型是基于非阻塞 IO 实现的，底层依赖的是 NIO 框架的多路复用器 Selector。采用 epoll 模式后，只需要一个线程负责 Selector 的轮询。当有数据处于就绪状态后，需要一个事件分发器（Event Dispather），它负责将读写事件分发给对应的读写事件处理器（Event Handler）。事件分发器有两种设计模式：Reactor 和 Proactor，Reactor 采用同步 IO， Proactor 采用异步 IO</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1715424254674-7a7159b1-d1ed-4236-ae18-09421c9837ed.png" alt="Netty 的 IO 模型"></p>
<p>Reactor 实现相对简单，适合处理耗时短的场景，对于耗时长的 IO 操作容易造成阻塞。Proactor 性能更高，但是实现逻辑非常复杂，适合图片或视频流分析服务器，目前主流的事件驱动模型还是依赖 select 或 epoll 来实现</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="1-有一个学生类，想按照分数排序，再按学号排序，应该怎么做？"><a href="#1-有一个学生类，想按照分数排序，再按学号排序，应该怎么做？" class="headerlink" title="1# 有一个学生类，想按照分数排序，再按学号排序，应该怎么做？"></a>1# 有一个学生类，想按照分数排序，再按学号排序，应该怎么做？</h2><p>在学生类中实现 <code>Comparable</code> 接口，并重写 <code>compareTo</code> 方法，然后在 <code>compareTo</code> 方法中实现按照分数排序和按照学号排序的逻辑:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法和其他属性、方法省略</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student other)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.score != other.score) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(other.score, <span class="built_in">this</span>.score); <span class="comment">// 按照分数降序排序</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.id, other.id); <span class="comment">// 如果分数相同，则按照学号升序排序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在需要对学生列表进行排序的地方，使用 <code>Collections.sort()</code> 方法对学生列表进行排序即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 添加学生对象到列表中</span></span><br><span class="line">Collections.sort(students);</span><br></pre></td></tr></table></figure>



<h2 id="2-解释一下-native-方法"><a href="#2-解释一下-native-方法" class="headerlink" title="2# 解释一下 native 方法"></a>2# 解释一下 native 方法</h2><p>在 Java 中，native 方法是一种特殊类型的方法，它允许 Java 代码调用外部的本地代码，即用 C、CPP 或其他语言编写的代码</p>
<p>native 方法看起来与其他方法相似，只是其方法体由 <code>native</code> 关键字代替，标记一个方法的实现将在外部定义，没有实际的实现代码。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeMethod</span><span class="params">()</span>; <span class="comment">// 声明为 native，无方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用 native 方法的一般流程</strong>：</p>
<ol>
<li><strong>声明 native 方法</strong>：在 Java 类中使用 <code>native</code> 关键字声明方法，无需提供方法体</li>
<li><strong>生成 JNI 头文件</strong>：使用 <code>javac</code> 编译 Java 类，然后用 <code>javah</code>（或 <code>javac -h</code>，较新版本）生成对应的 C&#x2F;CPP 头文件（<code>.h</code>），该文件包含 native 方法的函数签名</li>
<li><strong>实现本地代码</strong>：编写本地代码，实现 <code>.h</code> 文件中声明的方法逻辑。函数名需严格匹配 JNI 的命名规范</li>
<li><strong>编译为本地库</strong>：将本地代码编译成动态链接库（<code>.dll</code>，在 Windows 上），共享库（<code>.so</code>，在 Linux 上）</li>
<li><strong>加载本地库</strong>：使用 <code>System.loadLibrary(&quot;库名&quot;)</code> 加载编译好的本地库，使 JVM 能调用 native 方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeExample</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;nativeLib&quot;</span>); <span class="comment">// 加载名为 nativeLib 的本地库</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeMethod</span><span class="params">()</span>; <span class="comment">// 声明 native 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NativeExample</span>().nativeMethod(); <span class="comment">// 调用本地方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"># 笔记</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/11/13/AimAssist/" rel="prev" title="AimAssist">
                  <i class="fa fa-angle-left"></i> AimAssist
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/07/02/boilerplate-answers-2-java-collection/" rel="next" title="八股文笔记 #2 Java 集合">
                  八股文笔记 #2 Java 集合 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2024 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Marnumon</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">102k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">6:10</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div><script color="150,0,255" opacity="0.5" zIndex="-1" count="64" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/Marnumon" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"Marnumon","repo":"blog-comments","client_id":"Ov23liskioUxOHwH9wCv","client_secret":"09fa60a57fa00d2a18c0f7d36df7332f5a659915","admin_user":"Marnumon","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":null,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"b537261a9067f798d58a2928cbae67b4"}</script>
<script src="/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
