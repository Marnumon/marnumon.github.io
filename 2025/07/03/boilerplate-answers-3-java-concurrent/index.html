<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Courgette:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"marnumon.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>



<link rel="canonical" href="https://marnumon.github.io/2025/07/03/boilerplate-answers-3-java-concurrent/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://marnumon.github.io/2025/07/03/boilerplate-answers-3-java-concurrent/","path":"2025/07/03/boilerplate-answers-3-java-concurrent/","title":"八股文笔记 #3 Java 并发"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>八股文笔记 #3 Java 并发 | marnu's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>





  <script src="/js/third-party/pace.js" defer></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">marnu's blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Java-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%80%E6%A0%B7%E5%90%97%EF%BC%9F"><span class="nav-text">1# Java 的线程和操作系统的线程一样吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%A6%81%E6%B3%A8%E6%84%8F%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">2# 使用多线程要注意哪些问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%A1%88%E5%91%A2%EF%BC%9F"><span class="nav-text">3# 保证数据的一致性有哪些方案呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-text">4# 线程的创建方式有哪些?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B-%EF%BC%9F"><span class="nav-text">5# 如何启动线程 ？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="nav-text">6# 如何停止线程?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-interrupt-%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%A9%E7%BA%BF%E7%A8%8B%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84"><span class="nav-text">7# interrupt() 是如何让线程抛出异常的?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-Java-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">8# Java 线程的状态有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-sleep-%E5%92%8C-wait-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">9# sleep() 和 wait() 的区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-sleep-%E4%BC%9A%E9%87%8A%E6%94%BE-CPU-%E5%90%97%EF%BC%9F"><span class="nav-text">10# sleep() 会释放 CPU 吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-BLOCKED-%E5%92%8C-WAITING-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">11# BLOCKED 和 WAITING 有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E7%BA%BF%E7%A8%8B%E5%A4%84%E4%BA%8E-WAITING-%E7%8A%B6%E6%80%81%E6%97%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E4%B8%BA-RUNNING-%E7%8A%B6%E6%80%81"><span class="nav-text">12# 线程处于 WAITING 状态时，如何恢复为 RUNNING 状态?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-notify-%E5%92%8C-notifyAll-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">13# notify() 和 notifyAll() 的区别?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-notify-%E5%94%A4%E9%86%92%E7%9A%84%E6%98%AF%E5%93%AA%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="nav-text">14# notify() 唤醒的是哪个线程?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">15# 线程间通信方式有哪些？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-text">线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-juc-%E5%8C%85%E4%B8%8B%E4%BD%A0%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">1# juc 包下你常用的类有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="nav-text">2# 怎么保证多线程安全？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Java-%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E9%94%81%EF%BC%9F%E5%90%84%E8%87%AA%E9%80%82%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="nav-text">3# Java 中有哪些常用的锁？各自适用于什么场景？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%80%8E%E4%B9%88%E5%9C%A8%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%94%A8%E9%94%81%E7%9A%84%EF%BC%9F"><span class="nav-text">4# 怎么在实践中用锁的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Java-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">5# Java 并发工具你知道哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-CountDownLatch-%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F"><span class="nav-text">6# CountDownLatch 是做什么的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-synchronized-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-text">7# synchronized 的工作原理？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E9%99%A4%E4%BA%86%E7%94%A8-synchronized%EF%BC%8C%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9F"><span class="nav-text">8# 除了用 synchronized，还有哪些方式可以实现线程同步？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-synchronized-%E9%94%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8E%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">9# synchronized 锁静态方法与普通方法的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E8%AE%B2%E4%B8%80%E4%B8%8B-synchronized-%E7%9A%84%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B"><span class="nav-text">10# 讲一下 synchronized 的锁升级过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-JVM-%E5%AF%B9-synchronized-%E7%9A%84%E4%BC%98%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="nav-text">11# JVM 对 synchronized 的优化机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%9F"><span class="nav-text">12#  怎么理解可重入锁？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-synchronized-%E6%94%AF%E6%8C%81%E9%87%8D%E5%85%A5%E5%90%97%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="nav-text">13# synchronized 支持重入吗？如何实现的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-ReentrantLock-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">14# ReentrantLock 工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-synchronized-%E5%92%8C-ReentrantLock-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">15# synchronized 和 ReentrantLock 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-AQS"><span class="nav-text">16# 介绍一下 AQS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-CAS-%E4%B8%8E-AQS-%E7%9A%84%E5%85%B3%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="nav-text">17# CAS 与 AQS 的关系与区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-%E5%A6%82%E4%BD%95%E7%94%A8-AQS-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%9F"><span class="nav-text">18# 如何用 AQS 实现一个可重入的公平锁？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-ThreadLocal-%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%81%E7%BB%93%E6%9E%84%E3%80%81%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BD%9C%E5%9C%A8%E9%97%AE%E9%A2%98"><span class="nav-text">19# ThreadLocal 的作用、结构、原理与潜在问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">20# 悲观锁和乐观锁的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-Java-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-text">21# Java 中实现乐观锁的常见方式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-CAS-%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-text">22# CAS 有什么缺点？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%89%80%E6%9C%89%E7%9A%84%E9%94%81%E9%83%BD%E4%BD%BF%E7%94%A8-CAS%EF%BC%9F"><span class="nav-text">23# 为什么不能所有的锁都使用 CAS？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-text">24# volatile 关键字有什么作用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">25# 指令重排序的原理是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-volatile-%E8%83%BD%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F"><span class="nav-text">26# volatile 能保证线程安全吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-volatile-%E4%B8%8E-sychronized-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">27# volatile 与 sychronized 的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%9F"><span class="nav-text">28# 什么是公平锁和非公平锁？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E5%90%9E%E5%90%90%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94%E5%85%AC%E5%B9%B3%E9%94%81%E5%A4%A7%EF%BC%9F"><span class="nav-text">29# 非公平锁吞吐量为什么比公平锁大？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30-synchronized-%E6%98%AF%E5%85%AC%E5%B9%B3%E9%94%81%E5%90%97%EF%BC%9F"><span class="nav-text">30# synchronized 是公平锁吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31-ReentrantLock%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%EF%BC%9F"><span class="nav-text">31# ReentrantLock是怎么实现公平锁的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="nav-text">32# 什么情况会产生死锁问题？如何解决？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">1# 介绍一下线程池的工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">2# 线程池的参数有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="nav-text">3# 线程池有哪些拒绝策略？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="nav-text">4# 如何设置线程池参数？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%E8%AE%BE%E7%BD%AE%E4%B8%BA-0-%E5%8F%AF%E4%BB%A5%E5%90%97%EF%BC%9F"><span class="nav-text">5# 核心线程数设置为 0 可以吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%A7%8D%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">6# 线程池种类有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%80%E8%88%AC%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="nav-text">7# 线程池一般是怎么用的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD-shutdown-%E3%80%81shutdownNow-%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-text">8# 线程池中 shutdown ()、shutdownNow() 这两个方法有什么作用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E6%8F%90%E4%BA%A4%E7%BB%99%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%8F%AF%E4%BB%A5%E6%92%A4%E5%9B%9E%E5%90%97%EF%BC%9F"><span class="nav-text">9# 提交给线程池的任务可以撤回吗？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF"><span class="nav-text">场景</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%93%E5%8D%B0%E5%A5%87%E5%81%B6%E6%95%B0%EF%BC%8C%E6%80%8E%E4%B9%88%E6%8E%A7%E5%88%B6%E6%89%93%E5%8D%B0%E7%9A%84%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="nav-text">1# 多线程打印奇偶数，怎么控制打印的顺序？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%9E%8B%E6%97%A2%E7%84%B6%E5%B7%B2%E7%BB%8F%E7%94%A8%E4%BA%86-synchronized%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E5%9C%A8%E5%8A%A0-volatile%EF%BC%9F"><span class="nav-text">2# 单例模型既然已经用了 synchronized，为什么还要在加 volatile？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%EF%BC%8C1-%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E8%BF%99%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%85%A8%E9%83%A8%E6%89%A7%E8%A1%8C%E5%AE%8C%E5%9C%A8%E6%89%A7%E8%A1%8C%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-text">3# 3 个线程并发执行，1 个线程等待这三个线程全部执行完在执行，怎么实现？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%81%87%E8%AE%BE%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E8%AF%BB%E5%86%99%E5%90%8C%E4%B8%80%E4%B8%AA%E6%95%B4%E5%9E%8B%E5%8F%98%E9%87%8F%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%80%BC%E4%B8%BA%E9%9B%B6%EF%BC%8C%E6%AF%8F%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%8A%A0-50-%E6%AC%A1%EF%BC%8C%E7%BB%93%E6%9E%9C%E5%8F%AF%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">4# 假设两个线程并发读写同一个整型变量，初始值为零，每个线程加 50 次，结果可能是什么？</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Marnumon"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Marnumon</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Marnumon" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Marnumon" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/84063541" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;84063541" rel="noopener me" target="_blank"><i class="fab fa-bilibili fa-fw"></i>Bilibili</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://bobnlp.site/" title="https:&#x2F;&#x2F;bobnlp.site" rel="noopener" target="_blank">bobnlp</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://marnumon.github.io/2025/07/03/boilerplate-answers-3-java-concurrent/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Marnumon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="marnu's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="八股文笔记 #3 Java 并发 | marnu's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          八股文笔记 #3 Java 并发
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-07-03 09:12:14" itemprop="dateCreated datePublished" datetime="2025-07-03T09:12:14+00:00">2025-07-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>24k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:28</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="1-Java-的线程和操作系统的线程一样吗？"><a href="#1-Java-的线程和操作系统的线程一样吗？" class="headerlink" title="1# Java 的线程和操作系统的线程一样吗？"></a>1# Java 的线程和操作系统的线程一样吗？</h2><p>是的，Java 中的线程本质上与操作系统的线程是一致的</p>
<img src="https://cdn.xiaolincoding.com//picgo/image-20240725230425385.png" alt="Java 线程" style="zoom: 25%;" />

<span id="more"></span>

<p>在现代 JVM（如 HotSpot）中，Java 使用的是 <strong>一对一的线程模型</strong>，即每创建一个 Java 线程，JVM 底层都会调用操作系统的 API（如 Linux 下的 <code>pthread_create</code>）来创建一个 <strong>原生线程</strong></p>
<p>因此，Java 线程与操作系统线程是 <strong>一一对应</strong> 的，拥有独立的调用栈、程序计数器等资源，由操作系统负责调度和管理</p>
<p>这种设计使得 Java 能够充分利用多核 CPU 的并发能力，同时也意味着 Java 线程的性能和行为，受到操作系统线程调度策略的影响</p>
<h2 id="2-使用多线程要注意哪些问题？"><a href="#2-使用多线程要注意哪些问题？" class="headerlink" title="2# 使用多线程要注意哪些问题？"></a>2# 使用多线程要注意哪些问题？</h2><p>在使用多线程编程时，最关键的是确保<strong>线程安全</strong>，避免由于<strong>数据竞争</strong>导致的数据不一致、程序行为异常等问题</p>
<p>Java 中的线程安全主要体现在以下三个方面：</p>
<ol>
<li><strong>原子性</strong>：原子性保证<strong>某个操作在执行过程中不会被其他线程打断</strong>，即<strong>同一时刻只能有一个线程对共享数据进行修改</strong>。可以通过以下方式保障原子性<ul>
<li>使用 <code>synchronized</code> 关键字对代码块或方法加锁</li>
<li>使用 <code>java.util.concurrent.atomic</code> 包下的原子类（如 <code>AtomicInteger</code>、<code>AtomicReference</code>）来进行原子操作</li>
</ul>
</li>
<li><strong>可见性</strong>：可见性指的是<strong>一个线程对共享变量的修改能够及时地被其他线程看到</strong>。 Java 中通过以下机制保证可见性<ul>
<li><code>synchronized</code> 隐含地保证了进入和退出临界区时的内存刷新</li>
<li><code>volatile</code> 关键字用于标记变量，确保对该变量的读写不会被线程本地缓存，从而强制线程从主内存读取</li>
</ul>
</li>
<li><strong>有序性</strong>：在多线程环境下，Java 编译器和 CPU 可能对指令进行<strong>重排序</strong>以优化性能，导致线程间看到的执行顺序不一致。Java 使用<strong>happens-before 原则</strong>来建立线程间操作的执行顺序关系，确保必要的有序性</li>
</ol>
<h2 id="3-保证数据的一致性有哪些方案呢？"><a href="#3-保证数据的一致性有哪些方案呢？" class="headerlink" title="3# 保证数据的一致性有哪些方案呢？"></a>3# 保证数据的一致性有哪些方案呢？</h2><p>在并发编程或分布式系统中，确保数据一致性是至关重要的。以下是常见的几种实现方案：</p>
<ol>
<li><p><strong>事务管理</strong>：事务遵循 ACID 原则，通过数据库事务机制，确保一组操作要么<strong>全部执行成功并提交</strong>，要么<strong>全部失败并回滚</strong>，从而保证数据在操作过程中的一致性</p>
<ul>
<li><p><strong>原子性</strong>：事务中的所有操作要么全部执行，要么全部不执行</p>
</li>
<li><p><strong>一致性</strong>：事务执行前后，数据库始终处于一致的状态</p>
</li>
<li><p><strong>隔离性</strong>：多个事务之间的操作互不干扰</p>
</li>
<li><p><strong>持久性</strong>：事务一旦提交，数据变更就是永久性的</p>
</li>
</ul>
</li>
<li><p><strong>锁机制</strong>：锁机制是一种<strong>悲观并发控制策略</strong>，适合冲突概率较高的场景。通过加锁可以控制多个线程对共享资源的访问，避免并发读写导致的数据不一致问题。可以使用 Java 的 <code>synchronized</code> 关键字、<code>ReentrantLock</code> 等显示锁或者读写锁（<code>ReadWriteLock</code>）等</p>
</li>
<li><p><strong>版本控制（乐观锁）</strong>：乐观锁适用于<strong>读多写少、冲突较少</strong>的场景，可以有效提高系统的吞吐量。通过乐观锁的方式，在更新数据时记录数据的版本信息，从而避免同时对同一数据进行修改，进而保证数据的一致性</p>
</li>
</ol>
<h2 id="4-线程的创建方式有哪些"><a href="#4-线程的创建方式有哪些" class="headerlink" title="4# 线程的创建方式有哪些?"></a>4# 线程的创建方式有哪些?</h2><p><del><strong>太长不看版</strong></del></p>
<table>
<thead>
<tr>
<th>方式</th>
<th>关键点</th>
<th>优点</th>
<th>局限</th>
</tr>
</thead>
<tbody><tr>
<td><strong>继承 <code>Thread</code></strong></td>
<td>重写 <code>run()</code>，调用 <code>start()</code></td>
<td>编写简单；<code>this</code> 即当前线程</td>
<td>已继承 <code>Thread</code>，无法再继承其他类，线程与任务代码强耦合</td>
</tr>
<tr>
<td><strong>实现 <code>Runnable</code></strong></td>
<td>实现 <code>run()</code>，包装进 <code>Thread</code></td>
<td>可继承其它父类；多个线程可共享同一任务对象</td>
<td>需用 <code>Thread.currentThread()</code> 取当前线程；无返回值</td>
</tr>
<tr>
<td><strong>实现 <code>Callable</code> + <code>FutureTask</code></strong></td>
<td>实现 <code>call()</code>，包装成 <code>FutureTask</code> 再交给 <code>Thread</code></td>
<td>任务可返回结果，可抛异常；多个线程可共享同一任务对象</td>
<td>代码略复杂；同样需 <code>Thread.currentThread()</code></td>
</tr>
<tr>
<td><strong>线程池（<code>ExecutorService</code>）</strong></td>
<td>任务提交给池；池内部复用线程</td>
<td>复用线程、限制并发、便于管理</td>
<td>参数配置不当易导致资源耗尽或死锁；调优、排错复杂</td>
</tr>
</tbody></table>
<ol>
<li><p><strong>继承 <code>Thread</code></strong>：这是最直接的一种方式，用户自定义类继承 <code>java.lang.Thread</code> 类，需要重写 <code>run()</code> 方法，<code>run()</code> 方法中定义了线程执行的具体任务。创建该类的实例后，通过调用 <code>start()</code> 方法启动线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">/* 任务逻辑 */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：编写简单，如果需要访问当前线程，无需使用 <code>Thread.currentThread()</code> 方法，直接使用 <code>this</code>，即可获得当前线程</li>
<li>缺点：因为线程类已经继承了 <code>Thread</code> 类，所以不能再继承其他的父类</li>
</ul>
</li>
<li><p><strong>实现 <code>Runnable</code></strong>：如果一个类已经继承了其他类，就不能再继承 <code>Thread</code> 类，此时可以实现 <code>java.lang.Runnable</code> 接口，需要重写 <code>run()</code> 方法，然后将此 <code>Runnable</code> 对象作为参数传递给 <code>Thread</code> 类的构造器，调用 <code>start()</code> 方法启动线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">/* 任务逻辑 */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyTask</span>()).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：线程类只是实现了 <code>Runable</code> 接口，还可以继承其他的类。在这种方式下，可以多个线程共享同一个目标对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将 CPU 代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想</li>
<li>缺点：编程稍微复杂，如果需要访问当前线程，必须使用 <code>Thread.currentThread()</code> 方法</li>
</ul>
</li>
<li><p><strong>实现 <code>Callable</code> 接口 + <code>FutureTask</code></strong>：<code>java.util.concurrent.Callable</code> 接口类似于 <code>Runnable</code>，但 <code>Callable</code> 的 <code>call()</code> 方法可以有返回值并且可以抛出异常。要执行 <code>Callable</code> 任务，需将它包装进一个 <code>FutureTask</code>，因为 <code>Thread</code> 类的构造器只接受 <code>Runnable</code> 参数，而 <code>FutureTask</code> 实现了 <code>Runnable</code> 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCall</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyCall</span>());</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(ft).start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> ft.get();  <span class="comment">// 阻塞拿结果</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>缺点：编程稍微复杂，如果需要访问当前线程，必须调用 <code>Thread.currentThread()</code> 方法</li>
<li>优点：线程只是实现 <code>Runnable</code> 或实现 <code>Callable</code> 接口，还可以继承其他类。这种方式下，多个线程可以共享一个 target 对象，非常适合多线程处理同一份资源的情形</li>
</ul>
</li>
<li><p><strong>使用线程池（Executor 框架）</strong>：从 Java 5 开始引入的 <code>java.util.concurrent.ExecutorService</code> 和相关类提供了线程池的支持，这是一种更高效的线程管理方式，避免了频繁创建和销毁线程的开销。可以通过 <code>Executors</code> 类的静态方法创建不同类型的线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    pool.submit(() -&gt; &#123;<span class="comment">/* 任务逻辑 */</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>缺点：程池增加了程序的复杂度，特别是当涉及线程池参数调整和故障排查时。错误的配置可能导致死锁、资源耗尽等问题，这些问题的诊断和修复可能较为复杂</p>
</li>
<li><p>优点：线程池可以重用预先创建的线程，避免了线程创建和销毁的开销，显著提高了程序的性能。对于需要快速响应的并发请求，线程池可以迅速提供线程来处理任务，减少等待时间。并且，线程池能够有效控制运行的线程数量，防止因创建过多线程导致的系统资源耗尽（如内存溢出）。通过合理配置线程池大小，可以最大化 CPU 利用率和系统吞吐量</p>
</li>
</ul>
</li>
</ol>
<h2 id="5-如何启动线程-？"><a href="#5-如何启动线程-？" class="headerlink" title="5# 如何启动线程 ？"></a>5# 如何启动线程 ？</h2><p>在 Java 中，启动线程的标准方式是调用 <code>Thread</code> 类的 <strong><code>start()</code> 方法</strong>。该方法会通知 JVM 去创建一个新的线程，并由系统调度线程执行 <code>run()</code> 方法中定义的任务逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建两个线程，并使用 start() 启动它们</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"></span><br><span class="line">myThread1.start();  <span class="comment">// 启动线程1</span></span><br><span class="line">myThread2.start();  <span class="comment">// 启动线程2</span></span><br></pre></td></tr></table></figure>



<h2 id="6-如何停止线程"><a href="#6-如何停止线程" class="headerlink" title="6# 如何停止线程?"></a>6# 如何停止线程?</h2><p>停止线程应遵循 <strong>协作式</strong> 原则，既让线程 <strong>自行结束</strong>，又确保资源得到正确释放</p>
<p><del><strong>太长不看版</strong></del></p>
<table>
<thead>
<tr>
<th>#</th>
<th>停止方式</th>
<th>简要说明</th>
<th>场景适配性</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>volatile</code> 标志位控制循环</td>
<td>主线程控制标志，工作线程轮询判断是否退出</td>
<td>简单计算任务</td>
</tr>
<tr>
<td>2</td>
<td>使用 <code>interrupt()</code> + 判断中断状态</td>
<td>发送中断信号，由线程检查 <code>isInterrupted()</code> 响应退出</td>
<td>阻塞&#x2F;非阻塞任务</td>
</tr>
<tr>
<td>3</td>
<td>可中断阻塞操作（<code>sleep()</code> &#x2F; <code>wait()</code> &#x2F; <code>join()</code>）</td>
<td>阻塞时响应中断，捕获异常后安全退出</td>
<td>阻塞型任务</td>
</tr>
<tr>
<td>4</td>
<td>使用 <code>return</code> 提前结束 <code>run()</code> 方法</td>
<td>可配合中断或标志位，在逻辑判断处直接返回退出</td>
<td>控制逻辑明确</td>
</tr>
<tr>
<td>5</td>
<td>使用线程池 + <code>Future.cancel(true)</code></td>
<td>在线程池中通过 Future 中断任务</td>
<td>线程池管理的任务</td>
</tr>
<tr>
<td>6</td>
<td>关闭底层资源解除不可中断阻塞</td>
<td>关闭资源触发异常，中断无法生效的情况专用</td>
<td>I&#x2F;O、Socket 阻塞</td>
</tr>
<tr>
<td>7</td>
<td><code>Thread.stop()</code>（已废弃）</td>
<td>强制终止，风险极高，不建议使用</td>
<td>禁止使用</td>
</tr>
</tbody></table>
<ol>
<li><p><strong>使用 volatile 标志位控制循环退出</strong>：通过定义共享的 <code>volatile</code> 布尔变量，线程在 <code>run()</code> 中轮询该变量判断是否继续执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SafeStopFlag</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread exiting safely.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123; running = <span class="literal">false</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>interrupt()</code> + 判断中断状态</strong>：主线程调用 <code>interrupt()</code> 设置中断标志，线程通过 <code>isInterrupted()</code> 判断是否终止</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InterruptCheck</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="comment">// 正常执行逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread interrupted, exiting.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>处理中断异常：可中断阻塞操作（如 sleep&#x2F;wait&#x2F;join）</strong>：调用 <code>interrupt()</code> 后，线程在阻塞方法中抛出 <code>InterruptedException</code>，在异常处理中结束线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SleepInterruptDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>); <span class="comment">// 阻塞</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Interrupted during sleep.&quot;</span>);</span><br><span class="line">            Thread.currentThread().interrupt(); <span class="comment">// 恢复中断状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>return</code> 提前结束 <code>run()</code> 方法</strong>：配合中断标志或其他条件判断，在满足某条件时通过 <code>return</code> 直接结束 <code>run()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReturnEarlyDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 提前退出</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行任务逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线程池 + <code>Future.cancel(true)</code> 中断任务</strong>：将任务提交给线程池，通过 <code>Future.cancel(true)</code> 向线程发送中断信号来终止执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">Future&lt;?&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">future.cancel(<span class="literal">true</span>); <span class="comment">// 触发中断</span></span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>关闭资源解除不可中断阻塞（如 Socket.accept()）</strong>：对于不能响应中断的阻塞方法，通过关闭相关底层资源（如 <code>ServerSocket</code>）使其抛出异常退出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SocketTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerSocket server;</span><br><span class="line"></span><br><span class="line">    SocketTask(ServerSocket server) &#123; <span class="built_in">this</span>.server = server; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> server.accept(); <span class="comment">// 阻塞不可中断</span></span><br><span class="line">                <span class="comment">// 处理 socket</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Interrupted while blocked.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        server.close(); <span class="comment">// 触发 accept() 抛异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不推荐：使用 <code>Thread.stop()</code> 强制终止线程（已废弃）</strong>：直接停止线程执行，不会进行资源清理，存在严重安全隐患</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">/* 永久循环 */</span> &#125;</span><br><span class="line">&#125;);</span><br><span class="line">t.start();</span><br><span class="line">t.stop(); <span class="comment">// 已废弃，可能导致数据不一致</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="7-interrupt-是如何让线程抛出异常的"><a href="#7-interrupt-是如何让线程抛出异常的" class="headerlink" title="7# interrupt() 是如何让线程抛出异常的?"></a>7# interrupt() 是如何让线程抛出异常的?</h2><p>在 Java 中，每个线程都关联一个布尔类型的<strong>中断标志位</strong>，用于表示线程是否被中断。该标志的初始值为 <code>false</code>，可以通过调用线程的 <code>interrupt()</code> 方法将其设为 <code>true</code></p>
<p>当其他线程调用某个线程的 <code>interrupt()</code> 方法时，具体表现分为两种情况：</p>
<ul>
<li><p>如果线程<strong>处于阻塞状态</strong>：如果调用了 <code>Thread.sleep()</code>、<code>Thread.join()</code> 或 <code>Object.wait()</code> 等方法，则调用 <code>interrupt()</code> 会立即<strong>中断阻塞状态</strong>，并在该线程中<strong>抛出 <code>InterruptedException</code> 异常</strong>。此机制允许线程及时响应中断请求，跳出阻塞操作并执行善后处理</p>
</li>
<li><p>如果线程<strong>没有处于阻塞状态</strong>：此时调用 <code>interrupt()</code> 并不会抛出异常，仅仅是<strong>将中断标志设置为 <code>true</code></strong>。线程可以在运行过程中<strong>自行检查中断状态</strong>，例如通过</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().isInterrupted();</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Thread.interrupted()) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>来自行决定是否退出当前任务，进行资源释放或中断处理</p>
</li>
</ul>
<h2 id="8-Java-线程的状态有哪些？"><a href="#8-Java-线程的状态有哪些？" class="headerlink" title="8# Java 线程的状态有哪些？"></a>8# Java 线程的状态有哪些？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1712648206670-824228d1-be28-449d-8509-fd4df4ff63d3.webp" alt="Java 线程状态变迁"></p>
<p>Java 中的线程状态由 <code>java.lang.Thread.State</code> 枚举类定义，总共有六种状态。你可以通过线程对象的 <code>getState()</code> 方法来获取当前线程所处的状态</p>
<table>
<thead>
<tr>
<th>线程状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>NEW</code></td>
<td>新建状态：线程对象已创建，但尚未调用 <code>start()</code> 方法，尚未启动执行</td>
</tr>
<tr>
<td><code>RUNNABLE</code></td>
<td>可运行状态：线程已调用 <code>start()</code>，处于<strong>就绪状态</strong>或<strong>正在运行</strong>中</td>
</tr>
<tr>
<td><code>BLOCKED</code></td>
<td>阻塞状态：线程尝试获取某个对象的监视器锁时被阻塞，等待锁的释放</td>
</tr>
<tr>
<td><code>WAITING</code></td>
<td>等待状态：线程无限期等待另一个线程执行某个操作（如 <code>notify()</code>）</td>
</tr>
<tr>
<td><code>TIMED_WAITING</code></td>
<td>超时等待状态：线程在指定时间内等待另一个线程的操作（如 <code>sleep()</code>、<code>join(long)</code>）</td>
</tr>
<tr>
<td><code>TERMINATED</code></td>
<td>终止状态：线程执行完毕或被异常中止，生命周期结束</td>
</tr>
</tbody></table>
<p><strong>补充说明</strong></p>
<ul>
<li><strong><code>RUNNABLE</code> 包含两种实际状态</strong>：<ul>
<li>就绪（Ready）：已准备好等待 CPU 分配时间片</li>
<li>运行中（Running）：正在由 CPU 执行</li>
</ul>
</li>
<li><strong><code>BLOCKED</code>、<code>WAITING</code> 和 <code>TIMED_WAITING</code></strong> 都表示线程处于非运行态，但它们的等待条件不同，需结合具体方法（如 <code>synchronized</code>、<code>wait()</code>、<code>sleep()</code> 等）来区分</li>
</ul>
<h2 id="9-sleep-和-wait-的区别是什么？"><a href="#9-sleep-和-wait-的区别是什么？" class="headerlink" title="9# sleep() 和 wait() 的区别是什么？"></a>9# sleep() 和 wait() 的区别是什么？</h2><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><code>sleep()</code></th>
<th><code>wait()</code></th>
</tr>
</thead>
<tbody><tr>
<td>所属类</td>
<td><code>Thread</code>（静态方法）</td>
<td><code>Object</code>（实例方法）</td>
</tr>
<tr>
<td>是否释放锁</td>
<td>不释放锁</td>
<td>会释放锁</td>
</tr>
<tr>
<td>使用前提</td>
<td>可在任何线程上下文中调用</td>
<td>必须在同步块或同步方法中调用（即持有对象锁）</td>
</tr>
<tr>
<td>唤醒方式</td>
<td>到达指定时间自动唤醒</td>
<td>需要其他线程调用 <code>notify()</code> &#x2F; <code>notifyAll()</code> 或超时</td>
</tr>
<tr>
<td>设计目的</td>
<td>使线程暂停指定时间，不涉及线程协作</td>
<td>用于线程之间通信与协作，主动释放锁进入等待队列</td>
</tr>
</tbody></table>
<p><strong>一、类归属不同</strong>：</p>
<ul>
<li><code>sleep()</code> 是 <code>Thread</code> 类的静态方法，通过 <code>Thread.sleep()</code> 调用，无需依赖对象实例</li>
<li><code>wait()</code> 是 <code>Object</code> 类的实例方法，必须通过对象调用，例如 <code>obj.wait()</code></li>
</ul>
<p><strong>二、是否释放锁</strong>：</p>
<ul>
<li><code>sleep()</code> 不释放任何锁，即使在同步代码块中调用，线程休眠期间仍然占有锁，其他线程无法访问同步资源</li>
<li><code>wait()</code> 会释放当前线程持有的对象锁，使其他线程可以获得该锁并继续执行</li>
</ul>
<p><strong>三、使用条件</strong>：</p>
<ul>
<li><code>sleep()</code> 可在任意代码位置调用，无需持有任何锁</li>
<li><code>wait()</code> 只能在同步块或同步方法中调用（即必须先获取该对象的监视器锁），否则会抛出 <code>IllegalMonitorStateException</code> 异常</li>
</ul>
<p><strong>四、唤醒机制</strong>：</p>
<ul>
<li><code>sleep()</code> 会在指定时间后自动唤醒，回到可运行状态等待 CPU 调度</li>
<li><code>wait()</code> 必须依赖 <code>notify()</code> 或 <code>notifyAll()</code> 显式唤醒，或设置超时时间（如 <code>wait(5000)</code>）后自动唤醒</li>
</ul>
<h2 id="10-sleep-会释放-CPU-吗？"><a href="#10-sleep-会释放-CPU-吗？" class="headerlink" title="10# sleep() 会释放 CPU 吗？"></a>10# sleep() 会释放 CPU 吗？</h2><p>是的，调用 <code>Thread.sleep()</code> 时，线程会<strong>释放 CPU 使用权</strong>，但<strong>不会释放它所持有的锁</strong></p>
<p>当线程执行 <code>Thread.sleep()</code> 方法时，它会<strong>进入 <code>TIMED_WAITING</code>（计时等待）状态</strong>，暂停执行指定的时间；在这段时间内，<strong>线程主动让出 CPU 时间片</strong>，操作系统会进行线程调度，将 CPU 分配给其他处于可运行状态的线程；这使得其他线程可以获得 CPU 并执行任务，从而提高系统的并发性能</p>
<p>虽然线程暂停执行，但<strong>不会释放它已持有的同步锁</strong>（例如通过 <code>synchronized</code> 获取的锁）。如果其他线程尝试获取这些锁，仍会被阻塞，直到当前线程恢复执行并释放锁</p>
<h2 id="11-BLOCKED-和-WAITING-有什么区别？"><a href="#11-BLOCKED-和-WAITING-有什么区别？" class="headerlink" title="11# BLOCKED 和 WAITING 有什么区别？"></a>11# BLOCKED 和 WAITING 有什么区别？</h2><p>Java 中线程的 <code>BLOCKED</code> 和 <code>WAITING</code> 状态都表示线程当前没有运行，但两者产生的原因和恢复机制完全不同，主要区别如下：</p>
<img src="https://cdn.xiaolincoding.com//picgo/93a0d1531ea1271770686b9e91664a9c.png" alt="线程竞争锁后的状态" style="zoom:50%;" />

<ol>
<li><strong>触发条件</strong>：<ul>
<li><strong><code>BLOCKED</code>（阻塞状态）</strong>：当线程尝试<strong>获取某个对象的锁</strong>（例如进入一个 <code>synchronized</code> 块或方法）而该锁已被其他线程占用时，线程会进入 <code>BLOCKED</code> 状态。此状态下线程在等待锁的释放，<strong>无法参与锁竞争</strong>，也不会执行任何指令</li>
<li><strong><code>WAITING</code>（等待状态）</strong>：当线程<strong>主动调用</strong>如 <code>Object.wait()</code>、<code>Thread.join()</code> 或 <code>LockSupport.park()</code> 方法时，会进入 <code>WAITING</code> 状态。此时线程进入<strong>无限期等待</strong>，线程将不会消耗 CPU 资源，并且不会参与锁的竞争</li>
</ul>
</li>
<li><strong>唤醒机制</strong>：<ul>
<li><strong><code>BLOCKED</code> 状态的线程</strong>会在持有锁的线程释放锁后，<strong>自动进入就绪（<code>RUNNABLE</code>）状态</strong>，并参与下一轮的锁竞争</li>
<li><strong><code>WAITING</code> 状态的线程</strong>不会自动唤醒，必须由其他线程显式地调用 <code>notify()</code>、<code>notifyAll()</code>、<code>unpark()</code> 等方法，或者使用 <code>join()</code> 等触发条件满足后，才会恢复运行</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>BLOCKED</code> 状态</th>
<th><code>WAITING</code> 状态</th>
</tr>
</thead>
<tbody><tr>
<td>触发方式</td>
<td>被动触发，等待锁的释放</td>
<td>主动调用等待方法（如 <code>wait()</code>、<code>join()</code>）</td>
</tr>
<tr>
<td>是否释放锁</td>
<td>❌ 不释放</td>
<td>✅ 调用 <code>wait()</code> 时会释放当前锁</td>
</tr>
<tr>
<td>唤醒机制</td>
<td>自动唤醒（当锁可用时）</td>
<td>必须显式唤醒（如 <code>notify()</code>）或条件满足</td>
</tr>
<tr>
<td>是否参与锁竞争</td>
<td>❌ 不参与</td>
<td>❌ 不参与，直到被唤醒</td>
</tr>
</tbody></table>
<ul>
<li><code>BLOCKED</code> 是因<strong>锁竞争失败被动进入</strong>的状态，<code>WAITING</code> 是线程<strong>主动进入等待</strong>的状态</li>
<li><code>BLOCKED</code> 的唤醒是<strong>自动的</strong>，<code>WAITING</code> 的唤醒是<strong>手动触发的</strong>。</li>
</ul>
<h2 id="12-线程处于-WAITING-状态时，如何恢复为-RUNNING-状态"><a href="#12-线程处于-WAITING-状态时，如何恢复为-RUNNING-状态" class="headerlink" title="12# 线程处于 WAITING 状态时，如何恢复为 RUNNING 状态?"></a>12# 线程处于 WAITING 状态时，如何恢复为 RUNNING 状态?</h2><p>核心机制是<strong>通过外部事件触发或资源可用性变化</strong>，比如<strong>其他线程调用 <code>notify()</code> 或 <code>notifyAll()</code> 唤醒它</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待线程</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    lock.wait();  <span class="comment">// 当前线程进入 WAITING 状态，并释放锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒线程</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    lock.notify();      <span class="comment">// 唤醒一个等待该锁的线程</span></span><br><span class="line">    <span class="comment">// lock.notifyAll(); // 唤醒所有在该锁上等待的线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<ul>
<li><code>notify()</code> 会随机唤醒一个正在该对象上等待的线程</li>
<li><code>notifyAll()</code> 会唤醒所有在该对象上等待的线程（通常用于多个线程等待同一条件的场景）</li>
<li>被唤醒的线程会重新尝试获取锁，<strong>一旦成功获取锁，就会从 <code>WAITING</code> 状态转为 <code>RUNNABLE</code>，最终进入 <code>RUNNING</code> 状态</strong>继续执行</li>
<li>如果唤醒后竞争锁失败，线程会暂时进入 <code>BLOCKED</code> 状态，直到成功获取锁</li>
</ul>
<h2 id="13-notify-和-notifyAll-的区别"><a href="#13-notify-和-notifyAll-的区别" class="headerlink" title="13# notify() 和 notifyAll() 的区别?"></a>13# notify() 和 notifyAll() 的区别?</h2><p>两者都用于唤醒因调用 <code>wait()</code> 而处于等待状态的线程，但在唤醒数量和行为上存在显著差异：</p>
<ul>
<li><strong>共同点</strong>：<ul>
<li>都只能在同步代码块或同步方法中调用</li>
<li>都会将等待中的线程从 <code>WAITING</code> 状态变为 <code>BLOCKED</code>，接着尝试竞争锁资源</li>
<li>被唤醒的线程只有在重新获得锁后才能继续执行</li>
</ul>
</li>
<li><strong>区别</strong>：<ul>
<li><code>notify()</code>：<strong>只唤醒一个</strong>正在等待当前对象锁的线程，具体唤醒哪个线程不可控。如果被唤醒的线程没有在运行过程中再次调用 <code>notify()</code> 或 <code>notifyAll()</code>，其他线程将继续处于等待状态，可能导致<strong>线程 “永久等待”</strong> 的问题（死锁风险）</li>
<li><code>notifyAll()</code>：<strong>唤醒所有</strong>等待当前对象锁的线程。所有被唤醒的线程将同时进入阻塞状态（<code>BLOCKED</code>），并竞争锁资源。最终只有一个线程获得锁并进入运行状态，其余线程继续等待锁，避免了遗漏唤醒的情况</li>
</ul>
</li>
<li><strong>推荐使用场景</strong>：<ul>
<li>当只有一个线程需要被唤醒时，可使用 <code>notify()</code></li>
<li>当可能有多个线程等待，且不能确定具体唤醒哪一个为最佳时，应使用 <code>notifyAll()</code>，以防遗漏唤醒导致系统阻塞</li>
</ul>
</li>
</ul>
<h2 id="14-notify-唤醒的是哪个线程"><a href="#14-notify-唤醒的是哪个线程" class="headerlink" title="14# notify() 唤醒的是哪个线程?"></a>14# notify() 唤醒的是哪个线程?</h2><p>从语义上讲，<code>notify()</code> 唤醒的是<strong>任意一个正在等待该对象锁的线程</strong>，具体唤醒哪一个线程，不在 Java 语言层面定义，而是<strong>由 JVM 的实现来决定的</strong></p>
<p>虽然规范中声明唤醒是 “非确定性” 的，但主流 JVM 实现（如 <strong>HotSpot</strong>）在内部的实际处理方式却并非真正随机：在 <strong>HotSpot JVM</strong> 中，<code>notify()</code> 通常按照**等待队列中的先后顺序（FIFO）**来唤醒线程，也就是说，<strong>先进入等待队列的线程，通常会先被唤醒</strong></p>
<h2 id="15-线程间通信方式有哪些？"><a href="#15-线程间通信方式有哪些？" class="headerlink" title="15# 线程间通信方式有哪些？"></a>15# 线程间通信方式有哪些？</h2><p><del><strong>太长不看版</strong></del></p>
<table>
<thead>
<tr>
<th>方案</th>
<th>适用场景</th>
<th>优点</th>
<th>注意点 &#x2F; 限制</th>
</tr>
</thead>
<tbody><tr>
<td><code>volatile</code> &#x2F; 共享变量</td>
<td>极简标志位、写少读多</td>
<td>语法简单</td>
<td>无法做复杂同步；需防 busy‑wait</td>
</tr>
<tr>
<td><code>wait/notify</code></td>
<td>经典线程协作</td>
<td>JDK 原生；释放锁</td>
<td>必须同步块；易误用</td>
</tr>
<tr>
<td><code>Lock</code> + <code>Condition</code></td>
<td>多条件、更高灵活度</td>
<td>可多队列；响应中断</td>
<td>需显式加&#x2F;解锁</td>
</tr>
<tr>
<td><code>BlockingQueue</code></td>
<td>生产‑消费模型、任务队列</td>
<td>封装好并发控制；易用</td>
<td>需选合适容量及实现</td>
</tr>
</tbody></table>
<ol>
<li><p><strong>共享变量（<code>volatile</code> &#x2F; <code>synchronized</code>）</strong>：多线程读写同一变量完成信息传递</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedVarDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;   <span class="comment">// 保证可见性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="comment">// 生产者</span></span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;Producer → flag=true&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="comment">// 消费者</span></span><br><span class="line">            <span class="keyword">while</span> (!flag) &#123; <span class="comment">/* busy‑wait */</span> &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer  ← flag=true&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> s)</span> &#123; <span class="keyword">try</span> &#123; Thread.sleep(s * <span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>volatile</code> → 可见性；若需原子更新，可配合 <code>synchronized</code> 或原子类</li>
<li><strong>缺点</strong>：忙等浪费 CPU；适合极简单的状态标志</li>
</ul>
</li>
<li><p><strong><code>wait/notify</code></strong>：线程在<strong>对象监视器</strong>上等待并释放锁，唤醒后再次竞争锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WaitNotifyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 消费者</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!ready) &#123;        <span class="comment">// 避免虚假唤醒</span></span><br><span class="line">                    <span class="keyword">try</span> &#123; lock.wait(); &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer  ← ready&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                ready = <span class="literal">true</span>;</span><br><span class="line">                lock.notify();          <span class="comment">// 或 notifyAll()</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Producer → notify&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> s)</span> &#123; <span class="keyword">try</span> &#123; Thread.sleep(s * <span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>必须</strong>在同步块&#x2F;同步方法内调用，否则抛 <code>IllegalMonitorStateException</code></p>
</li>
<li><p>建议 <code>while</code> 循环重判条件，防止虚假唤醒</p>
</li>
</ul>
</li>
<li><p><strong><code>Lock</code> + <code>Condition</code></strong>：<code>Condition</code> 提供与 <code>wait/notify</code> 等价但更灵活的 API，可配多条件队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LockConditionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">done</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 消费者</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!ready) done.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer  ← ready&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123; lock.unlock(); &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ready = <span class="literal">true</span>;</span><br><span class="line">                done.signal();          <span class="comment">// 或 signalAll()</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Producer → signal&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123; lock.unlock(); &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> s)</span> &#123; <span class="keyword">try</span> &#123; Thread.sleep(s * <span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>与 <code>wait/notify</code> 相比，可针对不同条件建多条等待队列，更易管理</li>
</ul>
</li>
<li><p><strong><code>BlockingQueue</code></strong>：使用 <strong>线程安全</strong> 的阻塞队列负责生产&#x2F;消费，完全无需显式加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BlockingQueueDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 消费者</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">item</span> <span class="operator">=</span> queue.take();                <span class="comment">// 阻塞直到有元素</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer  ← &quot;</span> + item);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">1</span>);                           <span class="comment">// 队列满则阻塞</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Producer → 1&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> s)</span> &#123; <span class="keyword">try</span> &#123; Thread.sleep(s * <span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>阻塞队列内部已处理好并发与等待逻辑，是<strong>最推荐</strong>的生产‑消费实现。</p>
</li>
<li><p>常见实现：<code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>、<code>SynchronousQueue</code> 等</p>
</li>
</ul>
</li>
</ol>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="1-juc-包下你常用的类有哪些？"><a href="#1-juc-包下你常用的类有哪些？" class="headerlink" title="1# juc 包下你常用的类有哪些？"></a>1# juc 包下你常用的类有哪些？</h2><p><strong>一、线程池相关</strong></p>
<ul>
<li><code>ThreadPoolExecutor</code>：最核心的线程池类，用于创建和管理线程池。通过它可以灵活地配置线程池的参数，如核心线程数、最大线程数、任务队列等，以满足不同的并发处理需求</li>
<li><code>Executors</code>：线程池工厂类，提供了一系列静态方法来创建不同类型的线程池，如 <code>newFixedThreadPool</code>（创建固定线程数的线程池）、<code>newCachedThreadPool</code>（创建可缓存线程池）、<code>newSingleThreadExecutor</code>（创建单线程线程池）等，方便开发者快速创建线程池</li>
</ul>
<p><strong>二、并发集合类</strong></p>
<ul>
<li><code>ConcurrentHashMap</code>：线程安全的哈希映射表，用于在多线程环境下高效地存储和访问键值对。它采用了分段锁等技术，允许多个线程同时访问不同的段，提高了并发性能，在高并发场景下比传统的 <code>Hashtable</code> 性能更好</li>
<li><code>CopyOnWriteArrayList</code>：线程安全的列表，在对列表进行修改操作时，会创建一个新的底层数组，将修改操作应用到新数组上，而读操作仍然可以在旧数组上进行，从而实现了读写分离，提高了并发读的性能，适用于读多写少的场景</li>
</ul>
<p><strong>三、同步工具类</strong></p>
<ul>
<li><code>CountDownLatch</code>：允许一个或多个线程等待其他一组线程完成操作后再继续执行。它通过一个计数器来实现，计数器初始化为线程的数量，每个线程完成任务后调用 <code>countDown()</code> 方法将计数器减一，当计数器为零时，等待的线程可以继续执行。常用于多个线程完成各自任务后，再进行汇总或下一步操作的场景</li>
<li><code>CyclicBarrier</code>：让一组线程互相等待，直到所有线程都到达某个屏障点后，再一起继续执行。与 <code>CountDownLatch</code> 不同的是，<code>CyclicBarrier</code> 可以重复使用，当所有线程都通过屏障后，计数器会重置，可以再次用于下一轮的等待。适用于多个线程需要协同工作，在某个阶段完成后再一起进入下一个阶段的场景</li>
<li><code>Semaphore</code>：信号量，用于控制同时访问某个资源的线程数量。它维护了一个许可计数器，线程在访问资源前需要获取许可，如果有可用许可，则获取成功并将许可计数器减一，否则线程需要等待，直到有其他线程释放许可。常用于控制对有限资源的访问，如数据库连接池、线程池中的线程数量等</li>
</ul>
<p><strong>四、原子类</strong></p>
<ul>
<li><code>AtomicInteger</code>：原子整数类，提供了对整数类型的原子操作，如自增、自减、比较并交换等。通过硬件级别的原子指令来保证操作的原子性和线程安全性，避免了使用锁带来的性能开销，在多线程环境下对整数进行计数、状态标记等操作非常方便</li>
<li><code>AtomicReference</code>：原子引用类，用于对对象引用进行原子操作。可以保证在多线程环境下，对对象的更新操作是原子性的，即要么全部成功，要么全部失败，不会出现数据不一致的情况。常用于实现无锁数据结构或需要对对象进行原子更新的场景</li>
</ul>
<h2 id="2-怎么保证多线程安全？"><a href="#2-怎么保证多线程安全？" class="headerlink" title="2# 怎么保证多线程安全？"></a>2# 怎么保证多线程安全？</h2><ol>
<li><strong><code>synchronized</code> 关键字</strong>：通过内置锁实现互斥访问，<code>Synchronized</code> 可用于修饰方法或代码块，确保同一时刻只有一个线程能访问同步区域。其本质是基于对象的监视器锁（monitor）机制</li>
<li><strong><code>volatile</code> 关键字</strong>：确保变量的可见性，使用 <code>volatile</code> 修饰的变量不会被线程缓存，所有线程访问的都是主内存中的最新值。适用于状态标志等无需原子性但需要可见性的场景</li>
<li><strong>显式锁 <code>Lock</code> 接口与 <code>ReentrantLock</code></strong>：更灵活的同步控制，<code>ReentrantLock</code> 是一种可重入互斥锁，提供了 <code>tryLock()</code>、<code>lockInterruptibly()</code> 等高级控制方式，相较 <code>synchronized</code> 更灵活</li>
<li><strong>原子类（<code>AtomicInteger</code> 等）</strong>：原子性操作无需加锁，<code>java.util.concurrent.atomic</code> 包提供了多种原子类，支持无锁线程安全操作，适用于高并发计数、状态标志等场景</li>
<li><strong>线程局部变量（<code>ThreadLocal</code>）</strong>：每个线程独享变量副本，<code>ThreadLocal</code> 为每个线程提供独立的变量副本，避免了共享带来的同步问题，适合线程封闭（Thread Confinement）场景</li>
<li><strong>并发集合类</strong>：内置线程安全机制，使用 <code>java.util.concurrent</code> 包中的并发集合（如 <code>ConcurrentHashMap</code>、<code>ConcurrentLinkedQueue</code> 等）可以避免手动加锁，提升并发性能</li>
<li><strong>JUC 工具类</strong>：协调线程间协作，Java 并发包提供了一系列同步工具类，用于线程间的通信与协作控制，如：<code>Semaphore</code>（限制并发线程数）、<code>CountDownLatch</code>（等待多个线程完成任务）、<code>CyclicBarrier</code>（多线程在屏障点统一继续执行）、<code>Exchanger</code>（线程间交换数据）</li>
</ol>
<h2 id="3-Java-中有哪些常用的锁？各自适用于什么场景？"><a href="#3-Java-中有哪些常用的锁？各自适用于什么场景？" class="headerlink" title="3# Java 中有哪些常用的锁？各自适用于什么场景？"></a>3# Java 中有哪些常用的锁？各自适用于什么场景？</h2><p>在多线程编程中，锁是保障线程安全、避免并发冲突的核心机制</p>
<ol>
<li><strong>内置锁（synchronized）</strong>：最基本的互斥机制，<code>Synchronized</code> 是 Java 内置的同步机制，用于修饰方法或代码块。线程在进入同步区域前需要获取锁，离开后自动释放，保证同一时间只有一个线程能访问被保护的资源。其中，<code>syncronized</code> 加锁时有无锁、偏向锁、轻量级锁和重量级锁几个级别。偏向锁用于当一个线程进入同步块时，如果没有任何其他线程竞争，就会使用偏向锁，以减少锁的开销。轻量级锁使用线程栈上的数据结构，避免了操作系统级别的锁。重量级锁则涉及操作系统级的互斥锁</li>
<li><strong>可重入锁（<code>ReentrantLock</code>）</strong>：功能更强的显式锁，<code>ReentrantLock</code> 是 <code>java.util.concurrent.locks</code> 包中的显式锁，功能上比 <code>synchronized</code> 更灵活，支持<strong>可中断锁获取、限时等待锁、公平锁&#x2F;非公平锁切换、多条件变量（Condition）支持</strong>等。<code>ReentrantLock</code> 使用 <code>lock()</code> 和 <code>unlock()</code> 方法来获取和释放锁。其中，公平锁按照线程请求锁的顺序来分配锁，保证了锁分配的公平性，但可能增加锁的等待时间。非公平锁不保证锁分配的顺序，可以减少锁的竞争，提高性能，但可能造成某些线程的饥饿</li>
<li><strong>读写锁（ReadWriteLock）</strong>：提高读多写少场景的并发性，<code>ReadWriteLock</code> 允许多个线程并发读取共享资源，但写操作是独占的。常见实现如 <code>ReentrantReadWriteLock</code></li>
<li><strong>乐观锁和悲观锁</strong>：<strong>悲观锁（Pessimistic Locking）</strong>：默认认为并发冲突频繁，访问数据前先加锁，如 <code>synchronized</code> 和 <code>ReentrantLock</code>；<strong>乐观锁（Optimistic Locking）</strong>：假设冲突很少，不加锁而是通过版本号或时间戳在更新时校验数据是否被修改，常用 <code>CAS</code> 机制实现</li>
<li><strong>自旋锁（SpinLock）</strong>：短时等待情况下的非阻塞锁机制，自旋锁不会让线程阻塞，而是持续循环尝试获取锁（通常基于 <code>CAS</code> 操作）。适合锁竞争时间非常短的场景，避免线程频繁上下文切换</li>
</ol>
<h2 id="4-怎么在实践中用锁的？"><a href="#4-怎么在实践中用锁的？" class="headerlink" title="4# 怎么在实践中用锁的？"></a>4# 怎么在实践中用锁的？</h2><p><del><strong>太长不看版</strong></del></p>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>使用方式示例</th>
<th>优点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>synchronized</code></td>
<td><code>synchronized</code> 方法或代码块</td>
<td>简单易用、JVM 自动管理</td>
<td>一般同步逻辑</td>
</tr>
<tr>
<td><code>ReentrantLock</code></td>
<td><code>lock()</code> &#x2F; <code>unlock()</code></td>
<td>可中断、公平锁、尝试锁等高级功能</td>
<td>对同步控制要求更高的场景</td>
</tr>
<tr>
<td><code>ReadWriteLock</code></td>
<td><code>readLock()</code> &#x2F; <code>writeLock()</code></td>
<td>多读并发、写独占、提升读多写少性能</td>
<td>缓存、配置读取等并发读取场景</td>
</tr>
</tbody></table>
<ol>
<li><p><strong>使用 <code>synchronized</code> 实现简单互斥</strong>：<code>synchronized</code> 是 Java 中最早的同步机制，可用于方法或代码块，隐式地为指定对象加锁，保证同一时间只有一个线程执行被保护的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步代码块</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> ( ) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用代码块可以灵活控制加锁粒度，并避免同步整个方法带来的性能损耗</p>
</li>
<li><p><strong>使用 <code>Lock</code> 接口实现显式加锁</strong>：<code>Lock</code> 接口提供了比 <code>synchronized</code> 更强大的锁控制能力，如<strong>可中断锁</strong>、<strong>限时尝试锁</strong>、<strong>公平锁</strong>等。<code>ReentrantLock</code> 是最常用的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 显式加锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 确保锁最终释放，避免死锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>try-finally</code> 块是使用 <code>Lock</code> 的规范做法，以确保即使抛出异常也能正确释放锁</p>
</li>
<li><p><strong>使用 <code>ReadWriteLock</code> 提升读多写少的并发性能</strong>：<code>ReadWriteLock</code> 提供一对互斥锁：<strong>读锁（<code>readLock()</code>）</strong> 和 <strong>写锁（<code>writeLock()</code>）</strong>。它允许多个线程同时读取数据，但写操作必须是独</p>
</li>
<li><p>占的。典型实现为 <code>ReentrantReadWriteLock</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">readData</span><span class="params">()</span> &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeData</span><span class="params">(Object newData)</span> &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data = newData;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个线程可以同时读取 <code>data</code>，而写操作则是互斥的，这种设计大幅提升了<strong>读多写少场景</strong>的并发性能</p>
</li>
</ol>
<h2 id="5-Java-并发工具你知道哪些？"><a href="#5-Java-并发工具你知道哪些？" class="headerlink" title="5# Java 并发工具你知道哪些？"></a>5# Java 并发工具你知道哪些？</h2><p>Java 的并发工具类大多位于 <code>java.util.concurrent</code> 包中，提供了丰富的 API 来简化并发编程。这里主要提供代码参考，它们的详细概念见 [1# juc 包下你常用的类有哪些？](#1# juc 包下你常用的类有哪些？)</p>
<ol>
<li><p><code>CountDownLatch</code> 是一个同步辅助类，它允许一个或多个线程等待其他线程完成一组操作。它通过一个倒计时计数器来协调线程之间的执行顺序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行任务&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                latch.countDown();  <span class="comment">// 任务完成，计数器减一</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成任务&quot;</span>);</span><br><span class="line">            &#125;, <span class="string">&quot;Worker-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程等待所有子线程完成...&quot;</span>);</span><br><span class="line">        latch.await();  <span class="comment">// 阻塞直到计数器为 0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;所有子线程已完成，主线程继续执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>CyclicBarrier</code> 允许一组线程互相等待，直到所有线程都到达屏障点（barrier）为止，然后一同继续执行。它可以循环使用，适合分阶段并行计算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(threadCount, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;所有线程已到达屏障，执行后续操作&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行任务&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    barrier.await();  <span class="comment">// 等待其他线程</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 通过屏障&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;Worker-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Semaphore</code> 是一个计数信号量，用于控制同时访问某资源的线程数量。可用于流量控制、资源池等场景</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">2</span>);  <span class="comment">// 同时允许两个线程访问</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();  <span class="comment">// 获取许可</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获得许可&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);  <span class="comment">// 模拟处理资源</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放许可&quot;</span>);</span><br><span class="line">                    semaphore.release();  <span class="comment">// 释放许可</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;Worker-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Callable</code> 接口类似于 <code>Runnable</code>，但可以返回结果或抛出异常。<code>Future</code> 表示异步任务的结果，用于查询任务是否完成、取消任务或获取结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureCallableExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        Callable&lt;Integer&gt; task = () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行任务&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt; future = executor.submit(task);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程继续执行其他任务&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get();  <span class="comment">// 阻塞直到结果返回</span></span><br><span class="line">        System.out.println(<span class="string">&quot;异步任务结果: &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ConcurrentHashMap</code> 是高并发环境下的线程安全哈希表。它在内部对桶进行分段锁处理，支持高效的并发读写操作，适用于读多写少或高并发环境</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMapExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ConcurrentHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;key1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key2&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并发读操作</span></span><br><span class="line">        map.forEach((key, value) -&gt; System.out.println(key + <span class="string">&quot;: &quot;</span> + value));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并发写操作</span></span><br><span class="line">        map.computeIfAbsent(<span class="string">&quot;key3&quot;</span>, k -&gt; <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="6-CountDownLatch-是做什么的？"><a href="#6-CountDownLatch-是做什么的？" class="headerlink" title="6# CountDownLatch 是做什么的？"></a>6# CountDownLatch 是做什么的？</h2><p><code>CountDownLatch</code> 是 Java 并发包（<code>java.util.concurrent</code>）中的一个同步辅助类，用于<strong>让一个或多个线程等待其他线程完成任务后再继续执行</strong></p>
<p>它的核心机制是一个<strong>计数器</strong>（Counter），常用于多线程协作场景，例如主线程等待多个子线程就绪、任务分批执行等，工作原理：</p>
<ol>
<li><strong>初始化计数器</strong>：创建 <code>CountDownLatch</code> 时指定一个初始计数值（如 <code>N</code>）</li>
<li><strong>等待阻塞</strong>：调用 <code>await()</code> 方法的线程会被阻塞，直到计数器变为 0</li>
<li><strong>计数递减</strong>：其他线程完成任务后调用 <code>countDown()</code> 方法，使计数器减 1</li>
<li><strong>唤醒等待线程</strong>：当计数器归零，所有调用了 <code>await()</code> 的线程将被唤醒，继续执行</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainThreadWaitExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在执行任务&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">                    latch.countDown();  <span class="comment">// 当前线程完成，计数器减 1</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成任务&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;Worker-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程等待所有子线程完成任务...&quot;</span>);</span><br><span class="line">        latch.await(); <span class="comment">// 主线程阻塞，直到所有子线程完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;所有任务已完成，主线程继续执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-synchronized-的工作原理？"><a href="#7-synchronized-的工作原理？" class="headerlink" title="7# synchronized 的工作原理？"></a>7# synchronized 的工作原理？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1719918642412-181e3769-49d8-4c78-8f33-a866367a4693.png" alt="synchronized 的工作原理"></p>
<ol>
<li><p><strong>编译层：生成字节码指令</strong></p>
<ul>
<li>在同步代码块（或同步方法）前后，编译器会插入 <code>monitorenter</code> &#x2F; <code>monitorexit</code> 指令</li>
<li>这两条指令由 JVM 调用 <strong>对象监视器（Monitor）</strong> 完成加锁与解锁</li>
</ul>
</li>
<li><p><strong>运行时：Monitor 的加锁 &#x2F; 解锁流程</strong></p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>① 线程执行 <code>monitorenter</code></td>
<td>尝试获取对象监视器： • 若对象<strong>未被锁定</strong>或<strong>当前线程已持有</strong>锁⇒ 计数器 <code>+1</code>，线程继续执行； • 否则将线程加入 <strong>EntryList</strong>，进入 <strong>BLOCKED</strong> 状态，等待锁可用。</td>
</tr>
<tr>
<td>② 线程执行 <code>monitorexit</code></td>
<td>将计数器 <code>-1</code>；当计数器变为 <strong>0</strong> 时： • 释放锁； • 从 <strong>EntryList</strong> 取出一个线程（或按公平策略）尝试获取锁。</td>
</tr>
</tbody></table>
<p><strong>Wait &#x2F; Notify 机制</strong></p>
<ul>
<li>当线程在同步块内调用 <code>wait()</code>：释放锁，计数器 <code>-1</code>，自身进入 <strong>WaitSet</strong></li>
<li>其他线程执行 <code>notify()</code> &#x2F; <code>notifyAll()</code> 会将 WaitSet 中的线程移动到 EntryList，再次参与锁竞争</li>
</ul>
</li>
<li><p><strong>内存语义</strong></p>
<ul>
<li><strong>加锁</strong>：先 <strong>清空当前线程工作内存</strong> 中共享变量，再从主内存读取，保证后续操作能看到最新值</li>
<li><strong>解锁</strong>：将工作内存中被修改的共享变量 <strong>刷新回主内存</strong>，保证其他线程可见</li>
</ul>
</li>
<li><p><strong>锁的性质与性能影响</strong></p>
<ul>
<li><code>synchronized</code> 属于 <strong>排他锁</strong>（互斥锁），同一时刻只能有一个线程持有</li>
<li>Java 线程与 OS 原生线程 1:1 对应，阻塞 &#x2F; 唤醒需要从<strong>用户态切换到内核态</strong>，成本较高</li>
<li>JVM 为降低开销引入 <strong>偏向锁、轻量级锁、重量级锁</strong> 的分级优化策略，尽量在用户态完成自旋或 CAS 竞争，仅在竞争激烈时才升级为重量级锁</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<p><code>synchronized</code> 通过 <strong>对象监视器</strong> 保证了：</p>
<ul>
<li><strong>原子性</strong>：同一时刻只有一个线程进入同步块</li>
<li><strong>可见性 &amp; 有序性</strong>：锁的释放与获取隐式包含内存屏障，满足 happens‑before 规则</li>
</ul>
<p>在实际编码中，只需使用 <code>synchronized</code> 关键字即可享受上述语义；理解其底层机制能帮助我们在性能调优、死锁排查等场景中更有针对性地分析问题</p>
<h2 id="8-除了用-synchronized，还有哪些方式可以实现线程同步？"><a href="#8-除了用-synchronized，还有哪些方式可以实现线程同步？" class="headerlink" title="8# 除了用 synchronized，还有哪些方式可以实现线程同步？"></a>8# 除了用 synchronized，还有哪些方式可以实现线程同步？</h2><ol>
<li><strong>使用 <code>ReentrantLock</code> 类</strong>：<code>ReentrantLock</code> 是一个可重入的互斥锁，相比 <code>synchronized</code> 提供了更灵活的锁定和解锁操作。它还支持公平锁和非公平锁，以及可以响应中断的锁获取操作</li>
<li><strong>使用<code>volatile</code>关键字</strong>：虽然 <code>volatile</code> 不是一种锁机制，但它可以确保变量的可见性。当一个变量被声明为 <code>volatile</code> 后，线程将直接从主内存中读取该变量的值，这样就能保证线程间变量的可见性。但它不具备原子性</li>
<li><strong>使用<code>Atomic</code>类</strong>：Java 提供了一系列的原子类，例如 <code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicReference </code>等，用于实现对单个变量的原子操作，这些类在实现细节上利用了 CAS（Compare-And-Swap）算法，可以用来实现无锁的线程安全</li>
</ol>
<h2 id="9-synchronized-锁静态方法与普通方法的区别"><a href="#9-synchronized-锁静态方法与普通方法的区别" class="headerlink" title="9# synchronized 锁静态方法与普通方法的区别"></a>9# synchronized 锁静态方法与普通方法的区别</h2><ol>
<li><p><strong>锁的对象不同</strong></p>
<ul>
<li><p><strong>普通方法</strong>：锁的是当前对象实例（<code>this</code>）。<strong>同一个对象实例</strong>的多个线程访问同步方法时会互斥；而<strong>不同实例对象</strong>之间互不干扰，可以并发执行各自的同步方法</p>
</li>
<li><p><strong>静态方法</strong>：锁的是当前类的 <code>Class</code> 对象（<code>ClassName.class</code>）。JVM 中每个类对应唯一一个 <code>Class</code> 对象，因此无论多少个实例，访问静态同步方法时都竞争同一把锁</p>
</li>
</ul>
</li>
<li><p><strong>作用范围不同</strong></p>
<ul>
<li><p><strong>普通方法</strong>：仅对<strong>同一对象实例</strong>的同步方法调用互斥，<strong>不同实例</strong>的调用互不干扰</p>
</li>
<li><p><strong>静态方法</strong>：对<strong>整个类范围内的该静态方法调用都互斥</strong>，无论是哪个实例，甚至没有实例化对象时也是如此</p>
</li>
</ul>
</li>
<li><p><strong>多实例场景影响不同</strong></p>
<ul>
<li><p><strong>普通方法</strong>：如果多个线程访问<strong>不同对象实例的同步普通方法</strong>，由于锁对象不同，它们之间<strong>可以并发执行</strong></p>
</li>
<li><p><strong>静态方法</strong>：而多个线程访问<strong>静态同步方法</strong>，即使是通过不同实例调用，<strong>也会串行执行</strong>，因为它们竞争的是同一个 <code>Class</code> 对象锁</p>
</li>
</ul>
</li>
</ol>
<h2 id="10-讲一下-synchronized-的锁升级过程"><a href="#10-讲一下-synchronized-的锁升级过程" class="headerlink" title="10# 讲一下 synchronized 的锁升级过程"></a>10# 讲一下 synchronized 的锁升级过程</h2><p>具体的锁升级的过程是：<strong>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</strong></p>
<ol>
<li><strong>无锁</strong>：在对象创建初期，处于无锁状态，此时对象的对象头（Mark Word）中未记录线程相关信息，如果 JVM 未开启偏向锁（或偏向锁延迟生效），线程进入同步块将直接尝试升级为轻量级锁</li>
<li><strong>偏向锁</strong>：当对象第一次被某线程获取锁时，Mark Word 会记录该线程的 ID，之后该线程再次进入同步块时，只需比较 Mark Word 中的线程 ID 是否匹配，即可直接获取锁，无需 CAS 操作，也不会挂起线程；如果另一个线程尝试获取偏向锁，会触发 <strong>偏向锁撤销</strong>，撤销后锁升级为<strong>轻量级锁</strong>，同时偏向锁将不可再用于该对象（或类）</li>
<li><strong>轻量级锁</strong>：适用于多线程存在竞争，但<strong>竞争不激烈</strong>的场景。当前线程在进入同步块时，在自己虚拟机栈中创建 <strong>锁记录（Lock Record）</strong>，并将对象的 Mark Word 复制到锁记录中，然后尝试通过 <strong>CAS</strong> 将对象头中的 Mark Word 替换为指向这个锁记录的指针，如果 CAS 成功，表示线程获得锁；如果 CAS 失败，说明有其他线程竞争该锁 —— 进入自旋尝试再次获取，自旋多次仍无法获取，则升级为重量级锁</li>
<li><strong>重量级锁</strong>：发生在多线程高竞争场景。无法通过自旋获取锁的线程将被 <strong>挂起</strong>（阻塞），由操作系统调度，等待唤醒，重量级锁的获取和释放涉及<strong>用户态与内核态切换</strong>，开销较大，但保证线程安全</li>
</ol>
<img src="https://cdn.xiaolincoding.com//picgo/1721808326210-cce43537-20e7-4b7d-bed3-737dc7904d9a.png" alt="synchronized 的锁升级过程" style="zoom: 33%;" />

<ul>
<li><p><strong>线程 A</strong> 首次进入 <code>synchronized</code> 块：</p>
<ul>
<li>如果偏向锁已启用且对象未被锁定，则偏向 A，记录其线程 ID</li>
<li>A 再次进入同步代码时，<strong>直接命中偏向锁</strong>，无阻塞、无 CAS</li>
</ul>
</li>
<li><p><strong>线程 B</strong> 也尝试获取锁：</p>
<ul>
<li><p>偏向锁被撤销，升级为轻量级锁</p>
</li>
<li><p>B 通过自旋尝试获取锁</p>
</li>
<li><p>如果自旋失败，锁升级为重量级，B 被挂起等待唤醒</p>
</li>
</ul>
</li>
</ul>
<h2 id="11-JVM-对-synchronized-的优化机制"><a href="#11-JVM-对-synchronized-的优化机制" class="headerlink" title="11# JVM 对 synchronized 的优化机制"></a>11# JVM 对 synchronized 的优化机制</h2><ol>
<li><p><strong>锁膨胀</strong>：<code>synchronized</code> 支持从<strong>无锁 → 偏向锁 → 轻量级锁 → 重量级锁</strong>的渐进式升级过程（也称“锁膨胀”）：初始状态为无锁，当一个线程独占锁时，使用 <strong>偏向锁</strong>，几乎无性能开销。有线程竞争时升级为 <strong>轻量级锁</strong>，通过 CAS 和自旋尝试获取锁。多线程竞争激烈、自旋失败后，升级为 <strong>重量级锁</strong>，线程阻塞、由操作系统调度。这一机制极大减少了用户态与内核态之间的切换，提升了 <code>synchronized</code> 的性能</p>
</li>
<li><p><strong>锁消除</strong>：指的是在某些情况下，JVM 虚拟机如果检测不到某段代码被共享和竞争的可能性，就会将这段代码所属的同步锁消除掉，从而到底提高程序性能的目的</p>
</li>
<li><p><strong>锁粗化</strong>：如果 JVM 发现某个线程在<strong>短时间内频繁进行加锁和解锁操作</strong>，则会将这些操作合并成一个<strong>更大粒度的锁范围</strong></p>
</li>
<li><p><strong>自适应自旋锁</strong>：如果锁在短时间内就能被释放，则自旋线程可以快速获得锁，避免线程挂起&#x2F;恢复所造成的性能开销。若线程在之前的自旋中成功获取过锁，则可能增加下一次的自旋次数；若多次自旋失败，则减少自旋次数甚至不再自旋，直接阻塞</p>
</li>
</ol>
<h2 id="12-怎么理解可重入锁？"><a href="#12-怎么理解可重入锁？" class="headerlink" title="12#  怎么理解可重入锁？"></a>12#  怎么理解可重入锁？</h2><p><strong>可重入锁</strong>指的是：<strong>同一个线程在已经获取锁的情况下，仍然可以再次获取该锁而不会发生死锁</strong>。这种机制确保了在方法调用嵌套或递归时，线程不会因为已经持有的锁而被自己阻塞</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">outer</span><span class="params">()</span> &#123;</span><br><span class="line">    inner(); <span class="comment">// inner 也是 synchronized 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">inner</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果锁不具备可重入性，那么线程在调用 <code>outer()</code> 后再次尝试进入 <code>inner()</code> 时就会阻塞自己，造成死锁。而使用可重入锁机制，线程能够<strong>顺利重入</strong>，程序才能正常执行</p>
<p><code>ReentrantLock</code> 是 <code>java.util.concurrent.locks</code> 包下的可重入互斥锁，其可重入机制的核心是<strong>锁持有线程记录和重入计数器</strong>：</p>
<ul>
<li>当一个线程<strong>首次获取锁</strong>时：锁的持有线程被设置为当前线程，重入计数器设置为 <code>1</code></li>
<li>当该线程<strong>再次获取该锁</strong>时：如果判断当前线程已是锁的持有者，则只需将计数器加 <code>1</code>，<strong>不会被阻塞</strong></li>
<li>当线程执行完毕，<strong>释放锁时</strong>：每释放一次锁，计数器减 <code>1</code>，<strong>只有当计数器减为 0 时</strong>，锁才真正释放，其他线程才有机会获取</li>
</ul>
<p>这种计数机制避免了重复阻塞和死锁问题</p>
<h2 id="13-synchronized-支持重入吗？如何实现的？"><a href="#13-synchronized-支持重入吗？如何实现的？" class="headerlink" title="13# synchronized 支持重入吗？如何实现的？"></a>13# synchronized 支持重入吗？如何实现的？</h2><p>是的，<code>synchronized</code> 是<strong>可重入锁</strong>。这意味着：<strong>同一个线程在已经持有某个对象锁的情况下，可以再次获取该对象的锁而不会被阻塞</strong>。例如，在一个 <code>synchronized</code> 方法中调用该对象的另一个 <code>synchronized</code> 方法，当前线程不会因为再次请求锁而被挂起，这正是可重入性的体现</p>
<p><strong>如何实现？</strong></p>
<p><code>synchronized</code> 的底层实现依赖于 JVM 的<strong>监视器锁机制</strong>，而这些监视器锁通常是通过操作系统的 <strong>互斥量</strong> 实现的。其内部维护了两个核心状态：<strong>锁的持有线程和重入计数器</strong></p>
<ol>
<li><p><strong>锁的获取流程</strong></p>
<ul>
<li><p>**当线程首次请求锁：**检查锁的状态，若当前锁未被持有（状态为 0），则通过 CAS操作设置当前线程为锁持有者，同时将锁状态设为 1</p>
</li>
<li><p><strong>当锁已被占用时：<strong>如果当前线程再次请求该锁（即线程 ID 与持有锁线程一致），表示是重入，允许请求成功，并将</strong>重入计数器加 1</strong>；否则，线程将进入阻塞状态，等待锁释放</p>
<ol start="2">
<li><strong>锁的释放流程</strong></li>
</ol>
<ul>
<li>当线程执行完同步代码块或方法后，会释放锁</li>
<li>对于可重入锁，<strong>每释放一次锁，重入计数器减 1</strong>，仅当计数器减到 0 时，锁才真正释放，其他线程才能竞争该锁</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="14-ReentrantLock-工作原理"><a href="#14-ReentrantLock-工作原理" class="headerlink" title="14# ReentrantLock 工作原理"></a>14# ReentrantLock 工作原理</h2><p>ReentrantLock 的底层实现主要依赖于 AbstractQueuedSynchronizer（AQS）这个抽象类。AQS 是一个提供了基本同步机制的框架，其中包括了队列、状态值等</p>
<p>ReentrantLock 在 AQS 的基础上通过内部类 Sync 来实现具体的锁操作。不同的 Sync 子类实现了公平锁和非公平锁的不同逻辑：</p>
<ul>
<li><p><strong>可中断性</strong>： ReentrantLock 实现了可中断性，这意味着线程在等待锁的过程中，可以被其他线程中断而提前结束等待。在底层，ReentrantLock 使用了与 LockSupport.park() 和 LockSupport.unpark() 相关的机制来实现可中断性</p>
</li>
<li><p><strong>设置超时时间</strong>： ReentrantLock 支持在尝试获取锁时设置超时时间，即等待一定时间后如果还未获得锁，则放弃锁的获取。这是通过内部的 tryAcquireNanos 方法来实现的</p>
</li>
<li><p><strong>公平锁和非公平锁</strong>： 在直接创建 ReentrantLock 对象时，默认情况下是非公平锁。公平锁是按照线程等待的顺序来获取锁，而非公平锁则允许多个线程在同一时刻竞争锁，不考虑它们申请锁的顺序。公平锁可以通过在创建 ReentrantLock 时传入 true 来设置，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>多个条件变量</strong>： ReentrantLock 支持多个条件变量，每个条件变量可以与一个 ReentrantLock 关联。这使得线程可以更灵活地进行等待和唤醒操作，而不仅仅是基于对象监视器的 wait() 和 notify()。多个条件变量的实现依赖于 Condition 接口，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="comment">// 使用下面方法进行等待和唤醒</span></span><br><span class="line">condition.await();</span><br><span class="line">condition.signal();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>可重入性</strong>： ReentrantLock 支持可重入性，即同一个线程可以多次获得同一把锁，而不会造成死锁。这是通过内部的 holdCount 计数来实现的。当一个线程多次获取锁时，holdCount 递增，释放锁时递减，只有当 holdCount 为零时，其他线程才有机会获取锁</p>
</li>
</ul>
<h2 id="15-synchronized-和-ReentrantLock-的区别"><a href="#15-synchronized-和-ReentrantLock-的区别" class="headerlink" title="15# synchronized 和 ReentrantLock 的区别"></a>15# synchronized 和 ReentrantLock 的区别</h2><p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是 Java 中常用的<strong>可重入锁机制</strong>，用于实现线程间的互斥访问，但它们在语法、特性和底层实现等方面存在显著差异</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>synchronized</th>
<th>ReentrantLock</th>
</tr>
</thead>
<tbody><tr>
<td><strong>语法使用</strong></td>
<td>关键字形式，可修饰方法或代码块</td>
<td>通过显式调用 <code>lock()</code> 和 <code>unlock()</code> 进行加锁与释放，仅支持代码块</td>
</tr>
<tr>
<td><strong>加锁&#x2F;释放机制</strong></td>
<td>自动加锁与释放，进入同步块即加锁，退出即释放</td>
<td>需手动加锁与释放，必须配合 <code>try-finally</code> 使用避免死锁</td>
</tr>
<tr>
<td><strong>锁的公平性</strong></td>
<td>默认非公平，无法更改</td>
<td>支持公平锁（先到先得）与非公平锁（默认），通过构造函数设置</td>
</tr>
<tr>
<td><strong>中断响应能力</strong></td>
<td>不支持中断，线程在等待锁时无法被中断</td>
<td>支持中断，如 <code>lockInterruptibly()</code> 可响应中断，适用于死锁恢复</td>
</tr>
<tr>
<td><strong>条件变量支持</strong></td>
<td>支持单一条件队列（即 <code>wait()</code> &#x2F; <code>notify()</code>）</td>
<td>支持多个条件变量，基于 <code>Condition</code> 对象，控制更精细</td>
</tr>
<tr>
<td><strong>性能差异</strong></td>
<td>在现代 JVM 中性能已大幅优化，轻量、适合简单场景</td>
<td>灵活性强，适用于高并发场景，但使用复杂度稍高</td>
</tr>
<tr>
<td><strong>底层实现</strong></td>
<td>基于 JVM 实现，使用对象的<strong>监视器锁（Monitor）</strong>，生成 <code>monitorenter/monitorexit</code> 字节码</td>
<td>基于 AQS（AbstractQueuedSynchronizer）实现</td>
</tr>
</tbody></table>
<h2 id="16-介绍一下-AQS"><a href="#16-介绍一下-AQS" class="headerlink" title="16# 介绍一下 AQS"></a>16# 介绍一下 AQS</h2><p><strong>一、简介</strong></p>
<p>AQS 是 Java 提供的一个用于构建锁和同步器的抽象类，位于 <code>java.util.concurrent.locks</code> 包中。它是并发包的核心组件之一，被广泛应用于构建如 <code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code>、<code>ReentrantReadWriteLock</code>、<code>FutureTask</code> 等高级并发工具类</p>
<p>AQS 的核心思想是：<strong>如果共享资源空闲，则当前线程可直接获取锁；否则，线程需进入队列等待，直到被唤醒重新尝试获取锁</strong>。这个等待机制基于 <strong>CLH（Craig, Landin, and Hagersten）队列的变体</strong> —— 一个 <strong>虚拟的双向 FIFO 队列</strong>。AQS 会将每个请求资源但未成功的线程封装成一个 <code>Node</code> 节点，并串联到队列中，形成有序等待</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1721809581196-7c09ce04-1429-4810-ade4-bb3098a9303d.png" alt="CLH 变体队列"></p>
<p><strong>二、AQS 的核心组成</strong></p>
<p>AQS 的工作机制可以拆解为以下三大核心部分：</p>
<ol>
<li><p><strong>同步状态 <code>state</code></strong>：AQS 通过一个 <code>volatile int state</code> 变量来表示当前的同步状态，在不同的同步器中，<code>state</code> 表示不同含义：在 <code>ReentrantLock</code> 中：表示锁的重入次数；在 <code>Semaphore</code> 中：表示剩余的许可证数量；在 <code>CountDownLatch</code> 中：表示计数器的剩余数量</p>
<p>AQS 提供如下原子操作方法对 <code>state</code> 进行管理，这些操作基于底层的 <strong>Unsafe 类</strong> 和 CAS 机制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getState()</span><br><span class="line">setState(<span class="type">int</span> newState)</span><br><span class="line">compareAndSetState(<span class="type">int</span> expect, <span class="type">int</span> update)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>FIFO 同步队列（CLH 变体）</strong>：当线程无法成功获取同步状态时，它会被封装为一个 <code>Node</code> 并加入到 AQS 内部维护的 <strong>FIFO 双向等待队列</strong>中。该队列保证了线程获取锁的<strong>先来先服务</strong>原则，同时用于线程的阻塞与唤醒管理</p>
<p>AQS 就像一个“<strong>线程调度管家</strong>”，协调着所有竞争资源的线程：排队入列；等待唤醒；出队重新尝试获取锁</p>
</li>
<li><p><strong>获取与释放的模板方法（需子类实现）</strong>：AQS 通过模板方法设计模式，将核心的锁获取与释放逻辑交给具体的同步器子类实现。常用需要重写的方法包括：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> arg)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>获取操作</strong>：通常涉及 <code>acquire</code> 或 <code>acquireShared</code> 方法，若获取失败，线程将进入等待队列</li>
<li><strong>释放操作</strong>：通常是 <code>release</code> 或 <code>releaseShared</code>，当资源释放后，唤醒下一个等待的线程</li>
</ul>
<p>各个具体同步器类会根据自身语义实现这些方法，比如：<code>ReentrantLock</code> 实现了独占锁的获取与释放；<code>CountDownLatch</code> 实现了共享锁逻辑中的“倒计时”功能；<code>Semaphore</code> 控制并发线程数量，即许可数量管理</p>
</li>
</ol>
<p><strong>三、AQS 的职责总结</strong></p>
<table>
<thead>
<tr>
<th>作用</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>同步状态管理</strong></td>
<td>通过 <code>state</code> 和 CAS 保证原子性操作</td>
</tr>
<tr>
<td><strong>线程排队机制</strong></td>
<td>构建 CLH 队列，管理线程排队与调度</td>
</tr>
<tr>
<td><strong>模板方法扩展</strong></td>
<td>子类通过重写 <code>tryAcquire</code> 等方法定制锁语义</td>
</tr>
</tbody></table>
<h2 id="17-CAS-与-AQS-的关系与区别"><a href="#17-CAS-与-AQS-的关系与区别" class="headerlink" title="17# CAS 与 AQS 的关系与区别"></a>17# CAS 与 AQS 的关系与区别</h2><p><strong>一、两者的区别</strong></p>
<ol>
<li><strong>CAS（Compare-And-Swap）</strong>：CAS 是一种<strong>乐观锁机制</strong>，它通过对比内存中当前值和预期值是否一致，来决定是否更新数据。整个过程具备<strong>原子性</strong>，通常由底层硬件指令实现。<strong>CAS 的逻辑是</strong>：若内存地址 V 当前的值等于 A，则将 V 的值更新为 B；否则不做任何修改</li>
<li><strong>AQS（AbstractQueuedSynchronizer）</strong>：AQS 是一个用于构建同步器的抽象框架，例如 <code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code> 等都基于它实现。其核心机制包括：<ul>
<li>使用一个 <code>volatile int state</code> 表示<strong>同步状态</strong></li>
<li>使用一个变体的 <strong>CLH FIFO 队列</strong> 管理<strong>等待线程</strong></li>
<li>通过模板方法模式暴露出 <code>tryAcquire()</code>、<code>tryRelease()</code> 等方法，供具体同步器实现</li>
<li>AQS 提供了如 <code>acquire()</code>、<code>release()</code> 等通用同步操作，这些操作背后依赖状态的原子修改</li>
</ul>
</li>
</ol>
<p><strong>二、两者的关系</strong></p>
<p><strong>CAS 是 AQS 实现的基础手段之一</strong>。在 AQS 内部，为了实现线程安全地更新共享状态（即 <code>state</code> 变量），大量使用了 CAS 操作。其关键联系如下：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>状态修改</strong></td>
<td>AQS 通过 <code>CAS</code> 原子地修改 <code>state</code> 值，避免加锁操作</td>
</tr>
<tr>
<td><strong>获取资源</strong></td>
<td>在 <code>acquire()</code> 操作中，线程首先使用 CAS 尝试获取资源（修改 <code>state</code>）；如果失败，才进入阻塞队列</td>
</tr>
<tr>
<td><strong>释放资源</strong></td>
<td>在 <code>release()</code> 操作中，线程使用 CAS 安全地减少或重置 <code>state</code>，并唤醒下一个等待线程</td>
</tr>
<tr>
<td><strong>保证并发安全</strong></td>
<td>CAS 保证了 <code>state</code> 更新过程中的原子性，是整个 AQS 框架并发控制的关键保障</td>
</tr>
</tbody></table>
<h2 id="18-如何用-AQS-实现一个可重入的公平锁？"><a href="#18-如何用-AQS-实现一个可重入的公平锁？" class="headerlink" title="18# 如何用 AQS 实现一个可重入的公平锁？"></a>18# 如何用 AQS 实现一个可重入的公平锁？</h2><p>AQS 实现一个可重入的公平锁的详细步骤：</p>
<ol>
<li><strong>继承 AbstractQueuedSynchronizer</strong>：创建一个内部类继承自 <code>AbstractQueuedSynchronizer</code>，重写 <code>tryAcquire</code>、<code>tryRelease</code>、<code>isHeldExclusively</code> 等方法，这些方法将用于实现锁的获取、释放和判断锁是否被当前线程持有</li>
<li><strong>实现可重入逻辑</strong>：在 <code>tryAcquire</code> 方法中，检查当前线程是否已经持有锁，如果是，则增加锁的持有次数（通过 <code>state</code> 变量）；如果不是，尝试使用 CAS 操作来获取锁</li>
<li><strong>实现公平性</strong>：在 <code>tryAcquire</code> 方法中，按照队列顺序来获取锁，即先检查等待队列中是否有线程在等待，如果有，当前线程必须进入队列等待，而不是直接竞争锁</li>
<li><strong>创建锁的外部类</strong>：创建一个外部类，内部持有 <code>AbstractQueuedSynchronizer</code> 的子类对象，并提供 <code>lock</code> 和 <code>unlock</code> 方法，这些方法将调用 <code>AbstractQueuedSynchronizer</code> 子类中的方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FairReentrantLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 核心同步器，继承 AQS */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ========= 独占锁基础 ========= */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 当前线程是否占有锁 */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 尝试获取锁（公平 + 可重入）*/</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;                                     <span class="comment">// 锁空闲</span></span><br><span class="line">                <span class="comment">// ★ 公平性：队列前面有人 → 当前线程必须排队</span></span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors()</span><br><span class="line">                        &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// ★ 可重入</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (next &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;lock count overflow&quot;</span>);</span><br><span class="line">                setState(next);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 竞争失败</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 尝试释放锁 */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="literal">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);               <span class="comment">// 可重入计数减 1</span></span><br><span class="line">            <span class="keyword">return</span> free;               <span class="comment">// true → 唤醒队列首线程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ========= 条件变量 ========= */</span></span><br><span class="line"></span><br><span class="line">        Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;      <span class="comment">// 每个锁可派生多个条件队列</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ========= 对外 API ========= */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>           &#123; sync.acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="comment">// 解锁方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>         &#123; sync.release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="comment">// 判断当前线程是否持有锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHeldByMe</span><span class="params">()</span>  &#123; <span class="keyword">return</span> sync.isHeldExclusively(); &#125;</span><br><span class="line">    <span class="comment">// 提供一个条件变量，用于实现更复杂的同步需求，这里只是简单实现</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123; <span class="keyword">return</span> sync.newCondition(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>代码解释</strong></p>
<p><strong>内部类 Sync</strong>：</p>
<ul>
<li><code>isHeldExclusively</code>：使用 <code>getExclusiveOwnerThread</code> 方法检查当前锁是否被当前线程持有</li>
<li><code>tryAcquire</code>：<ul>
<li>首先获取当前锁的状态 <code>c</code></li>
<li>如果 <code>c</code> 为 0，表示锁未被持有，此时进行公平性检查，通过 <code>hasQueuedPredecessors</code> 检查是否有前驱节点在等待队列中。如果没有，使用 <code>compareAndSetState</code> 尝试将状态设置为 <code>acquires</code>（通常为 1），并设置当前线程为锁的持有线程</li>
<li>如果 <code>c</code> 不为 0，说明锁已被持有，检查是否为当前线程持有。如果是，增加锁的持有次数（可重入），但要防止溢出</li>
</ul>
</li>
<li><code>tryRelease</code>：<ul>
<li>先将状态减 <code>releases</code>（通常为 1）</li>
<li>检查当前线程是否为锁的持有线程，如果不是，抛出异常</li>
<li>如果状态减为 0，说明锁被完全释放，将持有线程设为 <code>null</code></li>
</ul>
</li>
<li><code>newCondition</code>：创建一个 <code>ConditionObject</code> 用于更复杂的同步操作，如等待 &#x2F; 通知机制。</li>
</ul>
<p><strong>外部类 FairReentrantLock</strong>：</p>
<ul>
<li><code>lock</code> 方法：调用 <code>sync.acquire(1)</code> 尝试获取锁</li>
<li><code>unlock</code> 方法：调用 <code>sync.release(1)</code> 释放锁</li>
<li><code>isLocked</code> 方法：调用 <code>sync.isHeldExclusively</code> 判断锁是否被当前线程持有</li>
<li><code>newCondition</code> 方法：调用 <code>sync.newCondition</code> 提供条件变量</li>
</ul>
<p><strong>使用示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FairReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FairReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    <span class="keyword">while</span> (!ready)              <span class="comment">// 条件不满足</span></span><br><span class="line">        condition.await();      <span class="comment">// 原子释放锁 + 挂起</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="19-ThreadLocal-的作用、结构、原理与潜在问题"><a href="#19-ThreadLocal-的作用、结构、原理与潜在问题" class="headerlink" title="19# ThreadLocal 的作用、结构、原理与潜在问题"></a>19# ThreadLocal 的作用、结构、原理与潜在问题</h2><p><code>ThreadLocal</code> 是 Java 提供的一种线程本地变量机制，它为每个线程提供独立的变量副本，避免多线程共享变量导致的线程安全问题</p>
<p><strong>一、ThreadLocal 的作用</strong></p>
<ol>
<li><p><strong>线程隔离</strong><br> 每个线程都维护自己的变量副本，线程之间互不影响，天然线程安全。常用于用户信息、数据库连接、事务上下文等场景</p>
</li>
<li><p><strong>简化参数传递，降低耦合度</strong><br> 不需要在方法间层层传递参数，便于在过滤器、拦截器等框架中保存线程上下文</p>
</li>
<li><p><strong>提升性能</strong><br> 避免加锁带来的开销，相比同步机制具有更优的性能，尤其适合高并发场景下的读操作</p>
</li>
</ol>
<p><strong>二、ThreadLocalMap 的内部结构</strong></p>
<img src="https://cdn.xiaolincoding.com//picgo/1719982991053-c983c4b8-7c5f-4e2d-a90d-5b42ebd533d5.png" alt="ThreadLocalMap" style="zoom:67%;" />

<ul>
<li>实际由一个 <strong>Entry 数组</strong> 实现（本质是一个定制的 HashMap）；</li>
<li><strong>Entry 的 key 是 ThreadLocal 实例（使用弱引用 WeakReference）</strong>；</li>
<li><strong>Entry 的 value 是对应线程的变量副本</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        Object value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：虽然 key 是 <code>WeakReference</code>（GC 可回收），但 value 是强引用，这种设计容易引发内存泄漏问题：</p>
<ul>
<li>如果 <code>ThreadLocal</code> 对象被外部代码丢弃（无强引用指向），而没有调用 <code>remove()</code>，即使 key 被 GC 回收，但 value 仍在 ThreadLocalMap 中，Entry 不会被自动清除，若线程是线程池中的线程（不会很快销毁），就会导致该 value 无法回收，造成 <strong>内存泄漏</strong></li>
</ul>
<p><strong>三、ThreadLocal 的工作原理</strong></p>
<p><code>ThreadLocal</code> 的实现依赖于 <strong>Thread 类中一个专属的 <code>ThreadLocalMap</code> 字段</strong>，每个 <code>ThreadLocal</code> 实例就是这个 Map 的 key，Map 中的 Value 就是当前线程对应的变量值</p>
<ul>
<li><strong>get() 方法</strong>：读取当前线程的 <code>ThreadLocalMap</code>，查找当前 <code>ThreadLocal</code> 作为 key 的 entry，找到则返回 value；找不到时，调用 <code>initialValue()</code> 初始化，存入 Map 并返回</li>
<li><strong>set(value) 方法</strong>：将当前 <code>ThreadLocal</code> 作为 key，value 存入当前线程的 <code>ThreadLocalMap</code> 中</li>
<li><strong>remove() 方法</strong>：移除当前线程中与该 <code>ThreadLocal</code> 实例关联的 entry，释放引用，防止内存泄漏</li>
</ul>
<h2 id="20-悲观锁和乐观锁的区别？"><a href="#20-悲观锁和乐观锁的区别？" class="headerlink" title="20# 悲观锁和乐观锁的区别？"></a>20# 悲观锁和乐观锁的区别？</h2><p>在并发编程中，<strong>悲观锁</strong>与<strong>乐观锁</strong>是两种常见的并发控制策略，它们的核心区别在于对<strong>资源竞争冲突的预期和处理方式</strong>不同</p>
<p><strong>一、悲观锁</strong></p>
<p>悲观锁对并发持谨慎态度，假设资源竞争一定会发生，因此在访问数据之前<strong>主动加锁</strong>，确保同一时间只有一个线程能访问该资源</p>
<p>悲观锁通过各种加锁机制实现，在操作数据之前即加锁，阻止其他线程并发访问。性能损耗较大，但冲突处理成本低，适合写操作频繁、冲突概率高或对一致性要求极高的业务场景（如金融、订单系统）</p>
<hr>
<p><strong>二、乐观锁</strong></p>
<p>乐观锁采取 “乐观” 的态度，认为线程之间的资源竞争是偶发的，大多数情况下不会发生冲突，因此不会在操作前加锁</p>
<p>乐观锁采用 <strong>“先检查再更新”</strong> 的方式进行控制，一般通过 <strong>CAS 机制</strong> 实现，在读取数据时不加锁，在更新时，通过对比数据是否被修改来决定是否成功更新，如果检测到冲突（数据已被其他线程修改），则重试或失败。适合读多写少或并发量大但冲突概率低的业务场景（如计数器、缓存更新等）</p>
<h2 id="21-Java-中实现乐观锁的常见方式？"><a href="#21-Java-中实现乐观锁的常见方式？" class="headerlink" title="21# Java 中实现乐观锁的常见方式？"></a>21# Java 中实现乐观锁的常见方式？</h2><table>
<thead>
<tr>
<th>实现方式</th>
<th>原理</th>
<th>场景适用</th>
<th>优点</th>
</tr>
</thead>
<tbody><tr>
<td>CAS 原子操作</td>
<td>比较并交换（无锁）</td>
<td>高并发、无共享状态的并发控制</td>
<td>快速、无阻塞</td>
</tr>
<tr>
<td>版本号控制</td>
<td>基于值的一致性检测</td>
<td>ORM 框架、数据库并发更新</td>
<td>精确控制、简单可靠</td>
</tr>
<tr>
<td>时间戳控制</td>
<td>基于时间的一致性检测</td>
<td>对更新时序敏感的场景</td>
<td>直观、可追踪</td>
</tr>
</tbody></table>
<ol>
<li><strong>CAS 操作：</strong> CAS 是乐观锁的基础。Java 提供了 <code>java.util.concurrent.atomic</code> 包中的原子类（如 <code>AtomicInteger</code>、<code>AtomicLong</code>），这些类使用 CAS 操作实现了线程安全的原子操作，可以用来实现乐观锁</li>
<li><strong>版本号控制</strong>：为共享资源维护一个“版本号”字段（或称 <code>version</code> &#x2F; <code>revision</code>），在更新前后对比版本号是否一致</li>
<li><strong>时间戳</strong>：使用数据的<strong>更新时间戳</strong>进行冲突检测。在更新数据时，在比较时间戳，如果当前时间戳大于数据的时间戳，则说明数据已经被其他线程更新，更新失败</li>
</ol>
<h2 id="22-CAS-有什么缺点？"><a href="#22-CAS-有什么缺点？" class="headerlink" title="22# CAS 有什么缺点？"></a>22# CAS 有什么缺点？</h2><ol>
<li><strong>ABA 问题</strong>：CAS 更新的过程中，当读取到的值是 A，然后准备赋值的时候仍然是 A，但是实际上有可能 A 的值被改成了 B，然后又被改回了 A，这个 CAS 更新的漏洞就叫做 ABA。只是 ABA 的问题大部分场景下都不影响并发的最终效果。Java 中有 <code>AtomicStampedReference</code> 来解决这个问题，它加入了预期标志和更新后标志两个字段，更新时不光检查值，还要检查当前的标志是否等于预期标志，全部相等的话才会更新</li>
<li><strong>循环时间长开销大</strong>：自旋 CAS 的方式如果长时间不成功，会给 CPU 带来很大的开销</li>
<li><strong>只能保证一个共享变量的原子操作</strong>：CAS 只能保证<strong>单个变量</strong>的原子更新。对于多个变量的复合操作，CAS 无法直接确保整体的原子性，容易产生中间状态或数据不一致的问题。可以使用 <code>AtomicReference</code> 进行对象整体引用的原子替换，对于复杂的多变量一致性需求，仍需使用传统的同步机制（如 <code>synchronized</code> 或 <code>ReentrantLock</code>）</li>
</ol>
<h2 id="23-为什么不能所有的锁都使用-CAS？"><a href="#23-为什么不能所有的锁都使用-CAS？" class="headerlink" title="23# 为什么不能所有的锁都使用 CAS？"></a>23# 为什么不能所有的锁都使用 CAS？</h2><ol>
<li><strong>自旋重试开销大，浪费 CPU 资源</strong>：当 CAS 失败时，线程不会挂起，而是不断地进行重试，大量线程同时自旋，频繁占用 CPU，会导致系统负载升高，甚至出现性能下降</li>
<li><strong>无法处理复杂的临界区逻辑</strong>：CAS 适合用于更新<strong>简单变量（如整数、引用）<strong>的场景，但不适合处理具有</strong>复杂临界区逻辑</strong>的同步问题（如多个变量同时更新、存在阻塞等待、必须保证某段代码原子执行）</li>
<li><strong>缺乏阻塞机制，不适用于等待&#x2F;唤醒模型</strong>：CAS 本身没有提供线程挂起与唤醒机制，一旦失败只能选择不停地重试</li>
</ol>
<h2 id="24-volatile-关键字有什么作用？"><a href="#24-volatile-关键字有什么作用？" class="headerlink" title="24# volatile 关键字有什么作用？"></a>24# volatile 关键字有什么作用？</h2><p><strong>一、保证可见性</strong></p>
<p>当一个变量被声明为 <code>volatile</code> 时，它保证了<strong>该变量对所有线程的可见性</strong>。一个线程对 <code>volatile</code> 变量的写操作，<strong>会立即刷新到主内存</strong>，其他线程在读取该变量时，<strong>总是直接从主内存中获取值</strong>，而不是从线程本地缓存中读取， 这样可以避免由于线程工作内存（缓存）不同步导致的数据不一致问题</p>
<p><strong>二、禁止指令重排序）</strong></p>
<p><code>volatile</code> 可以通过插入<strong>内存屏障</strong>来禁止特定类型的指令重排序，从而在一定程度上保证有序性：</p>
<ul>
<li><strong>写屏障</strong>：在对 <code>volatile</code> 变量写入之前插入。在 <code>volatile</code> 写之前的所有普通写操作在内存中都可见，防止这些写操作被重排序到 <code>volatile</code> 写之后</li>
<li><strong>读屏障</strong>：在读取 <code>volatile</code> 变量之后插入。防止后续普通读操作被提前到 <code>volatile</code> 读操作之前执行，确保读取的是最新数据</li>
<li><strong>写-读屏障</strong>：在 <code>volatile</code> 写之后和 <code>volatile</code> 读之间。<code>volatile</code> 写之前的所有写操作在 <code>volatile</code> 读之前对其他线程可见；同时防止 <code>volatile</code> 读之后的操作被重排到前面</li>
</ul>
<h2 id="25-指令重排序的原理是什么？"><a href="#25-指令重排序的原理是什么？" class="headerlink" title="25# 指令重排序的原理是什么？"></a>25# 指令重排序的原理是什么？</h2><p>为了提升程序运行效率，<strong>编译器</strong>和<strong>CPU处理器</strong>通常会对指令执行顺序进行优化，称为<strong>指令重排序</strong>。这是一种在保证单线程语义不变的前提下，重新调整代码执行顺序的技术，它必须遵守以下两个核心原则：</p>
<ol>
<li><p><strong>单线程语义等价</strong>：重排序不能改变<strong>单线程环境下程序的执行结果</strong>。换句话说，从单线程的角度看，重排序前后程序的行为应保持一致</p>
</li>
<li><p>**遵守数据依赖性约束：如果两条语句存在数据依赖关系（如读写同一个变量），它们的执行顺序不能被重排</p>
<ul>
<li><p>写后读（Write → Read）</p>
</li>
<li><p>写后写（Write → Write）</p>
</li>
<li><p>读后写（Read → Write）</p>
</li>
</ul>
</li>
</ol>
<p>所以重排序不会对单线程有影响，只会破坏多线程的执行语义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// A</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;  <span class="comment">// B</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;  <span class="comment">// C</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>C</code> 依赖 <code>A</code> 和 <code>B</code>，即它需要在 <code>A</code> 和 <code>B</code> 之后执行</li>
<li>因此，<strong><code>C</code> 不能被重排序</strong>到 <code>A</code> 或 <code>B</code> 之前</li>
<li>但是 <code>A</code> 和 <code>B</code> 之间没有依赖关系，它们的执行顺序可以被编译器或处理器重排</li>
</ul>
<p>虽然在<strong>单线程中</strong>重排序不会影响最终结果，但在<strong>多线程环境下</strong>，不同线程看到的执行顺序可能不一致，从而引发不可预期的问题，尤其是涉及共享变量的读写操作时。因此，Java 提供了 <code>volatile</code> 关键字和 <code>synchronized</code> 等机制，来<strong>禁止特定的重排序</strong>，确保在多线程下的可见性和有序性</p>
<h2 id="26-volatile-能保证线程安全吗？"><a href="#26-volatile-能保证线程安全吗？" class="headerlink" title="26# volatile 能保证线程安全吗？"></a>26# volatile 能保证线程安全吗？</h2><p><code>volatile</code> 关键字<strong>只能保证变量的可见性</strong>，<strong>不能保证原子性</strong>，因此 <strong>并不能完全保证线程安全</strong></p>
<ul>
<li><code>volatile</code> 并不能保证原子性（如 <code>i++</code> 操作就不是原子的）</li>
<li>如果需要保证原子性，应考虑使用 <code>synchronized</code> 或原子类（如 <code>AtomicInteger</code>）</li>
<li>它适用于状态标志类变量（如 <code>stopFlag</code>、<code>ready</code> 等），但不适合用于涉及复合操作（读-改-写）的逻辑</li>
</ul>
<h2 id="27-volatile-与-sychronized-的区别？"><a href="#27-volatile-与-sychronized-的区别？" class="headerlink" title="27# volatile 与 sychronized 的区别？"></a>27# volatile 与 sychronized 的区别？</h2><table>
<thead>
<tr>
<th>特性</th>
<th><code>volatile</code></th>
<th><code>synchronized</code></th>
</tr>
</thead>
<tbody><tr>
<td>可见性</td>
<td>✅ 保证</td>
<td>✅ 保证</td>
</tr>
<tr>
<td>原子性</td>
<td>❌ 不保证</td>
<td>✅ 保证（代码块原子执行）</td>
</tr>
<tr>
<td>互斥性</td>
<td>❌ 无</td>
<td>✅ 存在</td>
</tr>
<tr>
<td>禁止重排序</td>
<td>✅ 有效</td>
<td>✅ 间接实现（通过内存语义）</td>
</tr>
<tr>
<td>使用成本</td>
<td>较低（无锁，非阻塞）</td>
<td>较高（可能阻塞，涉及上下文切换）</td>
</tr>
<tr>
<td>适用场景</td>
<td>状态标志、单例懒加载等</td>
<td>临界区保护、资源读写同步</td>
</tr>
</tbody></table>
<p><strong>一、synchronized 重量级同步机制</strong></p>
<ul>
<li><strong>作用</strong>：解决多线程访问共享资源时可能出现的竞态条件和数据不一致问题，<strong>保证线程安全</strong></li>
<li><strong>特性</strong>：<ul>
<li>保证<strong>互斥性</strong>（同一时刻只有一个线程能执行同步代码块）</li>
<li>保证<strong>可见性</strong>（进入同步块前会将线程工作内存与主内存同步）</li>
<li>隐式<strong>原子性保障</strong>（对共享资源的操作是原子的）</li>
</ul>
</li>
<li><strong>使用方式</strong>：可用于方法或代码块，加锁的对象可以是类、实例或任意对象</li>
<li><strong>性能</strong>：开销较大，尤其在高并发下容易导致线程阻塞和上下文切换</li>
</ul>
<hr>
<p><strong>二、volatile 轻量级可见性保证</strong></p>
<ul>
<li><strong>作用</strong>：用于保证变量在多线程环境下的<strong>可见性</strong>和<strong>禁止指令重排序</strong>，<strong>不保证原子性</strong></li>
<li><strong>特性</strong>：<ul>
<li><strong>不具备互斥性</strong>，无法保证操作的原子性</li>
<li>保证<strong>可见性</strong>（修改立即对其他线程可见）</li>
<li>禁止<strong>指令重排序</strong>（通过内存屏障防止重排序破坏执行语义）</li>
</ul>
</li>
<li><strong>使用方式</strong>：用于修饰变量，一般用于状态标志、配置开关等场景</li>
<li><strong>性能</strong>：非常轻量，线程不会阻塞</li>
</ul>
<h2 id="28-什么是公平锁和非公平锁？"><a href="#28-什么是公平锁和非公平锁？" class="headerlink" title="28# 什么是公平锁和非公平锁？"></a>28# 什么是公平锁和非公平锁？</h2><p><strong>一、公平锁</strong></p>
<ul>
<li><strong>定义</strong>：按照线程<strong>请求锁的顺序</strong>来获取锁，先请求的线程先获得锁，后请求的线程排队等待</li>
<li><strong>特点</strong>：类似 “排队买票”，线程按照先来先服务的原则依次执行。每个线程都有公平的机会获得锁，不容易发生<strong>线程饥饿</strong></li>
<li><strong>优点</strong>：公平性强，避免某些线程长时间得不到锁</li>
<li><strong>缺点</strong>：等待队列的调度成本较高，频繁上下文切换会降低<strong>吞吐量</strong>和<strong>整体性能</strong></li>
</ul>
<hr>
<p><strong>二、 非公平锁</strong></p>
<ul>
<li><strong>定义</strong>：线程在尝试获取锁时<strong>不考虑等待队列的顺序</strong>，先尝试<strong>直接获取锁</strong>，获取失败才进入队列排队等待。</li>
<li><strong>特点</strong>：类似 “插队”，后来的线程可能比排队线程更早获得锁。提高了竞争成功的可能性，但可能导致部分线程长时间得不到锁（<strong>线程饥饿</strong>）</li>
<li><strong>优点</strong>：整体<strong>性能更高</strong>，<strong>吞吐量更大</strong>，减少线程切换</li>
<li><strong>缺点</strong>：公平性较差，某些线程可能长期 “饿死”</li>
</ul>
<h2 id="29-非公平锁吞吐量为什么比公平锁大？"><a href="#29-非公平锁吞吐量为什么比公平锁大？" class="headerlink" title="29# 非公平锁吞吐量为什么比公平锁大？"></a>29# 非公平锁吞吐量为什么比公平锁大？</h2><p>主要原因在于其<strong>减少了线程上下文切换和排队等待</strong>的开销。以下是两者执行流程的对比说明：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>公平锁</th>
<th>非公平锁</th>
</tr>
</thead>
<tbody><tr>
<td>获取顺序</td>
<td>严格按排队顺序，先来先得</td>
<td>不保证顺序，可能“插队”</td>
</tr>
<tr>
<td>性能表现</td>
<td>有更多上下文切换，性能相对较低</td>
<td>避免频繁挂起与恢复，性能更优</td>
</tr>
<tr>
<td>实现机制</td>
<td>线程入队 → 挂起 → 唤醒 → 获取锁</td>
<td>CAS尝试获取 → 失败则入队等待</td>
</tr>
<tr>
<td>吞吐量</td>
<td>相对较低</td>
<td>相对较高</td>
</tr>
<tr>
<td>是否可能饥饿</td>
<td>否，公平调度</td>
<td>是，排在后面的线程可能长时间得不到锁</td>
</tr>
</tbody></table>
<p><strong>一、公平锁执行流程</strong></p>
<ul>
<li>当线程尝试获取锁时，会<strong>先被加入到等待队列的尾部</strong>，然后<strong>挂起（休眠）</strong>，等待被调度</li>
<li>当前持有锁的线程释放锁后，会<strong>唤醒队列中最前面的线程</strong>来尝试获取锁</li>
<li>整个过程保证了 “先来先服务” 的公平性，每个等待线程需要经历从<strong>运行态 → 阻塞态 → 运行态</strong>的切换，这些状态切换涉及<strong>用户态与内核态之间的转换</strong>，这是一种昂贵的操作</li>
<li>因此，在高并发场景下，公平锁的<strong>上下文切换频繁</strong>，导致<strong>整体性能下降、吞吐量变</strong></li>
</ul>
<hr>
<p><strong>二、非公平锁执行流程</strong></p>
<ul>
<li>当线程尝试获取锁时，会<strong>先直接通过 CAS 操作抢占锁</strong>：如果抢到锁，就直接执行，无需排队；如果没抢到，再进入等待队列排队等待下一次竞争机会</li>
<li>由于不强制按照排队顺序执行，非公平锁能<strong>减少线程挂起&#x2F;恢复的频率</strong>，避免了大量上下文切换，<strong>线程有更高的概率 “插队” 获取锁</strong>，因此锁的利用效率更高</li>
<li>这使得非公平锁在高并发环境下的<strong>响应更快，吞吐量更大</strong></li>
</ul>
<h2 id="30-synchronized-是公平锁吗？"><a href="#30-synchronized-是公平锁吗？" class="headerlink" title="30# synchronized 是公平锁吗？"></a>30# synchronized 是公平锁吗？</h2><p>不是。<code>synchronized</code> 并<strong>不保证公平性</strong>，因此它并不是一种公平锁。在多线程竞争锁资源时，<code>synchronized</code> 采用的是<strong>非公平策略</strong>：当锁被释放时，<strong>所有等待线程都会同时竞争该锁</strong>，谁先抢到谁执行，线程的获取顺序<strong>不一定按照等待的先后顺序</strong></p>
<p>相比之下，<code>ReentrantLock</code> 是 Java 中提供的<strong>可重入锁</strong>，它<strong>支持公平和非公平两种模式</strong>，默认情况下，<code>ReentrantLock</code> 使用的是非公平策略；若需要公平性，可以通过构造方法 <code>new ReentrantLock(true)</code> 来显式指定为<strong>公平锁</strong></p>
<h2 id="31-ReentrantLock是怎么实现公平锁的？"><a href="#31-ReentrantLock是怎么实现公平锁的？" class="headerlink" title="31# ReentrantLock是怎么实现公平锁的？"></a>31# ReentrantLock是怎么实现公平锁的？</h2><p><code>ReentrantLock</code> 通过 <strong>Sync 内部类</strong>（继承自 AQS） 来区分 “公平锁” 和 “非公平锁”。二者在<strong>获取锁</strong>时的关键分支不同：</p>
<p><del><strong>太长不看版</strong></del></p>
<table>
<thead>
<tr>
<th>比较维度</th>
<th>公平锁 (<code>tryAcquire</code>)</th>
<th>非公平锁 (<code>nonfairTryAcquire</code>)</th>
</tr>
</thead>
<tbody><tr>
<td>获取策略</td>
<td>先检查 <code>hasQueuedPredecessors()</code>，前驱为空才能抢锁</td>
<td>直接 CAS 抢锁，失败后再排队</td>
</tr>
<tr>
<td>性能</td>
<td>上下文切换多，吞吐量稍低</td>
<td>吞吐量高，但可能产生线程饥饿</td>
</tr>
<tr>
<td>场景选择</td>
<td>需要严格先来先得 &#x2F; 避免饥饿</td>
<td>追求吞吐量、对公平性不敏感</td>
</tr>
</tbody></table>
<p><strong>公平锁源码（节选）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();                 <span class="comment">// ① 读锁状态</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ② “排队检查”：AQS 队列前面是否还有线程？</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">// 公平锁核心：必须排第一</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// ③ 可重入</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>核心语句</strong>：<code>hasQueuedPredecessors()</code></p>
<ul>
<li>返回 <code>true</code> ⇒ 队列中已有前驱线程，当前线程<strong>不得“插队”</strong>，必须排队</li>
<li>返回 <code>false</code> ⇒ 当前线程位于队首，可立即 CAS 抢锁</li>
</ul>
<p>因此，公平锁 <strong>严格按照先来后到</strong> 的排队顺序获取锁，避免了饿死现象，但带来了更多<strong>上下文切换</strong>成本</p>
<hr>
<p> <strong>非公平锁源码（节选）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();                 <span class="comment">// ① 读锁状态</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ② 直接 CAS 抢锁，不看队列</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// ③ 可重入</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>没有队列检查</strong>：线程一来就尝试 CAS 抢锁，成功则立即进入临界区，失败再进入队列挂起</li>
<li>好处：<strong>吞吐量更高</strong>（锁刚释放时附近线程可立即命中锁）</li>
<li>风险：可能出现“插队”，导致等待队列里的某些线程<strong>长时间得不到锁</strong>（轻度饥饿）</li>
</ul>
<hr>
<p><strong><code>tryLock()</code> 的特例</strong></p>
<p>无论 <code>ReentrantLock</code> 创建时指定的是公平 (<code>new ReentrantLock(true)</code>) 还是非公平模式，<strong><code>tryLock()</code> 一律使用非公平策略</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);   <span class="comment">// 始终调用非公平实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tryLock()</code> 本身语义就是“立即尝试一次”，所以可以“插队”成功，而不保证排队顺序</p>
<h2 id="32-什么情况会产生死锁问题？如何解决？"><a href="#32-什么情况会产生死锁问题？如何解决？" class="headerlink" title="32# 什么情况会产生死锁问题？如何解决？"></a>32# 什么情况会产生死锁问题？如何解决？</h2><p>死锁的发生必须<strong>同时满足以下四个条件</strong>：</p>
<ol>
<li><strong>互斥条件</strong>：某个资源一次只能被一个线程占用，不能共享使用</li>
<li><strong>占有且等待条件</strong>： 线程已持有至少一个资源，并且在等待获取其他被别的线程占用的资源，<strong>不释放当前已有资源</strong></li>
<li><strong>不可抢占条件</strong>：线程已获取的资源在未使用完之前<strong>不能被强行剥夺</strong>，只能线程自己释放</li>
<li><strong>循环等待条件</strong>：存在一个线程资源的循环等待链，即线程 A 等待线程 B 占用的资源，而线程 B 又在等待线程 A 的资源</li>
</ol>
<p>只要<strong>打破任意一个死锁条件</strong>，就可以有效避免死锁。最常见的并且可行的就是<strong>使用资源有序分配法，来破环环路等待条件</strong>：给资源编号，规定线程必须<strong>按照固定顺序申请资源</strong>，例如，无论线程 A 还是线程 B，始终按照 “先申请资源 R1，再申请资源 R2” 的顺序来获取资源</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="1-介绍一下线程池的工作原理"><a href="#1-介绍一下线程池的工作原理" class="headerlink" title="1# 介绍一下线程池的工作原理"></a>1# 介绍一下线程池的工作原理</h2><img src="https://cdn.xiaolincoding.com//picgo/1719389039034-0de42388-4ec6-44a6-9583-5d018e5cb4f3.png" alt="线程池的工作原理" style="zoom: 67%;" />

<p>线程池的主要作用是<strong>复用线程资源，避免频繁创建和销毁线程带来的性能开销</strong>。它通过预先创建一定数量的线程，并维护一个任务队列来管理并发任务，从而提高系统整体吞吐量和响应速度</p>
<p>线程池的设计理念是通过<strong>线程重用 + 队列排队 + 最大并发限制</strong>来管理资源和任务调度，它的典型执行策略是：</p>
<ul>
<li><strong>优先使用核心线程</strong></li>
<li><strong>核心线程满 → 入队列</strong></li>
<li><strong>队列满 → 创建非核心线程（直到最大线程数）</strong></li>
<li><strong>超出最大线程数 → 执行拒绝策略</strong></li>
</ul>
<h2 id="2-线程池的参数有哪些？"><a href="#2-线程池的参数有哪些？" class="headerlink" title="2# 线程池的参数有哪些？"></a>2# 线程池的参数有哪些？</h2><ol>
<li><p><strong><code>corePoolSize</code>（核心线程数）</strong>：线程池中<strong>常驻的线程数量</strong>。即使这些线程处于空闲状态，也不会被销毁，除非设置了 <code>allowCoreThreadTimeOut(true)</code></p>
</li>
<li><p><strong><code>maximumPoolSize</code>（最大线程数）</strong>：线程池中允许创建的<strong>最大线程数量</strong>。当任务过多、核心线程和队列都满时，线程池才会继续创建新线程，直到达到该上限</p>
</li>
<li><p><strong><code>keepAliveTime</code>（空闲线程存活时间）</strong>：当线程数<strong>大于核心线程数</strong>时，空闲线程在达到该时间后将被销毁，以节省资源</p>
</li>
<li><p><strong><code>unit</code>（时间单位）</strong>：<code>keepAliveTime</code> 的时间单位，例如 <code>TimeUnit.SECONDS</code>、<code>TimeUnit.MILLISECONDS</code> 等。</p>
</li>
<li><p><strong><code>workQueue</code>（任务队列）</strong>：用来保存<strong>待执行的任务</strong>。当所有核心线程都在忙时，新的任务会被加入该队列等待执行。常见实现包括：</p>
<ul>
<li><p><code>ArrayBlockingQueue</code>（有界队列）</p>
</li>
<li><p><code>LinkedBlockingQueue</code>（无界队列）</p>
</li>
<li><p><code>SynchronousQueue</code>（直接交付）</p>
</li>
<li><p><code>PriorityBlockingQueue</code>（优先级队列）</p>
</li>
</ul>
</li>
<li><p><strong><code>threadFactory</code>（线程工厂）</strong>：用于自定义线程的创建方式，通常可用来设置线程名称、优先级、是否为守护线程等</p>
</li>
<li><p><strong><code>handler</code>（拒绝策略）</strong>：当线程池<strong>达到最大线程数并且任务队列已满</strong>时的处理策略</p>
</li>
</ol>
<h2 id="3-线程池有哪些拒绝策略？"><a href="#3-线程池有哪些拒绝策略？" class="headerlink" title="3# 线程池有哪些拒绝策略？"></a>3# 线程池有哪些拒绝策略？</h2><ul>
<li><p><code>AbortPolicy</code>（抛出异常策略）：默认策略，直接<strong>抛出 <code>RejectedExecutionException</code> 异常</strong>，提醒程序任务已被拒绝处理</p>
</li>
<li><p><code>CallerRunsPolicy</code>（调用者执行策略）：由提交任务的线程（通常是主线程）<strong>直接执行该任务</strong>，从而降低任务提交的速度，避免任务快速堆积</p>
</li>
<li><p><code>DiscardPolicy</code>（静默丢弃策略）：<strong>不抛异常，也不执行被拒绝的任务</strong>，直接丢弃任务</p>
</li>
<li><p><code>DiscardOldestPolicy</code>（丢弃最旧任务策略）：<strong>丢弃任务队列中最早的任务</strong>，然后尝试重新提交当前任务</p>
</li>
</ul>
<p>此外，通过实现 <code>RejectedExecutionHandler</code> 接口，可以根据业务需求编写自定义拒绝策略，例如记录日志、报警、持久化任务等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomRejectHandler</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义处理逻辑，如记录日志、发送告警、持久化等</span></span><br><span class="line">        System.out.println(<span class="string">&quot;任务被拒绝：&quot;</span> + r.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-如何设置线程池参数？"><a href="#4-如何设置线程池参数？" class="headerlink" title="4# 如何设置线程池参数？"></a>4# 如何设置线程池参数？</h2><p><strong>核心线程数（<code>corePoolSize</code>）设置原则：</strong></p>
<ul>
<li><p><strong>CPU 密集型任务</strong>（如加解密、图像处理等）：<code>corePoolSize = CPU 核数 + 1</code>，避免线程频繁上下文切换，充分利用每个核心</p>
</li>
<li><p><strong>IO 密集型任务</strong>（如网络、数据库访问）：<code>corePoolSize = CPU 核数 × 2</code> 或更高，线程大部分时间阻塞于 IO，适当提高线程数以提升吞吐</p>
</li>
</ul>
<p><strong>场景一：电商高并发请求处理</strong>，突发流量高、任务处理快、对响应时间敏感</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">16</span>,                     <span class="comment">// corePoolSize（假设8核CPU × 2）</span></span><br><span class="line">    <span class="number">32</span>,                     <span class="comment">// maximumPoolSize，短时扩容</span></span><br><span class="line">    <span class="number">10</span>, TimeUnit.SECONDS,   <span class="comment">// 非核心线程空闲 10 秒后回收</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(), <span class="comment">// 无缓冲，任务直达线程</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy() <span class="comment">// 拒绝策略：快速失败</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>SynchronousQueue</code> 保证任务直达线程，响应及时</li>
<li>非核心线程可临时扩容，适应突发流量</li>
<li>拒绝策略使用 <code>AbortPolicy</code>，快速失败，结合前端提示“活动火爆”与缓存降级，保护系统稳定</li>
</ul>
<hr>
<p><strong>场景二：后台批处理或日志分析</strong>，流量稳定、任务耗时长、允许延迟</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">8</span>,                             <span class="comment">// 固定线程数，避免资源波动</span></span><br><span class="line">    <span class="number">8</span>,</span><br><span class="line">    <span class="number">0</span>, TimeUnit.SECONDS,           <span class="comment">// 线程始终保留，不回收</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1000</span>), <span class="comment">// 有界队列，容量1000</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="comment">// 调用线程兜底执行</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>限制线程数量，避免资源过载</li>
<li>队列缓冲大量任务，适用于慢速处理</li>
<li>使用 <code>CallerRunsPolicy</code>，队列满时由调用线程执行任务，起到背压效果</li>
<li>配合监控系统，当队列使用率超过阈值（如 80%）可自动触发扩容或报警</li>
</ul>
<hr>
<p><strong>场景三：微服务中处理 HTTP 请求</strong>，IO 密集型，依赖下游服务响应，需考虑请求超时和排队时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">16</span>,                            <span class="comment">// 8 核 CPU × 2，适应 IO 阻塞</span></span><br><span class="line">    <span class="number">64</span>,                            <span class="comment">// 最大线程数，支持更多并发</span></span><br><span class="line">    <span class="number">60</span>, TimeUnit.SECONDS,          <span class="comment">// 非核心线程空闲 1 分钟后回收</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">200</span>), <span class="comment">// 有界队列，防止OOM</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CustomRetryPolicy</span>()         <span class="comment">// 自定义拒绝策略</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>较高的最大线程数应对下游慢响应</li>
<li>有界队列防止内存泄露</li>
<li>自定义拒绝策略（例如将任务放入 Redis 或消息队列）实现异步重试或降级</li>
<li>可配合服务熔断、限流等机制构建完整容灾链路</li>
</ul>
<h2 id="5-核心线程数设置为-0-可以吗？"><a href="#5-核心线程数设置为-0-可以吗？" class="headerlink" title="5# 核心线程数设置为 0 可以吗？"></a>5# 核心线程数设置为 0 可以吗？</h2><p>可以，当核心线程数为 0 的时候，会创建一个非核心线程进行执行</p>
<p>任务提交后，<strong>任务会先尝试加入任务队列</strong>，如果当前没有线程在运行（即 <code>workerCount == 0</code>），则会创建一个<strong>非核心线程</strong>来处理队列中的任务，当任务处理完毕，且该线程处于空闲状态超过 <code>keepAliveTime</code>，它也会被回收</p>
<h2 id="6-线程池种类有哪些？"><a href="#6-线程池种类有哪些？" class="headerlink" title="6# 线程池种类有哪些？"></a>6# 线程池种类有哪些？</h2><p>Java 提供了多种内置线程池，位于 <code>java.util.concurrent.Executors</code> 工具类中，适用于不同的任务调度场景：</p>
<ol>
<li><p><strong>ScheduledThreadPool</strong></p>
<ul>
<li><p><strong>功能：</strong> 支持<strong>定时执行</strong>或<strong>周期性执行</strong>任务</p>
</li>
<li><p><strong>适用场景：</strong> 适合需要在固定时间间隔内重复执行任务的场景，例如：每隔 10 秒执行一次日志清理任务</p>
</li>
<li><p><strong>核心特点：</strong> 使用 <code>ScheduledExecutorService</code> 接口，可通过 <code>schedule()</code> 或 <code>scheduleAtFixedRate()</code> 方法配置延迟或周期性任务</p>
</li>
</ul>
</li>
<li><p><strong>FixedThreadPool</strong></p>
<ul>
<li><p><strong>功能：</strong> 创建一个固定线程数量的线程池</p>
</li>
<li><p><strong>适用场景：</strong> 稳定并发量的业务场景，如处理日志、消息消费等</p>
</li>
<li><p><strong>核心特点：</strong></p>
<ul>
<li>核心线程数 &#x3D; 最大线程数，线程数固定</li>
<li>超过线程数的任务会被放入阻塞队列等待执行</li>
<li>队列满时不会再扩展线程数量，可能触发拒绝策略</li>
<li>线程空闲不会被销毁，长期占用资源</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>CachedThreadPool</strong></p>
<ul>
<li><p><strong>功能：</strong> 创建一个可以无限扩展线程数量的线程池（理论上最大线程数为 <code>Integer.MAX_VALUE</code>）</p>
</li>
<li><p><strong>适用场景：</strong> 适合执行大量、短生命周期的异步任务</p>
</li>
<li><p><strong>核心特点：</strong></p>
<ul>
<li>使用 <code>SynchronousQueue</code> 作为任务队列（容量为 0，不存储任务，只做转交）</li>
<li>没有核心线程，任务来就创建线程</li>
<li>空闲线程在 60 秒后回收</li>
<li>创建和销毁线程代价相对较高，慎用</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>SingleThreadExecutor</strong></p>
<ul>
<li><p><strong>功能：</strong> 创建一个只有<strong>单个工作线程</strong>的线程池</p>
</li>
<li><p><strong>适用场景：</strong> 所有任务需要<strong>严格按照提交顺序</strong>执行的场景</p>
</li>
<li><p><strong>核心特点：</strong></p>
<ul>
<li>使用一个线程串行执行所有任务</li>
<li>线程异常退出时，会自动创建新的线程保障执行连续性</li>
<li>类似 <code>FixedThreadPool(1)</code>，但具备更强的顺序性保障</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>SingleThreadScheduledExecutor</strong></p>
<ul>
<li><p><strong>功能：</strong> 单线程版本的 <code>ScheduledThreadPool</code>，支持定时和周期性任务调度</p>
</li>
<li><p><strong>适用场景：</strong> 需要按顺序、定时执行任务的单线程场景</p>
</li>
<li><p><strong>核心特点：</strong></p>
<ul>
<li>内部只有一个线程</li>
<li>能保证任务按顺序定时执行</li>
<li>是 <code>ScheduledThreadPoolExecutor</code> 的特例</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>是否固定线程</th>
<th>是否支持定时</th>
<th>是否支持扩容</th>
<th>是否保证顺序</th>
</tr>
</thead>
<tbody><tr>
<td><code>FixedThreadPool</code></td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td><code>CachedThreadPool</code></td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td><code>ScheduledThreadPool</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td><code>SingleThreadExecutor</code></td>
<td>✅（1个）</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td><code>SingleThreadScheduledExecutor</code></td>
<td>✅（1个）</td>
<td>✅</td>
<td>❌</td>
<td>✅</td>
</tr>
</tbody></table>
<h2 id="7-线程池一般是怎么用的？"><a href="#7-线程池一般是怎么用的？" class="headerlink" title="7# 线程池一般是怎么用的？"></a>7# 线程池一般是怎么用的？</h2><p>Java 中的 <code>Executors</code> 类定义了一些快捷的工具方法，来帮助我们快速创建线程池。《阿里巴巴 Java 开发手册》中提到，禁止使用这些方法来创建线程池，而应该手动 <code>new ThreadPoolExecutor</code> 来创建线程池</p>
<p>为什么尽量不要用 <code>Executors</code> 快捷工厂？</p>
<table>
<thead>
<tr>
<th><code>Executors</code> 工厂方法</th>
<th>潜在风险</th>
<th>典型事故场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>newFixedThreadPool</code></td>
<td><strong>无界阻塞队列</strong>任务持续堆积 → 内存飙升</td>
<td>高并发秒杀、批量导入，队列挤满导致 OOM</td>
</tr>
<tr>
<td><code>newCachedThreadPool</code></td>
<td><strong>线程无限制增长</strong> (<code>Integer.MAX_VALUE</code>)快速消耗 CPU &#x2F; 句柄</td>
<td>下游接口持续超时，线程池疯狂扩容抢锁、最终拖垮机器</td>
</tr>
</tbody></table>
<ul>
<li>我们需要根据自己的场景、并发情况来评估线程池的几个核心参数，确保线程池的工作行为符合需求，一般都需要设置有界的工作队列和可控的线程数</li>
<li>任何时候，都应该为自定义线程池指定有意义的名称，以方便排查问题。当出现线程数量暴增、线程死锁、线程占用大量 CPU、线程执行出现异常等问题时，我们往往会抓取线程栈。此时，有意义的线程名称，就可以方便我们定位问题</li>
</ul>
<p>除了建议手动声明线程池以外，我还建议用一些监控手段来观察线程池的状态。线程池这个组件往往会表现得任劳任怨、默默无闻，除非是出现了拒绝策略，否则压力再大都不会抛出一个异常。如果我们能提前观察到线程池队列的积压，或者线程数量的快速膨胀，往往可以提早发现并解决问题。</p>
<h2 id="8-线程池中-shutdown-、shutdownNow-这两个方法有什么作用？"><a href="#8-线程池中-shutdown-、shutdownNow-这两个方法有什么作用？" class="headerlink" title="8# 线程池中 shutdown ()、shutdownNow() 这两个方法有什么作用？"></a>8# 线程池中 shutdown ()、shutdownNow() 这两个方法有什么作用？</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>行为特征</th>
</tr>
</thead>
<tbody><tr>
<td><code>shutdown()</code></td>
<td>优雅关闭：执行中的任务继续，等待队列中的任务照常处理</td>
</tr>
<tr>
<td><code>shutdownNow()</code></td>
<td>强制关闭：中断正在执行的任务，清空队列，立即返回未处理任务</td>
</tr>
<tr>
<td>共同点</td>
<td>都会拒绝新的任务提交，线程池状态都会改变，最终尝试终止线程池</td>
</tr>
</tbody></table>
<p><strong>一、<code>shutdown()</code></strong></p>
<p>调用 <code>shutdown()</code> 方法后，线程池的状态将被设置为 <code>SHUTDOWN</code>，此时：</p>
<ul>
<li>已提交但尚未执行的任务<strong>会继续排队等待执行</strong></li>
<li>正在执行的任务<strong>会继续执行直至完成</strong></li>
<li>线程池<strong>不再接收新的任务提交</strong>，否则会抛出 <code>RejectedExecutionException</code> 异常</li>
<li><strong>不会中断正在运行的线程</strong></li>
</ul>
<p>适用于<strong>优雅关闭线程池</strong>的场景</p>
<hr>
<p><strong>二、<code>shutdownNow()</code></strong></p>
<p>调用 <code>shutdownNow()</code> 方法后，线程池状态被设置为 <code>STOP</code>，并执行如下操作：</p>
<ul>
<li><strong>立即中断所有正在运行的线程</strong>（通过 <code>Thread.interrupt()</code> 实现）</li>
<li><strong>放弃队列中尚未执行的任务</strong>，并将这些任务作为 <code>List&lt;Runnable&gt;</code> 返回</li>
<li>同样<strong>不再接受新的任务提交</strong></li>
</ul>
<p>但请注意：<code>Thread.interrupt()</code> 仅能中断那些处于阻塞状态（如 <code>sleep()</code>、<code>wait()</code>、<code>join()</code>、<code>Condition.await()</code>、定时锁等）的线程，对于纯计算类任务并无实际中断效果</p>
<p>因此，调用 <code>shutdownNow()</code> 并不意味着线程池能够<strong>立即关闭</strong>，它可能仍需等待某些任务结束才能真正终止</p>
<h2 id="9-提交给线程池的任务可以撤回吗？"><a href="#9-提交给线程池的任务可以撤回吗？" class="headerlink" title="9# 提交给线程池的任务可以撤回吗？"></a>9# 提交给线程池的任务可以撤回吗？</h2><p>可以。在 Java 中，当向线程池提交任务时，会返回一个 <code>Future</code> 对象。通过这个对象，可以对任务的执行过程进行控制，例如：获取任务执行结果、判断任务是否完成、尝试取消任务执行</p>
<p><code>Future</code> 接口提供了 <code>cancel(boolean mayInterruptIfRunning)</code> 方法，用于取消任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>mayInterruptIfRunning = true</code>：如果任务正在运行，尝试中断该任务（调用 <code>Thread.interrupt()</code>）</li>
<li><code>mayInterruptIfRunning = false</code>：如果任务已启动，则不会中断，仅取消尚未开始的任务</li>
</ul>
<p>此外，<code>Future</code> 还提供了以下常用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;   <span class="comment">// 判断任务是否已取消</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;        <span class="comment">// 判断任务是否已完成（成功/失败/取消都算完成）</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">()</span>;                 <span class="comment">// 获取任务结果（阻塞直到结果返回或异常抛出）</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span>; <span class="comment">// 限时获取任务结果</span></span><br></pre></td></tr></table></figure>

<p>取消线程池中的任务示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CancelTaskDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        Future&lt;?&gt; future = service.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟耗时任务</span></span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;任务完成&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务被中断&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 等待任务完成</span></span><br><span class="line">            future.get(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException | TimeoutException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务超时，尝试取消...&quot;</span>);</span><br><span class="line">            <span class="comment">// 超时后尝试取消任务（允许中断）</span></span><br><span class="line">            future.cancel(<span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            service.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><h2 id="1-多线程打印奇偶数，怎么控制打印的顺序？"><a href="#1-多线程打印奇偶数，怎么控制打印的顺序？" class="headerlink" title="1# 多线程打印奇偶数，怎么控制打印的顺序？"></a>1# 多线程打印奇偶数，怎么控制打印的顺序？</h2><p><strong>交替打印奇偶数（<code>wait/notify</code> 方案）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintOddEven</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">odd</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; printNumber(<span class="literal">true</span>),  <span class="string">&quot;OddThread&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">even</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; printNumber(<span class="literal">false</span>), <span class="string">&quot;EvenThread&quot;</span>);</span><br><span class="line">        odd.start();</span><br><span class="line">        even.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@param</span> printOdd true 打印奇数，false 打印偶数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printNumber</span><span class="params">(<span class="type">boolean</span> printOdd)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="keyword">if</span> (counter &gt; MAX) &#123;</span><br><span class="line">                    LOCK.notifyAll();          <span class="comment">// 唤醒对方后退出</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((counter &amp; <span class="number">1</span>) == (printOdd ? <span class="number">1</span> : <span class="number">0</span>)) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%s : %d%n&quot;</span>,</span><br><span class="line">                            Thread.currentThread().getName(), counter++);</span><br><span class="line">                    LOCK.notifyAll();          <span class="comment">// 打印完唤醒对方</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123; LOCK.wait(); &#125;       <span class="comment">// 条件不满足，挂起</span></span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么能交替输出？</strong></p>
<ol>
<li><strong>共享状态</strong>：<code>counter</code> 决定当前应打印奇数还是偶数</li>
<li><strong>互斥</strong>：<code>synchronized (LOCK)</code> 保证同一时刻只有一个线程在修改 <code>counter</code></li>
<li><strong>协作</strong>：打印线程完成一次输出后调用 <code>notifyAll()</code>，提醒对方线程条件可能满足,如果发现当前不该自己打印，则调用 <code>wait()</code> 释放锁并挂起，等待被唤醒</li>
</ol>
<p>这样就形成了“<strong>打印 → 唤醒对方 → 自己等待</strong>”的循环，保证奇、偶顺序交替</p>
<p><strong>注意</strong>：<code>notifyAll()</code> 比 <code>notify()</code> 更安全，避免“假唤醒”或只有单线程等待场景时对方仍沉睡</p>
<h2 id="2-单例模型既然已经用了-synchronized，为什么还要在加-volatile？"><a href="#2-单例模型既然已经用了-synchronized，为什么还要在加-volatile？" class="headerlink" title="2# 单例模型既然已经用了 synchronized，为什么还要在加 volatile？"></a>2# 单例模型既然已经用了 synchronized，为什么还要在加 volatile？</h2><p>使用 <code>synchronized</code> 和 <code>volatile</code> 一起，可以创建一个既线程安全又能正确初始化的单例模式，避免了多线程环境下的各种潜在问题。这是一种比较完善的线程安全的单例模式实现方式，尤其适用于高并发环境</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>synchronized</code> 关键字的作用用于确保在多线程环境下，只有一个线程能够进入同步块（这里是 <code>synchronized (Singleton.class)</code>）。在创建单例对象时，通过 <code>synchronized</code> 保证了创建过程的线程安全性，避免多个线程同时创建多个单例对象</p>
<p><code>volatile</code> 确保了对象引用的可见性和创建过程的有序性，避免了由于指令重排序而导致的错误</p>
<p><code>instance = new Singleton();</code> 这行代码并不是一个原子操作，它实际上可以分解为以下几个步骤：</p>
<ul>
<li>分配内存空间。</li>
<li>实例化对象。</li>
<li>将对象引用赋值给 <code>instance</code>。</li>
</ul>
<p>由于 Java 内存模型允许编译器和处理器对指令进行重排序，在没有 <code>volatile</code> 的情况下，可能会出现重排序，例如先将对象引用赋值给 <code>instance</code>，但对象的实例化操作尚未完成</p>
<p>这样，其他线程在检查 <code>instance == null</code> 时，会认为单例已经创建，从而得到一个未完全初始化的对象，导致错误</p>
<p><code>volatile</code> 可以保证变量的可见性和禁止指令重排序。它确保对 <code>instance</code> 的修改对所有线程都是可见的，并且保证了上述三个步骤按顺序执行，避免了在单例创建过程中因指令重排序而导致的问题</p>
<h2 id="3-3-个线程并发执行，1-个线程等待这三个线程全部执行完在执行，怎么实现？"><a href="#3-3-个线程并发执行，1-个线程等待这三个线程全部执行完在执行，怎么实现？" class="headerlink" title="3# 3 个线程并发执行，1 个线程等待这三个线程全部执行完在执行，怎么实现？"></a>3# 3 个线程并发执行，1 个线程等待这三个线程全部执行完在执行，怎么实现？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatchDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">workers</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(workers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 个工作线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= workers; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Worker-&quot;</span> + id + <span class="string">&quot; working...&quot;</span>);</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;Worker-&quot;</span> + id + <span class="string">&quot; done.&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    latch.countDown();         <span class="comment">// 完成后递减计数</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有工作线程结束</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Awaiting completion of workers...&quot;</span>);</span><br><span class="line">                latch.await();                 <span class="comment">// 阻塞，直到计数=0</span></span><br><span class="line">                System.out.println(<span class="string">&quot;All workers finished. Main task starts.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Coordinator&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码说明</strong></p>
<ol>
<li><code>CountDownLatch latch = new CountDownLatch(3);</code><br> 创建一个计数器，初始值为 3，代表有 3 个线程需要 “倒计时”</li>
<li>每个线程在执行完任务后，调用 <code>latch.countDown()</code> 将计数器减 1</li>
<li>第 4 个线程调用 <code>latch.await()</code>，阻塞等待直到计数器变为 0，再继续执行自己的任务</li>
</ol>
<h2 id="4-假设两个线程并发读写同一个整型变量，初始值为零，每个线程加-50-次，结果可能是什么？"><a href="#4-假设两个线程并发读写同一个整型变量，初始值为零，每个线程加-50-次，结果可能是什么？" class="headerlink" title="4# 假设两个线程并发读写同一个整型变量，初始值为零，每个线程加 50 次，结果可能是什么？"></a>4# 假设两个线程并发读写同一个整型变量，初始值为零，每个线程加 50 次，结果可能是什么？</h2><p>在没有任何同步机制的情况下，两个线程并发对同一个整型变量进行 50 次加 1 操作，最终结果可能是 100，也可能小于 100，最坏的结果是 50，也就是最终的结果可能是在 [50, 100] </p>
<p><strong>原因</strong></p>
<p><code>num++</code> 操作并不是原子操作，它实际包含以下三个步骤：</p>
<ol>
<li>读取变量的当前值</li>
<li>将值加 1</li>
<li>将新值写回变量</li>
</ol>
<p>在多线程环境中，如果两个线程同时读取了相同的值并分别加 1，然后再写回，就会导致 “加 1” 操作丢失，从而导致最终结果小于预期</p>
<p><strong>解决方案一：使用 AtomicInteger</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerAddition</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                num.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                num.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;最终结果: &quot;</span> + num.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案二：使用 synchronized 或 ReentrantLock</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedAddition</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;最终结果: &quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"># 笔记</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/07/02/boilerplate-answers-2-java-collection/" rel="prev" title="八股文笔记 #2 Java 集合">
                  <i class="fa fa-angle-left"></i> 八股文笔记 #2 Java 集合
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/09/08/leetcode-notes/" rel="next" title="力扣 hot100 笔记">
                  力扣 hot100 笔记 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2024 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Marnumon</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">114k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">6:54</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div><script color="150,0,255" opacity="0.5" zIndex="-1" count="64" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/Marnumon" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"Marnumon","repo":"blog-comments","client_id":"Ov23liskioUxOHwH9wCv","client_secret":"09fa60a57fa00d2a18c0f7d36df7332f5a659915","admin_user":"Marnumon","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":null,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"af43c453f51ab94bd0801f09a40a326b"}</script>
<script src="/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>
