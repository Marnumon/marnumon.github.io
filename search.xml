<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AimAssist</title>
    <url>/2024/11/13/AimAssist/</url>
    <content><![CDATA[<h1 id="基于carpet-1-20的提前辅助瞄准"><a href="#基于carpet-1-20的提前辅助瞄准" class="headerlink" title="基于carpet 1.20的提前辅助瞄准"></a>基于carpet 1.20的提前辅助瞄准</h1><p><del>咕了</del></p>
<p>适用版本：1.20.x</p>
<span id="more"></span>

<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── helpers</span><br><span class="line">│   ├── BallisticCalculator // 弹道计算</span><br><span class="line">│   └── generateEmissionAngle(Player)</span><br><span class="line">└── mixins</span><br><span class="line">    ├── BowItem_aimAssistMixin  // 捕获目标</span><br><span class="line">    ├── getTarget(Level, Player, InteractionHand, CallbackInfoReturnable&lt;InteractionResultHolder&lt;ItemStack&gt;&gt;)</span><br><span class="line">    ├── LivingEntity_aimAssistMixin  // 准心控制</span><br><span class="line">    └── directionControl(CallbackInfo) // tick级物品栏检测</span><br></pre></td></tr></table></figure>

<h2 id="基本处理逻辑"><a href="#基本处理逻辑" class="headerlink" title="基本处理逻辑"></a>基本处理逻辑</h2><ol>
<li><p>输入指令，标记为true</p>
</li>
<li><p>鼠标右键（mouseDown）发出射线追踪获取实体信息，如果为Mob类，添加到目标队列，并且高亮目标，再次右键同一目标，移出队列，取消高亮</p>
</li>
<li><p>鼠标右键（mouseOn），根据目标的坐标和速度，计算弹道，并将准心设置在预设点，<del>蓄力完毕后会持续跟踪</del>，直到生物被移除目标队列</p>
</li>
</ol>
<h2 id="代码参考"><a href="#代码参考" class="headerlink" title="代码参考"></a>代码参考</h2><ul>
<li><p>carpet命令<br><code>carpet.commands.PlayerCommand</code><br><code>carpet.CarpetSettings</code><br><code>carpet.commands</code></p>
</li>
<li><p>使用mixin注入代码，检测玩家对于物品弓的使用事件<br><a href="https://github.com/gnembon/fabric-carpet/wiki/Checking-if-a-player-is-holding-the-right-tool">carpet检测玩家手持物品</a></p>
</li>
<li><p>射线检测获取目标<br><code>carpet.script.utils.Tracer.rayTrace</code><br><code>net.minecraft.world.phys.EntityHitResult</code><br><code>net.minecraft.world.entity.Entity.getViewVector</code>  </p>
</li>
<li><p>添加到目标队列<br>&#x2F;&#x2F; TODO</p>
</li>
<li><p>获取目标坐标，速度等信息<br><code>net.minecraft.world.entity.getDeltaMovement</code><br><code>net.minecraft.world.entity.spawnSprintParticle</code><br><code>net.minecraft.world.entity.getYRotf</code></p>
</li>
<li><p>获取轨迹所经过的方块，添加到队列<br><code>package net.minecraft.world.entity.projectile.shoot</code></p>
</li>
<li><p>箭的运动<br><code>net.minecraft.world.entity.projectile.AbstractArrow.tick</code></p>
</li>
<li><p>tick级计算并获取计算后的角度和力度<br>&#x2F;&#x2F; TODO</p>
</li>
<li><p>方向控制<br><code>carpet.helpers.EntityPlayerActionPack.look</code><br><code>net.minecraft.world.entity.ai.control.LookControl.tick</code><br><code>net.minecraft.world.entity.Entity.setRot</code></p>
</li>
<li><p>火力控制<br><code>carpet.helpers.EntityPlayerActionPack.ActionType.USE</code><br><code>net.minecraft.world.item.SnowballItem.use</code><br><code>net.minecraft.world.entity.projectile.Projectile.shoot</code><br><code>net.minecraft.world.entity.projectile.Projectile.shootFromRotation</code><br><code>net.minecraft.world.item.BowItem.releaseUsing</code></p>
</li>
<li><p>检查弓物品的使用状态<br><code>net.minecraft.world.entity.ai.goal.RangedBowAttackGoal.isHoldingBow</code></p>
</li>
<li><p>图腾检测<br><code>net.minecraft.world.entity.LivingEntity.checkTotemDeathProtection</code></p>
</li>
</ul>
<h2 id="待研究"><a href="#待研究" class="headerlink" title="待研究"></a>待研究</h2><ul>
<li><p>检测弓的使用*<br><code>net.minecraft.world.entity.LivingEntity.releaseUsingItem</code>  结束阶段<br><code>net.minecraft.world.entity.LivingEntity.updateUsingItem</code>  可能是中期阶段，待验证</p>
</li>
<li><p>实体<br><code>net.minecraft.world.entity.Entity.getOnPos</code>  脚底方块<br><code>net.minecraft.world.entity.Entity.getXRot</code>  角度</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Minecraft</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
        <tag>Carpet</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>八股文笔记 #1 Java 基础</title>
    <url>/2025/06/30/boilerplate-answers-1-java-basics/</url>
    <content><![CDATA[<p><del>再好的项目，也敌不过 HashMap 的 resize 过程没讲清楚</del></p>
<span id="more"></span>

<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="1-说一下-Java-的特点"><a href="#1-说一下-Java-的特点" class="headerlink" title="1# 说一下 Java 的特点"></a>1# 说一下 Java 的特点</h2><ol>
<li><strong>平台无关性</strong>：Java 的 “编写一次，运行无处不在” 哲学是其最大的特点之一。Java 编译器将源代码编译成字节码，该字节码可以在任何安装了 JVM 的系统上运行</li>
<li><strong>面向对象</strong>：Java 是一门严格的面向对象的编程语言，几乎一切都是对象。OOP 特性使得代码更易于维护和复用，包括类、对象、继承、多态、抽象和封装</li>
<li><strong>内存管理</strong>：Java 有自己的垃圾回收机制，自动管理内存和回收不再使用的对象</li>
</ol>
<h2 id="2-Java-的优势和劣势是什么？"><a href="#2-Java-的优势和劣势是什么？" class="headerlink" title="2# Java 的优势和劣势是什么？"></a>2# Java 的优势和劣势是什么？</h2><p><strong>优势</strong>：</p>
<ol>
<li><strong>跨平台</strong>：因为 JVM 的存在，一次编写到处运行</li>
<li><strong>面向对象</strong>：虽然现在很多语言都支持面向对象，但是 Java 的设计从一开始就是 OPP 的</li>
<li><strong>强大的生态</strong>：比如 Spring 框架，各种库和工具，社区支持大，企业应用广泛</li>
<li><strong>内存管理</strong>：自动垃圾回收机制，减少了内存泄漏的问题，对开发者友好</li>
<li><strong>多线程支持</strong>：内置的线程机制，方便并发编程</li>
<li><strong>安全性</strong>：Java 有安全模型，比如沙箱机制，适合网络环境</li>
<li><strong>稳定性</strong>：企业级应用长期使用，版本更新也比较注重向后兼容</li>
</ol>
<p><strong>劣势</strong>：</p>
<ol>
<li><strong>性能</strong>：虽然 JVM 优化了很多，但相比 CPP 和 Rust 这种原生编译语言，还是有一定开销</li>
<li><strong>启动时间</strong>：比如微服务场景下，可能不如 Go 之类的快</li>
<li><strong>语法繁琐</strong>：样板代码多，之前没有 lambda 的时候更麻烦，现在有了但是相比 Python 还是不够简洁</li>
<li><strong>内存消耗</strong>：JVM 本身占内存，对于资源有限的环境可能不太友好</li>
<li><strong>面向对象过于严格</strong>：有时候写简单程序反而麻烦，虽然 Java 8 引入了函数式编程，但是不如其他语言自然</li>
<li><strong>开发效率</strong>：相比动态语言如 Python，Java需要更多代码，编译过程也可能拖慢开发节奏</li>
</ol>
<h2 id="3-Java-为什么是跨平台的？"><a href="#3-Java-为什么是跨平台的？" class="headerlink" title="3# Java 为什么是跨平台的？"></a>3# Java 为什么是跨平台的？</h2><p>主要依赖于 JVM。JVM也是一个软件，不同平台有不同的版本。编写的 Java 源码在编译后生成一种 <code>.class</code> 文件，称为字节码文件。JVM 就是负责将机器码文件翻译成特定平台下的机器码然后运行</p>
<p>也就是说，只要在不同平台上安装对应的 JVM，就可以运行字节码文件，运行我们编写的 Java 程序</p>
<p>PS：不同平台下编译生成的字节码是一样的，但是由 JVM 翻译成的机器码是不一样的；即使将 Java 程序打包成可执行文件（如 <code>.exe</code>），仍然需要 JVM 的支持；跨平台的是 Java 程序，不是 JVM，JVM 是用 C&#x2F;CPP 开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的 JVM</p>
<h2 id="4-JVM、JDK、JRE-三者关系？"><a href="#4-JVM、JDK、JRE-三者关系？" class="headerlink" title="4# JVM、JDK、JRE 三者关系？"></a>4# JVM、JDK、JRE 三者关系？</h2><img src="https://cdn.xiaolincoding.com//picgo/image-20240725230247664.png" alt="JVM、JDK、JRE 关系图" style="zoom: 33%;" />

<ul>
<li>JDK 是 Java 开发工具包，是开发 Java 程序所需的工具集合。它包含了 JVM、编译器（javac）、调试器（jdb）等开发工具，以及一系列的类库（如 Java 标准库和开发工具库）。JDK 提供了开发、编译、调试和运行 Java 程序所需的全部工具和环境</li>
<li>JRE 是 Java 运行时环境，是 Java 程序运行所需的最小环境。它包含了 JVM 和 一组 Java 类库，用于支持 Java 程序的执行。JRE 不包含开发工具，只提供 Java 程序运行所需的运行环境</li>
<li>JVM 是 Java 虚拟机，是 Java 程序运行的环境。它负责将 Java 字节码（由 Java 编译器生成）解释或编译成机器码，并执行程序。JVM 提供了内存管理、垃圾回收、安全性等功能，使得 Java 程序具备跨平台性</li>
</ul>
<h2 id="5-为什么-Java-解释和编译都有？"><a href="#5-为什么-Java-解释和编译都有？" class="headerlink" title="5# 为什么 Java 解释和编译都有？"></a>5# 为什么 Java 解释和编译都有？</h2><p>在 Java 经过编译之后生成字节码文件，接下来进入 JVM 中，就有两个步骤编译和解释，如图：</p>
<img src="https://cdn.xiaolincoding.com//picgo/1715928000183-44fc6130-8abc-4f0b-8f6d-79de0ab09509.webp" alt="Java 源码执行过程" style="zoom: 67%;" />

<ul>
<li><p><strong>编译性</strong>：Java 源码（<code>.java</code> 文件）通过 <code>javac</code> 编译，生成字节码文件（<code>.class</code>）</p>
</li>
<li><p><strong>解释性</strong>：早期 JVM 使用<strong>解释器</strong>，逐行解释执行字节码。现代 JVM 引入 <strong>JIT（Just-In-Time）编译器</strong>，热点代码会被编译为本地机器码提高执行效率</p>
</li>
</ul>
<p>所以 Java 既是编译型语言，也是解释型语言，默认采用的是解释器和编译器混合的模式</p>
<h2 id="6-JVM-是什么？"><a href="#6-JVM-是什么？" class="headerlink" title="6# JVM 是什么？"></a>6# JVM 是什么？</h2><p>JVM 是 Java 虚拟机，主要工作是解释自己的指令集（即字节码）并映射到本地的 CPU 指令集和 OS 的系统调用</p>
<p>JVM 屏蔽了与操作系统平台相关的信息，使得 Java 程序只需要生成在 Java 虚拟机上运行的目标代码（字节码），就可在多种平台上不加修改地运行，这也是 Java 能够 “一次编译，到处运行” 的原因</p>
<h2 id="7-编译型语言和解释型语言的区别？"><a href="#7-编译型语言和解释型语言的区别？" class="headerlink" title="7# 编译型语言和解释型语言的区别？"></a>7# 编译型语言和解释型语言的区别？</h2><ul>
<li><p><strong>编译型语言</strong>：在程序执行之前，整个源码会被编译成字节码或机器码，生成可执行文件。执行时直接运行编译后的代码，速度快，但跨平台性较差</p>
</li>
<li><p><strong>解释型语言</strong>：在程序执行时，逐行解释执行源码，不生成独立的可执行文件。通常由解释器动态解释并执行代码，跨平台性好，但执行速度相对较慢</p>
</li>
</ul>
<p>典型的编译型语言如 C、CPP，典型的解释型语言如 Python、JavaScript</p>
<h2 id="8-Java-和-Python-的区别是什么？"><a href="#8-Java-和-Python-的区别是什么？" class="headerlink" title="8# Java 和 Python 的区别是什么？"></a>8# Java 和 Python 的区别是什么？</h2><ul>
<li>Java 是一种先编译后解释的混合型语言，Java 编译器将源码编译为字节码，而字节码则由 Java 虚拟机执行</li>
<li>Python 是一种解释型语言，会在执行程序的同时进行解释</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="1-8-种基本的数据类型"><a href="#1-8-种基本的数据类型" class="headerlink" title="1# 8 种基本的数据类型"></a>1# 8 种基本的数据类型</h2><ul>
<li><strong>数值型</strong>：整数类型（<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>）和浮点类型（<code>float</code>、<code>double</code>）</li>
<li><strong>字符型</strong>：<code>char</code></li>
<li><strong>布尔型</strong>：<code>boolean</code></li>
</ul>
<p>8 种基本数据类型的占用大小、取值范围、默认值，如下表所示：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>占用大小（字节）</th>
<th>取值范围</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>byte</code></td>
<td>1</td>
<td><code>-2^7</code> 到 <code>2^7 - 1</code></td>
<td>0</td>
<td>最小的整数类型，适合用于节省内存，例如在处理文件或网络流时存储小范围整数数据</td>
</tr>
<tr>
<td><code>short</code></td>
<td>2</td>
<td><code>-2^15</code> 到 <code>2^15 - 1</code></td>
<td>0</td>
<td>较少使用，通常用于在需要节省内存且数据范围在该区间的场景</td>
</tr>
<tr>
<td><code>int</code></td>
<td>4</td>
<td><code>-2^31</code>到 <code>2^31 - 1</code></td>
<td>0</td>
<td>最常用的整数类型，可满足大多数日常编程种整数计算的需求</td>
</tr>
<tr>
<td><code>long</code></td>
<td>8</td>
<td><code>-2^63</code>到 <code>2^63 - 1</code></td>
<td>0L</td>
<td>用于表示非常大的整数，当 <code>int</code> 类型无法满足需求时使用，定义时数值后需加 <code>L</code> 或 <code>l</code></td>
</tr>
<tr>
<td><code>float</code></td>
<td>4</td>
<td><code>-2^31</code>到 <code>2^31 - 1</code></td>
<td>0.0f</td>
<td>单精度浮点数，用于表示小数，定义时数值后需加 <code>F</code> 或 <code>f</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td>8</td>
<td><code>-2^63</code>到 <code>2^63 - 1</code></td>
<td>0.0d</td>
<td>双精度浮点数，精度比 <code>float</code> 高，是 Java 种表示小数的默认类型</td>
</tr>
<tr>
<td><code>char</code></td>
<td>2</td>
<td><code>-2^15</code> 到 <code>2^15 - 1</code></td>
<td>‘\u0000’</td>
<td>用于表示单个字符，采用 Unicode编码，可表示各种语言的字符</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>不确定（理论上1位）</td>
<td><code>true</code> 或 <code>false</code></td>
<td><code>false</code></td>
<td>用于逻辑判断，只有两个取值，常用于条件判断和循环控制等逻辑场景</td>
</tr>
</tbody></table>
<p><code>float</code> 和 <code>double</code> 的最小值和最大值是以科学计数法的形式输出的，比如 3.14E3 表示 3.14 * 10^3，3.14E-3 表示 3.14 &#x2F; 10^3</p>
<p>注意：</p>
<ul>
<li>浮点数的默认类型是 <code>double</code>，声明 <code>float</code> 时必须在末尾加上 <code>F</code> 或 <code>f</code></li>
<li>整数的默认类型为 <code>int</code>，声明 <code>long</code> 时必须在末尾加上 <code>L</code> 或 <code>l</code></li>
<li><code>char</code> 的包装类是 <code>Character</code>，<code>int</code> 的是 <code>Integer</code>，其他都是首字母大写</li>
<li><code>char</code> 是无符号的，不能为负，所以是 0 开始的</li>
</ul>
<h2 id="2-long-和-int-可以互转吗？"><a href="#2-long-和-int-可以互转吗？" class="headerlink" title="2# long 和 int 可以互转吗？"></a>2# long 和 int 可以互转吗？</h2><p><strong>可以</strong>。由于 <code>long</code> 的范围比 <code>int</code> 大，因此将 <code>int</code> 转换为 <code>long</code> 是安全的，而将 <code>long</code> 转换为 <code>int</code> 可能会导致数据丢失或溢出</p>
<p>将 <code>int</code> 转换为 <code>long</code> 可以通过直接赋值或强制类型转换来实现。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">longValue</span> <span class="operator">=</span> intValue; <span class="comment">// 自动转换，安全的</span></span><br></pre></td></tr></table></figure>

<p>将 <code>long</code> 转换为 <code>int</code> 需要使用强制类型转换，但需要注意潜在的数据丢失或溢出问题。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">longValue</span> <span class="operator">=</span> <span class="number">100L</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> (<span class="type">int</span>) longValue; <span class="comment">// 强制类转换，可能会有数据丢失或溢出</span></span><br></pre></td></tr></table></figure>

<p>如果 <code>longValue</code> 的值超出了 <code>int</code> 的范围，转换结果是截断后的低位部分。因此，在转换之前，建议先检查 <code>longValue</code> 的值是否在 <code>int</code> 范围内，以避免数据丢失或溢出的问题</p>
<h2 id="3-数据类型转换的方式有哪些？"><a href="#3-数据类型转换的方式有哪些？" class="headerlink" title="3# 数据类型转换的方式有哪些？"></a>3# 数据类型转换的方式有哪些？</h2><ol>
<li><strong>自动类型转换（隐式转换）</strong>：当目标类型的范围大于源类型时，Java 会自动将源类型转换为目标类型，不需要显示的类型转换。例如：将 <code>int</code> 转换为 <code>long</code>、将 <code>float</code> 转换为 <code>double</code> 等</li>
<li><strong>强制类型转换（显示转换）</strong>：当目标类型的范围小于源类型时，需要使用强制类型转换将源类型转换为目标类型。这可能导致数据丢失或溢出。例如：将 <code>long</code> 转换为 <code>int</code> 、将 <code>double</code> 转换为 <code>float</code> 等。语法为：目标类型 变量名 &#x3D; (目标类型) 源类型</li>
<li><strong>字符串转换</strong>：Java 提供了将字符串表示的数据转换为其他类型数据的方法。例如，将字符串转换为整型 <code>int</code>，可以使用 <code>Integer.parseInt()</code> 方法；将字符串转换为浮点型 <code>double</code>，可以使用 <code>Double.parseDouble()</code> 方法等</li>
<li><strong>数值之间的转换</strong>：Java 提供了一些数据类型之间的转换方法，如将整型转换为字符型、将字符型转换为整型等。这些转换方式可以通过类型的包装类来实现，例如：将 <code>int</code> 转换为 <code>char</code>，可以使用 <code>Character.forDigit()</code> 方法；将 <code>char</code> 转换为 <code>int</code>，可以使用 <code>Character.getNumericValue()</code> 方法</li>
</ol>
<h2 id="4-类型互转可能会出现什么问题？"><a href="#4-类型互转可能会出现什么问题？" class="headerlink" title="4# 类型互转可能会出现什么问题？"></a>4# 类型互转可能会出现什么问题？</h2><ol>
<li><strong>数据丢失</strong>：当将一个范围较大的数据类型转换为一个范围较小的数据类型时，可能会发生数据丢失。例如：将一个 <code>long</code> 转换为 <code>int</code> 时，如果 <code>long</code> 值超出了 <code>int</code> 类型的范围，转换结果将是截断后的低位部分，高位部分的数据丢失</li>
<li><strong>数据溢出</strong>：与数据丢失相反，当将一个范围较小的数据类型转换为一个范围较大的数据类型时，可能会发生数据溢出。例如：将一个 <code>int</code> 转换为 <code>long</code> 时，转换结果会填充额外的高位空间，但原始数据仍然保持不变</li>
<li><strong>精度损失</strong>：在进行浮点数类型的转换时，可能会发生精度损失。由于浮点数的表示方法不同，将一个双精度浮点数 <code>double</code> 转换为单精度浮点数 <code>float</code> 时，精度可能会损失</li>
<li><strong>类型不匹配导致的错误</strong>：在进行类型转换时，需要确保源类型和目标类型是兼容的。如果两者不兼容，会导致编译错误或运行时错误</li>
</ol>
<h2 id="5-为什么用-BigDecimal-不用-double？"><a href="#5-为什么用-BigDecimal-不用-double？" class="headerlink" title="5# 为什么用 BigDecimal 不用 double？"></a>5# 为什么用 BigDecimal 不用 double？</h2><p><code>double</code> 会出现精度丢失的问题，<code>dobule</code> 执行的是二进制浮点运算，二进制表示小数只能使用 1&#x2F;(2^n) 的和的组合，有些情况下不能准确地表示一个小数。</p>
<p>而 <code>BigDecimal</code> 是精确计算，一般牵扯到金钱的计算，都使用 <code>BigDecimal</code>。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.1&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">sum</span> <span class="operator">=</span> num1.add(num2); <span class="comment">// 0.3</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">product</span> <span class="operator">=</span> num1.multiply(num2); <span class="comment">// 0.02</span></span><br></pre></td></tr></table></figure>

<p>这样，<code>BigDecimal</code> 可以确保精确的十进制数值计算，避免了使用 <code>double</code> 可能出现的舍入误差。需要注意的是，在创建 <code>BigDecimal</code> 对象时，应该使用字符串作为参数，而不是直接使用浮点数值，以避免浮点数精度丢失</p>
<h2 id="6-装箱和拆箱是什么？"><a href="#6-装箱和拆箱是什么？" class="headerlink" title="6# 装箱和拆箱是什么？"></a>6# 装箱和拆箱是什么？</h2><p>装箱（Boxing）和拆箱（Unboxing）是将基本数据类型和对应的包装类之间进行转换的过程，自动装箱主要发送在赋值时和方法调用时，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 赋值时</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i; <span class="comment">// 拆箱</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法调用时</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">show</span><span class="params">(Integer iParam)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;自动装箱&quot;</span> + iParam);</span><br><span class="line">    <span class="keyword">return</span> iParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">show(<span class="number">3</span>); <span class="comment">// 装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> show(<span class="number">3</span>); <span class="comment">// 返回类型是 Integer，拆箱</span></span><br></pre></td></tr></table></figure>

<p>在一个循环中进行自动装箱操作的情况下可能出现问题，会创建多余的对象，影响程序的性能，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123; sum += <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure>

<p><code>+</code> 这个操作符不适用于 <code>Integer</code> 对象，首先 <code>sum</code> 进行自动拆箱操作，进行数值相加操作，最后发生自动装箱操作转换成 <code>Integer</code> 对象。其内部变化如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> sum.intValue() + i;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(result);</span><br></pre></td></tr></table></figure>

<p>因为 <code>sum</code> 声明为 <code>Integer</code> 类型，上面的循环中会创建 1000 个无用的 <code>Integer</code> 对象，会降低程序的性能，加重垃圾回收的工作量。因此在编程的时候，需要正确地声明变量类型，避免因为自动装箱引起的性能问题</p>
<h2 id="Java-为什么要有包装类？"><a href="#Java-为什么要有包装类？" class="headerlink" title="Java 为什么要有包装类？"></a>Java 为什么要有包装类？</h2><p>包装类就是将基本数据类型包装成 <code>Object</code> 对象，对象封装有诸多好处：</p>
<ol>
<li>可以把属性和方法结合在一起，比如 <code>Integer</code> 有 <code>parseInte()</code> 方法来专门处理 <code>int</code> 相关的数据</li>
<li>Java 中大部分类和方法都是用来处理<strong>引用类型</strong>的。像 <code>ArrayList</code> 这样的集合类，不能直接存储基本类型（如 <code>int</code>、<code>double</code>），而是必须使用其对应的包装类（如 <code>Integer</code>、<code>Double</code>）</li>
<li>在 Java 中，泛型只能使用<strong>引用类型</strong>，而不能使用<strong>基本数据类型</strong>。例如：对一个列表的元素进行排序，如果使用基本类型 <code>int</code>（实际上基本类型无法作为泛型参数，所以连 <code>List&lt;int&gt;</code> 都不合法），无法直接使用 <code>Collections.sort()</code> 方法，如果使用 <code>Integer</code> 包装类，则可以</li>
<li>在 Java 中，集合中只能存储引用类型，而不能存储基本类型。比如 <code>List&lt;int&gt;</code> 是不合法的，需要使用 <code>List&lt;Integer&gt;</code></li>
</ol>
<p>需要注意空指针异常。例如：<code>int</code> 可以赋值为 0，而 <code>Integer</code> 必须通过实例化对象来赋值，如果对一个未经初始化的 <code>Integer</code> 变量进行操作，就会出现 <code>NullPointerException</code>，这是因为它被赋值为 <code>null</code>，而 <code>null</code> 是无法进行自动拆箱的</p>
<h2 id="7-为什么还要保留基本数据类型？"><a href="#7-为什么还要保留基本数据类型？" class="headerlink" title="7# 为什么还要保留基本数据类型？"></a>7# 为什么还要保留基本数据类型？</h2><p>包装类是引用类型，对象的引用和对象本身是分开存储的，而对于基本数据类型，变量对应的内存块直接存储数据本身。因此，基本数据类型在读写效率方面，要比包装类高效</p>
<p>此外，在 64 位 JVM 上，在开启引用压缩的情况下，一个 <code>Integer</code> 对象占用 16 个字节的内存空间，而一个 <code>int</code> 类型数据只占用 4 字节的内存空间</p>
<p>不管在读写效率，还是存储效率，基本类型都比包装类高效</p>
<h2 id="8-说一下-Integer-的基本缓存"><a href="#8-说一下-Integer-的基本缓存" class="headerlink" title="8# 说一下 Integer 的基本缓存"></a>8# 说一下 Integer 的基本缓存</h2><p>Java 的 <code>Integer</code> 类内部实现了一个静态缓存池，用于存储特定范围内的整数值对应的 <code>Integer</code> 对象</p>
<p>默认情况下，这个范围是 -128 到 127。当通过 <code>Integer.valueOf(int)</code> 方法创建一个在这个范围内的整数对象时，并不会每次都生成新的对象实例，而是复用缓存中的对象，直接从内存中取出，不需要新建一个对象</p>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="1-怎么理解面向对象？简单说说封装、继承、多态"><a href="#1-怎么理解面向对象？简单说说封装、继承、多态" class="headerlink" title="1# 怎么理解面向对象？简单说说封装、继承、多态"></a>1# 怎么理解面向对象？简单说说封装、继承、多态</h2><p>面向对象是一种编程范式，它将现实世界中的事物抽象为对象，对象具有属性和方法。面向对象编程的设计思想是以对象为中心，通过对象之间的交互来完成程序的功能，具有灵活性和可扩展性</p>
<p>Java 面向对象的三大特性包括**：封装、继承、多态**</p>
<ul>
<li><strong>封装</strong>：封装是指将对象的属性（成员变量）和行为（方法）封装在一个类中，并通过访问控制符（如 <code>private</code>、<code>public</code> 等）隐藏内部实现细节，只暴露必要的接口供外部使用。封装的作用是<strong>增强安全性、提高模块独立性</strong>，防止外部对对象状态的非法访问或修改</li>
<li><strong>继承</strong>：继承是面向对象编程中实现代码复用的机制，它允许一个类（子类）继承另一个类（父类）的属性和方法。继承使得子类可以在父类基础上扩展功能，从而构建更清晰、更有层次的类结构</li>
<li><strong>多态</strong>：多态是指<strong>同一个方法调用，在不同对象上可以表现出不同的行为</strong>。它分为两种形式：<ul>
<li><strong>编译时多态（方法重载）</strong>：同一类中方法名相同、参数不同</li>
<li><strong>运行时多态（方法重写）</strong>：子类重写父类方法，并通过父类引用调用子类对象。<br> 多态使程序具备更好的<strong>扩展性和可维护性</strong>，是实现面向接口编程的关键</li>
</ul>
</li>
</ul>
<h2 id="2-多态体现在哪几个方面？"><a href="#2-多态体现在哪几个方面？" class="headerlink" title="2# 多态体现在哪几个方面？"></a>2# 多态体现在哪几个方面？</h2><ol>
<li><p><strong>方法重载</strong>：方法重载是指同一类中可以有多个同名方法，它们具有不同的参数列表。虽然方法名相同，但根据传入的不同参数，编译器会在编译时确定调用哪个方法。注意：方法返回值不同但参数相同，<strong>不构成重载</strong></p>
</li>
<li><p><strong>方法重写</strong>：方法重写是指子类能够提供对父类中同名方法的具体实现。在运行时，JVM 会根据对象的实际类型确定调用哪个版本的方法，这是实现多态的主要方式。注意：重写的方法必须具有<strong>相同的方法签名</strong>，且<strong>访问权限不能比父类更严格</strong></p>
</li>
<li><p><strong>接口与实现</strong>：Java 中的接口是一种行为规范，类通过 <code>implements</code> 关键字实现接口。多个类可以实现同一个接口，通过<strong>接口引用来调用方法</strong>，可以实现<strong>调用方与实现方的解耦</strong>，体现了多态特性</p>
</li>
<li><p><strong>向上转型和向下转型</strong>：</p>
<ul>
<li><p><strong>向上转型</strong>：子类对象可以被赋值给父类类型的引用（即：<code>Parent p = new Child()</code>），这在 Java 中是<strong>自动进行</strong>的，也是多态的前提。可以只调用父类中定义的方法，实际运行的是子类的重写实现（如果有）</p>
</li>
<li><p><strong>向下转型</strong>：将父类引用转换为子类类型（即：<code>Child c = (Child) p</code>），这通常需要<strong>强制类型转换</strong>，并应使用 <code>instanceof</code> 检查其实际类型，避免出现 <code>ClassCastException</code>。向下转型常用于访问子类特有的方法</p>
</li>
</ul>
</li>
</ol>
<h2 id="3-多态解决了什么问题？"><a href="#3-多态解决了什么问题？" class="headerlink" title="3# 多态解决了什么问题？"></a>3# 多态解决了什么问题？</h2><p>多态是指<strong>同一个方法调用，在不同对象上可以表现出不同的行为</strong>。多态的这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类</p>
<p>多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等</p>
<h2 id="4-面向对象的设计原则有哪些？"><a href="#4-面向对象的设计原则有哪些？" class="headerlink" title="4# 面向对象的设计原则有哪些？"></a>4# 面向对象的设计原则有哪些？</h2><ol>
<li><strong>单一职责原则（SRP）</strong>：一个类应该只有一个引起它变化的原因，即一个类应该只负责一项职责。例如：考虑一个员工类，它应该只负责管理员工信息，而不负责其他无关的工作</li>
<li><strong>开放封闭原则（OCP）</strong>：软件实体应该对扩展开放，对修改封闭。例如：定义一个图形类，然后让不同类型的图形继承这个类，而不需要修改图形类本身</li>
<li><strong>里式替换原则（LSP）</strong>：父类出现的地方，子类必须能够替代父类，并且保证原有功能不被破坏。例如：如果一个公司类包含部门类，应该考虑使用合成&#x2F;聚合关系，而不是将公司类继承自部门类</li>
<li><strong>接口隔离原则（ISP）</strong>：客户端不应该依赖那些它不需要的接口，即接口应该小而专。例如：你设计了一个 “多功能设备接口”，里面包含<strong>打印</strong>、<strong>扫描</strong>、<strong>传真</strong>、<strong>装订</strong>四个方法，结果，公司后来要做一款<strong>廉价入门级打印机</strong>，它只能打印，其余功能都没有。为了实现接口，这台打印机被迫提供空实现或抛异常</li>
<li><strong>依赖倒置原则（DIP）</strong>：高层模块不应该依赖低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。例如：假设有一个通知服务类 ，需要发送消息。错误的做法是它直接创建并依赖一个 <code>EmailSender</code> 类，这样如果以后要改用短信或微信，就必须修改通知服务的代码。正确的做法是先定义一个接口并实现它。通知服务类只依赖接口，而不是具体实现</li>
<li><strong>最少知识原则（Law of Demeter）</strong>：一个对象应当对其他对象有最少的了解，只与其直接的朋友交互。例如：你要点一杯咖啡，应该说：“服务员，请给我一杯拿铁。”，由服务员自己决定找谁、怎么做</li>
</ol>
<h2 id="5-抽象类和普通类的区别？"><a href="#5-抽象类和普通类的区别？" class="headerlink" title="5# 抽象类和普通类的区别？"></a>5# 抽象类和普通类的区别？</h2><ol>
<li><strong>实例化</strong>：普通类可以直接实例化对象，而抽象类不能被实例化，只能被继承</li>
<li><strong>方法实现</strong>：普通类中的方法可以有具体的实现，而抽象类中的方法可以有实现也可以没有实现</li>
<li><strong>实现限制</strong>：普通类可以被其他类继承和使用，而抽象类一般用于作为基类，被其他类继承和扩展使用</li>
</ol>
<h2 id="6-抽象类和接口的区别是什么？"><a href="#6-抽象类和接口的区别是什么？" class="headerlink" title="6# 抽象类和接口的区别是什么？"></a>6# 抽象类和接口的区别是什么？</h2><p><strong>两者的特点</strong>：</p>
<ul>
<li>抽象类用于描述类的共同特性和行为，可以有成员变量、构造方法和具体方法。适用于有明显继承关系的场景</li>
<li>接口用于定义行为规范，可以多实现，只能有常量和抽象方法（Java 8 以后可以有默认方法和静态方法）。适用于定义类的能力或功能</li>
</ul>
<p><strong>两者的区别:</strong></p>
<ol>
<li><strong>实现方式</strong>：实现接口的关键字为 <code>implements</code>，继承抽象类的关键字为 <code>extends</code>。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承</li>
<li><strong>方法方式</strong>：接口只有定义，不能有方法的实现，Java 8 中可以定义 <code>default</code> 方法体，而抽象类可以有定义与实现，方法可在抽象类中实现</li>
<li><strong>访问修饰符</strong>：接口成员变量默认为 <code>public static final</code>，必须赋初值，不能被修改；其所有的成员方法都是 <code>public abstract</code> 的。抽象类中成员变量默认 <code>default</code>，可在子类中被重新定义，也可被重新赋值；抽象方法被 <code>abstract</code> 修饰，不能被 <code>private</code>、<code>static</code>、<code>synchronized</code> 和 <code>native</code> 等修饰，必须以分号结尾，不带花括号</li>
<li><strong>变量</strong>：抽象类可以包含实例变量和静态变量，而接口只能包含常量（静态常量）</li>
</ol>
<h2 id="7-抽象类能加-final-修饰吗？"><a href="#7-抽象类能加-final-修饰吗？" class="headerlink" title="7# 抽象类能加 final 修饰吗？"></a>7# 抽象类能加 final 修饰吗？</h2><p><strong>不能</strong>。Java 中的抽象类是用来被继承的，而 <code>final</code> 修饰符用于禁止类被继承或方法被重写，因此，抽象类和 <code>final</code> 修饰符是互斥的，不能同时使用</p>
<h2 id="8-接口里面可以定义哪些方法"><a href="#8-接口里面可以定义哪些方法" class="headerlink" title="8# 接口里面可以定义哪些方法"></a>8# 接口里面可以定义哪些方法</h2><ol>
<li><strong>抽象方法</strong>：抽象方法是接口的核心部分，所有实现接口的类必须实现这些方法。抽象方法默认是 <code>public</code> 和 <code>abstract</code>，这些修饰符可以省略</li>
<li><strong>默认方法</strong>：默认方法是在 Java 8 引入的，允许接口提供具体实现，实现类可以选择重写默认方法</li>
<li><strong>静态方法</strong>：静态方法也是在 Java 8 引入的，它们属于接口本身，可以通过接口名直接调用，而不需要实现类的对象</li>
<li><strong>私有方法</strong>：私有方法是在 Java 9 引入的，用于在接口中为默认方法和其他私有方法提供辅助功能，这些方法不能被实现类访问，只能在接口内部使用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sleeping...&quot;</span>);</span><br><span class="line">        logSleep();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method in interface&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logSleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logging sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="9-抽象类可以被实例化吗？"><a href="#9-抽象类可以被实例化吗？" class="headerlink" title="9# 抽象类可以被实例化吗？"></a>9# 抽象类可以被实例化吗？</h2><p><strong>不能</strong>。这意味着不能使用 <code>new</code> 关键字直接创建一个抽象类的对象。抽象类的存在主要是为了被继承，它通常包含一个或多个抽象方法（由 <code>abstract</code> 关键字修饰且无方法体），这些方法在子类中被实现</p>
<p>抽象类可以有构造器，这些构造器在子类实例化时会被调用，以便进行必要的初始化工作。然而，这个过程并不是直接实例化抽象类，而是创建了子类的实例，间接地使用了抽象类的构造器。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 构造器代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ConcreteClass &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 调用抽象类的构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实现抽象方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ConcreteClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass</span>();</span><br></pre></td></tr></table></figure>



<h2 id="10-接口可以包含构造函数吗？"><a href="#10-接口可以包含构造函数吗？" class="headerlink" title="10# 接口可以包含构造函数吗？"></a>10# 接口可以包含构造函数吗？</h2><p><strong>不能</strong>。接口不会有自己的实例，所以不需要有构造函数</p>
<p>这是因为，构造函数就是初始化类的属性或方法，在 new 的一瞬间自动调用，然而接口是不能 new 的</p>
<h2 id="11-解释-Java-中的静态变量和静态方法"><a href="#11-解释-Java-中的静态变量和静态方法" class="headerlink" title="11# 解释 Java 中的静态变量和静态方法"></a>11# 解释 Java 中的静态变量和静态方法</h2><p>在 Java 中，静态变量和静态方法是与类本身关联的，而不是与类的实例（对象）关联，它们在内存中只存在一份，可以被类的所有实例共享</p>
<ul>
<li><strong>静态变量</strong>：静态变量（类变量）是在类中使用 <code>static</code> 关键字声明的变量，他们属于类而不是任何具体的对象。常用于需要在所有对象间共享的数据，如计数器、常量等。主要的特点：<ul>
<li><strong>共享性</strong>：所有该类的实例共享同一个静态变量。如果一个实例修改了静态变量的值，其他实例也会看到这个更改</li>
<li><strong>初始化</strong>：静态变量在类被加载时初始化，只会对其进行一次内存分配</li>
<li><strong>访问方式</strong>：静态变量可以直接通过类名访问，也可以通过实例访问，但推荐使用类名</li>
</ul>
</li>
<li><strong>静态方法</strong>：静态方法是在类中使用 <code>static</code> 关键字声明的方法，类似于静态变量，静态方法也属于类而不是任何具体的对象。常用于助手方法、获取类级别的信息或者是没有依赖于实例的数据处理。主要的特点：<ul>
<li><strong>访问静态成员</strong>：静态方法可以直接调用其他静态变量和静态方法，但不能直接访问非静态成员</li>
<li><strong>无实例依赖</strong>：静态方法可以在没有创建类实例的情况下调用。对于静态方法来说，不能直接访问非静态的成员变量或方法，因为静态方法没有上下文的实例</li>
<li><strong>多态性</strong>：静态方法不支持重写（Override），但可以被隐藏（Hide）</li>
</ul>
</li>
</ul>
<h2 id="12-非静态内部类和静态内部类的区别？"><a href="#12-非静态内部类和静态内部类的区别？" class="headerlink" title="12# 非静态内部类和静态内部类的区别？"></a>12# 非静态内部类和静态内部类的区别？</h2><ol>
<li>非静态内部类依赖于外部类的实例，而静态内部类不依赖于外部类的实例</li>
<li>非静态内部类可以访问外部类的实例变量和方法，而静态内部类只能访问外部类的静态成员</li>
<li>非静态内部类不能定义静态成员，而静态内部类可以定义静态成员</li>
<li>非静态内部类在外部类实例化后才能实例化，而静态内部类可以独立实例化</li>
<li>非静态内部类可以访问外部类的私有成员，而静态内部类不能直接访问外部类的私有成员，需要通过实例化外部类来访问</li>
</ol>
<h2 id="13-非静态内部类可以直接访问外部类的实例变量和方法，编译器是怎么做到的？"><a href="#13-非静态内部类可以直接访问外部类的实例变量和方法，编译器是怎么做到的？" class="headerlink" title="13# 非静态内部类可以直接访问外部类的实例变量和方法，编译器是怎么做到的？"></a>13# 非静态内部类可以直接访问外部类的实例变量和方法，编译器是怎么做到的？</h2><p>这是因为编译器在生成字节码时，会为非静态内部类维护一个指向外部类实例的引用，将外部类实例作为参数传入，并在内部类的实例化过程中建立外部类实例与内部类实例之间的联系，从而实现直接访问外部方法的功能</p>
<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="1-Java-中-final-的作用是什么？"><a href="#1-Java-中-final-的作用是什么？" class="headerlink" title="1# Java 中 final 的作用是什么？"></a>1# Java 中 final 的作用是什么？</h2><ol>
<li><strong>装饰类</strong>：当 <code>final</code> 修饰一个类时，表示这个类不能被继承，是类继承体系中的最终形态。例如：Java 中的 <code>String</code> 类就是用 <code>final</code> 修饰的，着保证了 <code>String</code> 类的不可变性和安全性，防止其他类通过继承来改变 <code>String</code> 类的行为和特性</li>
<li><strong>修饰方法</strong>：用 <code>final</code> 修饰的方法不能在子类中被重写。例如：<code>java.lang.Object</code> 类中的 <code>getClass</code> 方法就是 <code>final</code> 的，因为这个方法的行为是由 JVM 底层实现来保证的，不应该被子类修改</li>
<li><strong>修饰变量</strong>：当 <code>final</code> 修饰基本数据类型的变量时，改变量一旦被赋值就不能再改变。例如：<code>final int num = 10</code>，这里的 <code>num</code> 就是一个常量，不能再对齐进行重新赋值操作，否则会导致编译错误。对于引用类型，<code>final</code> 修饰意味着这个引用变量不能再指向其他对象，但对象本身的内容是可以改变的。例如：<code>final StringBuilder sb = new StringBuilder(&quot;Hello&quot;);</code>，不能让 <code>sb</code> 再指向其他 <code>StringBuilder</code> 对象，但可以通过 <code>sb.append(&quot; World!&quot;);</code> 来修改字符串的内容</li>
</ol>
<h1 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h1><h2 id="1-浅拷贝和深拷贝的区别？"><a href="#1-浅拷贝和深拷贝的区别？" class="headerlink" title="1# 浅拷贝和深拷贝的区别？"></a>1# 浅拷贝和深拷贝的区别？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1720683675376-c5af6668-4538-479f-84e8-42d4143ab101.webp" alt="深拷贝和浅拷贝的区别"></p>
<ul>
<li><strong>浅拷贝</strong>：只复制对象本身以及其字段中的基本类型值和引用类型的引用地址，不会递归复制引用对象本身。也就是说，浅拷贝会创建一个新的对象，但其中引用类型的字段仍指向原对象中引用的<strong>同一内存地址</strong>，所以原对象和拷贝对象会<strong>共享</strong>这些引用</li>
<li><strong>深拷贝</strong>：不仅复制对象本身，还会递归复制对象中所有的引用类型字段，确保所有嵌套的对象也被复制一份。这样，深拷贝生成的是一个完全独立的对象及其所有内部对象，原对象和拷贝对象之间互不影响</li>
</ul>
<h2 id="2-实现深拷贝的三种方法是什么"><a href="#2-实现深拷贝的三种方法是什么" class="headerlink" title="2# 实现深拷贝的三种方法是什么?"></a>2# 实现深拷贝的三种方法是什么?</h2><ul>
<li><strong>实现 <code>Cloneable</code> 接口并重写 <code>clone()</code> 方法</strong>：在 <code>clone()</code> 方法中，通过递归克隆引用类型字段来实现深拷贝</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String field1;</span><br><span class="line">    <span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">cloned</span> <span class="operator">=</span> (MyClass) <span class="built_in">super</span>.clone();</span><br><span class="line">        cloned.nestedObject = (NestedClass) nestedObject.clone(); <span class="comment">// 深拷贝内部的引用对象</span></span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>使用序列化和反序列化</strong>：通过将对象序列化为字节流，再从字节流反序列化为对象来实现深拷贝。要求对象及其所有引用类型字段都实现 <code>Serializable</code> 接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String field1;</span><br><span class="line">    <span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Myclass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">			<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">			oos.writeObject(<span class="built_in">this</span>);</span><br><span class="line">			oos.flush();</span><br><span class="line">			oos.close();</span><br><span class="line">			<span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray());</span><br><span class="line">			<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">			<span class="keyword">return</span> (MyClass) ois.readObject();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>手动递归复制</strong>：针对特定对象结构，手动递归复制对象及其引用类型字段。适用于对象结构复杂度不高的情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String field1;</span><br><span class="line">	<span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> MyClass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">MyClass</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">		copy.setField1(<span class="built_in">this</span>.field1);</span><br><span class="line">		copy.setNestedObject(<span class="built_in">this</span>.nestedObject.deepCopy());</span><br><span class="line">		<span class="keyword">return</span> copy;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line">	<span class="keyword">public</span> NestedClass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">NestedClass</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NestedClass</span>();</span><br><span class="line">		copy.setNestedField(<span class="built_in">this</span>.nestedField);</span><br><span class="line">		<span class="keyword">return</span> copy;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="1-什么是泛型？"><a href="#1-什么是泛型？" class="headerlink" title="1# 什么是泛型？"></a>1# 什么是泛型？</h2><p>泛型是 Java 编程语言中的一个重要特性，它允许类、接口和方法在定义时使用一个或多个类型参数，这些类型参数在使用时可以被指定为具体的类型</p>
<p>泛型的主要目的是在编译时提供更强的类型检查，并且在编译后能够保留类型信息，避免了在运行时出现类型转换异常</p>
<h2 id="2-为什么需要泛型？"><a href="#2-为什么需要泛型？" class="headerlink" title="2# 为什么需要泛型？"></a>2# 为什么需要泛型？</h2><ul>
<li><strong>适用于多种数据类型执行相同的代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">	System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">add</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> &#123;</span><br><span class="line">	System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">	System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个 <code>add()</code> 方法；通过泛型，我们可以复用为一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="type">double</span> <span class="title function_">add</span> <span class="params">(T a, T b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a.doubleValue() + b.doubleValue()));</span><br><span class="line">    <span class="keyword">return</span> a.doubleValue() + b.doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）</strong></li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.add(<span class="number">123</span>); <span class="comment">// 添加的是 Integer</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) list.get(<span class="number">1</span>); <span class="comment">// 编译通过，但运行时抛出 CCE</span></span><br></pre></td></tr></table></figure>

<p><code>list</code> 中的元素都是 <code>Object</code> 类型（无法约束其中的类型），所以在取出集合元素时需要人为地强制类型转换到具体的目标类型，且很容易出现 <code>ClassCastException</code> 异常</p>
<p>引入泛型，它将提供类型的约束，提供编译前的检查：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">// list.add(123); // 编译错误，不允许添加非 String 类型</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> list.get(<span class="number">0</span>); <span class="comment">// 不需要强制类型转换</span></span><br></pre></td></tr></table></figure>



<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="1-Java-创建对象有哪些方式？"><a href="#1-Java-创建对象有哪些方式？" class="headerlink" title="1# Java 创建对象有哪些方式？"></a>1# Java 创建对象有哪些方式？</h2><ol>
<li><p><strong>使用 <code>new</code> 关键字</strong>：通过 <code>new</code> 关键字直接调用类的构造方法来创建对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过反射创建对象</strong>：通过 Java 的反射机制可以再运行时动态地创建对象。可以使用 <code>Class</code> 类的 <code>newInstance()</code> 或者 <code>Constructor</code> 类的 <code>newInstance()</code> 方法创建对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Class 类</span></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>).newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Construcotr 类</span></span><br><span class="line">Constructor&lt;MyClass&gt; constructor = MyClass.class.getConstructor();</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>clone()</code> 方法</strong>：如果类实现了 <code>Cloneable</code> 接口，可以使用 <code>clone()</code> 方法复制对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj2</span> <span class="operator">=</span> (MyClass) obj1.clone();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用反序列化</strong>：通过将对象序列化到文件流中，然后再进行反序列化来创建对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">	<span class="comment">// Class definition</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// Serialize object</span></span><br><span class="line">		<span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">		<span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> 					<span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.ser&quot;</span>))</span><br><span class="line">		out.writeObject(obj);</span><br><span class="line">		out.close();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// Deserialize object</span></span><br><span class="line">		<span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> 						<span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line">		<span class="type">MyClass</span> <span class="variable">newObj</span> <span class="operator">=</span> (MyClass) in.readObject();</span><br><span class="line">		in.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-new-出的对象什么时候回收？"><a href="#2-new-出的对象什么时候回收？" class="headerlink" title="2# new 出的对象什么时候回收？"></a>2# new 出的对象什么时候回收？</h2><p>通过关键字 <code>new</code> 创建的对象，由 Java 的**垃圾回收器（Garbage Collector）**负责回收。垃圾回收器的工作是在程序运行过程中自动进行的，它会周期性地检测不再被引用的对象，并将其回收释放内存</p>
<p>具体来说，Java 对象的回收时机是由垃圾回收器根据一些算法来决定的，主要有以下几种情况：</p>
<ol>
<li><strong>引用计数法</strong>：某个对象的引用计数为 0 时，表示该对象不再被引用，可以被回收</li>
<li><strong>可达性分析算法</strong>：从根对象（如方法区中的类静态属性、方法中的局部变量等）出发，通过对象之间的引用链进行遍历，如果存在一条引用链到达某个对象，则说明该对象是可达的，反之则不可达，不可达的对象将被回收</li>
<li><strong>终结器（Finalizer）</strong>：如果对象重写了 <code>finalize()</code> 方法，垃圾回收器会在回收该对象之前调用 <code>finalize()</code> 方法，对象可以在 <code>finalize()</code> 方法中进行一些清理操作。然而，终结器机制的使用不被推荐，因为它的执行时间是不确定的，可能会导致不可预测的性能问题</li>
</ol>
<h2 id="3-如何获取私有对象？"><a href="#3-如何获取私有对象？" class="headerlink" title="3# 如何获取私有对象？"></a>3# 如何获取私有对象？</h2><p>在 Java 中，私有对象通常指的是类中被声明为 <code>private</code>  的成员变量或方法。由于 <code>private</code> 访问修饰符的限制，这些成员只能在其所在的类内部被访问</p>
<p>不过，可以通过下面两种方式来间接获取私有对象</p>
<ol>
<li><p><strong>使用公共访问器方法（<code>getter</code> 方法）</strong>：如果类的设计者遵循良好的编程规范，通常会为私有成员变量提供公共的访问器方法（<code>getter</code> 方法），通过调用这些方法可以安全地获取私有对象</p>
</li>
<li><p><strong>反射机制</strong>：反射机制允许在运行时检查和修改类、方法、字段等信息，通过反射可以绕过 <code>private</code> 访问修饰符的限制来获取私有对象。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">privateField</span> <span class="operator">=</span> <span class="string">&quot;私有字段的值&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessExcept &#123;</span><br><span class="line">		<span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">		Class&lt;?&gt; clazz = obj.getClass(); <span class="comment">// 获取 Class 对象</span></span><br><span class="line">		<span class="type">Field</span> <span class="variable">privateField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;privateField&quot;</span>); <span class="comment">// 获取私有字段</span></span><br><span class="line">		privateField.setAccessible(<span class="literal">true</span>); <span class="comment">// 设置可访问性</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) privateField.get(obj); <span class="comment">// 获取私有字段的值</span></span><br><span class="line">		System.out.println(value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="1-什么是反射？"><a href="#1-什么是反射？" class="headerlink" title="1# 什么是反射？"></a>1# 什么是反射？</h2><p><strong>Java 反射机制</strong>是指在程序运行期间，能够动态地获取一个类的结构信息（如类名、属性、方法、构造函数等），并且可以在运行时操作这些信息，例如创建对象、访问属性、调用方法等。这使得 Java 拥有强大的动态性和灵活性，是实现诸如框架设计、依赖注入、动态代理等高级功能的重要基础</p>
<img src="https://cdn.xiaolincoding.com//picgo/1718957173277-863d2ec6-a754-423b-9066-9f28610d1a31.png" alt="反射机制" style="zoom: 67%;" />

<p><strong>反射具有以下特性</strong>：</p>
<ol>
<li><strong>运行时类信息访问</strong>：反射允许程序在运行时获取一个类的完整结构信息，包括类名、字段、方法、构造器等，即使在编译时并不知道具体的类</li>
<li><strong>动态创建对象</strong>：通过反射，可以在运行时动态地创建对象实例。即便类名是在运行时才确定，也可以使用 <code>Class.newInstance()</code> 或 <code>Constructor.newInstance()</code> 方法完成对象的创建</li>
<li><strong>动态方法调用</strong>：反射支持在运行时调用对象的方法，包括私有方法。这通常通过 <code>Method.invoke()</code> 实现，允许传入对象实例和参数，从而执行对应的方法</li>
<li><strong>字段访问与修改</strong>：反射还可以访问和修改对象的字段值，包括私有字段。可以使用 <code>Field.set()</code> 方法设置字段的值，必要时可通过 <code>setAccessible(true)</code> 打破访问限制</li>
</ol>
<h2 id="2-反射在你平时写代码或者框架中的应用场景有哪些？"><a href="#2-反射在你平时写代码或者框架中的应用场景有哪些？" class="headerlink" title="2# 反射在你平时写代码或者框架中的应用场景有哪些？"></a>2# 反射在你平时写代码或者框架中的应用场景有哪些？</h2><p><strong>一、加载数据库驱动</strong>：在使用 JDBC 连接数据库时，常常需要根据实际使用的数据库类型（如 MySQL、Oracle）动态加载对应的驱动类。此时可以使用 <code>Class.forName()</code> 方法通过反射机制加载指定的驱动类，而无需在代码中硬编码具体的驱动实现，从而提升系统的灵活性和可配置性。例如：</p>
  <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;db.properties&quot;</span>));</span><br><span class="line"><span class="type">String</span> <span class="variable">driverClass</span> <span class="operator">=</span> props.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">Class.forName(driverClass); <span class="comment">// 反射方式动态加载驱动</span></span><br></pre></td></tr></table></figure>

<p><strong>二、配置文件加载</strong>：在 Spring 框架中，IoC（控制反转）容器能够根据配置文件（如 XML 或 properties）动态加载和管理 Bean。你只需在配置文件中声明需要的类及其属性，Spring 就会自动通过反射机制实例化相应的对象并注入依赖，极大地提高了程序的可扩展性与解耦性</p>
<p>  下面以简单示例说明 Spring 通过配置文件和反射加载 Bean 的过程：</p>
<ul>
<li>将所有 XML 或 properties 配置文件加载到内存中</li>
<li>通过 Java 代码解析配置文件，提取类的全限定名（即类的完整包名路径）及其属性等配置信息</li>
<li>利用反射机制，根据提取的类名动态获取对应的 <code>Class</code> 实例，并创建对象或调用方法</li>
</ul>
<p>  配置文件（如 <code>config.properties</code>）</p>
  <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">className</span>=<span class="string">com.example.reflectdemo.TestInvoke</span></span><br><span class="line"><span class="attr">methodName</span>=<span class="string">printlnState</span></span><br></pre></td></tr></table></figure>

<p>  实体类（<code>TestInvoke.java</code>）</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInvoke</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printlnState</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;I am fine&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  配置读取工具方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getName</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\config.properties&quot;</span>);</span><br><span class="line">    properties.load(in);</span><br><span class="line">    in.close();</span><br><span class="line">    <span class="keyword">return</span> properties.getProperty(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  主方法：使用反射加载类并调用方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1. 通过配置文件读取类名和方法名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> getName(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> getName(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 加载类</span></span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取并访问方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(methodName);</span><br><span class="line">    method.setAccessible(<span class="literal">true</span>); <span class="comment">// 允许访问私有方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 实例化对象并调用方法</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">    method.invoke(instance); <span class="comment">// 输出：I am fine</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="1-能讲一讲注解的原理吗？"><a href="#1-能讲一讲注解的原理吗？" class="headerlink" title="1# 能讲一讲注解的原理吗？"></a>1# 能讲一讲注解的原理吗？</h2><p>在 Java 中，注解（Annotation）本质上是继承了 <code>java.lang.annotation.Annotation</code> 接口的特殊接口。每个注解类型在编译后都会生成一个 <code>.class</code> 文件，JVM 会根据字节码中的信息，在运行时动态创建该注解的<strong>代理对象</strong></p>
<p>当我们通过反射调用 <code>clazz.getAnnotation(MyAnnotation.class)</code> 获取注解时，返回的并不是一个普通对象，而是一个由 JVM 动态生成的代理实例。该代理实现了注解接口，并会将方法调用转发给 <code>AnnotationInvocationHandler</code> 的 <code>invoke()</code> 方法</p>
<p>在 <code>AnnotationInvocationHandler</code> 中维护了一个 <code>memberValues</code> 的 <code>Map</code>，它存储了注解的属性名与属性值。这个 Map 的内容来源于 <code>.class</code> 文件中的常量池，类加载时被 JVM 解析并缓存</p>
<p><strong>总结整个流程</strong>：</p>
<ol>
<li>注解被编写并编译后，相关信息存入 <code>.class</code> 文件的字节码结构中；</li>
<li>如果注解的保留策略为 <code>RUNTIME</code>，JVM 在加载类时会解析注解信息；</li>
<li>调用反射 API 获取注解对象时，JVM 返回的是一个动态代理实例；</li>
<li>调用注解方法（如 <code>value()</code>）时，方法会被代理对象拦截；</li>
<li>代理将调用转发至 <code>AnnotationInvocationHandler</code>，从 <code>memberValues</code> 中取出实际值并返回。</li>
</ol>
<h2 id="2-对注解解析的底层实现了解吗？"><a href="#2-对注解解析的底层实现了解吗？" class="headerlink" title="2# 对注解解析的底层实现了解吗？"></a>2# 对注解解析的底层实现了解吗？</h2><p>注解本质上是一个接口，继承自 <code>java.lang.annotation.Annotation</code>。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后，注解类型会被转换成一个普通接口的形式，并保留相关元数据到 <code>.class</code> 文件中</p>
<p>Java 中通过 <code>@Retention</code> 注解指定注解的保留策略，常见的三种为：</p>
<ul>
<li><code>SOURCE</code>：仅保留在源码中，编译后丢弃</li>
<li><code>CLASS</code>：编译时保留在 <code>.class</code> 文件中，运行时不可访问</li>
<li><code>RUNTIME</code>：编译后保留，并可通过反射访问（<strong>实际参与运行时行为</strong>）</li>
</ul>
<p>只有 <code>RUNTIME</code> 注解会被 JVM 加载并参与反射处理，JVM 会将注解元数据存储在 <code>.class</code> 文件的**属性表（Attribute Table）**中，包括：</p>
<ul>
<li><strong><code>RuntimeVisibleAnnotations</code></strong>：存储运行时可见的注解信息</li>
<li><strong><code>RuntimeInvisibleAnnotations</code></strong>：存储运行时不可见的注解信息</li>
<li><strong><code>RuntimeVisibleParameterAnnotations</code></strong>：存储方法参数上的注解信息</li>
</ul>
<p>通过反射 API 可以获取类、方法、字段等元素上的注解。反射的核心类 <code>AnnotatedElement</code>（如 <code>Class</code>、<code>Method</code>、<code>Field</code> 都实现了它）提供了访问注解的接口，如：</p>
<ul>
<li><strong><code>getAnnotation(Class&lt;T&gt; annotationClass)</code></strong>：获取指定类型的注解</li>
<li><strong><code>getAnnotations()</code></strong>：获取所有注解</li>
<li><strong><code>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</code></strong>：判断是否包含指定注解</li>
</ul>
<p>这些方法最终调用的是 JVM 的 native 方法，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">native</span> Annotation[] getDeclaredAnnotations0(<span class="type">boolean</span> publicOnly);</span><br></pre></td></tr></table></figure>

<p>这些 native 方法在类加载时解析 <code>.class</code> 文件中保存的注解字节码信息，并生成<strong>动态代理对象</strong>，用于运行时访问</p>
<p>因此，注解解析的底层实现主要依赖于 Java 的反射机制和字节码文件的存储。通过 <code>@Retention</code> 元注解可以控制注解的保留策略，当使用 <code>RetentionPolicy.RUNTIME</code> 时，可以在运行时通过反射 API 来解析注解信息。在 JVM 层面，会从字节码文件中读取注解信息，并创建注解的代理对象来获取注解的属性值</p>
<h2 id="3-注解的适用范围（Target）是什么？"><a href="#3-注解的适用范围（Target）是什么？" class="headerlink" title="3# 注解的适用范围（Target）是什么？"></a>3# 注解的适用范围（Target）是什么？</h2><p>Java 中注解的“适用范围”由 <code>@Target</code> 元注解指定，用于定义注解可以作用于哪些程序元素。常见的范围包括：</p>
<ul>
<li><code>ElementType.TYPE</code>：类、接口（包括注解类型）或枚举</li>
<li><code>ElementType.METHOD</code>：方法</li>
<li><code>ElementType.FIELD</code>：字段（包括枚举常量）</li>
<li><code>ElementType.CONSTRUCTOR</code>：构造方法</li>
<li><code>ElementType.PARAMETER</code>：参数</li>
<li><code>ElementType.LOCAL_VARIABLE</code>：局部变量</li>
<li><code>ElementType.ANNOTATION_TYPE</code>：注解类型本身</li>
<li><code>ElementType.PACKAGE</code>：包</li>
<li><code>ElementType.TYPE_USE</code>：任何使用类型的地方（如泛型、强转、注解类型参数等）</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个注解就只能用于类或方法</p>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="1-介绍一下-Java-的异常"><a href="#1-介绍一下-Java-的异常" class="headerlink" title="1# 介绍一下 Java 的异常"></a>1# 介绍一下 Java 的异常</h2><img src="https://cdn.xiaolincoding.com//picgo/1720683900898-1d0ce69d-4b5d-41a6-a5df-022e42f8f4c5.webp" alt="Java 异常类层次结构图" style="zoom:50%;" />

<p>Java 的异常体系是围绕 <code>Throwable</code> 类及其子类构建的。<code>Throwable</code> 有两个直接子类：<code>Error</code> 和 <code>Exception</code>，它们代表了两类不同性质的问题：</p>
<ol>
<li><p><strong>Error（错误）</strong>：表示 JVM 运行时出现的严重错误，通常是系统级的问题，程序无法控制和恢复。常见的错误包括 <code>OutOfMemoryError</code>、<code>StackOverflowError</code> 等，这类错误 <strong>不建议</strong> 程序捕获或处理，因为处理后也难以恢复</p>
</li>
<li><p><strong>Exception（异常）</strong>：表示程序本身可以<strong>感知并处理</strong>的问题，又细分为：</p>
<ul>
<li><p><strong>受检查异常</strong>：编译器会强制检查，必须显式处理（try-catch）或声明抛出（throws）。例如 <code>IOException</code>、<code>SQLException</code>、<code>ClassNotFoundException</code> 等，这些异常多与外部资源或环境因素有关（如文件、数据库、网络），处理它们可以提升程序的健壮性</p>
</li>
<li><p><strong>非受检查异常</strong>：<code>RuntimeException</code> 及其子类，编译器<strong>不会强制检查</strong>，通常由程序逻辑错误引起。例如 <code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code>、<code>ArithmeticException</code> 等。虽然不是强制处理，但良好的程序设计应尽量避免这类异常</p>
</li>
</ul>
</li>
</ol>
<h2 id="2-Java-的异常处理方式有哪些？"><a href="#2-Java-的异常处理方式有哪些？" class="headerlink" title="2# Java 的异常处理方式有哪些？"></a>2# Java 的异常处理方式有哪些？</h2><p>Java 提供了一套完整的异常处理机制，用于捕获和处理运行时可能出现的异常，以增强程序的健壮性和可维护性。主要包括以下几种方式：</p>
<p><strong>一、<code>try-catch-finally</code> 语句块</strong>：用于捕获并处理代码执行过程中可能抛出的异常</p>
<ul>
<li><code>try</code> 块包含可能抛出异常的代码</li>
<li><code>catch</code> 块用于捕获并处理特定类型的异常</li>
<li><code>finally</code> 块（可选）用于释放资源或执行善后操作，无论是否发生异常都会执行，常用于资源释放（如关闭文件流、数据库连接等）</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType1 e1) &#123;</span><br><span class="line">    <span class="comment">// 处理异常类型1</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType2 e2) &#123;</span><br><span class="line">    <span class="comment">// 处理异常类型2</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论是否发生异常，都会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二、<code>throw</code> 语句</strong>：用于<strong>手动抛出</strong>一个异常实例，抛出的对象必须是 <code>Throwable</code> 类型或其子类，通常用于业务逻辑判断，如参数校验失败时主动抛出异常</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>三、<code>throws</code> 关键字</strong>：用于在<strong>方法签名</strong>中声明该方法可能抛出的异常类型，通知调用者需要处理这些异常，如果是受检异常，必须显式处理或继续声明抛出</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 可能抛出 IOException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-抛出异常为什么不用-throws？"><a href="#3-抛出异常为什么不用-throws？" class="headerlink" title="3# 抛出异常为什么不用 throws？"></a>3# 抛出异常为什么不用 throws？</h2><p>在 Java 中，如果异常属于<strong>非受检异常</strong>，或者在方法内部已经<strong>被捕获并处理</strong>，那么就不需要在方法签名中使用 <code>throws</code> 关键字</p>
<ol>
<li><strong>非受检异常</strong>：非检查异常是指继承自 <code>RuntimeException</code> 或 <code>Error</code> 的异常类型。编译器<strong>不会强制要求</strong>开发者显式地处理这些异常，也不要求在方法签名中声明它们。包括 <code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code>、<code>IllegalArgumentException</code>、<code>ArithmeticException</code> 等，由于这类异常往往是由程序逻辑错误引起的，Java 更倾向于通过代码修复，而不是强制捕获或声明</li>
<li><strong>异常已被捕获并处理</strong>：如果在方法内部使用了 <code>try-catch</code> 块对异常进行了处理，那么该异常就<strong>不会继续向外抛出</strong>，因此也不需要在方法签名中使用 <code>throws</code></li>
</ol>
<h2 id="4-try-catch-中的语句运行情况"><a href="#4-try-catch-中的语句运行情况" class="headerlink" title="4# try-catch 中的语句运行情况"></a>4# try-catch 中的语句运行情况</h2><p>在 Java 中，<code>try</code> 块中的代码会按顺序执行：</p>
<ul>
<li>如果 <code>try</code> 块中<strong>未发生异常</strong>，则跳过所有 <code>catch</code> 块，<strong>直接执行 <code>finally</code>（如果有）</strong>，然后继续执行后续代码</li>
<li>如果 <code>try</code> 块中<strong>发生了异常</strong>，Java 会依次检查每个 <code>catch</code> 块，看是否有匹配的异常类型：<ul>
<li>如果匹配成功，对应的 <code>catch</code> 块会执行，然后进入 <code>finally</code>（如果有）</li>
<li>如果没有匹配的 <code>catch</code>，异常将<strong>向上抛出</strong>，由调用者处理，<code>finally</code> 块仍会执行</li>
</ul>
</li>
<li><strong><code>finally</code> 块始终会执行</strong>，无论是否发生异常，除非 JVM 退出或程序崩溃</li>
</ul>
<h2 id="5-try-return-“a”-finally-return-“b”-返回什么？"><a href="#5-try-return-“a”-finally-return-“b”-返回什么？" class="headerlink" title="5# try { return “a” } finally { return “b” } 返回什么？"></a>5# try { return “a” } finally { return “b” } 返回什么？</h2><p>该语句的返回值是 <code>&quot;b&quot;</code></p>
<p>在 Java 中，如果 <code>try</code> 和 <code>finally</code> 中都包含 <code>return</code> 语句，<strong><code>finally</code> 中的 <code>return</code> 会覆盖 <code>try</code> 中的返回值</strong>。即使 <code>try</code> 中已经准备好返回 <code>&quot;a&quot;</code>，在执行 <code>finally</code> 时仍会被 <code>&quot;b&quot;</code> 替代</p>
<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><h2 id="1-与-equals-有什么区别？"><a href="#1-与-equals-有什么区别？" class="headerlink" title="1# &#x3D;&#x3D; 与 equals() 有什么区别？"></a>1# &#x3D;&#x3D; 与 equals() 有什么区别？</h2><p>在 Java 中，<code>==</code> 和 <code>equals()</code> 都可用于比较两个对象，但它们的行为有本质上的不同：</p>
<ul>
<li><p><strong><code>==</code></strong>：比较的是引用是否相等</p>
<ul>
<li><p><code>==</code> 判断两个对象<strong>是否指向同一块内存地址</strong>，即它们是否是<strong>同一个对象的引用</strong></p>
</li>
<li><p>对于基本数据类型，<code>==</code> 比较的是<strong>数值本身是否相等</strong></p>
</li>
<li><p>对于引用类型（如字符串、对象等），<code>==</code> 比较的是两个引用是否指向<strong>同一对象</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(a == b); <span class="comment">// false：不同对象，地址不同</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>equals()</code></strong>：比较的是内容是否相等</p>
<ul>
<li><p><code>equals()</code> 是 <code>Object</code> 类中的方法，默认行为与 <code>==</code> 相同，即<strong>比较引用地址</strong></p>
</li>
<li><p>但很多类（如 <code>String</code>、<code>Integer</code>、<code>List</code> 等）都<strong>重写了 <code>equals()</code> 方法</strong>，改为比较对象的<strong>内容</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(a.equals(b)); <span class="comment">// true：内容相同</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>需要注意</strong>：字符串是 Java 中的特殊对象，字面量字符串会被放入<strong>字符串常量池</strong>，如果你写 <code>String s1 = &quot;abc&quot;; String s2 = &quot;abc&quot;;</code>，则 <code>s1 == s2</code> 会返回 <code>true</code>，因为它们引用的是常量池中的同一个对象</p>
<h2 id="2-hashCode-和-equals-方法有什么关系？"><a href="#2-hashCode-和-equals-方法有什么关系？" class="headerlink" title="2# hashCode() 和 equals() 方法有什么关系？"></a>2# hashCode() 和 equals() 方法有什么关系？</h2><p>在 Java 中，对于重写 <code>equals()</code> 方法的类，通常也需要重写 <code>hashCode()</code> 方法，并且需要遵循以下规定：</p>
<ul>
<li><strong>一致性</strong>：如果两个对象使用 <code>equals()</code> 方法比较结果为 <code>true</code>，那么它们的 <code>hashCode()</code> 的值必须相同。也就是说，如果 <code>obj1.equals(obj2)</code> 返回 <code>true</code>，那么 <code>obj1.hashCode()</code> 必须等于 <code>obj2.hashCode()</code></li>
<li><strong>非一致性</strong>：如果两个对象的 <code>hashCode()</code> 的值相同，它们使用 <code>equals()</code> 方法比较的结果不一定为 <code>true</code>。即 <code>obj1.hashCode() == obj2.hashCode()</code> 时，<code>obj1.equals(obj2)</code> 可能为 <code>false</code>，这种情况称为哈希冲突</li>
</ul>
<p><code>hashCode()</code> 和 <code>equals()</code> 方法是紧密相关的，重写 <code>equals()</code> 方法时必须重写 <code>hashCode()</code> 方法，以保证在使用哈希表等数据结构时，对象的相等性判断和存储查找操作能够正常工作。而重写 <code>hashCode()</code> 方法时，需要确保相等的对象具有相同的哈希码，但相同哈希码的对象不一定相等</p>
<h2 id="3-String、StringBuilder、StringBuffer-的区别和联系"><a href="#3-String、StringBuilder、StringBuffer-的区别和联系" class="headerlink" title="3# String、StringBuilder、StringBuffer 的区别和联系"></a>3# String、StringBuilder、StringBuffer 的区别和联系</h2><ol>
<li><p><strong>可变性</strong>： <code>String</code> 是不可变的（Immutable），一旦创建，内容无法修改，每次修改都会生成一个新的对象。<code>StringBuilder</code> 和 <code>StringBuffer</code> 是可变的（Mutable），可以直接对字符串内容进行修改而不会创建新对象</p>
</li>
<li><p>**线程安全性 **：<code>String</code> 因为不可变，天然线程安全。<code>StringBuilder</code> 不是线程安全的，适用于单线程环境。<code>StringBuffer</code> 是线程安全的，其方法通过 <code>synchronized</code> 关键字实现同步，适用于多线程环境</p>
</li>
<li><p>**性能 **：<code>String</code> 性能最低，尤其是在频繁修改字符串时会生成大量临时对象，增加内存开销和垃圾回收压力。<code>StringBuilder</code> 性能最高，因为它没有线程安全的开销，适合单线程下的字符串操作。<code>StringBuffer</code> 性能略低于 <code>StringBuilder</code>，因为它的线程安全机制引入了同步开销</p>
</li>
<li><p>**使用场景 **：如果字符串内容固定或不常变化，优先使用 <code>String</code>。如果需要频繁修改字符串且在单线程环境下，使用 <code>StringBuilder</code>。如果需要频繁修改字符串且在多线程环境下，使用 <code>StringBuffer</code></p>
</li>
</ol>
<p>对比总结如下：</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>String</strong></th>
<th><strong>StringBuilder</strong></th>
<th><strong>StringBuffer</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>不可变性</strong></td>
<td>不可变</td>
<td>可变</td>
<td>可变</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>是（因不可变）</td>
<td>否</td>
<td>是（同步方法）</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>低（频繁修改时）</td>
<td>高（单线程）</td>
<td>中（多线程安全）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>静态字符串</td>
<td>单线程动态字符串</td>
<td>多线程动态字符串</td>
</tr>
</tbody></table>
<h1 id="Java-新特性"><a href="#Java-新特性" class="headerlink" title="Java 新特性"></a>Java 新特性</h1><h2 id="1-Java-8-有什么新特性？"><a href="#1-Java-8-有什么新特性？" class="headerlink" title="1# Java 8 有什么新特性？"></a>1# Java 8 有什么新特性？</h2><p>下面是 Java 8 主要新特性的整理表格，包含关键改进和示例说明：</p>
<table>
<thead>
<tr>
<th><strong>特性名称</strong></th>
<th><strong>描述</strong></th>
<th><strong>示例或说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Lambda 表达式</strong></td>
<td>简化匿名内部类，支持函数式编程</td>
<td><code>(a, b) -&gt; a + b</code> 代替匿名类实现接口</td>
</tr>
<tr>
<td><strong>函数式接口</strong></td>
<td>仅含一个抽象方法的接口，可用 <code>@FunctionalInterface</code> 注解标记</td>
<td><code>Runnable</code>, <code>Comparator</code> 或自定义接口 <code>@FunctionalInterface interface MyFunc { void run(); }</code></td>
</tr>
<tr>
<td><strong>Stream API</strong></td>
<td>提供链式操作处理集合数据，支持并行处理</td>
<td><code>list.stream().filter(x -&gt; x &gt; 0).collect(Collectors.toList())</code></td>
</tr>
<tr>
<td><strong>Optional 类</strong></td>
<td>封装可能为 <code>null</code> 的对象，减少空指针异常</td>
<td><code>Optional.ofNullable(value).orElse(&quot;default&quot;)</code></td>
</tr>
<tr>
<td><strong>方法引用</strong></td>
<td>简化 Lambda 表达式，直接引用现有方法</td>
<td><code>System.out::println</code> 等价于 <code>x -&gt; System.out.println(x)</code></td>
</tr>
<tr>
<td><strong>接口的默认方法与静态方法</strong></td>
<td>接口可定义默认实现和静态方法，增强扩展性</td>
<td><code>interface A { default void print() { System.out.println(&quot;默认方法&quot;); } }</code></td>
</tr>
<tr>
<td><strong>并行数组排序</strong></td>
<td>使用多线程加速数组排序</td>
<td><code>Arrays.parallelSort(array)</code></td>
</tr>
<tr>
<td><strong>重复注解</strong></td>
<td>允许同一位置多次使用相同注解</td>
<td><code>@Repeatable</code> 注解配合容器注解使用</td>
</tr>
<tr>
<td><strong>类型注解</strong></td>
<td>注解可应用于更多位置（如泛型、异常等）</td>
<td><code>List&lt;@NonNull String&gt; list</code></td>
</tr>
<tr>
<td><strong>CompletableFuture</strong></td>
<td>增强异步编程能力，支持链式调用和组合操作</td>
<td><code>CompletableFuture.supplyAsync(() -&gt; &quot;result&quot;).thenAccept(System.out::println)</code></td>
</tr>
</tbody></table>
<h2 id="2-Lambda-表达式了解吗？"><a href="#2-Lambda-表达式了解吗？" class="headerlink" title="2# Lambda 表达式了解吗？"></a>2# Lambda 表达式了解吗？</h2><p>Lambda 表达式是一种简洁的语法，用于创建匿名函数，主要用于简化函数式接口（只有一个抽象方法的接口）的使用。其基本语法有以下两种形式：</p>
<ul>
<li><strong><code>(parameters) -&gt; expression</code></strong>：当 Lambda 体只有一个表达式时使用，表达式的结果会作为返回值</li>
<li><strong><code>(parameters) -&gt; { statements; }</code></strong>：当 Lambda 体包含多条语句时，需要使用大括号将语句括起来，若有返回值则需要使用 <code>return</code> 语句</li>
</ul>
<p>传统的匿名内部类实现方式代码较为冗长，<strong>而 Lambda 表达式可以用更简洁的语法实现相同的功能</strong>。例如，使用匿名内部类实现 <code>Runnable</code> 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousClassExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Running using anonymous class&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Lambda 表达式实现相同功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;Running using lambda expression&quot;</span>));</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Lambda 表达式能够更清晰地表达代码的意图</strong>，尤其是在处理集合操作时，如过滤、映射等。例如，过滤出列表中所有偶数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadabilityExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式结合 Stream API 过滤偶数</span></span><br><span class="line">        List&lt;Integer&gt; evenNumbers = numbers.stream()</span><br><span class="line">                                           .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                                           .collect(Collectors.toList());</span><br><span class="line">        System.out.println(evenNumbers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Lambda 表达式使得 Java 支持函数式编程范式</strong>，允许将函数作为参数传递，从而可以编写更灵活、可复用的代码。例如，定义一个通用的计算函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionalProgrammingExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">operate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, Calculator calculator)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> calculator.calculate(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式传递加法函数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> operate(<span class="number">3</span>, <span class="number">5</span>, (x, y) -&gt; x + y);</span><br><span class="line">        System.out.println(<span class="string">&quot;Sum: &quot;</span> + sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式传递乘法函数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> operate(<span class="number">3</span>, <span class="number">5</span>, (x, y) -&gt; x * y);</span><br><span class="line">        System.out.println(<span class="string">&quot;Product: &quot;</span> + product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然 Lambda 表达式优点蛮多的，不过也有一些缺点，比如会增加调试困难，因为 Lambda 表达式是匿名的，在调试时很难定位具体是哪个 Lambda 表达式出现了问题。尤其是当 Lambda 表达式嵌套使用或者比较复杂时，调试难度会进一步增加</p>
<h2 id="3-介绍一下-Stream-API"><a href="#3-介绍一下-Stream-API" class="headerlink" title="3# 介绍一下 Stream API"></a>3# 介绍一下 Stream API</h2><p>Java 8 引入了 Stream API，它提供了一种高效且易于使用的数据处理方式，特别适合集合对象的操作，如过滤、映射、排序等。Stream API 不仅可以提高代码的可读性和简洁性，还能利用多核处理器的优势进行并行处理</p>
<p><strong>案例1：过滤并收集满足条件的元素</strong></p>
<p><strong>问题场景</strong>：从一个列表中筛选出所有长度大于 3 的字符串，并收集到一个新的列表中</p>
<p><strong>没有 Stream API 的做法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; originalList = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;fig&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;kiwi&quot;</span>);</span><br><span class="line">List&lt;String&gt; filteredList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String item : originalList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.length() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        filteredList.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码需要显式地创建一个新的 <code>ArrayList</code>，并通过循环遍历原列表，手动检查每个元素是否满足条件，然后添加到新列表中</p>
<p><strong>使用 Stream API 的做法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; originalList = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;fig&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;kiwi&quot;</span>);</span><br><span class="line">List&lt;String&gt; filteredList = originalList.stream()</span><br><span class="line">                                        .filter(s -&gt; s.length() &gt; <span class="number">3</span>)</span><br><span class="line">                                        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>这里，我们直接在原始列表上调用 <code>stream()</code> 方法创建了一个流，使用 <code>filter()</code> 中间操作筛选出长度大于 3 的字符串，最后使用 <code>collect(Collectors.toList())</code> 终端操作将结果收集到一个新的列表中。代码更加简洁明了，逻辑一目了然</p>
<p><strong>案例2：计算列表中所有数字的总和</strong></p>
<p><strong>问题场景</strong>：计算一个数字列表中所有元素的总和</p>
<p><strong>没有 Stream API 的做法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Integer number : numbers) &#123;</span><br><span class="line">    sum += number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个传统的 for-each 循环遍历列表中的每一个元素，累加它们的值来计算总和</p>
<p><strong>使用 Stream API 的做法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers.stream()</span><br><span class="line">                 .mapToInt(Integer::intValue)</span><br><span class="line">                 .sum();</span><br></pre></td></tr></table></figure>

<p>通过 Stream API，我们可以先使用 <code>mapToInt()</code> 将 Integer 流转换为 IntStream（这是为了高效处理基本类型），然后直接调用 <code>sum()</code> 方法来计算总和，极大地简化了代码</p>
<h2 id="4-Stream-流的并行-API-是什么？"><a href="#4-Stream-流的并行-API-是什么？" class="headerlink" title="4# Stream 流的并行 API 是什么？"></a>4# Stream 流的并行 API 是什么？</h2><p><strong>是 ParallelStream</strong></p>
<p>并行流（ParallelStream）就是将源数据分为多个子流对象进行多线程操作，然后将处理的结果再汇总为一个流对象，底层是使用通用的 fork&#x2F;join 池来实现，即将一个任务拆分成多个 “小任务” 并行计算，再把多个 “小任务” 的结果合并成总的计算结果</p>
<p>Stream 串行流与并行流的主要区别：</p>
<p> <img src="https://cdn.xiaolincoding.com//picgo/1716365522454-4b56a07e-9b54-4cbb-9832-26b099fc35cd.png" alt="Stream 串行流与并行流的主要区别"></p>
<p>对 CPU 密集型的任务来说，并行流使用 ForkJoinPool 线程池，为每个 CPU 分配一个任务，这是非常有效率的，但是如果任务不是 CPU 密集的，而是 IO 密集的，并且任务数相对线程数比较大，那么直接用 ParallelStream 并不是很好的选择</p>
<h2 id="5-CompletableFuture-怎么用的？"><a href="#5-CompletableFuture-怎么用的？" class="headerlink" title="5# CompletableFuture 怎么用的？"></a>5# CompletableFuture 怎么用的？</h2><p><code>CompletableFuture</code> 是由 Java 8 引入的，在 Java 8 之前我们一般通过 Future 实现异步</p>
<ul>
<li><code>Future</code> 用于表示异步计算的结果，只能通过阻塞或者轮询的方式获取结果，而且不支持设置回调方法，Java 8 之前若要设置回调一般会使用 guava 的 <code>ListenableFuture</code> ，回调的引入又会导致臭名昭著的回调地狱</li>
<li><code>CompletableFuture</code> 对 <code>Future</code> 进行了扩展，可以通过设置回调的方式处理计算结果，同时也支持组合操作，支持进一步的编排，同时一定程度解决了回调地狱的问题</li>
</ul>
<p><code>Future</code>（<code>ListenableFuture</code>）的实现（回调地狱）如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="type">ListeningExecutorService</span> <span class="variable">guavaExecutor</span> <span class="operator">=</span> MoreExecutors.listeningDecorator(executor);</span><br><span class="line">ListenableFuture&lt;String&gt; future1 = guavaExecutor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//step 1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step1 result&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">ListenableFuture&lt;String&gt; future2 = guavaExecutor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//step 2</span></span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step2 result&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">ListenableFuture&lt;List&lt;String&gt;&gt; future1And2 = Futures.allAsList(future1, future2);</span><br><span class="line">Futures.addCallback(future1And2, <span class="keyword">new</span> <span class="title class_">FutureCallback</span>&lt;List&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(List&lt;String&gt; result)</span> &#123;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        ListenableFuture&lt;String&gt; future3 = guavaExecutor.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行step 3&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;step3 result&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        Futures.addCallback(future3, <span class="keyword">new</span> <span class="title class_">FutureCallback</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String result)</span> &#123;</span><br><span class="line">                System.out.println(result);</span><br><span class="line">            &#125;        </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, guavaExecutor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">    &#125;&#125;, guavaExecutor);</span><br></pre></td></tr></table></figure>

<p><code>CompletableFuture</code> 的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step1 result&quot;</span>;</span><br><span class="line">&#125;, executor);</span><br><span class="line">CompletableFuture&lt;String&gt; cf2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step2 result&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">cf1.thenCombine(cf2, (result1, result2) -&gt; &#123;</span><br><span class="line">    System.out.println(result1 + <span class="string">&quot; , &quot;</span> + result2);</span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 3&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step3 result&quot;</span>;</span><br><span class="line">&#125;).thenAccept(result3 -&gt; System.out.println(result3));</span><br></pre></td></tr></table></figure>

<p>显然，<code>CompletableFuture</code> 的实现更为简洁，可读性更好</p>
<img src="https://cdn.xiaolincoding.com//picgo/1713777049912-2268a5fc-c7f1-477d-8c9c-310aae18f51a.png" alt="CompletableFuture" style="zoom:50%;" />

<p><code>CompletableFuture</code> 实现了两个接口：<code>Future</code>、<code>CompletionStage</code></p>
<ul>
<li><code>Future</code> 表示异步计算的结果，<code>CompletionStage</code> 用于表示异步执行过程中的一个步骤（Stage），这个步骤可能是由另外一个 <code>CompletionStage</code> 触发的，随着当前步骤的完成，也可能会触发其他一系列 <code>CompletionStage</code> 的执行</li>
<li>从而我们可以根据实际业务对这些步骤进行多样化的编排组合，<code>CompletionStage</code> 接口正是定义了这样的能力，我们可以通过其提供的 <code>thenAppy</code>、<code>thenCompose</code> 等函数式编程方法来组合编排这些步骤</li>
</ul>
<h2 id="6-Java-21-新特性知道哪些？"><a href="#6-Java-21-新特性知道哪些？" class="headerlink" title="6# Java 21 新特性知道哪些？"></a>6# Java 21 新特性知道哪些？</h2><p><strong>新语言特性</strong>：</p>
<ol>
<li><strong>Switch 语句的模式匹配</strong>：该功能在 Java 21 中也得到了增强。它允许在 <code>switch</code> 的 <code>case</code> 标签中使用模式匹配，使操作更加灵活和类型安全，减少了样板代码和潜在错误。例如：对于不同类型的账户类，可以在 <code>switch</code> 语句中直接根据账户类型的模式来获取相应的余额，如 <code>case savingsAccount sa -&gt; result = sa.getSavings();</code></li>
<li><strong>数组模式</strong>：将模式匹配扩展到数组中，使开发者能够在条件语句中更高效地解构和检查数组内容。例如：<code>if (arr instanceof int[] {1, 2, 3})</code>，可以直接判断数组 <code>arr</code> 是否匹配指定的模式</li>
<li><strong>字符串模板（预览版）</strong>：提供了一种更可读、更易维护的方式来构建复杂字符串，支持在字符串字面量中直接嵌入表达式。例如，以前可能需要使用 <code>&quot;hello &quot; + name + &quot;, welcome to the geeksforgeeks!&quot;</code> 这样的方式来拼接字符串，在 Java 21 中可以使用  <code>hello {name}, welcome to the geeksforgeeks!</code> 这种更简洁的写法</li>
</ol>
<p><strong>新并发特性方面</strong>：</p>
<ol>
<li><strong>虚拟线程</strong>：这是 Java 21 引入的一种轻量级并发的新选择。它通过共享堆栈的方式，大大降低了内存消耗，同时提高了应用程序的吞吐量和响应速度。可以使用静态构建方法、构建器或 <code>ExecutorService</code> 来创建和使用虚拟线程</li>
<li><strong>Scoped Values（范围值）</strong>：提供了一种在线程间共享不可变数据的新方式，避免使用传统的线程局部存储，促进了更好的封装性和线程安全，可用于在不通过方法参数传递的情况下，传递上下文信息，如用户会话或配置设置</li>
</ol>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><h2 id="1-怎么把一个对象从一个-JVM-转移到另一个-JVM"><a href="#1-怎么把一个对象从一个-JVM-转移到另一个-JVM" class="headerlink" title="1# 怎么把一个对象从一个 JVM 转移到另一个 JVM"></a>1# 怎么把一个对象从一个 JVM 转移到另一个 JVM</h2><ol>
<li><strong>使用序列化和反序列化</strong>：将对象序列化为字节流，并将其发送到另一个 JVM，然后在另一个 JVM 中反序列化字节流恢复对象。这可以通过 Java 的 <code>ObjectOutputStream</code> 和 <code>ObjectInputStream</code> 来实现。</li>
<li><strong>使用消息传递机制</strong>：利用消息传递机制，比如使用消息队列（如 RabbitMQ、Kafka）或者通过网络套接字进行通信，将对象从一个 JVM 发送到另一个。这需要自定义协议来序列化对象并在另一个 JVM 中反序列化</li>
<li><strong>使用远程方法调用（RPC）</strong>：可以使用远程方法调用框架，如 gRPC，来实现对象在不同 JVM 之间的传输。远程方法调用可以让你在分布式系统中调用远程 JVM 上的对象的方法</li>
<li><strong>使用共享数据库或缓存</strong>：将对象存储在共享数据库（如 MySQL、PostgreSQL）或共享缓存（如 Redis）中，让不同的 JVM 可以访问这些共享数据。这种方法适用于需要共享数据但不需要直接传输对象的场景</li>
</ol>
<h2 id="2-让你自己实现序列化和反序列化，你会怎么做"><a href="#2-让你自己实现序列化和反序列化，你会怎么做" class="headerlink" title="2# 让你自己实现序列化和反序列化，你会怎么做?"></a>2# 让你自己实现序列化和反序列化，你会怎么做?</h2><p>Java 默认的序列化虽然实现方便，但却存在安全漏洞、不跨语言以及性能差等缺陷：</p>
<ol>
<li><strong>无法跨语言</strong>： Java 序列化目前只适用基于 Java 语言实现的框架，其它语言大部分都没有使用 Java 的序列化框架，也没有实现 Java 序列化这套协议。因此，如果是两个基于不同语言编写的应用程序相互通信，则无法实现两个应用服务之间传输对象的序列化与反序列化</li>
<li><strong>容易被攻击</strong>：Java 序列化是不安全的，我们知道对象是通过在 <code>ObjectInputStream</code> 上调用 <code>readObject()</code> 方法进行反序列化的，这个方法其实是一个神奇的构造器，它可以将类路径上几乎所有实现了 <code>Serializable</code> 接口的对象都实例化。这也就意味着，在反序列化字节流的过程中，该方法可以执行任意类型的代码，这是非常危险的</li>
<li><strong>序列化后的流太大</strong>：序列化后的二进制流大小能体现序列化的性能。序列化后的二进制数组越大，占用的存储空间就越多，存储硬件的成本就越高。如果我们是进行网络传输，则占用的带宽就更多，这时就会影响到系统的吞吐量</li>
</ol>
<p>我会考虑用主流序列化框架，比如 FastJson、Protobuf 来替代 Java 序列化</p>
<p>如果追求性能的话，Protobuf 序列化框架会比较合适，Protobuf 的这种数据存储格式，不仅压缩存储数据的效果好， 在编码和解码的性能方面也很高效。Protobuf 的编码和解码过程结合 <code>.proto</code> 文件格式，加上 Protocol Buffer 独特的编码格式，只需要简单的数据运算以及位移等操作就可以完成编码与解码。可以说 Protobuf 的整体性能非常优秀</p>
<h2 id="3-将对象转为二进制字节流具体怎么实现"><a href="#3-将对象转为二进制字节流具体怎么实现" class="headerlink" title="3# 将对象转为二进制字节流具体怎么实现?"></a>3# 将对象转为二进制字节流具体怎么实现?</h2><p>其实，像序列化和反序列化，无论这些可逆操作是什么机制，都会有对应的<strong>处理和解析协议</strong>，例如加密和解密，TCP的粘包和拆包，序列化机制是通过序列化协议来进行处理的，和 <code>.class</code> 文件类似，它其实是定义了序列化后的字节流格式，然后对此格式进行操作，生成符合格式的字节流或者将字节流解析成对象</p>
<p>在 Java 中通过序列化对象流来完成序列化和反序列化：</p>
<ul>
<li><code>ObjectOutputStream</code>：通过 <code>writeObject()</code> 方法做序列化操作</li>
<li><code>ObjectInputStrean</code>：通过 <code>readObject()</code> 方法做反序列化操作</li>
</ul>
<p>只有实现了 <code>Serializable</code> 或 <code>Externalizable</code> 接口的类的对象才能被序列化，否则抛出异常</p>
<p><strong>一、实现对象序列化</strong></p>
<ul>
<li>让类实现 <code>Serializable</code> 接口：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// class code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建输出流并写入对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.ser&quot;</span>);</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOut);</span><br><span class="line">    out.writeObject(obj);</span><br><span class="line">    out.close();</span><br><span class="line">    fileOut.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二、实现对象反序列化</strong></p>
<ul>
<li>创建输入流并读取对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">newObj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>);</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileIn);</span><br><span class="line">    newObj = (MyClass) in.readObject();</span><br><span class="line">    in.close();</span><br><span class="line">    fileIn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上步骤，对象 <code>obj</code> 会被序列化并写入到文件 <code>object.ser</code> 中，然后通过反序列化操作，从文件中读取字节流并恢复为对象 <code>newObj</code>。这种方式可以方便地将对象转换为字节流用于持久化存储、网络传输等操作。需要注意的是，要确保类实现了 <code>Serializable</code> 接口，并且所有成员变量都是 <code>Serializable</code> 的才能被正确序列化</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="1-volatile-和-sychronized-如何实现单例模式"><a href="#1-volatile-和-sychronized-如何实现单例模式" class="headerlink" title="1# volatile 和 sychronized 如何实现单例模式"></a>1# volatile 和 sychronized 如何实现单例模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleTon</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止指令重排，保证可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">SingleTon</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleTon</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleTon <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingleTon.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">SingleTon</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>volatile</code> 的作用：</p>
<ol>
<li><strong>保证可见性</strong>：多个线程访问 <code>instance</code> 时，能看到最新的值</li>
<li><strong>禁止指令重排序</strong>：确保对象在完全构造前，其他线程不会看到它的引用，避免出现 “半初始化” 对象</li>
</ol>
<p>双重检查锁定（DCL）原理：</p>
<ul>
<li><strong>第一次检查</strong>：避免进入同步块（提升性能）</li>
<li><strong>同步块内部再次检查</strong>：保证线程安全，仅在首次创建对象时同步</li>
</ul>
<h2 id="2-代理模式和适配器模式有什么区别？"><a href="#2-代理模式和适配器模式有什么区别？" class="headerlink" title="2# 代理模式和适配器模式有什么区别？"></a>2# 代理模式和适配器模式有什么区别？</h2><ol>
<li><strong>目的不同</strong>：代理模式主要关注控制对对象的访问，而适配器模式则用于接口转换，使不兼容的类能够一起工作</li>
<li><strong>结构不同</strong>：代理模式一般包含抽象主题、真实主题和代理三个角色，适配器模式包含目标接口、适配器和被适配者三个角色</li>
<li><strong>应用场景不同</strong>：代理模式常用于添加额外功能或控制对对象的访问，适配器模式常用于让不兼容的接口协同工作</li>
</ol>
<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="1-Java-怎么实现网络-IO-高并发编程？"><a href="#1-Java-怎么实现网络-IO-高并发编程？" class="headerlink" title="1# Java 怎么实现网络 IO 高并发编程？"></a>1# Java 怎么实现网络 IO 高并发编程？</h2><p><strong>可以用 Java NIO</strong>，是一种同步非阻塞的 IO 模型，也是 IO 多路复用的基础</p>
<p>传统的 BIO 里面 <code>socket.read()</code>，如果 TCP RecvBuffer 里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据， 如果使用 BIO 要想要并发处理多个客户端的 IO，那么会使用多线程模式，一个线程专门处理一个客户端 IO，这种模式随着客户端越来越多，所需要创建的线程也越来越多，会急剧消耗系统的性能</p>
<img src="https://cdn.xiaolincoding.com//picgo/image-20240820112641716.png" alt="BIO" style="zoom:50%;" />

<p>NIO 是基于 IO 多路复用实现的，它可以只用一个线程处理多个客户端 IO，如果你需要同时管理成千上万的连接，但是每个连接只发送少量数据，例如一个聊天服务器，用NIO实现会更好一些</p>
<img src="https://cdn.xiaolincoding.com//picgo/image-20240820112656259.png" alt="NIO" style="zoom:50%;" />



<h2 id="2-BIO、NIO、AIO区别是什么？"><a href="#2-BIO、NIO、AIO区别是什么？" class="headerlink" title="2# BIO、NIO、AIO区别是什么？"></a>2# BIO、NIO、AIO区别是什么？</h2><table>
<thead>
<tr>
<th>模型</th>
<th>特点</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>BIO</strong></td>
<td>同步阻塞，每个连接一个线程，简单但性能差</td>
<td>适用于连接数少、对实时性要求不高的系统</td>
</tr>
<tr>
<td><strong>NIO</strong></td>
<td>同步非阻塞，使用 <code>Selector</code> 管理多个通道，一个线程可处理多个连接</td>
<td>适用于高并发、大量连接的服务端程序</td>
</tr>
<tr>
<td><strong>AIO</strong></td>
<td>异步非阻塞，基于回调通知，IO 操作完全由系统异步完成</td>
<td>适用于连接数非常多、IO 操作频繁的高性能场景</td>
</tr>
</tbody></table>
<ul>
<li><strong>BIO（Blocking IO）</strong>：传统 <code>java.io</code>，线程阻塞直至完成读写操作，编程简单但不适合高并发</li>
<li><strong>NIO（Non-blocking IO）</strong>：Java 1.4 引入，引入 <code>Channel</code>、<code>Selector</code>、<code>Buffer</code>，可以实现单线程处理多连接</li>
<li><strong>AIO（Asynchronous IO）</strong>：Java 1.7 引入，真正的异步非阻塞，系统完成 IO 后自动回调通知业务线程处理</li>
</ul>
<h2 id="3-NIO-是怎么实现的？"><a href="#3-NIO-是怎么实现的？" class="headerlink" title="3# NIO 是怎么实现的？"></a>3# NIO 是怎么实现的？</h2><p>NIO 是一种<strong>同步非阻塞</strong>的 IO 模型 </p>
<p>同步是指线程不断轮询 IO 事件是否就绪，同步的核心是 Selector（IO多路复用），Selector 代替了线程本身轮询 IO 事件，避免了阻塞，同时减少了不必要的线程消耗；非阻塞是指线程在等待 IO 的时候，可以同时做其他任务，非阻塞的核心就是通道和缓冲区，当 IO 事件就绪时，可以通过写到缓冲区，保证 IO 的成功，而无需线程阻塞式地等待</p>
<p>NIO 通常由一个专门的线程负责监听所有 IO 事件，并进行分发处理。它基于事件驱动机制：当感兴趣的事件（如连接就绪、数据可读）发生时，线程被唤醒进行处理，而不是长时间阻塞等待</p>
<p><strong>NIO 的核心组件</strong>：</p>
<ul>
<li><p><strong>Channel（通道）</strong><br> 类似传统 IO 的流，但既可读也可写，支持非阻塞模式</p>
</li>
<li><p><strong>Buffer（缓冲区）</strong><br> 所有数据读写都要通过 Buffer，Channel 与 Buffer 相互配合实现数据交换</p>
</li>
<li><p><strong>Selector（选择器）</strong><br> 允许单线程监听多个 Channel 的 IO 事件（如连接建立、数据可读），实现 <strong>IO 多路复用</strong></p>
</li>
</ul>
<img src="https://cdn.xiaolincoding.com//picgo/1716018476312-e5525ca7-acf8-46b1-8fff-8a7d22db5304.webp" alt="NIO 原理" style="zoom:67%;" />



<h2 id="4-你知道有哪个框架用到-NIO-了吗？"><a href="#4-你知道有哪个框架用到-NIO-了吗？" class="headerlink" title="4# 你知道有哪个框架用到 NIO 了吗？"></a>4# 你知道有哪个框架用到 NIO 了吗？</h2><p><strong>Netty</strong></p>
<p>Netty 的 IO 模型是基于非阻塞 IO 实现的，底层依赖的是 NIO 框架的多路复用器 Selector。采用 epoll 模式后，只需要一个线程负责 Selector 的轮询。当有数据处于就绪状态后，需要一个事件分发器（Event Dispather），它负责将读写事件分发给对应的读写事件处理器（Event Handler）。事件分发器有两种设计模式：Reactor 和 Proactor，Reactor 采用同步 IO， Proactor 采用异步 IO</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1715424254674-7a7159b1-d1ed-4236-ae18-09421c9837ed.png" alt="Netty 的 IO 模型"></p>
<p>Reactor 实现相对简单，适合处理耗时短的场景，对于耗时长的 IO 操作容易造成阻塞。Proactor 性能更高，但是实现逻辑非常复杂，适合图片或视频流分析服务器，目前主流的事件驱动模型还是依赖 select 或 epoll 来实现</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="1-有一个学生类，想按照分数排序，再按学号排序，应该怎么做？"><a href="#1-有一个学生类，想按照分数排序，再按学号排序，应该怎么做？" class="headerlink" title="1# 有一个学生类，想按照分数排序，再按学号排序，应该怎么做？"></a>1# 有一个学生类，想按照分数排序，再按学号排序，应该怎么做？</h2><p>在学生类中实现 <code>Comparable</code> 接口，并重写 <code>compareTo</code> 方法，然后在 <code>compareTo</code> 方法中实现按照分数排序和按照学号排序的逻辑:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法和其他属性、方法省略</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student other)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.score != other.score) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(other.score, <span class="built_in">this</span>.score); <span class="comment">// 按照分数降序排序</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.id, other.id); <span class="comment">// 如果分数相同，则按照学号升序排序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在需要对学生列表进行排序的地方，使用 <code>Collections.sort()</code> 方法对学生列表进行排序即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 添加学生对象到列表中</span></span><br><span class="line">Collections.sort(students);</span><br></pre></td></tr></table></figure>



<h2 id="2-解释一下-native-方法"><a href="#2-解释一下-native-方法" class="headerlink" title="2# 解释一下 native 方法"></a>2# 解释一下 native 方法</h2><p>在 Java 中，native 方法是一种特殊类型的方法，它允许 Java 代码调用外部的本地代码，即用 C、CPP 或其他语言编写的代码</p>
<p>native 方法看起来与其他方法相似，只是其方法体由 <code>native</code> 关键字代替，标记一个方法的实现将在外部定义，没有实际的实现代码。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeMethod</span><span class="params">()</span>; <span class="comment">// 声明为 native，无方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用 native 方法的一般流程</strong>：</p>
<ol>
<li><strong>声明 native 方法</strong>：在 Java 类中使用 <code>native</code> 关键字声明方法，无需提供方法体</li>
<li><strong>生成 JNI 头文件</strong>：使用 <code>javac</code> 编译 Java 类，然后用 <code>javah</code>（或 <code>javac -h</code>，较新版本）生成对应的 C&#x2F;CPP 头文件（<code>.h</code>），该文件包含 native 方法的函数签名</li>
<li><strong>实现本地代码</strong>：编写本地代码，实现 <code>.h</code> 文件中声明的方法逻辑。函数名需严格匹配 JNI 的命名规范</li>
<li><strong>编译为本地库</strong>：将本地代码编译成动态链接库（<code>.dll</code>，在 Windows 上），共享库（<code>.so</code>，在 Linux 上）</li>
<li><strong>加载本地库</strong>：使用 <code>System.loadLibrary(&quot;库名&quot;)</code> 加载编译好的本地库，使 JVM 能调用 native 方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeExample</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;nativeLib&quot;</span>); <span class="comment">// 加载名为 nativeLib 的本地库</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeMethod</span><span class="params">()</span>; <span class="comment">// 声明 native 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NativeExample</span>().nativeMethod(); <span class="comment">// 调用本地方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>八股文笔记 #2 Java 集合</title>
    <url>/2025/07/02/boilerplate-answers-2-java-collection/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="1-数组与集合的区别是？用过哪些？"><a href="#1-数组与集合的区别是？用过哪些？" class="headerlink" title="1# 数组与集合的区别是？用过哪些？"></a>1# 数组与集合的区别是？用过哪些？</h2><p>数组和集合的区别：</p>
<ul>
<li>数组是固定长度的数据结构，一旦创建长度就无法改变，而集合是动态长度的数据结构，可以根据需要动态增加或减少元素</li>
<li>数组可以包含基本数据类型和对象，而集合只能包含对象</li>
<li>数组可以直接访问元素，而集合需要通过迭代器或其他方法访问元素</li>
</ul>
<span id="more"></span>

<p>我用过的一些 Java 集合类：</p>
<ol>
<li><p><strong><code>List</code> 系列（有序、可重复）</strong>：</p>
<ul>
<li><strong><code>ArrayList</code></strong>： 动态数组，随机访问快，适合读多写少场景</li>
<li><strong><code>LinkedList</code></strong>： 双向链表，插入&#x2F;删除快，适合频繁操作头尾</li>
</ul>
</li>
<li><p><strong><code>Set</code> 系列（无序&#x2F;有序、不可重复）</strong>：</p>
<ul>
<li><strong><code>HashSet</code></strong>： 基于 <code>HashMap</code> 实现的 <code>Set</code> 集合，用于存储唯一元素</li>
<li><strong><code>LinkedHashSet</code></strong>：有插入顺序的 <code>HashSet</code></li>
<li><strong><code>TreeSet</code></strong>：基于红黑树，元素自动排序（按自然顺序或比较器）</li>
</ul>
</li>
<li><p><strong><code>Map</code> 系列（键值对）</strong>：</p>
<ul>
<li><strong><code>HashMap</code></strong>： 基于哈希表的 <code>Map</code> 实现，存储键值对，通过键快速查找值</li>
<li><strong><code>ConcurrentHashMap</code></strong>：线程安全的高性能并发 <code>Map</code></li>
<li><strong><code>TreeMap</code></strong>： 基于红黑树实现的有序 <code>Map</code> 集合，可以按照键的顺序进行排序</li>
<li><strong><code>LinkedHashMap</code></strong>： 基于哈希表和双向链表实现的 <code>Map</code> 集合，保持插入顺序或访问顺序</li>
</ul>
</li>
<li><p><strong><code>Queue</code> 系列（队列&#x2F;优先队列）</strong>：</p>
<ul>
<li><p><strong><code>PriorityQueue</code></strong>： 优先队列，可以按照比较器或元素的自然顺序进行排序</p>
</li>
<li><p><strong><code>ArrayDeque</code></strong>：双端队列，可用于栈或队列结构</p>
</li>
</ul>
</li>
</ol>
<h2 id="2-说说-Java-中的集合？"><a href="#2-说说-Java-中的集合？" class="headerlink" title="2# 说说 Java 中的集合？"></a>2# 说说 Java 中的集合？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1717481094793-b8ffe6ae-2ee6-4de5-b61b-8468e32bf269.webp" alt="Java 集合"></p>
<p><code>List</code> 是一个<strong>有序、可重复</strong>的集合，它允许根据索引精确控制元素的插入位置，也支持根据索引访问、搜索和修改元素</p>
<ul>
<li><code>ArrayList</code> 基于<strong>动态数组</strong>实现，元素按插入顺序排序。因为底层是数组，支持<strong>快速随机访问</strong>（时间复杂度 O(1)），插入和删除操作（特别是在中间位置）较慢，需移动大量元素（时间复杂度 O(n)）。当几何扩容时，会创建更大的数组，并把原数组复制到新数组。<strong>线程不安全</strong>，适用于单线程环境</li>
<li><code>LinkedList</code> 基于<strong>双向链表</strong>实现，每个节点都保存前后指针。插入和删除操作性能较好，尤其是在首尾位置添加&#x2F;删除元素时（O(1)），不支持高效的随机访问（访问第 n 个元素需从头或尾遍历，时间复杂度 O(n)）。同样是<strong>线程不安全</strong>的</li>
<li><code>Vector</code>：与 <code>ArrayList</code> 类似，也是基于<strong>动态数组</strong>实现的。<code>Vector</code> 是<strong>线程安全的</strong>，其大多数方法都使用了 <code>synchronized</code> 关键字修饰，保证线程同步。属于<strong>过时类</strong>，在 JDK 的后续发展中不再推荐使用</li>
<li><code>Stack</code>：是 <code>Vector</code> 的子类，继承了 <code>Vector</code> 的所有特性，线程安全。它实现的是**后进先出（LIFO）**的数据结构，提供了栈操作方法。同样存在设计上的历史局限，不推荐在新的项目中使用</li>
</ul>
<p><code>Set</code> 是一个<strong>不包含重复元素</strong>的集合，元素通常是<strong>无序</strong>的，但具体顺序取决于其实现类</p>
<ul>
<li><code>HashSet</code> ：基于 <code>HashMap</code> 实现，底层以 <code>HashMap</code> 的 key 存储元素，所有 key 对应的 value 都是一个统一的常量 <code>PRESENT</code>。它不保证元素顺序，插入顺序和取出顺序可能不同。由于依赖 <code>HashMap</code>，因此是<strong>线程不安全的</strong></li>
<li><code>LinkedHashSet</code>：继承自 <code>HashSet</code>，通过 <code>LinkedHashMap</code> 实现，内部使用<strong>双向链表</strong>维护元素的插入顺序，因此是<strong>有序的（按插入顺序）</strong></li>
<li><code>TreeSet</code>：基于 <code>TreeMap</code> 实现，底层结构为<strong>红黑树</strong>。元素将根据其<strong>自然顺序</strong>或提供的<strong>比较器（Comparator）进行排序，因此是有序集合</strong></li>
</ul>
<p><code>Map</code> 是一种键值对集合，<strong>key 不可重复</strong>，<strong>value 可重复</strong>。它不是 <code>Collection</code> 的子接口，但同样是 Java 集合框架的核心部分</p>
<ul>
<li><code>HashMap</code>：最常用的 <code>Map</code> 实现，key 无序、唯一，value 可重复。JDK 1.8 之前底层是<strong>数组 + 链表</strong>结构，使用<strong>拉链法</strong>解决哈希冲突；JDK 1.8 之后，当单个桶中的链表长度超过阈值（默认 8），链表将转为<strong>红黑树</strong>以提高性能。线程不安全，适用于单线程环境</li>
<li><code>LinkedHashMap</code>：是 <code>HashMap</code> 的子类，底层在 <code>HashMap</code> 基础上添加了<strong>双向链表</strong>，以维护插入顺序或访问顺序。可以通过构造函数设置为按<strong>访问顺序排序</strong>，常用于实现 LRU 缓存</li>
<li><code>HashTable</code>：较早的实现，底层为<strong>数组 + 链表</strong>，链表主要是为了解决哈希冲突。所有方法都使用 <code>synchronized</code> 修饰，线程安全但性能较差，已基本被 <code>ConcurrentHashMap</code> 替代</li>
<li><code>TreeMap</code>：是基于红黑树实现的<code>Map</code>，它可以对键进行排序，默认按照自然顺序排序，也可以通过指定的比较器进行排序。<code>TreeMap</code> 是非线程安全的，在多线程环境下，如果多个线程同时对 <code>TreeMap</code> 进行插入、删除等操作，可能会破坏红黑树的结构，导致数据不一致或程序出现异常</li>
<li><code>ConcurrentHashMap</code>：支持高并发访问的线程安全 <code>Map</code> 实现。JDK 1.8 以前使用 <strong>Segment 分段锁机制</strong>；JDK 1.8 后采用<strong>数组 + 链表 + 红黑树</strong>结构，并通过 <strong>CAS + synchronized</strong> 等机制实现更细粒度的并发控制，性能显著提升</li>
</ul>
<h2 id="3-Java-中线程安全的集合有什么？"><a href="#3-Java-中线程安全的集合有什么？" class="headerlink" title="3# Java 中线程安全的集合有什么？"></a>3# Java 中线程安全的集合有什么？</h2><p>在 <code>java.util</code> 包中的线程安全的类主要 2 个，其他都是非线程安全的：</p>
<ul>
<li><code>Vector</code>：和 <code>ArrayList</code> 类似，也是基于数组实现。其大多数方法通过 <code>synchronized</code> 保证线程安全，但在单线程场景中同步开销大，性能略低于 <code>ArrayList</code>。<code>Vector</code> 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据</li>
<li><code>Hashtable</code>：线程安全的哈希表，<code>HashTable</code> 的加锁方法是给每个方法加上 <code>synchronized</code> 关键字，这样锁住的是整个 <code>Table</code> 对象，不支持 <code>null</code> 键和值，由于同步导致的性能开销，所以已经很少被推荐使用，如果要保证线程安全的哈希表，可以用 <code>ConcurrentHashMap</code></li>
</ul>
<p><code>java.util.concurrent</code> 包提供的都是线程安全的集合：</p>
<p><strong>并发 Map</strong>：</p>
<ul>
<li><code>ConcurrentHashMap</code>：它与 <code>HashTable</code> 的主要区别是二者加锁粒度的不同，在 JDK 1.8 前，<code>ConcurrentHashMap</code> 加的是分段锁，也就是 Segment 锁，每个 Segment 含有整个 table 的一部分，这样不同分段之间的并发操作就互不影响。在 JDK 1.8 后，它取消了 Segment 字段，直接在 table 元素上加锁，实现对每一行进行加锁，进一步减小了并发冲突的概率。对于 put 操作，如果 key 对应的数组元素为 <code>null</code>，则通过 CAS 操作（Compare and Swap）将其设置为当前值。如果 key 对应的数组元素（也即链表表头或者树的根元素）不为 <code>null</code>，则对该元素使用 <code>synchronized</code> 关键字申请锁，然后进行操作。如果该 put 操作使得当前链表长度超过一定阈值，则将该链表转换为红黑树，从而提高寻址效率</li>
<li><code>ConcurrentSkipListMap</code>：实现了一个基于 <code>SkipList</code>（跳表）算法的可排序的并发集合，<code>SkipList</code> 是一种可以在对数预期时间内完成搜索、插入、删除等操作的数据结构，通过维护多个指向其他元素的 “跳跃” 链接来实现高效查找</li>
</ul>
<p><strong>并发 Set</strong>：</p>
<ul>
<li><code>ConcurrentSkipListSet</code>：是线程安全的有序的集合。底层是使用 <code>ConcurrentSkipListMap</code> 实现</li>
<li><code>CopyOnWriteArraySet</code>：是线程安全的 <code>Set</code> 实现，它是线程安全的无序的集合，可以将它理解成线程安全的 <code>HashSet</code>。有意思的是，<code>CopyOnWriteArraySet</code> 和 <code>HashSet</code> 虽然都继承于共同的父类 <code>AbstractSet</code>；但是，<code>HashSet</code> 是通过散列表实现的，而 <code>CopyOnWriteArraySet</code> 则是通过动态数组 <code>CopyOnWriteArrayList</code> 实现的，并不是散列表</li>
</ul>
<p><strong>并发 List</strong>：</p>
<ul>
<li><code>CopyOnWriteArrayList</code>：它是 <code>ArrayList</code> 的线程安全的变体，其中所有写操作（add，set 等）都通过对底层数组进行全新复制来实现，允许存储 <code>null</code> 元素。即当对象进行写操作时，使用了 Lock 锁做同步处理，内部拷贝了原数组，并在新数组上进行添加操作，最后将新数组替换掉旧数组；若进行的读操作，则直接返回结果，操作过程中不需要进行同步</li>
</ul>
<p><strong>并发 Queue</strong>：</p>
<ul>
<li><code>ConcurrentLinkedQueue</code>：是一个适用于高并发场景下的队列，它通过无锁的方式（CAS），实现了高并发状态下的高性能。通常，<code>ConcurrentLinkedQueue</code> 的性能要好于 <code>BlockingQueue</code></li>
<li><code>BlockingQueue</code>：与 <code>ConcurrentLinkedQueue</code> 的使用场景不同，<code>BlockingQueue</code> 的主要功能并不是在于提升高并发时的队列性能，而在于简化多线程间的数据共享。<code>BlockingQueue</code> 提供一种读写阻塞等待的机制，即如果消费者速度较快，则 <code>BlockingQueue</code> 则可能被清空，此时消费线程再试图从 <code>BlockingQueue</code> 读取数据时就会被阻塞。反之，如果生产线程较快，则 <code>BlockingQueue</code> 可能会被装满，此时，生产线程再试图向 <code>BlockingQueue</code> 队列装入数据时，便会被阻塞等待</li>
</ul>
<p><strong>并发 Deque</strong>：</p>
<ul>
<li><code>LinkedBlockingDeque</code>：是一个线程安全的双端队列实现。它的内部使用链表结构，每一个节点都维护了一个前驱节点和一个后驱节点。<code>LinkedBlockingDeque</code> 没有进行读写锁的分离，因此同一时间只能有一个线程对其进行操作</li>
<li><code>ConcurrentLinkedDeque</code>：<code>ConcurrentLinkedDeque</code> 是一种基于链接节点的无限并发链表。可以安全地并发执行插入、删除和访问操作。当许多线程同时访问一个公共集合时，<code>ConcurrentLinkedDeque</code> 是一个合适的选择</li>
</ul>
<p><del><strong>太长不看版</strong>：</del></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>主要实现</th>
<th>线程安全机制 &amp; 典型特性</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>早期同步类（<code>java.util</code>）</strong></td>
<td><code>Vector</code>、<code>Hashtable</code></td>
<td>整体 <code>synchronized</code>，简单但锁粒度大，已基本淘汰</td>
<td>兼容遗留代码</td>
</tr>
<tr>
<td><strong>并发 Map</strong></td>
<td><code>ConcurrentHashMap``ConcurrentSkipListMap</code></td>
<td>JDK 8：数组 + 链表&#x2F;红黑树 + <strong>CAS &#x2F; synchronized</strong>（行锁）SkipList：基于跳表，<strong>有序</strong>、读写并发</td>
<td>高并发 KV 存储；有序场景用 SkipList</td>
</tr>
<tr>
<td><strong>并发 Set</strong></td>
<td><code>ConcurrentSkipListSet``CopyOnWriteArraySet</code></td>
<td>前者基于 SkipList（有序）后者基于 Copy‑On‑Write，读多写少</td>
<td>排序去重 &#x2F; 读多写少</td>
</tr>
<tr>
<td><strong>并发 List</strong></td>
<td><code>CopyOnWriteArrayList</code></td>
<td>写时复制：写操作复制数组，读无需加锁</td>
<td>读多写少、迭代不要求实时一致</td>
</tr>
<tr>
<td><strong>并发 Queue &#x2F; Deque</strong></td>
<td><code>ConcurrentLinkedQueue</code>（无锁链表）<code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>、<code>LinkedBlockingDeque</code>（阻塞队列）<code>ConcurrentLinkedDeque</code>（无锁双端）</td>
<td>CAS 或 <code>ReentrantLock</code> + 条件队列，实现非阻塞或阻塞语义</td>
<td>生产者&#x2F;消费者模型、任务队列、并发栈&#x2F;队列</td>
</tr>
</tbody></table>
<h2 id="4-Collection-和-Collections-的区别"><a href="#4-Collection-和-Collections-的区别" class="headerlink" title="4# Collection 和 Collections 的区别"></a>4# Collection 和 Collections 的区别</h2><ul>
<li><code>Collection</code> 是 Java 集合框架的顶层接口，位于 <code>java.util</code> 包中，定义了集合的基本操作，如增删改查、遍历等。它是 <code>List</code>、<code>Set</code>、<code>Queue</code> 等集合接口的父接口，用于表示一组元素的抽象结构</li>
<li><code>Collections</code> 是 Java 提供的一个 <strong>工具类</strong>，同样位于 <code>java.util</code> 包中，专门用于对集合进行操作。它包含大量的<strong>静态方法</strong>，如排序 <code>sort()</code>、查找 <code>binarySearch()</code>、替换、反转 <code>reverse()</code>、线程安全包装 <code>synchronizedList()</code>等，可用于处理实现了 <code>Collection</code> 接口的集合对象（如 <code>List</code>、<code>Set</code> 等）</li>
</ul>
<h2 id="5-遍历集合的方式有哪些？"><a href="#5-遍历集合的方式有哪些？" class="headerlink" title="5# 遍历集合的方式有哪些？"></a>5# 遍历集合的方式有哪些？</h2><ol>
<li><strong>普通 for 循环</strong>：可以使用带有索引的普通 for 循环来遍历 <code>List</code></li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>增强 for 循环（for-each 循环）</strong>： 用于循环访问数组或集合中的元素</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String element : list) &#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>Iterator 迭代器</strong>： 可以使用迭代器来遍历集合，特别适用于需要删除元素的情况</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>ListIterator 列表迭代器</strong>： <code>ListIterator</code> 是迭代器的子类，可以双向访问列表并在迭代过程中修改元素</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListIterator&lt;String&gt; listIterator = list.listIterator();</span><br><span class="line"><span class="keyword">while</span> (listIterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> listIterator.next();</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>使用 <code>forEach()</code> 方法</strong>： Java 8 引入了 <code>forEach()</code> 方法，可以对集合进行快速遍历</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.forEach(element -&gt; System.out.println(element));</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>Stream API</strong>： Java 8 的 Stream API 提供了丰富的功能，可以对集合进行函数式操作，如过滤、映射等</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.stream().forEach(element -&gt; System.out.println(element));</span><br></pre></td></tr></table></figure>



<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="1-说说常见的-list-集合？"><a href="#1-说说常见的-list-集合？" class="headerlink" title="1# 说说常见的 list 集合？"></a>1# 说说常见的 list 集合？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1737438845596-760eb59b-c34c-441c-bea7-5b4eb1da4db4.png" alt="List 集合"></p>
<p><strong>非线程安全</strong>：</p>
<ul>
<li><code>ArrayList</code> ：基于<strong>动态数组</strong>实现，元素按插入顺序排序。因为底层是数组，支持<strong>快速随机访问</strong>（时间复杂度 O(1)），插入和删除操作（特别是在中间位置）较慢，需移动大量元素（时间复杂度 O(n)）。当几何扩容时，会创建更大的数组，并把原数组复制到新数组。<strong>线程不安全</strong>，适用于单线程环境</li>
<li><code>LinkedList</code> ：基于<strong>双向链表</strong>实现，每个节点都保存前后指针。插入和删除操作性能较好，尤其是在首尾位置添加&#x2F;删除元素时（O(1)），不支持高效的随机访问（访问第 n 个元素需从头或尾遍历，时间复杂度 O(n)）。同样是<strong>线程不安全</strong>的</li>
</ul>
<p><strong>线程安全</strong>：</p>
<ul>
<li><p><code>Vector</code>：和 <code>ArrayList</code> 类似，也是基于数组实现。其大多数方法通过 <code>synchronized</code> 保证线程安全，但在单线程场景中同步开销大，性能略低于 <code>ArrayList</code>。<code>Vector</code> 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据</p>
</li>
<li><p><code>CopyOnWriteArrayList</code>：一种<strong>并发容器类</strong>，写操作（如添加、删除）时会复制一份底层数组，并在新数组上修改，写完后再替换旧数组；读操作无需加锁，始终在旧数组上执行，实现了<strong>读写分离</strong>，大幅提升读性能。适用于<strong>读多写少</strong>的并发场景，如事件监听器列表、缓存快照等。缺点是写操作开销较大，且不适合大数据量频繁写入的场景</p>
</li>
</ul>
<h2 id="2-讲一下-List-的几种实现，几种实现有什么不同？"><a href="#2-讲一下-List-的几种实现，几种实现有什么不同？" class="headerlink" title="2# 讲一下 List 的几种实现，几种实现有什么不同？"></a>2# 讲一下 List 的几种实现，几种实现有什么不同？</h2><p><code>ArrayList</code>、<code>Vector</code>、<code>LinkedList</code>，概念如上</p>
<p><code>ArrayList</code> 和 <code>Vector</code> 作为动态数组，因为底层是数组，支持<strong>快速随机访问</strong>（时间复杂度 O(1)），插入和删除操作（特别是在中间位置）较慢，需移动大量元素（时间复杂度 O(n)）</p>
<p>而 <code>LinkedList</code> 插入和删除操作性能较好，尤其是在首尾位置添加&#x2F;删除元素时（O(1)），不支持高效的随机访问（访问第 n 个元素需从头或尾遍历，时间复杂度 O(n)）</p>
<h2 id="3-List-可以一边遍历一边修改元素吗？"><a href="#3-List-可以一边遍历一边修改元素吗？" class="headerlink" title="3# List 可以一边遍历一边修改元素吗？"></a>3# List 可以一边遍历一边修改元素吗？</h2><ol>
<li><strong>使用普通 for 循环遍历</strong>：可以在遍历过程中修改元素，只要修改的索引不超出<code>List</code>的范围即可</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">	list.set(i, list.get(i) * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>使用 for-earch 循环遍历</strong>：一般不建议在 <code>for-earch</code> 循环中直接修改正在遍历的 <code>List</code> 元素，可能会导致意外的结果或 <code>ConcurrentModificationException</code> 异常。因为 <code>for-earch</code> 循环底层是基于迭代器实现的，在遍历过程中修改集合结构，会导致迭代器的预期结构和实际结构不一致</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Integer num : list) &#123;</span><br><span class="line">	list.set(list.indexOf(num), num * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>使用迭代器遍历</strong>：可以使用迭代器的 <code>remove()</code> 方法来删除元素，但如果要修改元素的值，需要通过迭代器的 <code>set()</code> 方法来进行，而不是直接通过 <code>List</code> 的 <code>set()</code> 方法，否则也可能会抛出 <code>ConcurrentModificationException</code> 异常</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">	<span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">	iterator.set(num * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-List-如何快速删除指定下标的元素？"><a href="#4-List-如何快速删除指定下标的元素？" class="headerlink" title="4# List 如何快速删除指定下标的元素？"></a>4# List 如何快速删除指定下标的元素？</h2><ol>
<li><p><strong><code>ArrayList</code> 的 <code>remove(int index)</code> 方法</strong>：该方法在删除元素后，会将后续元素向前移动，以填补被删除元素的位置。如果删除的是列表中间的元素，时间复杂度为 O (n)；如果删除的是列表末尾的元素，时间复杂度为 O (1)</p>
</li>
<li><p><strong><code>LinkedList</code> 的 <code>remove(int index)</code> 方法</strong>：它需要先遍历到指定下标位置，然后修改链表的指针来删除元素，时间复杂度为 O (n)；如果删除的是链表的头节点或尾节点的元素，可以直接通过修改头指针或尾指针来实现删除，时间复杂度为 O (1)</p>
</li>
<li><p><strong><code>CopyOnWriteArrayList</code> 的 <code>remove(int index)</code> 方法</strong>：由于 <code>CopyOnWriteArrayList</code> 在写操作时会创建一个新的数组，所以删除操作的时间复杂度取决于数组的复制速度，通常为 O (n)。但在并发环境下，它的删除操作不会影响读操作，具有较好的并发性能</p>
</li>
</ol>
<h2 id="5-ArrayList-线程安全吗？把-Arraylist-变成线程安全的方式有哪些？"><a href="#5-ArrayList-线程安全吗？把-Arraylist-变成线程安全的方式有哪些？" class="headerlink" title="5# ArrayList 线程安全吗？把 Arraylist 变成线程安全的方式有哪些？"></a>5# ArrayList 线程安全吗？把 Arraylist 变成线程安全的方式有哪些？</h2><p><strong>不是线程安全的</strong>。变成线程安全的方式：</p>
<ol>
<li>使用 <code>Collections</code> 类的 <code>synchronizedList</code> 方法将 <code>ArrayList</code> 包装成线程安全的 <code>List</code>：</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; synchronizedList = Collections.synchronizedList(arrayList);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 <code>CopyOnWriteArrayList</code> 类代替 <code>ArrayList</code>，它是一个线程安全的 <code>List</code> 实现：</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CopyOnWriteArrayList&lt;String&gt; copyOnWriteArrayList = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;(arrayList);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用 <code>Vector</code> 类代替 <code>ArrayList</code>，<code>Vector</code> 是线程安全的 <code>List</code> 实现：</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Vector&lt;String&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;(arrayList);</span><br></pre></td></tr></table></figure>



<h2 id="6-为什么-ArrayList-不是线程安全的"><a href="#6-为什么-ArrayList-不是线程安全的" class="headerlink" title="6# 为什么 ArrayList 不是线程安全的?"></a>6# 为什么 ArrayList 不是线程安全的?</h2><p>在高并发添加数据时，<code>ArrayList</code> 会暴露三个问题：</p>
<ul>
<li>部分值为 <code>null</code></li>
<li>索引越界异常（<code>IndexOutOfBoundsException</code>）</li>
<li>size 与 add 的数量不符</li>
</ul>
<p><code>ArrayList</code> 添加元素的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">	ensureCapacityInternal(size + <span class="number">1</span>); <span class="comment">// 可能扩容</span></span><br><span class="line">	elementData[size++] = e;          <span class="comment">// 赋值后再自增 size</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ensureCapacityInternal()</code> 方法判断将当前的新元素加到列表后面，列表的 <code>elementData</code> 数组的大小是否满足，如果 size + 1 的这个需求长度大于了 <code>elementData</code> 这个数组的长度，那么就要对这个数组进行扩容</p>
<p>大体可以分为三步：</p>
<ol>
<li><p>判断数组需不需要扩容，如果需要的话，调用 <code>grow()</code> 方法进行扩容</p>
</li>
<li><p>将数组的 size 位置设置值（因为数组的下标是从 0 开始的）</p>
</li>
<li><p>将当前集合的大小加 1</p>
</li>
</ol>
<p>那么三个问题都是如何产生的？</p>
<ul>
<li>部分值为 <code>null</code>：根因是同一索引被<strong>重复写</strong>，导致后继位置空洞。线程 T1 与 T2 都判断无需扩容（容量 &#x3D;10，size &#x3D;9） → T1 把元素写入 <code>elementData[9]</code>，尚未 <code>size++</code> 就被抢占 → T2 也把元素写入同一槽位并随后 <code>size++</code> → 槽位 10 从未被写入，被视为 <code>null</code></li>
<li>索引越界异常：根因是第二线程基于<strong>过期的容量判断</strong>，写到实际不存在的索引。线程 T1 与 T2 都判断无需扩容（容量 &#x3D;10，size &#x3D;9）→ T1 写索引  9  并 <code>size++</code> → size&#x3D;10 → T2 继续写 <strong>索引 10</strong> → 数组下标越界（数组的下标索引从 0 开始）</li>
<li>size 与 add 的数量不符：根因是<code>size++</code> 是<strong>非原子</strong>递增，发生 “写覆盖”。两线程几乎同时执行 <code>size++</code>：都读取到 size&#x3D;5 → 都各自加1 → 都写回 6 → 少加了一次</li>
</ul>
<h2 id="7-ArrayList-和-LinkedList-的应用场景分别是什么？"><a href="#7-ArrayList-和-LinkedList-的应用场景分别是什么？" class="headerlink" title="7# ArrayList 和 LinkedList 的应用场景分别是什么？"></a>7# ArrayList 和 LinkedList 的应用场景分别是什么？</h2><ul>
<li><code>ArrayList</code>：适用于需要频繁访问集合元素的场景。它基于<strong>动态数组</strong>实现，可以通过索引快速访问元素，因此在按索引查找、遍历和随机访问元素的操作上具有较高的性能</li>
<li><code>LinkedList</code>：适用于频繁进行插入和删除操作的场景。它基于<strong>双向链表</strong>实现，插入和删除元素的操作只需要调整节点的指针，因此在插入和删除操作上具有较高的性能</li>
</ul>
<h2 id="8-说一下-ArrayList-的扩容机制"><a href="#8-说一下-ArrayList-的扩容机制" class="headerlink" title="8# 说一下 ArrayList 的扩容机制"></a>8# 说一下 ArrayList 的扩容机制</h2><p><code>ArrayList</code> 在添加元素时，如果当前元素数量已达到内部数组的容量上限，就会触发扩容操作。<code>ArrayList</code> 的扩容操作主要包括以下几个步骤：</p>
<ol>
<li><strong>计算新的容量</strong>：一般情况下，<code>ArrayList</code> 会将容量扩大为原来的 <strong>1.5 倍</strong>（在 JDK 10 之后，扩容策略做了调整），这是通过移位运算来避免浮点运算，效率较高，例如：</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>创建新的数组</strong>：根据新的容量创建一个更大的数组</p>
</li>
<li><p><strong>将元素复制</strong>：将旧数组中的元素逐个复制到新数组中</p>
</li>
<li><p><strong>更新引用</strong>：将内部数组引用指向新的数组</p>
</li>
<li><p><strong>完成扩容</strong>：之后即可继续向列表中添加新元素</p>
</li>
</ol>
<p>扩容过程中涉及到<strong>数组复制和内存重新分配</strong>，是一个相对开销较大的操作。因此，在预计会添加大量元素的场景下，建议在构造 <code>ArrayList</code> 时指定初始容量，以减少扩容次数，提高性能</p>
<h2 id="9-CopyonWriteArraylist-是如何实现线程安全的？"><a href="#9-CopyonWriteArraylist-是如何实现线程安全的？" class="headerlink" title="9# CopyonWriteArraylist 是如何实现线程安全的？"></a>9# CopyonWriteArraylist 是如何实现线程安全的？</h2><p><code>CopyOnWriteArrayList</code> 是一种<strong>线程安全</strong>的列表实现，其核心思想是**：写时复制**（Copy-On-Write）。它的底层通过一个被 <code>volatile</code> 修饰的数组来保存数据，并结合 <code>ReentrantLock</code> 实现写操作的互斥，确保线程安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// 加锁，保证写操作互斥</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();               <span class="comment">// 获取当前数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;                    <span class="comment">// 原数组长度</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>); <span class="comment">// 创建新数组</span></span><br><span class="line">        newElements[len] = e;                         <span class="comment">// 添加新元素</span></span><br><span class="line">        setArray(newElements);                        <span class="comment">// 替换原数组引用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行写入操作时，首先获取当前的底层数组，然后创建一个长度为原数组长度加一的新数组，并将旧数组中的所有元素复制到新数组中。接着，将待添加的新元素放置到新数组的末尾位置。最后，将内部数组的引用更新为这个新数组。整个写入过程在加锁的保护下进行，确保在并发环境中写操作的互斥性和数据的一致性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于新数组是在写操作期间独立构建的，读操作始终访问旧数组，因此不会受到影响，实现了读写分离的线程安全策略。因为数组引用是 <code>volatile</code> 的，所以读取总是能看到最新或一致的有效数据</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="1-说说常见的-Map-集合？"><a href="#1-说说常见的-Map-集合？" class="headerlink" title="1# 说说常见的 Map 集合？"></a>1# 说说常见的 Map 集合？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1737437072655-fd232d5c-f89c-4d28-b2f2-a29f908ecaba.png" alt="Map 集合"></p>
<p><strong>非线程安全</strong>：</p>
<ul>
<li><p><code>HashMap</code>：最常用的 <code>Map</code> 实现，key 无序、唯一，value 可重复。JDK 1.8 之前底层是<strong>数组 + 链表</strong>结构，使用<strong>拉链法</strong>解决哈希冲突；JDK 1.8 之后，当单个桶中的链表长度超过阈值（默认 8），链表将转为<strong>红黑树</strong>以提高性能。<code>HashMap</code> 是非线程安全的，在多线程环境下，当多个线程同时对 <code>HashMap</code> 进行操作时，可能会导致数据不一致或出现死循环等问题</p>
</li>
<li><p><code>LinkedHashMap</code>：是 <code>HashMap</code> 的子类，底层在 <code>HashMap</code> 基础上添加了<strong>双向链表</strong>，以维护插入顺序或访问顺序。可以通过构造函数设置为按<strong>访问顺序排序</strong>，常用于实现 LRU 缓存。由于它继承自<code>HashMap</code>，在多线程并发访问时，同样会出现与<code>HashMap</code>类似的线程安全问题</p>
</li>
<li><p><code>TreeMap</code>：是基于红黑树实现的<code>Map</code>，它可以对键进行排序，默认按照自然顺序排序，也可以通过指定的比较器进行排序。<code>TreeMap</code> 是非线程安全的，在多线程环境下，如果多个线程同时对 <code>TreeMap</code> 进行插入、删除等操作，可能会破坏红黑树的结构，导致数据不一致或程序出现异常</p>
</li>
</ul>
<p><strong>线程安全</strong>：</p>
<ul>
<li><code>HashTable</code>：较早的实现，底层为<strong>数组 + 链表</strong>，链表主要是为了解决哈希冲突。所有方法都使用 <code>synchronized</code> 修饰，线程安全但性能较差，已基本被 <code>ConcurrentHashMap</code> 替代</li>
<li><code>ConcurrentHashMap</code>：支持高并发访问的线程安全 <code>Map</code> 实现。JDK 1.8 以前使用 <strong>Segment 分段锁机制</strong>，将数据分成多个段（Segment），每个段都有自己的锁。在进行插入、删除等操作时，只需要获取相应段的锁，而不是整个 <code>Map</code> 的锁，这样可以允许多个线程同时访问不同的段，提高了并发访问的效率；JDK 1.8 后采用<strong>数组 + 链表 + 红黑树</strong>结构，并通过 <strong>CAS + synchronized</strong> 等机制实现更细粒度的并发控制，性能显著提升</li>
</ul>
<h2 id="2-如何对-Map-进行快速遍历？"><a href="#2-如何对-Map-进行快速遍历？" class="headerlink" title="2# 如何对 Map 进行快速遍历？"></a>2# 如何对 Map 进行快速遍历？</h2><ol>
<li><strong>使用 for-each 循环和 <code>entrySet()</code> 方法</strong>：这是一种较为常见和简洁的遍历方式，它可以同时获取 <code>Map</code> 中的键和值</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;Key: &quot;</span> + entry.getKey() + <span class="string">&quot;, Value: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>使用 for-each 循环和 <code>keySet()</code> 方法</strong>：只需要遍历 <code>Map</code> 中的键，这种方式相对简单，性能也较好</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;Key: &quot;</span> + key + <span class="string">&quot;, Value: &quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>使用迭代器</strong>：通过获取 <code>Map</code> 的 <code>entrySet()</code> 或 <code>keySet()</code> 的迭代器，也可以实现对 <code>Map</code> 的遍历，这种方式在需要删除元素等操作时比较有用</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">	Entry&lt;String, Integer&gt; entry = iterator.next();</span><br><span class="line">	System.out.println(<span class="string">&quot;Key: &quot;</span> + entry.getKey() + <span class="string">&quot;, Value: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>使用 Lambda 表达式和 <code>forEach()</code> 方法</strong>：这种方式更加简洁和函数式</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; System.out.println(<span class="string">&quot;Key: &quot;</span> + key + <span class="string">&quot;, Value: &quot;</span> + value));</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>使用 Stream API</strong>：可以将 <code>Map</code> 转换为流，然后进行各种操作</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.entrySet().stream().forEach(entry -&gt; System.out.println(<span class="string">&quot;Key: &quot;</span> + entry.getKey() + <span class="string">&quot;, Value: &quot;</span> + entry.getValue()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以进行其他操作，如过滤、映射等</span></span><br><span class="line">Map&lt;String, Integer&gt; filteredMap = map.entrySet().stream()</span><br><span class="line">    .filter(entry -&gt; entry.getValue() &gt; <span class="number">1</span>)</span><br><span class="line">    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));</span><br><span class="line">System.out.println(filteredMap);</span><br></pre></td></tr></table></figure>



<h2 id="3-介绍一下-HashMap实现原理？"><a href="#3-介绍一下-HashMap实现原理？" class="headerlink" title="3# 介绍一下 HashMap实现原理？"></a>3# 介绍一下 HashMap实现原理？</h2><p>在 JDK 1.8 之前，<code>HashMap</code> 数据结构是<strong>数组和链表</strong>，<code>HashMap</code> 通过哈希算法将元素的键映射到数组中的槽位（Bucket）。如果多个键映射到同一个槽位，它们会以链表的形式存储在同一个槽位上，因为链表的查询时间是O(n)，所以冲突很严重，一个索引上的链表非常长，效率就很低了</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1719565480532-57a14329-c36b-4514-8e7d-2f2f1df88a82.webp" alt="Java7 HashMap 结构"></p>
<p>所以在 <strong>JDK 1.8</strong> 做了优化，当一个链表的长度超过 8 的时候就转换数据结构，不再使用链表存储，而是使用<strong>红黑树</strong>，查找时使用红黑树，时间复杂度O（log n），可以提高查询性能，但是在数量较少时，即数量小于 6 时，会将红黑树转换回链表</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1719565481289-0c2164f4-f755-46e3-bb39-b5f28621bb6b.webp" alt="Java8 HashMap 结构"></p>
<h2 id="4-哈希冲突的解决方式有哪些？"><a href="#4-哈希冲突的解决方式有哪些？" class="headerlink" title="4# 哈希冲突的解决方式有哪些？"></a>4# 哈希冲突的解决方式有哪些？</h2><ol>
<li><strong>链接法</strong>：使用链表或其他数据结构来存储冲突的键值对，将它们链接在同一个哈希桶中</li>
<li><strong>开放寻址法</strong>：在哈希表中找到另一个可用的位置来存储冲突的键值对，而不是存储在链表中。常见的开放寻址方法包括线性探测、二次探测和双重散列</li>
<li><strong>再哈希法（Rehashing）</strong>：当发生冲突时，使用另一个哈希函数再次计算键的哈希值，直到找到一个空槽来存储键值对</li>
<li><strong>哈希桶扩容</strong>：当哈希冲突过多时，可以动态地扩大哈希桶的数量，重新分配键值对，以减少冲突的概率</li>
</ol>
<h2 id="5-HashMap-是线程安全的吗？"><a href="#5-HashMap-是线程安全的吗？" class="headerlink" title="5# HashMap 是线程安全的吗？"></a>5# HashMap 是线程安全的吗？</h2><p><code>HashMap</code> 不是线程安全的，<code>HashMap</code> 在多线程会存在下面的问题：</p>
<ul>
<li>JDK 1.7 的 <code>HashMap</code> 采用<strong>数组 + 链表</strong>的数据结构，多线程背景下，在数组扩容的时候，有可能导致环形链表的出现，形成死循环</li>
<li>JDK 1.8 的 <code>HashMap</code> 采用<strong>数组 + 链表 + 红黑树</strong>的数据结构，优化了 1.7 中数组扩容的方案，使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。但是多线程同时执行 <code>put()</code> 方法，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失</li>
</ul>
<p>如果要保证线程安全，可以通过这些方法来保证：</p>
<ul>
<li>多线程环境可以使用 <code>Collections.synchronizedMap</code> 同步加锁的方式，还可以使用 <code>HashTable</code>，但是同步的方式显然性能不达标，而 <code>ConcurrentHashMap </code> 更适合高并发场景使用</li>
<li><code>ConcurrentHashMap</code> 在 JDK 1.7 和 1.8 的版本改动比较大，1.7 使用 <strong>Segment + HashEntry</strong> 分段锁的方式实现，1.8 则抛弃了 Segment，改为使用 <strong>CAS + synchronized + Node</strong> 实现，同样也加入了红黑树，避免链表过长导致性能的问题</li>
</ul>
<h2 id="6-HashMap-的常见方法有哪些？"><a href="#6-HashMap-的常见方法有哪些？" class="headerlink" title="6# HashMap 的常见方法有哪些？"></a>6# HashMap 的常见方法有哪些？</h2><p><code>HashMap</code> 常用于存储和快速查找 <strong>键值对</strong> 数据。常见方法包括：</p>
<ol>
<li><code>put(K key, V value)</code>：添加或更新键值对</li>
<li><code>get(Object key)</code>：根据键获取对应的值</li>
<li><code>containsKey(Object key)</code>：判断某个键是否存在</li>
<li><code>remove(Object key)</code>：移除指定键的键值对</li>
<li><code>keySet()</code>、<code>values()</code>、<code>entrySet()</code>：遍历键、值或整个映射项</li>
</ol>
<h2 id="7-讲一下-HashMap-的-put-过程"><a href="#7-讲一下-HashMap-的-put-过程" class="headerlink" title="7# 讲一下 HashMap 的 put 过程"></a>7# 讲一下 HashMap 的 put 过程</h2><img src="https://cdn.xiaolincoding.com//picgo/1720684054342-1e3cb2a9-532e-40b8-b5cf-0043811391dc.png" alt="HashMap 的 put 过程" style="zoom:67%;" />

<p>当调用 <code>put(key, value)</code> 向 <code>HashMap</code> 添加键值对时，会按以下步骤执行：</p>
<ol>
<li><p><strong>计算索引</strong></p>
<p>根据键的哈希码，通过扰动函数（hash 方法）计算出其在数组中的位置（桶索引）</p>
</li>
<li><p><strong>检查该位置是否为空</strong></p>
<ul>
<li>如果该位置为空（无碰撞），直接创建一个新节点存入该桶</li>
<li>修改计数器 <code>modCount</code>，以支持快速失败机制（fail-fast）</li>
</ul>
</li>
<li><p><strong>该位置已有节点（发生哈希冲突）</strong></p>
<ul>
<li><p>比较头节点的哈希值和键，若相同则直接替换其值</p>
</li>
<li><p>否则遍历链表或红黑树：</p>
<ul>
<li><p><strong>链表结构</strong>：遍历节点，比较键的 <code>equals()</code> 方法，若找到则替换；否则将新节点追加到链尾</p>
</li>
<li><p><strong>红黑树结构</strong>：使用哈希和键比较规则在树中查找，若找到则替换；否则插入为新节点</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>检查是否需要树化</strong><br> 如果该桶中链表长度 ≥ 8 且数组容量 ≥ 64，则将链表转换为红黑树，以提升查询效率。</p>
</li>
<li><p><strong>检查是否需要扩容</strong><br> 若当前键值对总数超过阈值（容量 × 负载因子，默认 0.75），则触发扩容。</p>
</li>
<li><p><strong>扩容操作</strong></p>
<ul>
<li><p>创建新数组，容量为原数组的 2 倍。</p>
</li>
<li><p>重新计算所有节点的索引位置，并迁移到新数组。</p>
</li>
<li><p>更新阈值与数组引用。</p>
</li>
</ul>
</li>
<li><p><strong>插入完成</strong><br> 最终完成键值对的添加，否则返回 <code>null</code></p>
</li>
</ol>
<h2 id="8-HashMap-的-put-key-val-和-get-key-过程"><a href="#8-HashMap-的-put-key-val-和-get-key-过程" class="headerlink" title="8# HashMap 的 put(key, val) 和 get(key) 过程"></a>8# HashMap 的 put(key, val) 和 get(key) 过程</h2><p><strong>插入数据（<code>put(key, value)</code>）时</strong>，<code>HashMap</code> 首先通过 <code>hashCode()</code> 方法计算哈希值，再根据哈希值定位到对应的桶位置。如果该位置为空，直接插入；如果已存在元素（哈希冲突），则通过链表或红黑树的方式将新节点插入其中。若元素数量超过负载因子（默认 0.75）与容量的乘积，<code>HashMap</code> 会触发扩容，通常为原容量的 2 倍</p>
<p><strong>查询数据（<code>get(key)</code>）时</strong>，同样根据 <code>hashCode()</code> 方法定位到桶，再遍历桶中节点（通过 <code>equals()</code> 判断键是否相等）以查找目标键值对。若该桶中的节点数超过阈值（默认 8），且总容量大于等于 64，链表将转化为红黑树，以提高查找效率</p>
<h2 id="9-HashMap-调用-get-方法一定安全吗？"><a href="#9-HashMap-调用-get-方法一定安全吗？" class="headerlink" title="9# HashMap 调用 get() 方法一定安全吗？"></a>9# HashMap 调用 get() 方法一定安全吗？</h2><p>并不，调用 <code>get()</code> 方法有几点需要注意的地方：</p>
<ul>
<li><strong>空指针异常</strong>：如果你尝试用 <code>null</code> 作为键调用 <code>get()</code> 方法，而 <code>HashMap</code> 没有被初始化（即为 <code>null</code>），那么会抛出空指针异常。不过，如果 <code>HashMap</code> 已经初始化，使用 <code>null</code> 作为键是允许的，因为 <code>HashMap</code> 支持 <code>null</code> 键</li>
<li><strong>线程安全</strong>：<code>HashMap</code> 本身不是线程安全的。如果在多线程环境中，没有适当的同步措施，同时对 <code>HashMap</code> 进行读写操作可能会导致不可预测的行为。例如，在一个线程中调用 <code>get()</code> 方法读取数据，而另一个线程同时修改了结构（如增加或删除元素），可能会导致读取操作得到错误的结果或抛出 <code>ConcurrentModificationException</code>。如果需要在多线程环境中使用类似 <code>HashMap</code> 的数据结构，可以考虑使用 <code>ConcurrentHashMap</code></li>
</ul>
<h2 id="10-为什么-String-适合作为HashMap-的-key？"><a href="#10-为什么-String-适合作为HashMap-的-key？" class="headerlink" title="10# 为什么 String 适合作为HashMap 的 key？"></a>10# 为什么 String 适合作为HashMap 的 key？</h2><p>因为 <code>String</code> 对象是不可变的，一旦创建就不能被修改，这确保了 key 的稳定性。如果 key 是可变的，可能会导致 <code>hashCode</code> 和 <code>equals()</code> 方法的不一致，进而影响 <code>HashMap</code> 的正确性</p>
<h2 id="11-为什么-HashMap-要用红黑树而不是平衡二叉树？"><a href="#11-为什么-HashMap-要用红黑树而不是平衡二叉树？" class="headerlink" title="11# 为什么 HashMap 要用红黑树而不是平衡二叉树？"></a>11# 为什么 HashMap 要用红黑树而不是平衡二叉树？</h2><p>平衡二叉树追求的是一种 <strong>“完全平衡”</strong> 状态：任何结点的左右子树的高度差不会超过 1，优势是树的结点是很平均分配的。这个要求实在是太严了，导致每次进行插入&#x2F;删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过<strong>左旋</strong>和<strong>右旋</strong>来进行调整，使之再次成为一颗符合要求的平衡树 1</p>
<p>红黑树不追求这种完全平衡状态，而是追求一种 <strong>“弱平衡”</strong> 状态：整个树最长路径不会超过最短路径的 2 倍。优势是虽然牺牲了一部分查找的性能效率，但是能够换取一部分维持树平衡状态的成本。与平衡树不同的是，红黑树在插入、删除等操作，<strong>不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整</strong>，这也是我们为什么大多数情况下使用红黑树的原因</p>
<h2 id="12-HashMap-的-key-可以为-null-吗？"><a href="#12-HashMap-的-key-可以为-null-吗？" class="headerlink" title="12# HashMap 的 key 可以为 null 吗？"></a>12# HashMap 的 key 可以为 null 吗？</h2><p><strong>可以</strong></p>
<p><code>HashMap</code> 中使用 <code>hash()</code> 方法来计算 key 的哈希值，当 key 为空时，哈希值为 0，不走 <code>key.hashCode()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>HashMap</code> 虽然支持 key 和 value 为 <code>null</code>，但是 <code>null</code> 作为 key 只能有一个， <code>null</code> 作为 value 可以有多个</p>
<h2 id="13-重写-HashMap-的-equals-和-hashCode-方法需要注意什么？"><a href="#13-重写-HashMap-的-equals-和-hashCode-方法需要注意什么？" class="headerlink" title="13# 重写 HashMap 的 equals() 和 hashCode() 方法需要注意什么？"></a>13# 重写 HashMap 的 equals() 和 hashCode() 方法需要注意什么？</h2><p>在使用 <code>HashMap</code> 时，键对象的 <code>hashCode()</code> 和 <code>equals()</code> 方法起着决定性作用：</p>
<ul>
<li><code>hashCode()</code> 用于确定键值对在哈希表中的存储位置（即桶的位置）</li>
<li><code>equals()</code> 用于在哈希冲突时，判断两个键是否 “真正相等”</li>
</ul>
<p>当我们向 <code>HashMap</code> 中存入或读取数据时，会先调用键的 <code>hashCode()</code> 方法定位桶，再通过 <code>equals()</code> 判断桶中是否已存在相同的键。如果这两个方法没有被正确重写：</p>
<ul>
<li>可能导致不同的键被误认为相同，从而覆盖原有的数据（没有正确重写 <code>equals()</code> 方法）</li>
<li></li>
<li>或者导致相同的键被误认为不同，存储在不同位置，无法正确获取（没有正确重写 <code>hashCode()</code> 方法）</li>
</ul>
<p>此外，所有基于哈希结构、不允许键重复的集合类（如 <code>HashSet</code>）也依赖这两个方法判断元素的唯一性</p>
<p>重写时必须遵循 Java 规范中规定的以下契约：</p>
<ul>
<li>如果 <code>o1.equals(o2)</code> 为 <code>true</code>，那么 <code>o1.hashCode() == o2.hashCode()</code> 必须也为 <code>true</code></li>
<li>如果 <code>o1.hashCode() == o2.hashCode()</code>，并不要求 <code>o1.equals(o2)</code> 一定为 <code>true</code></li>
</ul>
<h2 id="14-介绍一下-HashMap-的扩容机制"><a href="#14-介绍一下-HashMap-的扩容机制" class="headerlink" title="14# 介绍一下 HashMap 的扩容机制"></a>14# 介绍一下 HashMap 的扩容机制</h2><p><code>HashMap</code> 的默认负载因子是 <strong>0.75</strong>，也就是说，当哈希表中元素数量超过总容量的 75% 时，就会触发扩容操作。扩容主要包括两个步骤：</p>
<ol>
<li><strong>扩展数组容量为原来的 2 倍</strong></li>
<li><strong>将旧数组中的元素重新映射到新数组中（即重新分配位置）</strong></li>
</ol>
<p>因为 <code>HashMap</code> 使用的是 <strong>2 次幂</strong>的扩展，所以，元素在新数组中的位置，要么与原位置相同，要么是在原位置再移动 2 次幂</p>
<p>例如，从 16 扩展为 32 时，具体的变化如下所示：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1713514753772-9467a399-6b18-4a47-89d4-957adcc53cc0.webp" alt="img"></p>
<p>在计算桶索引时，<code>HashMap</code> 使用 <code>(n - 1) &amp; hash</code> 来定位元素。扩容时，数组长度 <code>n</code> 变为原来的两倍，n - 1 的二进制表示会在高位多出一个 1，因此新的索引就会发生这样的变化：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1713514753786-cdca10bf-6eda-47f9-9bbe-0cc3beb67d76.webp" alt="img"></p>
<p>因此我们只需观察原哈希值中的这个新 bit：如果该 bit 是 0，元素在新数组中的位置不变；如果该 bit 是 1，元素的新位置 &#x3D; 原位置 + oldCap</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1713514753885-d1529537-322c-49b1-beec-5d9953da5150.webp" alt="img"></p>
<p>这意味着<strong>不需要重新计算 hash 值</strong>，只需简单地判断一个 bit 位即可完成重新分配，极大提升了扩容效率。同时，由于新增的 bit 是 0 还是 1 可以认为是随机的，<strong>原先冲突的元素更均匀地分布到了新的桶中</strong>，从而提升了查找性能</p>
<h2 id="15-为什么-HashMap-的容量是-2-的幂次方？"><a href="#15-为什么-HashMap-的容量是-2-的幂次方？" class="headerlink" title="15# 为什么 HashMap 的容量是 2 的幂次方？"></a>15# 为什么 HashMap 的容量是 2 的幂次方？</h2><p>在 JDK 1.7 中，<code>HashMap</code> 扩容时，会遍历旧数组中的每个元素，并根据它们的 hash 值重新计算在新数组中的位置。这些元素通常以链表形式存储。当链表中的元素被转移到新数组时，会根据新数组容量重新计算索引位置。由于遍历是从链表头节点开始，重新插入时顺序发生变化，原本在尾部的元素可能被移到新链表的头部</p>
<p>到了 JDK 1.8，<code>HashMap</code> 的扩容过程做了优化，避免了重新计算完整的 hash 值。扩容时数组长度总是原来的两倍（即左移一位），因此可以通过 <strong>hash 值中新增的那一位是否为 1</strong>，来判断元素的新位置：</p>
<ul>
<li>如果该位为 <code>0</code>，则元素在新数组中的索引与原索引相同</li>
<li>如果该位为 <code>1</code>，则元素的新索引为 <code>原索引 + oldCap</code></li>
</ul>
<p>这依赖于 <code>HashMap</code> 中定位桶的位置是通过 <code>index = (n - 1) &amp; hash</code> 计算的。当 <code>n</code> 是 2 的幂次方时，这个与运算可以高效地代替取模操作，同时保证索引分布的均匀性</p>
<h2 id="16-往-HashMap-存入-20-个元素，会扩容几次？"><a href="#16-往-HashMap-存入-20-个元素，会扩容几次？" class="headerlink" title="16# 往 HashMap 存入 20 个元素，会扩容几次？"></a>16# 往 HashMap 存入 20 个元素，会扩容几次？</h2><p>总共会触发 <strong>一次扩容操作</strong>。在默认情况下，<code>HashMap</code> 的初始容量为 16，负载因子为 0.75。也就是说，当元素个数超过 <code>16 × 0.75 = 12</code> 时，就会触发扩容操作：</p>
<ul>
<li><strong>初始容量：16</strong><ul>
<li>插入第 1 到第 12 个元素时，不会触发扩容；</li>
<li>插入第 13 个元素时，超过负载因子阈值（12），触发扩容，容量翻倍为 32。</li>
</ul>
</li>
<li><strong>扩容后容量：32</strong><ul>
<li>插入第 14 到第 20 个元素时，元素总数仍未超过 <code>32 × 0.75 = 24</code>，因此不会再次扩容。</li>
</ul>
</li>
</ul>
<h2 id="17-说说-HashMap-的负载因子"><a href="#17-说说-HashMap-的负载因子" class="headerlink" title="17# 说说 HashMap 的负载因子"></a>17# 说说 HashMap 的负载因子</h2><p><code>HashMap</code> 的负载因子（<code>loadFactor</code>）默认值为 <strong>0.75</strong>，表示当元素个数超过当前容量的 75% 时，就会触发扩容操作</p>
<p>这个默认值是在 <strong>时间效率和空间利用率之间取得的权衡</strong></p>
<ul>
<li>如果负载因子设置过低，会导致哈希表中存在大量空桶，浪费内存空间；</li>
<li>如果设置过高，会增加哈希冲突的概率，导致查找效率下降。</li>
</ul>
<p><strong>0.75</strong> 是在实际使用中得出的一个经验值，能够在 <strong>减少冲突次数</strong> 和 <strong>节省空间成本</strong> 之间实现较好的平衡</p>
<h2 id="18-ConcurrentHashMap-怎么实现的？"><a href="#18-ConcurrentHashMap-怎么实现的？" class="headerlink" title="18# ConcurrentHashMap 怎么实现的？"></a>18# ConcurrentHashMap 怎么实现的？</h2><p><strong>ConcurrentHashMap 的两代实现思路</strong></p>
<table>
<thead>
<tr>
<th>JDK 版本</th>
<th>主要结构</th>
<th>加锁策略</th>
<th>冲突链</th>
<th>典型特征</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1.7</strong></td>
<td><strong>Segment 数组</strong> → Segment 内部 <strong>HashEntry 数组 + 链表</strong></td>
<td>每个 Segment 一把 <code>ReentrantLock</code>（分段锁）</td>
<td>单向链表</td>
<td>锁粒度 &#x3D; Segment，最大并发度 &#x3D; Segment 数</td>
</tr>
<tr>
<td><strong>1.8</strong></td>
<td><strong>Node 数组</strong> → 单个桶为 <strong>链表 &#x2F; 红黑树</strong></td>
<td>① 首次初始化和扩容：<code>CAS</code> + <code>synchronized</code>② 桶内插入&#x2F;替换：给桶头节点加 <code>synchronized</code></td>
<td>链表 → 长度 ≥ 8 时且容量 ≥ 64 转红黑树</td>
<td>锁粒度 &#x3D; 单个桶头节点，并发更高；查询 O(1)&#x2F;O(log n)</td>
</tr>
</tbody></table>
<p><strong>一、JDK 1.7：Segment‑Lock 方案</strong></p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1721807523151-41ad316a-6264-48e8-9704-5b362bc0083c.webp" alt="JDK 1.7 ConcurrentHashMap"></p>
<ol>
<li><strong>数据分段</strong>：整个表被切分为若干 Segment，每段内部维护一个 <code>HashEntry[]</code>（桶数组）</li>
<li><strong>分段加锁</strong>：线程操作键值对时，只需竞争目标 Segment 的 <code>ReentrantLock</code>，其它 Segment 可并行访问</li>
<li><strong>缺点</strong>：Segment 数固定，极端高并发下仍存在锁争用。桶内冲突仅靠<strong>链表</strong>，数据量大时查找性能 O(n)</li>
</ol>
<hr>
<p><strong>二、JDK 1.8：CAS + Node + 红黑树</strong></p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1721807523128-7b1419e7-e6ba-47e6-aba0-8b29423a8ce7.webp" alt="JDK 1.8 ConcurrentHashMap"></p>
<ol>
<li><strong>取消 Segment</strong>：直接对头结点加锁来保证线程安全的，锁的粒度相比 Segment 来说更小了，发生冲突和加锁的频率降低了，并发操作的性能就提高了</li>
<li><strong>初始化 &amp; 扩容</strong>：采用 <strong>volatile + CAS</strong> 竞争表头，少量线程失败后退让，再由 “领头线程” 使用 <code>synchronized</code> 完成初始化&#x2F;迁移</li>
<li><strong>插入流程</strong><ul>
<li>计算索引 idx，判断桶是否为空</li>
<li>桶为空：CAS 直接放节点</li>
<li>桶非空：对桶头节点加 <code>synchronized</code>，遍历链表 &#x2F; 红黑树，并替换或追加节点，最后再判断是否需要转为红黑树（链表长度 ≥ 8 且容量 ≥ 64 → 树化）</li>
</ul>
</li>
<li><strong>优点</strong><ul>
<li><strong>锁粒度更小</strong>：仅锁冲突桶的头节点</li>
<li><strong>查询性能提升</strong>：链表转为红黑树后，桶内查找由 O(n) → O(log n)</li>
<li><strong>更高并发度</strong>：大量场景下只用 CAS，无显式锁</li>
</ul>
</li>
</ol>
<h2 id="19-分段锁是如何加锁的？"><a href="#19-分段锁是如何加锁的？" class="headerlink" title="19# 分段锁是如何加锁的？"></a>19# 分段锁是如何加锁的？</h2><p>在 <strong>JDK 1.7 的 ConcurrentHashMap</strong> 中，采用了一种叫作 <strong>分段锁（Segment Lock）</strong> 的机制来实现线程安全</p>
<p>整个 <code>ConcurrentHashMap</code> 被划分为多个 <strong>Segment</strong>，每个 Segment 本质上就是一个小型的 <code>HashMap</code>，并配有一把独立的锁。这样一来，多个线程只要访问的是不同的 Segment，就可以<strong>并发地进行读写操作</strong>，无需互相等待，从而大大提升了并发性能</p>
<p>当执行插入、更新或删除操作时，<code>ConcurrentHashMap</code> 首先会根据 key 的 hash 定位到对应的 Segment，然后<strong>只对这个 Segment 加锁</strong>，而不是对整个 Map 加锁。这种粒度更细的加锁方式，相比传统的全表锁（如 <code>Hashtable</code> 中的 <code>synchronized</code> 方法），性能提升非常明显</p>
<h2 id="20-分段锁是可重入的吗？"><a href="#20-分段锁是可重入的吗？" class="headerlink" title="20# 分段锁是可重入的吗？"></a>20# 分段锁是可重入的吗？</h2><p>在 <strong>JDK 1.7 的 ConcurrentHashMap</strong> 中，分段锁是通过 <strong>ReentrantLock（可重入锁）</strong> 实现的。也就是说，每个 Segment 内部维护了一把 ReentrantLock，使得同一个线程在未释放锁的情况下，可以多次获取同一把锁而不会发生死锁。这种设计既保证了线程安全，又提高了灵活性</p>
<h2 id="21-已经用了-synchronized，为什么还要用-CAS-呢？"><a href="#21-已经用了-synchronized，为什么还要用-CAS-呢？" class="headerlink" title="21# 已经用了 synchronized，为什么还要用 CAS 呢？"></a>21# 已经用了 synchronized，为什么还要用 CAS 呢？</h2><p>在 <code>ConcurrentHashMap</code> 中，<strong>CAS 和 synchronized 是互补使用的</strong>，目的是在不同的并发场景下权衡性能与安全性</p>
<p>例如，在 <code>putVal()</code> 方法中，如果计算出的桶（槽）位置为空，也就是说没有发生哈希冲突，那么就会尝试使用 <strong>CAS（无锁操作）</strong> 来插入新节点。由于哈希值经过扰动处理后冲突概率较低，这种情况下通过少量自旋即可完成插入操作，<strong>避免了加锁的开销</strong>，性能更高</p>
<p>而当发生哈希冲突、桶中已有节点时，说明当前桶出现竞争或者数据较多，此时再使用 CAS 会导致频繁失败和自旋，反而浪费资源。因此在这种场景下，<strong>ConcurrentHashMap 会退而使用 synchronized 来保证线程安全</strong>，处理冲突的链表或红黑树操作</p>
<p>总结来说：</p>
<ul>
<li><strong>无冲突时优先用 CAS，提高性能；</strong></li>
<li><strong>发生冲突时使用 synchronized，降低竞争消耗</strong></li>
</ul>
<h2 id="22-ConcurrentHashMap用了悲观锁还是乐观锁"><a href="#22-ConcurrentHashMap用了悲观锁还是乐观锁" class="headerlink" title="22# ConcurrentHashMap用了悲观锁还是乐观锁?"></a>22# ConcurrentHashMap用了悲观锁还是乐观锁?</h2><p><strong>ConcurrentHashMap 同时使用了乐观锁和悲观锁，依据场景选择不同的并发策略，以实现性能与线程安全之间的平衡</strong></p>
<p>在添加元素（<code>put</code> 操作）时，其执行流程如下：</p>
<ol>
<li><strong>初始化阶段</strong>：</li>
</ol>
<p>  如果表为空，使用 <code>volatile</code> 配合 <strong>CAS（乐观锁）</strong> 来初始化桶数组</p>
<ol start="2">
<li><strong>定位桶位时</strong>：<br> 如果目标位置（槽位）为空，尝试使用 <strong>CAS（乐观锁）</strong> 直接将节点插入该位置，无需加锁</li>
<li><strong>发生哈希冲突时</strong>：<br> 如果目标位置已有其他节点（发生哈希碰撞），则使用 <strong><code>synchronized</code>（悲观锁）</strong> 加锁处理。在锁定的情况下，会遍历链表或红黑树，更新或新增节点，并在必要时判断是否需要将链表转为红黑树，以提升性能</li>
</ol>
<h2 id="23-HashTable-底层实现原理是什么？"><a href="#23-HashTable-底层实现原理是什么？" class="headerlink" title="23# HashTable 底层实现原理是什么？"></a>23# HashTable 底层实现原理是什么？</h2><img src="https://cdn.xiaolincoding.com//picgo/1719982934770-8587cb0a-6e1d-4007-9a22-bc1e41276491.png" alt="HashTable 原理" style="zoom: 50%;" />

<ul>
<li>Hashtable 底层主要由<strong>数组 + 链表</strong>组成，数组负责存储数据，而链表用来解决哈希冲突</li>
<li>为了保证线程安全，Hashtable 中所有的公共方法都使用了 <code>synchronized</code> 关键字进行同步。当一个线程访问同步方法时，其他线程如果也想访问这些方法，就会被阻塞，直到锁被释放</li>
</ul>
<h2 id="24-HashTable-线程安全是怎么实现的？"><a href="#24-HashTable-线程安全是怎么实现的？" class="headerlink" title="24# HashTable 线程安全是怎么实现的？"></a>24# HashTable 线程安全是怎么实现的？</h2><p><code>Hashtable</code> 之所以线程安全，是因为其所有涉及数据访问的方法（如 <code>put</code>、<code>get</code> 等）都使用了 <code>synchronized</code> 关键字进行同步控制。这意味着，在任何时刻，<strong>只能有一个线程对整个 Hashtable 实例进行操作</strong>，从而保证了线程安全性，但也带来了性能瓶颈</p>
<p>源码示例（以 <code>put()</code> 和 <code>get()</code> 方法为例）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;?,?&gt;[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">    <span class="keyword">for</span> (; entry != <span class="literal">null</span>; entry = entry.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.hash == hash &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;?,?&gt;[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (V) e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，<code>Hashtable</code> 通过给整个方法加上 <code>synchronized</code>，确保了多线程环境下的可见性与互斥访问</p>
<p><strong>同步机制说明</strong></p>
<p>在 Java 中，<code>synchronized</code> 是一种内置锁机制。它可以修饰方法或代码块，当一个线程进入 <code>synchronized</code> 方法或代码块时，会独占该对象的锁，其他线程只能等待该锁被释放后才能继续执行</p>
<p>这种做法虽然简单直接，但由于<strong>锁粒度较大（作用于整个对象），并发性能相对较低</strong>。因此在高并发场景下，<code>Hashtable</code> 逐渐被 <code>ConcurrentHashMap</code> 等更高效的并发容器取代</p>
<h2 id="25-HashTable-和-ConcurrentHashMap-有什么区别？"><a href="#25-HashTable-和-ConcurrentHashMap-有什么区别？" class="headerlink" title="25# HashTable 和 ConcurrentHashMap 有什么区别？"></a>25# HashTable 和 ConcurrentHashMap 有什么区别？</h2><p><strong>底层数据结构</strong></p>
<ul>
<li><strong>ConcurrentHashMap</strong><ul>
<li>JDK 1.7，采用 <strong>分段锁机制（Segment）+ 数组 + 链表</strong> 的结构。整个 Map 被划分为多个 Segment，每个 Segment 内部是一个小的 <code>HashMap</code>，具备独立锁</li>
<li>JDK 1.8 及以后，移除了 Segment，使用 <strong>数组 + 链表 + 红黑树</strong> 实现，结构与 <code>HashMap</code> 类似。链表过长（超过 8 个元素）时转为红黑树以提升查询效率</li>
</ul>
</li>
<li><strong>HashTable</strong><ul>
<li>始终采用 <strong>数组 + 链表</strong> 的结构，数组是主体，链表用于处理哈希冲突</li>
</ul>
</li>
</ul>
<p><strong>实现线程安全的方式</strong></p>
<ul>
<li><strong>ConcurrentHashMap</strong><ul>
<li><strong>JDK 1.7</strong>：通过 <strong>分段锁（Segment + ReentrantLock）</strong> 实现部分同步，锁粒度小，多个线程可并发访问不同的 Segment，提升并发性能</li>
<li><strong>JDK 1.8</strong>：采用 <strong>CAS（乐观锁） + synchronized（悲观锁）</strong> 结合的方式实现更细粒度的同步控制：<ul>
<li>桶位为空时，用 CAS 插入节点</li>
<li>桶位非空（发生哈希冲突）时，用 <code>synchronized</code> 加锁处理</li>
<li>结构中引入红黑树，优化了链表查询性能</li>
</ul>
</li>
</ul>
</li>
<li><strong>HashTable</strong><ul>
<li>所有方法都使用了 <code>synchronized</code> 关键字，属于<strong>粗粒度锁</strong>，整个对象在同一时刻只能被一个线程访问，线程安全但效率低下</li>
</ul>
</li>
</ul>
<h2 id="26-HashMap、HashTable-和-ConcurrentHashMap-的区别"><a href="#26-HashMap、HashTable-和-ConcurrentHashMap-的区别" class="headerlink" title="26# HashMap、HashTable 和 ConcurrentHashMap 的区别"></a>26# HashMap、HashTable 和 ConcurrentHashMap 的区别</h2><p><strong>HashMap</strong></p>
<ul>
<li><strong>线程不安全</strong>，但性能较高，适合单线程或线程安全有保障的场景</li>
<li>允许一个 <code>null</code> key 和多个 <code>null</code> value</li>
<li>默认初始容量为 <strong>16</strong>，扩容时按 <strong>2 的倍数增长</strong></li>
<li>如果用户指定初始容量，内部会将其调整为 <strong>最接近且大于该值的 2 的幂次方</strong></li>
<li><strong>底层结构</strong>：数组 + 链表（JDK 1.8 以后引入红黑树），当链表长度超过阈值（默认为 8），并且数组长度大于 64 时，会将链表转换为 <strong>红黑树</strong>，以提升查询效率；若数组长度不够，则优先选择扩容</li>
</ul>
<p><strong>HashTable</strong></p>
<ul>
<li><strong>线程安全</strong>，但效率低，<strong>所有公共方法都使用 <code>synchronized</code> 修饰</strong>，属于<strong>粗粒度锁</strong>。</li>
<li>不允许 <code>null</code> 的 key 和 value</li>
<li>默认初始容量为 <strong>11</strong>，扩容时容量变为 <code>2n + 1</code></li>
<li>创建时如果指定容量，就直接使用该容量（不会调整为 2 的幂次方）</li>
<li><strong>底层结构</strong>：数组 + 链表，用于解决哈希冲突</li>
<li>已逐渐被淘汰，如需线程安全更推荐使用 <strong><code>ConcurrentHashMap</code></strong></li>
</ul>
<p><strong>ConcurrentHashMap</strong></p>
<ul>
<li><strong>线程安全</strong>，性能优于 <code>HashTable</code>，适合高并发场景</li>
<li>不允许 <code>null</code> 的 key 或 value（防止空值导致歧义）</li>
<li><strong>JDK 1.7 实现</strong>：基于 <strong>分段锁（Segment）</strong>，将哈希表分为若干段，每段维护自己的锁，多个线程可同时访问不同段，提高并发性</li>
<li><strong>JDK 1.8 实现</strong>：移除了 Segment，改为使用 <strong>CAS（乐观锁）+ synchronized（悲观锁）</strong> 的组合方式进行细粒度同步<ul>
<li>使用 <strong>CAS</strong> 插入空桶节点，避免加锁</li>
<li>若发生哈希冲突，再使用 <strong>synchronized</strong> 锁定桶进行处理</li>
<li>链表过长时转为 <strong>红黑树</strong>，提升查询效率</li>
</ul>
</li>
<li>读操作在多数情况下是无锁的，性能更优</li>
</ul>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="1-Set-集合有什么特点？如何实现-key-无重复的？"><a href="#1-Set-集合有什么特点？如何实现-key-无重复的？" class="headerlink" title="1# Set 集合有什么特点？如何实现 key 无重复的？"></a>1# Set 集合有什么特点？如何实现 key 无重复的？</h2><p><strong>Set 的特点</strong></p>
<p>Set 集合用于存储<strong>不重复的元素</strong>，<strong>不保证元素的顺序</strong>（具体顺序取决于其具体实现，例如 <code>HashSet</code>、<code>TreeSet</code>、<code>LinkedHashSet</code>）</p>
<p><strong>如何保证元素唯一性</strong></p>
<p>Set 是通过内部使用的 <strong>数据结构</strong> 来保证元素不重复的：</p>
<ul>
<li>对于 <code>HashSet</code>：底层基于 <strong>HashMap</strong> 实现，插入元素时会计算其 <code>hashCode()</code>，再通过 <code>equals()</code> 方法判断是否已经存在相同元素，若存在，则不会重复插入</li>
<li>对于 <code>TreeSet</code>：底层基于 <strong>红黑树（TreeMap）</strong> 实现，依赖元素的自然顺序或指定的 <code>Comparator</code> 来比较是否相等</li>
<li>对于 <code>LinkedHashSet</code>：底层是 <strong>HashMap + 双向链表</strong>，既保证了插入顺序，又保证了元素唯一性</li>
</ul>
<p>因此，Set 保证元素不重复，依赖的是 <code>hashCode()</code> 和 <code>equals()</code> 方法（哈希结构）或 <code>compareTo()</code> &#x2F; <code>Comparator</code>（排序结构）</p>
<h2 id="2-有序的-Set-是什么？记录插入顺序的集合是哪种？"><a href="#2-有序的-Set-是什么？记录插入顺序的集合是哪种？" class="headerlink" title="2# 有序的 Set 是什么？记录插入顺序的集合是哪种？"></a>2# 有序的 Set 是什么？记录插入顺序的集合是哪种？</h2><p><strong>有序的 Set</strong></p>
<ul>
<li><code>TreeSet</code> ：它基于<strong>红黑树</strong>实现，能够按照元素的<strong>自然顺序</strong>（或自定义的 <code>Comparator</code>）自动排序</li>
<li><code>LinkedHashSet</code> ：它基于 <strong>哈希表 + 双向链表</strong> 实现，保持的是<strong>元素的插入顺序</strong>，而非排序顺序</li>
</ul>
<p><strong>记录插入顺序的 Set</strong></p>
<ul>
<li><code>LinkedHashSet</code> 是专门用来记录插入顺序的 Set。它在保证元素不重复的同时，也能按照插入的顺序进行迭代访问</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>八股文笔记 #3 Java 并发</title>
    <url>/2025/07/03/boilerplate-answers-3-java-concurrent/</url>
    <content><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="1-Java-的线程和操作系统的线程一样吗？"><a href="#1-Java-的线程和操作系统的线程一样吗？" class="headerlink" title="1# Java 的线程和操作系统的线程一样吗？"></a>1# Java 的线程和操作系统的线程一样吗？</h2><p>是的，Java 中的线程本质上与操作系统的线程是一致的</p>
<img src="https://cdn.xiaolincoding.com//picgo/image-20240725230425385.png" alt="Java 线程" style="zoom: 25%;" />

<span id="more"></span>

<p>在现代 JVM（如 HotSpot）中，Java 使用的是 <strong>一对一的线程模型</strong>，即每创建一个 Java 线程，JVM 底层都会调用操作系统的 API（如 Linux 下的 <code>pthread_create</code>）来创建一个 <strong>原生线程</strong></p>
<p>因此，Java 线程与操作系统线程是 <strong>一一对应</strong> 的，拥有独立的调用栈、程序计数器等资源，由操作系统负责调度和管理</p>
<p>这种设计使得 Java 能够充分利用多核 CPU 的并发能力，同时也意味着 Java 线程的性能和行为，受到操作系统线程调度策略的影响</p>
<h2 id="2-使用多线程要注意哪些问题？"><a href="#2-使用多线程要注意哪些问题？" class="headerlink" title="2# 使用多线程要注意哪些问题？"></a>2# 使用多线程要注意哪些问题？</h2><p>在使用多线程编程时，最关键的是确保<strong>线程安全</strong>，避免由于<strong>数据竞争</strong>导致的数据不一致、程序行为异常等问题</p>
<p>Java 中的线程安全主要体现在以下三个方面：</p>
<ol>
<li><strong>原子性</strong>：原子性保证<strong>某个操作在执行过程中不会被其他线程打断</strong>，即<strong>同一时刻只能有一个线程对共享数据进行修改</strong>。可以通过以下方式保障原子性<ul>
<li>使用 <code>synchronized</code> 关键字对代码块或方法加锁</li>
<li>使用 <code>java.util.concurrent.atomic</code> 包下的原子类（如 <code>AtomicInteger</code>、<code>AtomicReference</code>）来进行原子操作</li>
</ul>
</li>
<li><strong>可见性</strong>：可见性指的是<strong>一个线程对共享变量的修改能够及时地被其他线程看到</strong>。 Java 中通过以下机制保证可见性<ul>
<li><code>synchronized</code> 隐含地保证了进入和退出临界区时的内存刷新</li>
<li><code>volatile</code> 关键字用于标记变量，确保对该变量的读写不会被线程本地缓存，从而强制线程从主内存读取</li>
</ul>
</li>
<li><strong>有序性</strong>：在多线程环境下，Java 编译器和 CPU 可能对指令进行<strong>重排序</strong>以优化性能，导致线程间看到的执行顺序不一致。Java 使用<strong>happens-before 原则</strong>来建立线程间操作的执行顺序关系，确保必要的有序性</li>
</ol>
<h2 id="3-保证数据的一致性有哪些方案呢？"><a href="#3-保证数据的一致性有哪些方案呢？" class="headerlink" title="3# 保证数据的一致性有哪些方案呢？"></a>3# 保证数据的一致性有哪些方案呢？</h2><p>在并发编程或分布式系统中，确保数据一致性是至关重要的。以下是常见的几种实现方案：</p>
<ol>
<li><p><strong>事务管理</strong>：事务遵循 ACID 原则，通过数据库事务机制，确保一组操作要么<strong>全部执行成功并提交</strong>，要么<strong>全部失败并回滚</strong>，从而保证数据在操作过程中的一致性</p>
<ul>
<li><p><strong>原子性</strong>：事务中的所有操作要么全部执行，要么全部不执行</p>
</li>
<li><p><strong>一致性</strong>：事务执行前后，数据库始终处于一致的状态</p>
</li>
<li><p><strong>隔离性</strong>：多个事务之间的操作互不干扰</p>
</li>
<li><p><strong>持久性</strong>：事务一旦提交，数据变更就是永久性的</p>
</li>
</ul>
</li>
<li><p><strong>锁机制</strong>：锁机制是一种<strong>悲观并发控制策略</strong>，适合冲突概率较高的场景。通过加锁可以控制多个线程对共享资源的访问，避免并发读写导致的数据不一致问题。可以使用 Java 的 <code>synchronized</code> 关键字、<code>ReentrantLock</code> 等显示锁或者读写锁（<code>ReadWriteLock</code>）等</p>
</li>
<li><p><strong>版本控制（乐观锁）</strong>：乐观锁适用于<strong>读多写少、冲突较少</strong>的场景，可以有效提高系统的吞吐量。通过乐观锁的方式，在更新数据时记录数据的版本信息，从而避免同时对同一数据进行修改，进而保证数据的一致性</p>
</li>
</ol>
<h2 id="4-线程的创建方式有哪些"><a href="#4-线程的创建方式有哪些" class="headerlink" title="4# 线程的创建方式有哪些?"></a>4# 线程的创建方式有哪些?</h2><p><del><strong>太长不看版</strong></del></p>
<table>
<thead>
<tr>
<th>方式</th>
<th>关键点</th>
<th>优点</th>
<th>局限</th>
</tr>
</thead>
<tbody><tr>
<td><strong>继承 <code>Thread</code></strong></td>
<td>重写 <code>run()</code>，调用 <code>start()</code></td>
<td>编写简单；<code>this</code> 即当前线程</td>
<td>已继承 <code>Thread</code>，无法再继承其他类，线程与任务代码强耦合</td>
</tr>
<tr>
<td><strong>实现 <code>Runnable</code></strong></td>
<td>实现 <code>run()</code>，包装进 <code>Thread</code></td>
<td>可继承其它父类；多个线程可共享同一任务对象</td>
<td>需用 <code>Thread.currentThread()</code> 取当前线程；无返回值</td>
</tr>
<tr>
<td><strong>实现 <code>Callable</code> + <code>FutureTask</code></strong></td>
<td>实现 <code>call()</code>，包装成 <code>FutureTask</code> 再交给 <code>Thread</code></td>
<td>任务可返回结果，可抛异常；多个线程可共享同一任务对象</td>
<td>代码略复杂；同样需 <code>Thread.currentThread()</code></td>
</tr>
<tr>
<td><strong>线程池（<code>ExecutorService</code>）</strong></td>
<td>任务提交给池；池内部复用线程</td>
<td>复用线程、限制并发、便于管理</td>
<td>参数配置不当易导致资源耗尽或死锁；调优、排错复杂</td>
</tr>
</tbody></table>
<ol>
<li><p><strong>继承 <code>Thread</code></strong>：这是最直接的一种方式，用户自定义类继承 <code>java.lang.Thread</code> 类，需要重写 <code>run()</code> 方法，<code>run()</code> 方法中定义了线程执行的具体任务。创建该类的实例后，通过调用 <code>start()</code> 方法启动线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">/* 任务逻辑 */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：编写简单，如果需要访问当前线程，无需使用 <code>Thread.currentThread()</code> 方法，直接使用 <code>this</code>，即可获得当前线程</li>
<li>缺点：因为线程类已经继承了 <code>Thread</code> 类，所以不能再继承其他的父类</li>
</ul>
</li>
<li><p><strong>实现 <code>Runnable</code></strong>：如果一个类已经继承了其他类，就不能再继承 <code>Thread</code> 类，此时可以实现 <code>java.lang.Runnable</code> 接口，需要重写 <code>run()</code> 方法，然后将此 <code>Runnable</code> 对象作为参数传递给 <code>Thread</code> 类的构造器，调用 <code>start()</code> 方法启动线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">/* 任务逻辑 */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyTask</span>()).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：线程类只是实现了 <code>Runable</code> 接口，还可以继承其他的类。在这种方式下，可以多个线程共享同一个目标对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将 CPU 代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想</li>
<li>缺点：编程稍微复杂，如果需要访问当前线程，必须使用 <code>Thread.currentThread()</code> 方法</li>
</ul>
</li>
<li><p><strong>实现 <code>Callable</code> 接口 + <code>FutureTask</code></strong>：<code>java.util.concurrent.Callable</code> 接口类似于 <code>Runnable</code>，但 <code>Callable</code> 的 <code>call()</code> 方法可以有返回值并且可以抛出异常。要执行 <code>Callable</code> 任务，需将它包装进一个 <code>FutureTask</code>，因为 <code>Thread</code> 类的构造器只接受 <code>Runnable</code> 参数，而 <code>FutureTask</code> 实现了 <code>Runnable</code> 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCall</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyCall</span>());</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(ft).start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> ft.get();  <span class="comment">// 阻塞拿结果</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>缺点：编程稍微复杂，如果需要访问当前线程，必须调用 <code>Thread.currentThread()</code> 方法</li>
<li>优点：线程只是实现 <code>Runnable</code> 或实现 <code>Callable</code> 接口，还可以继承其他类。这种方式下，多个线程可以共享一个 target 对象，非常适合多线程处理同一份资源的情形</li>
</ul>
</li>
<li><p><strong>使用线程池（Executor 框架）</strong>：从 Java 5 开始引入的 <code>java.util.concurrent.ExecutorService</code> 和相关类提供了线程池的支持，这是一种更高效的线程管理方式，避免了频繁创建和销毁线程的开销。可以通过 <code>Executors</code> 类的静态方法创建不同类型的线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    pool.submit(() -&gt; &#123;<span class="comment">/* 任务逻辑 */</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>缺点：程池增加了程序的复杂度，特别是当涉及线程池参数调整和故障排查时。错误的配置可能导致死锁、资源耗尽等问题，这些问题的诊断和修复可能较为复杂</p>
</li>
<li><p>优点：线程池可以重用预先创建的线程，避免了线程创建和销毁的开销，显著提高了程序的性能。对于需要快速响应的并发请求，线程池可以迅速提供线程来处理任务，减少等待时间。并且，线程池能够有效控制运行的线程数量，防止因创建过多线程导致的系统资源耗尽（如内存溢出）。通过合理配置线程池大小，可以最大化 CPU 利用率和系统吞吐量</p>
</li>
</ul>
</li>
</ol>
<h2 id="5-如何启动线程-？"><a href="#5-如何启动线程-？" class="headerlink" title="5# 如何启动线程 ？"></a>5# 如何启动线程 ？</h2><p>在 Java 中，启动线程的标准方式是调用 <code>Thread</code> 类的 <strong><code>start()</code> 方法</strong>。该方法会通知 JVM 去创建一个新的线程，并由系统调度线程执行 <code>run()</code> 方法中定义的任务逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建两个线程，并使用 start() 启动它们</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"></span><br><span class="line">myThread1.start();  <span class="comment">// 启动线程1</span></span><br><span class="line">myThread2.start();  <span class="comment">// 启动线程2</span></span><br></pre></td></tr></table></figure>



<h2 id="6-如何停止线程"><a href="#6-如何停止线程" class="headerlink" title="6# 如何停止线程?"></a>6# 如何停止线程?</h2><p>停止线程应遵循 <strong>协作式</strong> 原则，既让线程 <strong>自行结束</strong>，又确保资源得到正确释放</p>
<p><del><strong>太长不看版</strong></del></p>
<table>
<thead>
<tr>
<th>#</th>
<th>停止方式</th>
<th>简要说明</th>
<th>场景适配性</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>volatile</code> 标志位控制循环</td>
<td>主线程控制标志，工作线程轮询判断是否退出</td>
<td>简单计算任务</td>
</tr>
<tr>
<td>2</td>
<td>使用 <code>interrupt()</code> + 判断中断状态</td>
<td>发送中断信号，由线程检查 <code>isInterrupted()</code> 响应退出</td>
<td>阻塞&#x2F;非阻塞任务</td>
</tr>
<tr>
<td>3</td>
<td>可中断阻塞操作（<code>sleep()</code> &#x2F; <code>wait()</code> &#x2F; <code>join()</code>）</td>
<td>阻塞时响应中断，捕获异常后安全退出</td>
<td>阻塞型任务</td>
</tr>
<tr>
<td>4</td>
<td>使用 <code>return</code> 提前结束 <code>run()</code> 方法</td>
<td>可配合中断或标志位，在逻辑判断处直接返回退出</td>
<td>控制逻辑明确</td>
</tr>
<tr>
<td>5</td>
<td>使用线程池 + <code>Future.cancel(true)</code></td>
<td>在线程池中通过 Future 中断任务</td>
<td>线程池管理的任务</td>
</tr>
<tr>
<td>6</td>
<td>关闭底层资源解除不可中断阻塞</td>
<td>关闭资源触发异常，中断无法生效的情况专用</td>
<td>I&#x2F;O、Socket 阻塞</td>
</tr>
<tr>
<td>7</td>
<td><code>Thread.stop()</code>（已废弃）</td>
<td>强制终止，风险极高，不建议使用</td>
<td>禁止使用</td>
</tr>
</tbody></table>
<ol>
<li><p><strong>使用 volatile 标志位控制循环退出</strong>：通过定义共享的 <code>volatile</code> 布尔变量，线程在 <code>run()</code> 中轮询该变量判断是否继续执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SafeStopFlag</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread exiting safely.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123; running = <span class="literal">false</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>interrupt()</code> + 判断中断状态</strong>：主线程调用 <code>interrupt()</code> 设置中断标志，线程通过 <code>isInterrupted()</code> 判断是否终止</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InterruptCheck</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="comment">// 正常执行逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread interrupted, exiting.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>处理中断异常：可中断阻塞操作（如 sleep&#x2F;wait&#x2F;join）</strong>：调用 <code>interrupt()</code> 后，线程在阻塞方法中抛出 <code>InterruptedException</code>，在异常处理中结束线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SleepInterruptDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>); <span class="comment">// 阻塞</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Interrupted during sleep.&quot;</span>);</span><br><span class="line">            Thread.currentThread().interrupt(); <span class="comment">// 恢复中断状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>return</code> 提前结束 <code>run()</code> 方法</strong>：配合中断标志或其他条件判断，在满足某条件时通过 <code>return</code> 直接结束 <code>run()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReturnEarlyDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 提前退出</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行任务逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线程池 + <code>Future.cancel(true)</code> 中断任务</strong>：将任务提交给线程池，通过 <code>Future.cancel(true)</code> 向线程发送中断信号来终止执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">Future&lt;?&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">future.cancel(<span class="literal">true</span>); <span class="comment">// 触发中断</span></span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>关闭资源解除不可中断阻塞（如 Socket.accept()）</strong>：对于不能响应中断的阻塞方法，通过关闭相关底层资源（如 <code>ServerSocket</code>）使其抛出异常退出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SocketTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerSocket server;</span><br><span class="line"></span><br><span class="line">    SocketTask(ServerSocket server) &#123; <span class="built_in">this</span>.server = server; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> server.accept(); <span class="comment">// 阻塞不可中断</span></span><br><span class="line">                <span class="comment">// 处理 socket</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Interrupted while blocked.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        server.close(); <span class="comment">// 触发 accept() 抛异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不推荐：使用 <code>Thread.stop()</code> 强制终止线程（已废弃）</strong>：直接停止线程执行，不会进行资源清理，存在严重安全隐患</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">/* 永久循环 */</span> &#125;</span><br><span class="line">&#125;);</span><br><span class="line">t.start();</span><br><span class="line">t.stop(); <span class="comment">// 已废弃，可能导致数据不一致</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="7-interrupt-是如何让线程抛出异常的"><a href="#7-interrupt-是如何让线程抛出异常的" class="headerlink" title="7# interrupt() 是如何让线程抛出异常的?"></a>7# interrupt() 是如何让线程抛出异常的?</h2><p>在 Java 中，每个线程都关联一个布尔类型的<strong>中断标志位</strong>，用于表示线程是否被中断。该标志的初始值为 <code>false</code>，可以通过调用线程的 <code>interrupt()</code> 方法将其设为 <code>true</code></p>
<p>当其他线程调用某个线程的 <code>interrupt()</code> 方法时，具体表现分为两种情况：</p>
<ul>
<li><p>如果线程<strong>处于阻塞状态</strong>：如果调用了 <code>Thread.sleep()</code>、<code>Thread.join()</code> 或 <code>Object.wait()</code> 等方法，则调用 <code>interrupt()</code> 会立即<strong>中断阻塞状态</strong>，并在该线程中<strong>抛出 <code>InterruptedException</code> 异常</strong>。此机制允许线程及时响应中断请求，跳出阻塞操作并执行善后处理</p>
</li>
<li><p>如果线程<strong>没有处于阻塞状态</strong>：此时调用 <code>interrupt()</code> 并不会抛出异常，仅仅是<strong>将中断标志设置为 <code>true</code></strong>。线程可以在运行过程中<strong>自行检查中断状态</strong>，例如通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.currentThread().isInterrupted();</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Thread.interrupted()) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>来自行决定是否退出当前任务，进行资源释放或中断处理</p>
</li>
</ul>
<h2 id="8-Java-线程的状态有哪些？"><a href="#8-Java-线程的状态有哪些？" class="headerlink" title="8# Java 线程的状态有哪些？"></a>8# Java 线程的状态有哪些？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1712648206670-824228d1-be28-449d-8509-fd4df4ff63d3.webp" alt="Java 线程状态变迁"></p>
<p>Java 中的线程状态由 <code>java.lang.Thread.State</code> 枚举类定义，总共有六种状态。你可以通过线程对象的 <code>getState()</code> 方法来获取当前线程所处的状态</p>
<table>
<thead>
<tr>
<th>线程状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>NEW</code></td>
<td>新建状态：线程对象已创建，但尚未调用 <code>start()</code> 方法，尚未启动执行</td>
</tr>
<tr>
<td><code>RUNNABLE</code></td>
<td>可运行状态：线程已调用 <code>start()</code>，处于<strong>就绪状态</strong>或<strong>正在运行</strong>中</td>
</tr>
<tr>
<td><code>BLOCKED</code></td>
<td>阻塞状态：线程尝试获取某个对象的监视器锁时被阻塞，等待锁的释放</td>
</tr>
<tr>
<td><code>WAITING</code></td>
<td>等待状态：线程无限期等待另一个线程执行某个操作（如 <code>notify()</code>）</td>
</tr>
<tr>
<td><code>TIMED_WAITING</code></td>
<td>超时等待状态：线程在指定时间内等待另一个线程的操作（如 <code>sleep()</code>、<code>join(long)</code>）</td>
</tr>
<tr>
<td><code>TERMINATED</code></td>
<td>终止状态：线程执行完毕或被异常中止，生命周期结束</td>
</tr>
</tbody></table>
<p><strong>补充说明</strong></p>
<ul>
<li><strong><code>RUNNABLE</code> 包含两种实际状态</strong>：<ul>
<li>就绪（Ready）：已准备好等待 CPU 分配时间片</li>
<li>运行中（Running）：正在由 CPU 执行</li>
</ul>
</li>
<li><strong><code>BLOCKED</code>、<code>WAITING</code> 和 <code>TIMED_WAITING</code></strong> 都表示线程处于非运行态，但它们的等待条件不同，需结合具体方法（如 <code>synchronized</code>、<code>wait()</code>、<code>sleep()</code> 等）来区分</li>
</ul>
<h2 id="9-sleep-和-wait-的区别是什么？"><a href="#9-sleep-和-wait-的区别是什么？" class="headerlink" title="9# sleep() 和 wait() 的区别是什么？"></a>9# sleep() 和 wait() 的区别是什么？</h2><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><code>sleep()</code></th>
<th><code>wait()</code></th>
</tr>
</thead>
<tbody><tr>
<td>所属类</td>
<td><code>Thread</code>（静态方法）</td>
<td><code>Object</code>（实例方法）</td>
</tr>
<tr>
<td>是否释放锁</td>
<td>不释放锁</td>
<td>会释放锁</td>
</tr>
<tr>
<td>使用前提</td>
<td>可在任何线程上下文中调用</td>
<td>必须在同步块或同步方法中调用（即持有对象锁）</td>
</tr>
<tr>
<td>唤醒方式</td>
<td>到达指定时间自动唤醒</td>
<td>需要其他线程调用 <code>notify()</code> &#x2F; <code>notifyAll()</code> 或超时</td>
</tr>
<tr>
<td>设计目的</td>
<td>使线程暂停指定时间，不涉及线程协作</td>
<td>用于线程之间通信与协作，主动释放锁进入等待队列</td>
</tr>
</tbody></table>
<p><strong>一、类归属不同</strong>：</p>
<ul>
<li><code>sleep()</code> 是 <code>Thread</code> 类的静态方法，通过 <code>Thread.sleep()</code> 调用，无需依赖对象实例</li>
<li><code>wait()</code> 是 <code>Object</code> 类的实例方法，必须通过对象调用，例如 <code>obj.wait()</code></li>
</ul>
<p><strong>二、是否释放锁</strong>：</p>
<ul>
<li><code>sleep()</code> 不释放任何锁，即使在同步代码块中调用，线程休眠期间仍然占有锁，其他线程无法访问同步资源</li>
<li><code>wait()</code> 会释放当前线程持有的对象锁，使其他线程可以获得该锁并继续执行</li>
</ul>
<p><strong>三、使用条件</strong>：</p>
<ul>
<li><code>sleep()</code> 可在任意代码位置调用，无需持有任何锁</li>
<li><code>wait()</code> 只能在同步块或同步方法中调用（即必须先获取该对象的监视器锁），否则会抛出 <code>IllegalMonitorStateException</code> 异常</li>
</ul>
<p><strong>四、唤醒机制</strong>：</p>
<ul>
<li><code>sleep()</code> 会在指定时间后自动唤醒，回到可运行状态等待 CPU 调度</li>
<li><code>wait()</code> 必须依赖 <code>notify()</code> 或 <code>notifyAll()</code> 显式唤醒，或设置超时时间（如 <code>wait(5000)</code>）后自动唤醒</li>
</ul>
<h2 id="10-sleep-会释放-CPU-吗？"><a href="#10-sleep-会释放-CPU-吗？" class="headerlink" title="10# sleep() 会释放 CPU 吗？"></a>10# sleep() 会释放 CPU 吗？</h2><p>是的，调用 <code>Thread.sleep()</code> 时，线程会<strong>释放 CPU 使用权</strong>，但<strong>不会释放它所持有的锁</strong></p>
<p>当线程执行 <code>Thread.sleep()</code> 方法时，它会<strong>进入 <code>TIMED_WAITING</code>（计时等待）状态</strong>，暂停执行指定的时间；在这段时间内，<strong>线程主动让出 CPU 时间片</strong>，操作系统会进行线程调度，将 CPU 分配给其他处于可运行状态的线程；这使得其他线程可以获得 CPU 并执行任务，从而提高系统的并发性能</p>
<p>虽然线程暂停执行，但<strong>不会释放它已持有的同步锁</strong>（例如通过 <code>synchronized</code> 获取的锁）。如果其他线程尝试获取这些锁，仍会被阻塞，直到当前线程恢复执行并释放锁</p>
<h2 id="11-BLOCKED-和-WAITING-有什么区别？"><a href="#11-BLOCKED-和-WAITING-有什么区别？" class="headerlink" title="11# BLOCKED 和 WAITING 有什么区别？"></a>11# BLOCKED 和 WAITING 有什么区别？</h2><p>Java 中线程的 <code>BLOCKED</code> 和 <code>WAITING</code> 状态都表示线程当前没有运行，但两者产生的原因和恢复机制完全不同，主要区别如下：</p>
<img src="https://cdn.xiaolincoding.com//picgo/93a0d1531ea1271770686b9e91664a9c.png" alt="线程竞争锁后的状态" style="zoom:50%;" />

<ol>
<li><strong>触发条件</strong>：<ul>
<li><strong><code>BLOCKED</code>（阻塞状态）</strong>：当线程尝试<strong>获取某个对象的锁</strong>（例如进入一个 <code>synchronized</code> 块或方法）而该锁已被其他线程占用时，线程会进入 <code>BLOCKED</code> 状态。此状态下线程在等待锁的释放，<strong>无法参与锁竞争</strong>，也不会执行任何指令</li>
<li><strong><code>WAITING</code>（等待状态）</strong>：当线程<strong>主动调用</strong>如 <code>Object.wait()</code>、<code>Thread.join()</code> 或 <code>LockSupport.park()</code> 方法时，会进入 <code>WAITING</code> 状态。此时线程进入<strong>无限期等待</strong>，线程将不会消耗 CPU 资源，并且不会参与锁的竞争</li>
</ul>
</li>
<li><strong>唤醒机制</strong>：<ul>
<li><strong><code>BLOCKED</code> 状态的线程</strong>会在持有锁的线程释放锁后，<strong>自动进入就绪（<code>RUNNABLE</code>）状态</strong>，并参与下一轮的锁竞争</li>
<li><strong><code>WAITING</code> 状态的线程</strong>不会自动唤醒，必须由其他线程显式地调用 <code>notify()</code>、<code>notifyAll()</code>、<code>unpark()</code> 等方法，或者使用 <code>join()</code> 等触发条件满足后，才会恢复运行</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>BLOCKED</code> 状态</th>
<th><code>WAITING</code> 状态</th>
</tr>
</thead>
<tbody><tr>
<td>触发方式</td>
<td>被动触发，等待锁的释放</td>
<td>主动调用等待方法（如 <code>wait()</code>、<code>join()</code>）</td>
</tr>
<tr>
<td>是否释放锁</td>
<td>❌ 不释放</td>
<td>✅ 调用 <code>wait()</code> 时会释放当前锁</td>
</tr>
<tr>
<td>唤醒机制</td>
<td>自动唤醒（当锁可用时）</td>
<td>必须显式唤醒（如 <code>notify()</code>）或条件满足</td>
</tr>
<tr>
<td>是否参与锁竞争</td>
<td>❌ 不参与</td>
<td>❌ 不参与，直到被唤醒</td>
</tr>
</tbody></table>
<ul>
<li><code>BLOCKED</code> 是因<strong>锁竞争失败被动进入</strong>的状态，<code>WAITING</code> 是线程<strong>主动进入等待</strong>的状态</li>
<li><code>BLOCKED</code> 的唤醒是<strong>自动的</strong>，<code>WAITING</code> 的唤醒是<strong>手动触发的</strong>。</li>
</ul>
<h2 id="12-线程处于-WAITING-状态时，如何恢复为-RUNNING-状态"><a href="#12-线程处于-WAITING-状态时，如何恢复为-RUNNING-状态" class="headerlink" title="12# 线程处于 WAITING 状态时，如何恢复为 RUNNING 状态?"></a>12# 线程处于 WAITING 状态时，如何恢复为 RUNNING 状态?</h2><p>核心机制是<strong>通过外部事件触发或资源可用性变化</strong>，比如<strong>其他线程调用 <code>notify()</code> 或 <code>notifyAll()</code> 唤醒它</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待线程</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    lock.wait();  <span class="comment">// 当前线程进入 WAITING 状态，并释放锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒线程</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    lock.notify();      <span class="comment">// 唤醒一个等待该锁的线程</span></span><br><span class="line">    <span class="comment">// lock.notifyAll(); // 唤醒所有在该锁上等待的线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<ul>
<li><code>notify()</code> 会随机唤醒一个正在该对象上等待的线程</li>
<li><code>notifyAll()</code> 会唤醒所有在该对象上等待的线程（通常用于多个线程等待同一条件的场景）</li>
<li>被唤醒的线程会重新尝试获取锁，<strong>一旦成功获取锁，就会从 <code>WAITING</code> 状态转为 <code>RUNNABLE</code>，最终进入 <code>RUNNING</code> 状态</strong>继续执行</li>
<li>如果唤醒后竞争锁失败，线程会暂时进入 <code>BLOCKED</code> 状态，直到成功获取锁</li>
</ul>
<h2 id="13-notify-和-notifyAll-的区别"><a href="#13-notify-和-notifyAll-的区别" class="headerlink" title="13# notify() 和 notifyAll() 的区别?"></a>13# notify() 和 notifyAll() 的区别?</h2><p>两者都用于唤醒因调用 <code>wait()</code> 而处于等待状态的线程，但在唤醒数量和行为上存在显著差异：</p>
<ul>
<li><strong>共同点</strong>：<ul>
<li>都只能在同步代码块或同步方法中调用</li>
<li>都会将等待中的线程从 <code>WAITING</code> 状态变为 <code>BLOCKED</code>，接着尝试竞争锁资源</li>
<li>被唤醒的线程只有在重新获得锁后才能继续执行</li>
</ul>
</li>
<li><strong>区别</strong>：<ul>
<li><code>notify()</code>：<strong>只唤醒一个</strong>正在等待当前对象锁的线程，具体唤醒哪个线程不可控。如果被唤醒的线程没有在运行过程中再次调用 <code>notify()</code> 或 <code>notifyAll()</code>，其他线程将继续处于等待状态，可能导致<strong>线程 “永久等待”</strong> 的问题（死锁风险）</li>
<li><code>notifyAll()</code>：<strong>唤醒所有</strong>等待当前对象锁的线程。所有被唤醒的线程将同时进入阻塞状态（<code>BLOCKED</code>），并竞争锁资源。最终只有一个线程获得锁并进入运行状态，其余线程继续等待锁，避免了遗漏唤醒的情况</li>
</ul>
</li>
<li><strong>推荐使用场景</strong>：<ul>
<li>当只有一个线程需要被唤醒时，可使用 <code>notify()</code></li>
<li>当可能有多个线程等待，且不能确定具体唤醒哪一个为最佳时，应使用 <code>notifyAll()</code>，以防遗漏唤醒导致系统阻塞</li>
</ul>
</li>
</ul>
<h2 id="14-notify-唤醒的是哪个线程"><a href="#14-notify-唤醒的是哪个线程" class="headerlink" title="14# notify() 唤醒的是哪个线程?"></a>14# notify() 唤醒的是哪个线程?</h2><p>从语义上讲，<code>notify()</code> 唤醒的是<strong>任意一个正在等待该对象锁的线程</strong>，具体唤醒哪一个线程，不在 Java 语言层面定义，而是<strong>由 JVM 的实现来决定的</strong></p>
<p>虽然规范中声明唤醒是 “非确定性” 的，但主流 JVM 实现（如 <strong>HotSpot</strong>）在内部的实际处理方式却并非真正随机：在 <strong>HotSpot JVM</strong> 中，<code>notify()</code> 通常按照**等待队列中的先后顺序（FIFO）**来唤醒线程，也就是说，<strong>先进入等待队列的线程，通常会先被唤醒</strong></p>
<h2 id="15-线程间通信方式有哪些？"><a href="#15-线程间通信方式有哪些？" class="headerlink" title="15# 线程间通信方式有哪些？"></a>15# 线程间通信方式有哪些？</h2><p><del><strong>太长不看版</strong></del></p>
<table>
<thead>
<tr>
<th>方案</th>
<th>适用场景</th>
<th>优点</th>
<th>注意点 &#x2F; 限制</th>
</tr>
</thead>
<tbody><tr>
<td><code>volatile</code> &#x2F; 共享变量</td>
<td>极简标志位、写少读多</td>
<td>语法简单</td>
<td>无法做复杂同步；需防 busy‑wait</td>
</tr>
<tr>
<td><code>wait/notify</code></td>
<td>经典线程协作</td>
<td>JDK 原生；释放锁</td>
<td>必须同步块；易误用</td>
</tr>
<tr>
<td><code>Lock</code> + <code>Condition</code></td>
<td>多条件、更高灵活度</td>
<td>可多队列；响应中断</td>
<td>需显式加&#x2F;解锁</td>
</tr>
<tr>
<td><code>BlockingQueue</code></td>
<td>生产‑消费模型、任务队列</td>
<td>封装好并发控制；易用</td>
<td>需选合适容量及实现</td>
</tr>
</tbody></table>
<ol>
<li><p><strong>共享变量（<code>volatile</code> &#x2F; <code>synchronized</code>）</strong>：多线程读写同一变量完成信息传递</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedVarDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;   <span class="comment">// 保证可见性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="comment">// 生产者</span></span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;Producer → flag=true&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="comment">// 消费者</span></span><br><span class="line">            <span class="keyword">while</span> (!flag) &#123; <span class="comment">/* busy‑wait */</span> &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer  ← flag=true&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> s)</span> &#123; <span class="keyword">try</span> &#123; Thread.sleep(s * <span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>volatile</code> → 可见性；若需原子更新，可配合 <code>synchronized</code> 或原子类</li>
<li><strong>缺点</strong>：忙等浪费 CPU；适合极简单的状态标志</li>
</ul>
</li>
<li><p><strong><code>wait/notify</code></strong>：线程在<strong>对象监视器</strong>上等待并释放锁，唤醒后再次竞争锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WaitNotifyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 消费者</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!ready) &#123;        <span class="comment">// 避免虚假唤醒</span></span><br><span class="line">                    <span class="keyword">try</span> &#123; lock.wait(); &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer  ← ready&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                ready = <span class="literal">true</span>;</span><br><span class="line">                lock.notify();          <span class="comment">// 或 notifyAll()</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Producer → notify&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> s)</span> &#123; <span class="keyword">try</span> &#123; Thread.sleep(s * <span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>必须</strong>在同步块&#x2F;同步方法内调用，否则抛 <code>IllegalMonitorStateException</code></p>
</li>
<li><p>建议 <code>while</code> 循环重判条件，防止虚假唤醒</p>
</li>
</ul>
</li>
<li><p><strong><code>Lock</code> + <code>Condition</code></strong>：<code>Condition</code> 提供与 <code>wait/notify</code> 等价但更灵活的 API，可配多条件队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LockConditionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">done</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 消费者</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!ready) done.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer  ← ready&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123; lock.unlock(); &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ready = <span class="literal">true</span>;</span><br><span class="line">                done.signal();          <span class="comment">// 或 signalAll()</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Producer → signal&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123; lock.unlock(); &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> s)</span> &#123; <span class="keyword">try</span> &#123; Thread.sleep(s * <span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>与 <code>wait/notify</code> 相比，可针对不同条件建多条等待队列，更易管理</li>
</ul>
</li>
<li><p><strong><code>BlockingQueue</code></strong>：使用 <strong>线程安全</strong> 的阻塞队列负责生产&#x2F;消费，完全无需显式加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BlockingQueueDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 消费者</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">item</span> <span class="operator">=</span> queue.take();                <span class="comment">// 阻塞直到有元素</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer  ← &quot;</span> + item);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">1</span>);                           <span class="comment">// 队列满则阻塞</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Producer → 1&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> s)</span> &#123; <span class="keyword">try</span> &#123; Thread.sleep(s * <span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>阻塞队列内部已处理好并发与等待逻辑，是<strong>最推荐</strong>的生产‑消费实现。</p>
</li>
<li><p>常见实现：<code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>、<code>SynchronousQueue</code> 等</p>
</li>
</ul>
</li>
</ol>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="1-juc-包下你常用的类有哪些？"><a href="#1-juc-包下你常用的类有哪些？" class="headerlink" title="1# juc 包下你常用的类有哪些？"></a>1# juc 包下你常用的类有哪些？</h2><p><strong>一、线程池相关</strong></p>
<ul>
<li><code>ThreadPoolExecutor</code>：最核心的线程池类，用于创建和管理线程池。通过它可以灵活地配置线程池的参数，如核心线程数、最大线程数、任务队列等，以满足不同的并发处理需求</li>
<li><code>Executors</code>：线程池工厂类，提供了一系列静态方法来创建不同类型的线程池，如 <code>newFixedThreadPool</code>（创建固定线程数的线程池）、<code>newCachedThreadPool</code>（创建可缓存线程池）、<code>newSingleThreadExecutor</code>（创建单线程线程池）等，方便开发者快速创建线程池</li>
</ul>
<p><strong>二、并发集合类</strong></p>
<ul>
<li><code>ConcurrentHashMap</code>：线程安全的哈希映射表，用于在多线程环境下高效地存储和访问键值对。它采用了分段锁等技术，允许多个线程同时访问不同的段，提高了并发性能，在高并发场景下比传统的 <code>Hashtable</code> 性能更好</li>
<li><code>CopyOnWriteArrayList</code>：线程安全的列表，在对列表进行修改操作时，会创建一个新的底层数组，将修改操作应用到新数组上，而读操作仍然可以在旧数组上进行，从而实现了读写分离，提高了并发读的性能，适用于读多写少的场景</li>
</ul>
<p><strong>三、同步工具类</strong></p>
<ul>
<li><code>CountDownLatch</code>：允许一个或多个线程等待其他一组线程完成操作后再继续执行。它通过一个计数器来实现，计数器初始化为线程的数量，每个线程完成任务后调用 <code>countDown()</code> 方法将计数器减一，当计数器为零时，等待的线程可以继续执行。常用于多个线程完成各自任务后，再进行汇总或下一步操作的场景</li>
<li><code>CyclicBarrier</code>：让一组线程互相等待，直到所有线程都到达某个屏障点后，再一起继续执行。与 <code>CountDownLatch</code> 不同的是，<code>CyclicBarrier</code> 可以重复使用，当所有线程都通过屏障后，计数器会重置，可以再次用于下一轮的等待。适用于多个线程需要协同工作，在某个阶段完成后再一起进入下一个阶段的场景</li>
<li><code>Semaphore</code>：信号量，用于控制同时访问某个资源的线程数量。它维护了一个许可计数器，线程在访问资源前需要获取许可，如果有可用许可，则获取成功并将许可计数器减一，否则线程需要等待，直到有其他线程释放许可。常用于控制对有限资源的访问，如数据库连接池、线程池中的线程数量等</li>
</ul>
<p><strong>四、原子类</strong></p>
<ul>
<li><code>AtomicInteger</code>：原子整数类，提供了对整数类型的原子操作，如自增、自减、比较并交换等。通过硬件级别的原子指令来保证操作的原子性和线程安全性，避免了使用锁带来的性能开销，在多线程环境下对整数进行计数、状态标记等操作非常方便</li>
<li><code>AtomicReference</code>：原子引用类，用于对对象引用进行原子操作。可以保证在多线程环境下，对对象的更新操作是原子性的，即要么全部成功，要么全部失败，不会出现数据不一致的情况。常用于实现无锁数据结构或需要对对象进行原子更新的场景</li>
</ul>
<h2 id="2-怎么保证多线程安全？"><a href="#2-怎么保证多线程安全？" class="headerlink" title="2# 怎么保证多线程安全？"></a>2# 怎么保证多线程安全？</h2><ol>
<li><strong><code>synchronized</code> 关键字</strong>：通过内置锁实现互斥访问，<code>Synchronized</code> 可用于修饰方法或代码块，确保同一时刻只有一个线程能访问同步区域。其本质是基于对象的监视器锁（monitor）机制</li>
<li><strong><code>volatile</code> 关键字</strong>：确保变量的可见性，使用 <code>volatile</code> 修饰的变量不会被线程缓存，所有线程访问的都是主内存中的最新值。适用于状态标志等无需原子性但需要可见性的场景</li>
<li><strong>显式锁 <code>Lock</code> 接口与 <code>ReentrantLock</code></strong>：更灵活的同步控制，<code>ReentrantLock</code> 是一种可重入互斥锁，提供了 <code>tryLock()</code>、<code>lockInterruptibly()</code> 等高级控制方式，相较 <code>synchronized</code> 更灵活</li>
<li><strong>原子类（<code>AtomicInteger</code> 等）</strong>：原子性操作无需加锁，<code>java.util.concurrent.atomic</code> 包提供了多种原子类，支持无锁线程安全操作，适用于高并发计数、状态标志等场景</li>
<li><strong>线程局部变量（<code>ThreadLocal</code>）</strong>：每个线程独享变量副本，<code>ThreadLocal</code> 为每个线程提供独立的变量副本，避免了共享带来的同步问题，适合线程封闭（Thread Confinement）场景</li>
<li><strong>并发集合类</strong>：内置线程安全机制，使用 <code>java.util.concurrent</code> 包中的并发集合（如 <code>ConcurrentHashMap</code>、<code>ConcurrentLinkedQueue</code> 等）可以避免手动加锁，提升并发性能</li>
<li><strong>JUC 工具类</strong>：协调线程间协作，Java 并发包提供了一系列同步工具类，用于线程间的通信与协作控制，如：<code>Semaphore</code>（限制并发线程数）、<code>CountDownLatch</code>（等待多个线程完成任务）、<code>CyclicBarrier</code>（多线程在屏障点统一继续执行）、<code>Exchanger</code>（线程间交换数据）</li>
</ol>
<h2 id="3-Java-中有哪些常用的锁？各自适用于什么场景？"><a href="#3-Java-中有哪些常用的锁？各自适用于什么场景？" class="headerlink" title="3# Java 中有哪些常用的锁？各自适用于什么场景？"></a>3# Java 中有哪些常用的锁？各自适用于什么场景？</h2><p>在多线程编程中，锁是保障线程安全、避免并发冲突的核心机制</p>
<ol>
<li><strong>内置锁（synchronized）</strong>：最基本的互斥机制，<code>Synchronized</code> 是 Java 内置的同步机制，用于修饰方法或代码块。线程在进入同步区域前需要获取锁，离开后自动释放，保证同一时间只有一个线程能访问被保护的资源。其中，<code>syncronized</code> 加锁时有无锁、偏向锁、轻量级锁和重量级锁几个级别。偏向锁用于当一个线程进入同步块时，如果没有任何其他线程竞争，就会使用偏向锁，以减少锁的开销。轻量级锁使用线程栈上的数据结构，避免了操作系统级别的锁。重量级锁则涉及操作系统级的互斥锁</li>
<li><strong>可重入锁（<code>ReentrantLock</code>）</strong>：功能更强的显式锁，<code>ReentrantLock</code> 是 <code>java.util.concurrent.locks</code> 包中的显式锁，功能上比 <code>synchronized</code> 更灵活，支持<strong>可中断锁获取、限时等待锁、公平锁&#x2F;非公平锁切换、多条件变量（Condition）支持</strong>等。<code>ReentrantLock</code> 使用 <code>lock()</code> 和 <code>unlock()</code> 方法来获取和释放锁。其中，公平锁按照线程请求锁的顺序来分配锁，保证了锁分配的公平性，但可能增加锁的等待时间。非公平锁不保证锁分配的顺序，可以减少锁的竞争，提高性能，但可能造成某些线程的饥饿</li>
<li><strong>读写锁（ReadWriteLock）</strong>：提高读多写少场景的并发性，<code>ReadWriteLock</code> 允许多个线程并发读取共享资源，但写操作是独占的。常见实现如 <code>ReentrantReadWriteLock</code></li>
<li><strong>乐观锁和悲观锁</strong>：<strong>悲观锁（Pessimistic Locking）</strong>：默认认为并发冲突频繁，访问数据前先加锁，如 <code>synchronized</code> 和 <code>ReentrantLock</code>；<strong>乐观锁（Optimistic Locking）</strong>：假设冲突很少，不加锁而是通过版本号或时间戳在更新时校验数据是否被修改，常用 <code>CAS</code> 机制实现</li>
<li><strong>自旋锁（SpinLock）</strong>：短时等待情况下的非阻塞锁机制，自旋锁不会让线程阻塞，而是持续循环尝试获取锁（通常基于 <code>CAS</code> 操作）。适合锁竞争时间非常短的场景，避免线程频繁上下文切换</li>
</ol>
<h2 id="4-怎么在实践中用锁的？"><a href="#4-怎么在实践中用锁的？" class="headerlink" title="4# 怎么在实践中用锁的？"></a>4# 怎么在实践中用锁的？</h2><p><del><strong>太长不看版</strong></del></p>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>使用方式示例</th>
<th>优点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>synchronized</code></td>
<td><code>synchronized</code> 方法或代码块</td>
<td>简单易用、JVM 自动管理</td>
<td>一般同步逻辑</td>
</tr>
<tr>
<td><code>ReentrantLock</code></td>
<td><code>lock()</code> &#x2F; <code>unlock()</code></td>
<td>可中断、公平锁、尝试锁等高级功能</td>
<td>对同步控制要求更高的场景</td>
</tr>
<tr>
<td><code>ReadWriteLock</code></td>
<td><code>readLock()</code> &#x2F; <code>writeLock()</code></td>
<td>多读并发、写独占、提升读多写少性能</td>
<td>缓存、配置读取等并发读取场景</td>
</tr>
</tbody></table>
<ol>
<li><p><strong>使用 <code>synchronized</code> 实现简单互斥</strong>：<code>synchronized</code> 是 Java 中最早的同步机制，可用于方法或代码块，隐式地为指定对象加锁，保证同一时间只有一个线程执行被保护的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步代码块</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> ( ) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用代码块可以灵活控制加锁粒度，并避免同步整个方法带来的性能损耗</p>
</li>
<li><p><strong>使用 <code>Lock</code> 接口实现显式加锁</strong>：<code>Lock</code> 接口提供了比 <code>synchronized</code> 更强大的锁控制能力，如<strong>可中断锁</strong>、<strong>限时尝试锁</strong>、<strong>公平锁</strong>等。<code>ReentrantLock</code> 是最常用的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 显式加锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 确保锁最终释放，避免死锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>try-finally</code> 块是使用 <code>Lock</code> 的规范做法，以确保即使抛出异常也能正确释放锁</p>
</li>
<li><p><strong>使用 <code>ReadWriteLock</code> 提升读多写少的并发性能</strong>：<code>ReadWriteLock</code> 提供一对互斥锁：<strong>读锁（<code>readLock()</code>）</strong> 和 <strong>写锁（<code>writeLock()</code>）</strong>。它允许多个线程同时读取数据，但写操作必须是独</p>
</li>
<li><p>占的。典型实现为 <code>ReentrantReadWriteLock</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">readData</span><span class="params">()</span> &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeData</span><span class="params">(Object newData)</span> &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data = newData;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个线程可以同时读取 <code>data</code>，而写操作则是互斥的，这种设计大幅提升了<strong>读多写少场景</strong>的并发性能</p>
</li>
</ol>
<h2 id="5-Java-并发工具你知道哪些？"><a href="#5-Java-并发工具你知道哪些？" class="headerlink" title="5# Java 并发工具你知道哪些？"></a>5# Java 并发工具你知道哪些？</h2><p>Java 的并发工具类大多位于 <code>java.util.concurrent</code> 包中，提供了丰富的 API 来简化并发编程。这里主要提供代码参考，它们的详细概念见 [1# juc 包下你常用的类有哪些？](#1# juc 包下你常用的类有哪些？)</p>
<ol>
<li><p><code>CountDownLatch</code> 是一个同步辅助类，它允许一个或多个线程等待其他线程完成一组操作。它通过一个倒计时计数器来协调线程之间的执行顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行任务&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                latch.countDown();  <span class="comment">// 任务完成，计数器减一</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成任务&quot;</span>);</span><br><span class="line">            &#125;, <span class="string">&quot;Worker-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程等待所有子线程完成...&quot;</span>);</span><br><span class="line">        latch.await();  <span class="comment">// 阻塞直到计数器为 0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;所有子线程已完成，主线程继续执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>CyclicBarrier</code> 允许一组线程互相等待，直到所有线程都到达屏障点（barrier）为止，然后一同继续执行。它可以循环使用，适合分阶段并行计算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(threadCount, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;所有线程已到达屏障，执行后续操作&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行任务&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    barrier.await();  <span class="comment">// 等待其他线程</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 通过屏障&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;Worker-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Semaphore</code> 是一个计数信号量，用于控制同时访问某资源的线程数量。可用于流量控制、资源池等场景</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">2</span>);  <span class="comment">// 同时允许两个线程访问</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();  <span class="comment">// 获取许可</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获得许可&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);  <span class="comment">// 模拟处理资源</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放许可&quot;</span>);</span><br><span class="line">                    semaphore.release();  <span class="comment">// 释放许可</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;Worker-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Callable</code> 接口类似于 <code>Runnable</code>，但可以返回结果或抛出异常。<code>Future</code> 表示异步任务的结果，用于查询任务是否完成、取消任务或获取结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureCallableExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        Callable&lt;Integer&gt; task = () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行任务&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt; future = executor.submit(task);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程继续执行其他任务&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get();  <span class="comment">// 阻塞直到结果返回</span></span><br><span class="line">        System.out.println(<span class="string">&quot;异步任务结果: &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ConcurrentHashMap</code> 是高并发环境下的线程安全哈希表。它在内部对桶进行分段锁处理，支持高效的并发读写操作，适用于读多写少或高并发环境</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMapExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ConcurrentHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;key1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key2&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并发读操作</span></span><br><span class="line">        map.forEach((key, value) -&gt; System.out.println(key + <span class="string">&quot;: &quot;</span> + value));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并发写操作</span></span><br><span class="line">        map.computeIfAbsent(<span class="string">&quot;key3&quot;</span>, k -&gt; <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="6-CountDownLatch-是做什么的？"><a href="#6-CountDownLatch-是做什么的？" class="headerlink" title="6# CountDownLatch 是做什么的？"></a>6# CountDownLatch 是做什么的？</h2><p><code>CountDownLatch</code> 是 Java 并发包（<code>java.util.concurrent</code>）中的一个同步辅助类，用于<strong>让一个或多个线程等待其他线程完成任务后再继续执行</strong></p>
<p>它的核心机制是一个<strong>计数器</strong>（Counter），常用于多线程协作场景，例如主线程等待多个子线程就绪、任务分批执行等，工作原理：</p>
<ol>
<li><strong>初始化计数器</strong>：创建 <code>CountDownLatch</code> 时指定一个初始计数值（如 <code>N</code>）</li>
<li><strong>等待阻塞</strong>：调用 <code>await()</code> 方法的线程会被阻塞，直到计数器变为 0</li>
<li><strong>计数递减</strong>：其他线程完成任务后调用 <code>countDown()</code> 方法，使计数器减 1</li>
<li><strong>唤醒等待线程</strong>：当计数器归零，所有调用了 <code>await()</code> 的线程将被唤醒，继续执行</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainThreadWaitExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在执行任务&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">                    latch.countDown();  <span class="comment">// 当前线程完成，计数器减 1</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成任务&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;Worker-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程等待所有子线程完成任务...&quot;</span>);</span><br><span class="line">        latch.await(); <span class="comment">// 主线程阻塞，直到所有子线程完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;所有任务已完成，主线程继续执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-synchronized-的工作原理？"><a href="#7-synchronized-的工作原理？" class="headerlink" title="7# synchronized 的工作原理？"></a>7# synchronized 的工作原理？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1719918642412-181e3769-49d8-4c78-8f33-a866367a4693.png" alt="synchronized 的工作原理"></p>
<ol>
<li><p><strong>编译层：生成字节码指令</strong></p>
<ul>
<li>在同步代码块（或同步方法）前后，编译器会插入 <code>monitorenter</code> &#x2F; <code>monitorexit</code> 指令</li>
<li>这两条指令由 JVM 调用 <strong>对象监视器（Monitor）</strong> 完成加锁与解锁</li>
</ul>
</li>
<li><p><strong>运行时：Monitor 的加锁 &#x2F; 解锁流程</strong></p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>① 线程执行 <code>monitorenter</code></td>
<td>尝试获取对象监视器： • 若对象<strong>未被锁定</strong>或<strong>当前线程已持有</strong>锁⇒ 计数器 <code>+1</code>，线程继续执行； • 否则将线程加入 <strong>EntryList</strong>，进入 <strong>BLOCKED</strong> 状态，等待锁可用。</td>
</tr>
<tr>
<td>② 线程执行 <code>monitorexit</code></td>
<td>将计数器 <code>-1</code>；当计数器变为 <strong>0</strong> 时： • 释放锁； • 从 <strong>EntryList</strong> 取出一个线程（或按公平策略）尝试获取锁。</td>
</tr>
</tbody></table>
<p><strong>Wait &#x2F; Notify 机制</strong></p>
<ul>
<li>当线程在同步块内调用 <code>wait()</code>：释放锁，计数器 <code>-1</code>，自身进入 <strong>WaitSet</strong></li>
<li>其他线程执行 <code>notify()</code> &#x2F; <code>notifyAll()</code> 会将 WaitSet 中的线程移动到 EntryList，再次参与锁竞争</li>
</ul>
</li>
<li><p><strong>内存语义</strong></p>
<ul>
<li><strong>加锁</strong>：先 <strong>清空当前线程工作内存</strong> 中共享变量，再从主内存读取，保证后续操作能看到最新值</li>
<li><strong>解锁</strong>：将工作内存中被修改的共享变量 <strong>刷新回主内存</strong>，保证其他线程可见</li>
</ul>
</li>
<li><p><strong>锁的性质与性能影响</strong></p>
<ul>
<li><code>synchronized</code> 属于 <strong>排他锁</strong>（互斥锁），同一时刻只能有一个线程持有</li>
<li>Java 线程与 OS 原生线程 1:1 对应，阻塞 &#x2F; 唤醒需要从<strong>用户态切换到内核态</strong>，成本较高</li>
<li>JVM 为降低开销引入 <strong>偏向锁、轻量级锁、重量级锁</strong> 的分级优化策略，尽量在用户态完成自旋或 CAS 竞争，仅在竞争激烈时才升级为重量级锁</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<p><code>synchronized</code> 通过 <strong>对象监视器</strong> 保证了：</p>
<ul>
<li><strong>原子性</strong>：同一时刻只有一个线程进入同步块</li>
<li><strong>可见性 &amp; 有序性</strong>：锁的释放与获取隐式包含内存屏障，满足 happens‑before 规则</li>
</ul>
<p>在实际编码中，只需使用 <code>synchronized</code> 关键字即可享受上述语义；理解其底层机制能帮助我们在性能调优、死锁排查等场景中更有针对性地分析问题</p>
<h2 id="8-除了用-synchronized，还有哪些方式可以实现线程同步？"><a href="#8-除了用-synchronized，还有哪些方式可以实现线程同步？" class="headerlink" title="8# 除了用 synchronized，还有哪些方式可以实现线程同步？"></a>8# 除了用 synchronized，还有哪些方式可以实现线程同步？</h2><ol>
<li><strong>使用 <code>ReentrantLock</code> 类</strong>：<code>ReentrantLock</code> 是一个可重入的互斥锁，相比 <code>synchronized</code> 提供了更灵活的锁定和解锁操作。它还支持公平锁和非公平锁，以及可以响应中断的锁获取操作</li>
<li><strong>使用<code>volatile</code>关键字</strong>：虽然 <code>volatile</code> 不是一种锁机制，但它可以确保变量的可见性。当一个变量被声明为 <code>volatile</code> 后，线程将直接从主内存中读取该变量的值，这样就能保证线程间变量的可见性。但它不具备原子性</li>
<li><strong>使用<code>Atomic</code>类</strong>：Java 提供了一系列的原子类，例如 <code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicReference </code>等，用于实现对单个变量的原子操作，这些类在实现细节上利用了 CAS（Compare-And-Swap）算法，可以用来实现无锁的线程安全</li>
</ol>
<h2 id="9-synchronized-锁静态方法与普通方法的区别"><a href="#9-synchronized-锁静态方法与普通方法的区别" class="headerlink" title="9# synchronized 锁静态方法与普通方法的区别"></a>9# synchronized 锁静态方法与普通方法的区别</h2><ol>
<li><p><strong>锁的对象不同</strong></p>
<ul>
<li><p><strong>普通方法</strong>：锁的是当前对象实例（<code>this</code>）。<strong>同一个对象实例</strong>的多个线程访问同步方法时会互斥；而<strong>不同实例对象</strong>之间互不干扰，可以并发执行各自的同步方法</p>
</li>
<li><p><strong>静态方法</strong>：锁的是当前类的 <code>Class</code> 对象（<code>ClassName.class</code>）。JVM 中每个类对应唯一一个 <code>Class</code> 对象，因此无论多少个实例，访问静态同步方法时都竞争同一把锁</p>
</li>
</ul>
</li>
<li><p><strong>作用范围不同</strong></p>
<ul>
<li><p><strong>普通方法</strong>：仅对<strong>同一对象实例</strong>的同步方法调用互斥，<strong>不同实例</strong>的调用互不干扰</p>
</li>
<li><p><strong>静态方法</strong>：对<strong>整个类范围内的该静态方法调用都互斥</strong>，无论是哪个实例，甚至没有实例化对象时也是如此</p>
</li>
</ul>
</li>
<li><p><strong>多实例场景影响不同</strong></p>
<ul>
<li><p><strong>普通方法</strong>：如果多个线程访问<strong>不同对象实例的同步普通方法</strong>，由于锁对象不同，它们之间<strong>可以并发执行</strong></p>
</li>
<li><p><strong>静态方法</strong>：而多个线程访问<strong>静态同步方法</strong>，即使是通过不同实例调用，<strong>也会串行执行</strong>，因为它们竞争的是同一个 <code>Class</code> 对象锁</p>
</li>
</ul>
</li>
</ol>
<h2 id="10-讲一下-synchronized-的锁升级过程"><a href="#10-讲一下-synchronized-的锁升级过程" class="headerlink" title="10# 讲一下 synchronized 的锁升级过程"></a>10# 讲一下 synchronized 的锁升级过程</h2><p>具体的锁升级的过程是：<strong>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</strong></p>
<ol>
<li><strong>无锁</strong>：在对象创建初期，处于无锁状态，此时对象的对象头（Mark Word）中未记录线程相关信息，如果 JVM 未开启偏向锁（或偏向锁延迟生效），线程进入同步块将直接尝试升级为轻量级锁</li>
<li><strong>偏向锁</strong>：当对象第一次被某线程获取锁时，Mark Word 会记录该线程的 ID，之后该线程再次进入同步块时，只需比较 Mark Word 中的线程 ID 是否匹配，即可直接获取锁，无需 CAS 操作，也不会挂起线程；如果另一个线程尝试获取偏向锁，会触发 <strong>偏向锁撤销</strong>，撤销后锁升级为<strong>轻量级锁</strong>，同时偏向锁将不可再用于该对象（或类）</li>
<li><strong>轻量级锁</strong>：适用于多线程存在竞争，但<strong>竞争不激烈</strong>的场景。当前线程在进入同步块时，在自己虚拟机栈中创建 <strong>锁记录（Lock Record）</strong>，并将对象的 Mark Word 复制到锁记录中，然后尝试通过 <strong>CAS</strong> 将对象头中的 Mark Word 替换为指向这个锁记录的指针，如果 CAS 成功，表示线程获得锁；如果 CAS 失败，说明有其他线程竞争该锁 —— 进入自旋尝试再次获取，自旋多次仍无法获取，则升级为重量级锁</li>
<li><strong>重量级锁</strong>：发生在多线程高竞争场景。无法通过自旋获取锁的线程将被 <strong>挂起</strong>（阻塞），由操作系统调度，等待唤醒，重量级锁的获取和释放涉及<strong>用户态与内核态切换</strong>，开销较大，但保证线程安全</li>
</ol>
<img src="https://cdn.xiaolincoding.com//picgo/1721808326210-cce43537-20e7-4b7d-bed3-737dc7904d9a.png" alt="synchronized 的锁升级过程" style="zoom: 33%;" />

<ul>
<li><p><strong>线程 A</strong> 首次进入 <code>synchronized</code> 块：</p>
<ul>
<li>如果偏向锁已启用且对象未被锁定，则偏向 A，记录其线程 ID</li>
<li>A 再次进入同步代码时，<strong>直接命中偏向锁</strong>，无阻塞、无 CAS</li>
</ul>
</li>
<li><p><strong>线程 B</strong> 也尝试获取锁：</p>
<ul>
<li><p>偏向锁被撤销，升级为轻量级锁</p>
</li>
<li><p>B 通过自旋尝试获取锁</p>
</li>
<li><p>如果自旋失败，锁升级为重量级，B 被挂起等待唤醒</p>
</li>
</ul>
</li>
</ul>
<h2 id="11-JVM-对-synchronized-的优化机制"><a href="#11-JVM-对-synchronized-的优化机制" class="headerlink" title="11# JVM 对 synchronized 的优化机制"></a>11# JVM 对 synchronized 的优化机制</h2><ol>
<li><p><strong>锁膨胀</strong>：<code>synchronized</code> 支持从<strong>无锁 → 偏向锁 → 轻量级锁 → 重量级锁</strong>的渐进式升级过程（也称“锁膨胀”）：初始状态为无锁，当一个线程独占锁时，使用 <strong>偏向锁</strong>，几乎无性能开销。有线程竞争时升级为 <strong>轻量级锁</strong>，通过 CAS 和自旋尝试获取锁。多线程竞争激烈、自旋失败后，升级为 <strong>重量级锁</strong>，线程阻塞、由操作系统调度。这一机制极大减少了用户态与内核态之间的切换，提升了 <code>synchronized</code> 的性能</p>
</li>
<li><p><strong>锁消除</strong>：指的是在某些情况下，JVM 虚拟机如果检测不到某段代码被共享和竞争的可能性，就会将这段代码所属的同步锁消除掉，从而到底提高程序性能的目的</p>
</li>
<li><p><strong>锁粗化</strong>：如果 JVM 发现某个线程在<strong>短时间内频繁进行加锁和解锁操作</strong>，则会将这些操作合并成一个<strong>更大粒度的锁范围</strong></p>
</li>
<li><p><strong>自适应自旋锁</strong>：如果锁在短时间内就能被释放，则自旋线程可以快速获得锁，避免线程挂起&#x2F;恢复所造成的性能开销。若线程在之前的自旋中成功获取过锁，则可能增加下一次的自旋次数；若多次自旋失败，则减少自旋次数甚至不再自旋，直接阻塞</p>
</li>
</ol>
<h2 id="12-怎么理解可重入锁？"><a href="#12-怎么理解可重入锁？" class="headerlink" title="12#  怎么理解可重入锁？"></a>12#  怎么理解可重入锁？</h2><p><strong>可重入锁</strong>指的是：<strong>同一个线程在已经获取锁的情况下，仍然可以再次获取该锁而不会发生死锁</strong>。这种机制确保了在方法调用嵌套或递归时，线程不会因为已经持有的锁而被自己阻塞</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">outer</span><span class="params">()</span> &#123;</span><br><span class="line">    inner(); <span class="comment">// inner 也是 synchronized 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">inner</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果锁不具备可重入性，那么线程在调用 <code>outer()</code> 后再次尝试进入 <code>inner()</code> 时就会阻塞自己，造成死锁。而使用可重入锁机制，线程能够<strong>顺利重入</strong>，程序才能正常执行</p>
<p><code>ReentrantLock</code> 是 <code>java.util.concurrent.locks</code> 包下的可重入互斥锁，其可重入机制的核心是<strong>锁持有线程记录和重入计数器</strong>：</p>
<ul>
<li>当一个线程<strong>首次获取锁</strong>时：锁的持有线程被设置为当前线程，重入计数器设置为 <code>1</code></li>
<li>当该线程<strong>再次获取该锁</strong>时：如果判断当前线程已是锁的持有者，则只需将计数器加 <code>1</code>，<strong>不会被阻塞</strong></li>
<li>当线程执行完毕，<strong>释放锁时</strong>：每释放一次锁，计数器减 <code>1</code>，<strong>只有当计数器减为 0 时</strong>，锁才真正释放，其他线程才有机会获取</li>
</ul>
<p>这种计数机制避免了重复阻塞和死锁问题</p>
<h2 id="13-synchronized-支持重入吗？如何实现的？"><a href="#13-synchronized-支持重入吗？如何实现的？" class="headerlink" title="13# synchronized 支持重入吗？如何实现的？"></a>13# synchronized 支持重入吗？如何实现的？</h2><p>是的，<code>synchronized</code> 是<strong>可重入锁</strong>。这意味着：<strong>同一个线程在已经持有某个对象锁的情况下，可以再次获取该对象的锁而不会被阻塞</strong>。例如，在一个 <code>synchronized</code> 方法中调用该对象的另一个 <code>synchronized</code> 方法，当前线程不会因为再次请求锁而被挂起，这正是可重入性的体现</p>
<p><strong>如何实现？</strong></p>
<p><code>synchronized</code> 的底层实现依赖于 JVM 的<strong>监视器锁机制</strong>，而这些监视器锁通常是通过操作系统的 <strong>互斥量</strong> 实现的。其内部维护了两个核心状态：<strong>锁的持有线程和重入计数器</strong></p>
<ol>
<li><p><strong>锁的获取流程</strong></p>
<ul>
<li><p>**当线程首次请求锁：**检查锁的状态，若当前锁未被持有（状态为 0），则通过 CAS操作设置当前线程为锁持有者，同时将锁状态设为 1</p>
</li>
<li><p><strong>当锁已被占用时：<strong>如果当前线程再次请求该锁（即线程 ID 与持有锁线程一致），表示是重入，允许请求成功，并将</strong>重入计数器加 1</strong>；否则，线程将进入阻塞状态，等待锁释放</p>
<ol start="2">
<li><strong>锁的释放流程</strong></li>
</ol>
<ul>
<li>当线程执行完同步代码块或方法后，会释放锁</li>
<li>对于可重入锁，<strong>每释放一次锁，重入计数器减 1</strong>，仅当计数器减到 0 时，锁才真正释放，其他线程才能竞争该锁</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="14-ReentrantLock-工作原理"><a href="#14-ReentrantLock-工作原理" class="headerlink" title="14# ReentrantLock 工作原理"></a>14# ReentrantLock 工作原理</h2><p>ReentrantLock 的底层实现主要依赖于 AbstractQueuedSynchronizer（AQS）这个抽象类。AQS 是一个提供了基本同步机制的框架，其中包括了队列、状态值等</p>
<p>ReentrantLock 在 AQS 的基础上通过内部类 Sync 来实现具体的锁操作。不同的 Sync 子类实现了公平锁和非公平锁的不同逻辑：</p>
<ul>
<li><p><strong>可中断性</strong>： ReentrantLock 实现了可中断性，这意味着线程在等待锁的过程中，可以被其他线程中断而提前结束等待。在底层，ReentrantLock 使用了与 LockSupport.park() 和 LockSupport.unpark() 相关的机制来实现可中断性</p>
</li>
<li><p><strong>设置超时时间</strong>： ReentrantLock 支持在尝试获取锁时设置超时时间，即等待一定时间后如果还未获得锁，则放弃锁的获取。这是通过内部的 tryAcquireNanos 方法来实现的</p>
</li>
<li><p><strong>公平锁和非公平锁</strong>： 在直接创建 ReentrantLock 对象时，默认情况下是非公平锁。公平锁是按照线程等待的顺序来获取锁，而非公平锁则允许多个线程在同一时刻竞争锁，不考虑它们申请锁的顺序。公平锁可以通过在创建 ReentrantLock 时传入 true 来设置，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>多个条件变量</strong>： ReentrantLock 支持多个条件变量，每个条件变量可以与一个 ReentrantLock 关联。这使得线程可以更灵活地进行等待和唤醒操作，而不仅仅是基于对象监视器的 wait() 和 notify()。多个条件变量的实现依赖于 Condition 接口，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="comment">// 使用下面方法进行等待和唤醒</span></span><br><span class="line">condition.await();</span><br><span class="line">condition.signal();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>可重入性</strong>： ReentrantLock 支持可重入性，即同一个线程可以多次获得同一把锁，而不会造成死锁。这是通过内部的 holdCount 计数来实现的。当一个线程多次获取锁时，holdCount 递增，释放锁时递减，只有当 holdCount 为零时，其他线程才有机会获取锁</p>
</li>
</ul>
<h2 id="15-synchronized-和-ReentrantLock-的区别"><a href="#15-synchronized-和-ReentrantLock-的区别" class="headerlink" title="15# synchronized 和 ReentrantLock 的区别"></a>15# synchronized 和 ReentrantLock 的区别</h2><p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是 Java 中常用的<strong>可重入锁机制</strong>，用于实现线程间的互斥访问，但它们在语法、特性和底层实现等方面存在显著差异</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>synchronized</th>
<th>ReentrantLock</th>
</tr>
</thead>
<tbody><tr>
<td><strong>语法使用</strong></td>
<td>关键字形式，可修饰方法或代码块</td>
<td>通过显式调用 <code>lock()</code> 和 <code>unlock()</code> 进行加锁与释放，仅支持代码块</td>
</tr>
<tr>
<td><strong>加锁&#x2F;释放机制</strong></td>
<td>自动加锁与释放，进入同步块即加锁，退出即释放</td>
<td>需手动加锁与释放，必须配合 <code>try-finally</code> 使用避免死锁</td>
</tr>
<tr>
<td><strong>锁的公平性</strong></td>
<td>默认非公平，无法更改</td>
<td>支持公平锁（先到先得）与非公平锁（默认），通过构造函数设置</td>
</tr>
<tr>
<td><strong>中断响应能力</strong></td>
<td>不支持中断，线程在等待锁时无法被中断</td>
<td>支持中断，如 <code>lockInterruptibly()</code> 可响应中断，适用于死锁恢复</td>
</tr>
<tr>
<td><strong>条件变量支持</strong></td>
<td>支持单一条件队列（即 <code>wait()</code> &#x2F; <code>notify()</code>）</td>
<td>支持多个条件变量，基于 <code>Condition</code> 对象，控制更精细</td>
</tr>
<tr>
<td><strong>性能差异</strong></td>
<td>在现代 JVM 中性能已大幅优化，轻量、适合简单场景</td>
<td>灵活性强，适用于高并发场景，但使用复杂度稍高</td>
</tr>
<tr>
<td><strong>底层实现</strong></td>
<td>基于 JVM 实现，使用对象的<strong>监视器锁（Monitor）</strong>，生成 <code>monitorenter/monitorexit</code> 字节码</td>
<td>基于 AQS（AbstractQueuedSynchronizer）实现</td>
</tr>
</tbody></table>
<h2 id="16-介绍一下-AQS"><a href="#16-介绍一下-AQS" class="headerlink" title="16# 介绍一下 AQS"></a>16# 介绍一下 AQS</h2><p><strong>一、简介</strong></p>
<p>AQS 是 Java 提供的一个用于构建锁和同步器的抽象类，位于 <code>java.util.concurrent.locks</code> 包中。它是并发包的核心组件之一，被广泛应用于构建如 <code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code>、<code>ReentrantReadWriteLock</code>、<code>FutureTask</code> 等高级并发工具类</p>
<p>AQS 的核心思想是：<strong>如果共享资源空闲，则当前线程可直接获取锁；否则，线程需进入队列等待，直到被唤醒重新尝试获取锁</strong>。这个等待机制基于 <strong>CLH（Craig, Landin, and Hagersten）队列的变体</strong> —— 一个 <strong>虚拟的双向 FIFO 队列</strong>。AQS 会将每个请求资源但未成功的线程封装成一个 <code>Node</code> 节点，并串联到队列中，形成有序等待</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1721809581196-7c09ce04-1429-4810-ade4-bb3098a9303d.png" alt="CLH 变体队列"></p>
<p><strong>二、AQS 的核心组成</strong></p>
<p>AQS 的工作机制可以拆解为以下三大核心部分：</p>
<ol>
<li><p><strong>同步状态 <code>state</code></strong>：AQS 通过一个 <code>volatile int state</code> 变量来表示当前的同步状态，在不同的同步器中，<code>state</code> 表示不同含义：在 <code>ReentrantLock</code> 中：表示锁的重入次数；在 <code>Semaphore</code> 中：表示剩余的许可证数量；在 <code>CountDownLatch</code> 中：表示计数器的剩余数量</p>
<p>AQS 提供如下原子操作方法对 <code>state</code> 进行管理，这些操作基于底层的 <strong>Unsafe 类</strong> 和 CAS 机制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getState()</span><br><span class="line">setState(<span class="type">int</span> newState)</span><br><span class="line">compareAndSetState(<span class="type">int</span> expect, <span class="type">int</span> update)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>FIFO 同步队列（CLH 变体）</strong>：当线程无法成功获取同步状态时，它会被封装为一个 <code>Node</code> 并加入到 AQS 内部维护的 <strong>FIFO 双向等待队列</strong>中。该队列保证了线程获取锁的<strong>先来先服务</strong>原则，同时用于线程的阻塞与唤醒管理</p>
<p>AQS 就像一个“<strong>线程调度管家</strong>”，协调着所有竞争资源的线程：排队入列；等待唤醒；出队重新尝试获取锁</p>
</li>
<li><p><strong>获取与释放的模板方法（需子类实现）</strong>：AQS 通过模板方法设计模式，将核心的锁获取与释放逻辑交给具体的同步器子类实现。常用需要重写的方法包括：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> arg)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>获取操作</strong>：通常涉及 <code>acquire</code> 或 <code>acquireShared</code> 方法，若获取失败，线程将进入等待队列</li>
<li><strong>释放操作</strong>：通常是 <code>release</code> 或 <code>releaseShared</code>，当资源释放后，唤醒下一个等待的线程</li>
</ul>
<p>各个具体同步器类会根据自身语义实现这些方法，比如：<code>ReentrantLock</code> 实现了独占锁的获取与释放；<code>CountDownLatch</code> 实现了共享锁逻辑中的“倒计时”功能；<code>Semaphore</code> 控制并发线程数量，即许可数量管理</p>
</li>
</ol>
<p><strong>三、AQS 的职责总结</strong></p>
<table>
<thead>
<tr>
<th>作用</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>同步状态管理</strong></td>
<td>通过 <code>state</code> 和 CAS 保证原子性操作</td>
</tr>
<tr>
<td><strong>线程排队机制</strong></td>
<td>构建 CLH 队列，管理线程排队与调度</td>
</tr>
<tr>
<td><strong>模板方法扩展</strong></td>
<td>子类通过重写 <code>tryAcquire</code> 等方法定制锁语义</td>
</tr>
</tbody></table>
<h2 id="17-CAS-与-AQS-的关系与区别"><a href="#17-CAS-与-AQS-的关系与区别" class="headerlink" title="17# CAS 与 AQS 的关系与区别"></a>17# CAS 与 AQS 的关系与区别</h2><p><strong>一、两者的区别</strong></p>
<ol>
<li><strong>CAS（Compare-And-Swap）</strong>：CAS 是一种<strong>乐观锁机制</strong>，它通过对比内存中当前值和预期值是否一致，来决定是否更新数据。整个过程具备<strong>原子性</strong>，通常由底层硬件指令实现。<strong>CAS 的逻辑是</strong>：若内存地址 V 当前的值等于 A，则将 V 的值更新为 B；否则不做任何修改</li>
<li><strong>AQS（AbstractQueuedSynchronizer）</strong>：AQS 是一个用于构建同步器的抽象框架，例如 <code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code> 等都基于它实现。其核心机制包括：<ul>
<li>使用一个 <code>volatile int state</code> 表示<strong>同步状态</strong></li>
<li>使用一个变体的 <strong>CLH FIFO 队列</strong> 管理<strong>等待线程</strong></li>
<li>通过模板方法模式暴露出 <code>tryAcquire()</code>、<code>tryRelease()</code> 等方法，供具体同步器实现</li>
<li>AQS 提供了如 <code>acquire()</code>、<code>release()</code> 等通用同步操作，这些操作背后依赖状态的原子修改</li>
</ul>
</li>
</ol>
<p><strong>二、两者的关系</strong></p>
<p><strong>CAS 是 AQS 实现的基础手段之一</strong>。在 AQS 内部，为了实现线程安全地更新共享状态（即 <code>state</code> 变量），大量使用了 CAS 操作。其关键联系如下：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>状态修改</strong></td>
<td>AQS 通过 <code>CAS</code> 原子地修改 <code>state</code> 值，避免加锁操作</td>
</tr>
<tr>
<td><strong>获取资源</strong></td>
<td>在 <code>acquire()</code> 操作中，线程首先使用 CAS 尝试获取资源（修改 <code>state</code>）；如果失败，才进入阻塞队列</td>
</tr>
<tr>
<td><strong>释放资源</strong></td>
<td>在 <code>release()</code> 操作中，线程使用 CAS 安全地减少或重置 <code>state</code>，并唤醒下一个等待线程</td>
</tr>
<tr>
<td><strong>保证并发安全</strong></td>
<td>CAS 保证了 <code>state</code> 更新过程中的原子性，是整个 AQS 框架并发控制的关键保障</td>
</tr>
</tbody></table>
<h2 id="18-如何用-AQS-实现一个可重入的公平锁？"><a href="#18-如何用-AQS-实现一个可重入的公平锁？" class="headerlink" title="18# 如何用 AQS 实现一个可重入的公平锁？"></a>18# 如何用 AQS 实现一个可重入的公平锁？</h2><p>AQS 实现一个可重入的公平锁的详细步骤：</p>
<ol>
<li><strong>继承 AbstractQueuedSynchronizer</strong>：创建一个内部类继承自 <code>AbstractQueuedSynchronizer</code>，重写 <code>tryAcquire</code>、<code>tryRelease</code>、<code>isHeldExclusively</code> 等方法，这些方法将用于实现锁的获取、释放和判断锁是否被当前线程持有</li>
<li><strong>实现可重入逻辑</strong>：在 <code>tryAcquire</code> 方法中，检查当前线程是否已经持有锁，如果是，则增加锁的持有次数（通过 <code>state</code> 变量）；如果不是，尝试使用 CAS 操作来获取锁</li>
<li><strong>实现公平性</strong>：在 <code>tryAcquire</code> 方法中，按照队列顺序来获取锁，即先检查等待队列中是否有线程在等待，如果有，当前线程必须进入队列等待，而不是直接竞争锁</li>
<li><strong>创建锁的外部类</strong>：创建一个外部类，内部持有 <code>AbstractQueuedSynchronizer</code> 的子类对象，并提供 <code>lock</code> 和 <code>unlock</code> 方法，这些方法将调用 <code>AbstractQueuedSynchronizer</code> 子类中的方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FairReentrantLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 核心同步器，继承 AQS */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ========= 独占锁基础 ========= */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 当前线程是否占有锁 */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 尝试获取锁（公平 + 可重入）*/</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;                                     <span class="comment">// 锁空闲</span></span><br><span class="line">                <span class="comment">// ★ 公平性：队列前面有人 → 当前线程必须排队</span></span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors()</span><br><span class="line">                        &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// ★ 可重入</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (next &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;lock count overflow&quot;</span>);</span><br><span class="line">                setState(next);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 竞争失败</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 尝试释放锁 */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="literal">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);               <span class="comment">// 可重入计数减 1</span></span><br><span class="line">            <span class="keyword">return</span> free;               <span class="comment">// true → 唤醒队列首线程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ========= 条件变量 ========= */</span></span><br><span class="line"></span><br><span class="line">        Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;      <span class="comment">// 每个锁可派生多个条件队列</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ========= 对外 API ========= */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>           &#123; sync.acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="comment">// 解锁方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>         &#123; sync.release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="comment">// 判断当前线程是否持有锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHeldByMe</span><span class="params">()</span>  &#123; <span class="keyword">return</span> sync.isHeldExclusively(); &#125;</span><br><span class="line">    <span class="comment">// 提供一个条件变量，用于实现更复杂的同步需求，这里只是简单实现</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123; <span class="keyword">return</span> sync.newCondition(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>代码解释</strong></p>
<p><strong>内部类 Sync</strong>：</p>
<ul>
<li><code>isHeldExclusively</code>：使用 <code>getExclusiveOwnerThread</code> 方法检查当前锁是否被当前线程持有</li>
<li><code>tryAcquire</code>：<ul>
<li>首先获取当前锁的状态 <code>c</code></li>
<li>如果 <code>c</code> 为 0，表示锁未被持有，此时进行公平性检查，通过 <code>hasQueuedPredecessors</code> 检查是否有前驱节点在等待队列中。如果没有，使用 <code>compareAndSetState</code> 尝试将状态设置为 <code>acquires</code>（通常为 1），并设置当前线程为锁的持有线程</li>
<li>如果 <code>c</code> 不为 0，说明锁已被持有，检查是否为当前线程持有。如果是，增加锁的持有次数（可重入），但要防止溢出</li>
</ul>
</li>
<li><code>tryRelease</code>：<ul>
<li>先将状态减 <code>releases</code>（通常为 1）</li>
<li>检查当前线程是否为锁的持有线程，如果不是，抛出异常</li>
<li>如果状态减为 0，说明锁被完全释放，将持有线程设为 <code>null</code></li>
</ul>
</li>
<li><code>newCondition</code>：创建一个 <code>ConditionObject</code> 用于更复杂的同步操作，如等待 &#x2F; 通知机制。</li>
</ul>
<p><strong>外部类 FairReentrantLock</strong>：</p>
<ul>
<li><code>lock</code> 方法：调用 <code>sync.acquire(1)</code> 尝试获取锁</li>
<li><code>unlock</code> 方法：调用 <code>sync.release(1)</code> 释放锁</li>
<li><code>isLocked</code> 方法：调用 <code>sync.isHeldExclusively</code> 判断锁是否被当前线程持有</li>
<li><code>newCondition</code> 方法：调用 <code>sync.newCondition</code> 提供条件变量</li>
</ul>
<p><strong>使用示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FairReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FairReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    <span class="keyword">while</span> (!ready)              <span class="comment">// 条件不满足</span></span><br><span class="line">        condition.await();      <span class="comment">// 原子释放锁 + 挂起</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="19-ThreadLocal-的作用、结构、原理与潜在问题"><a href="#19-ThreadLocal-的作用、结构、原理与潜在问题" class="headerlink" title="19# ThreadLocal 的作用、结构、原理与潜在问题"></a>19# ThreadLocal 的作用、结构、原理与潜在问题</h2><p><code>ThreadLocal</code> 是 Java 提供的一种线程本地变量机制，它为每个线程提供独立的变量副本，避免多线程共享变量导致的线程安全问题</p>
<p><strong>一、ThreadLocal 的作用</strong></p>
<ol>
<li><p><strong>线程隔离</strong><br> 每个线程都维护自己的变量副本，线程之间互不影响，天然线程安全。常用于用户信息、数据库连接、事务上下文等场景</p>
</li>
<li><p><strong>简化参数传递，降低耦合度</strong><br> 不需要在方法间层层传递参数，便于在过滤器、拦截器等框架中保存线程上下文</p>
</li>
<li><p><strong>提升性能</strong><br> 避免加锁带来的开销，相比同步机制具有更优的性能，尤其适合高并发场景下的读操作</p>
</li>
</ol>
<p><strong>二、ThreadLocalMap 的内部结构</strong></p>
<img src="https://cdn.xiaolincoding.com//picgo/1719982991053-c983c4b8-7c5f-4e2d-a90d-5b42ebd533d5.png" alt="ThreadLocalMap" style="zoom:67%;" />

<ul>
<li>实际由一个 <strong>Entry 数组</strong> 实现（本质是一个定制的 HashMap）；</li>
<li><strong>Entry 的 key 是 ThreadLocal 实例（使用弱引用 WeakReference）</strong>；</li>
<li><strong>Entry 的 value 是对应线程的变量副本</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        Object value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：虽然 key 是 <code>WeakReference</code>（GC 可回收），但 value 是强引用，这种设计容易引发内存泄漏问题：</p>
<ul>
<li>如果 <code>ThreadLocal</code> 对象被外部代码丢弃（无强引用指向），而没有调用 <code>remove()</code>，即使 key 被 GC 回收，但 value 仍在 ThreadLocalMap 中，Entry 不会被自动清除，若线程是线程池中的线程（不会很快销毁），就会导致该 value 无法回收，造成 <strong>内存泄漏</strong></li>
</ul>
<p><strong>三、ThreadLocal 的工作原理</strong></p>
<p><code>ThreadLocal</code> 的实现依赖于 <strong>Thread 类中一个专属的 <code>ThreadLocalMap</code> 字段</strong>，每个 <code>ThreadLocal</code> 实例就是这个 Map 的 key，Map 中的 Value 就是当前线程对应的变量值</p>
<ul>
<li><strong>get() 方法</strong>：读取当前线程的 <code>ThreadLocalMap</code>，查找当前 <code>ThreadLocal</code> 作为 key 的 entry，找到则返回 value；找不到时，调用 <code>initialValue()</code> 初始化，存入 Map 并返回</li>
<li><strong>set(value) 方法</strong>：将当前 <code>ThreadLocal</code> 作为 key，value 存入当前线程的 <code>ThreadLocalMap</code> 中</li>
<li><strong>remove() 方法</strong>：移除当前线程中与该 <code>ThreadLocal</code> 实例关联的 entry，释放引用，防止内存泄漏</li>
</ul>
<h2 id="20-悲观锁和乐观锁的区别？"><a href="#20-悲观锁和乐观锁的区别？" class="headerlink" title="20# 悲观锁和乐观锁的区别？"></a>20# 悲观锁和乐观锁的区别？</h2><p>在并发编程中，<strong>悲观锁</strong>与<strong>乐观锁</strong>是两种常见的并发控制策略，它们的核心区别在于对<strong>资源竞争冲突的预期和处理方式</strong>不同</p>
<p><strong>一、悲观锁</strong></p>
<p>悲观锁对并发持谨慎态度，假设资源竞争一定会发生，因此在访问数据之前<strong>主动加锁</strong>，确保同一时间只有一个线程能访问该资源</p>
<p>悲观锁通过各种加锁机制实现，在操作数据之前即加锁，阻止其他线程并发访问。性能损耗较大，但冲突处理成本低，适合写操作频繁、冲突概率高或对一致性要求极高的业务场景（如金融、订单系统）</p>
<hr>
<p><strong>二、乐观锁</strong></p>
<p>乐观锁采取 “乐观” 的态度，认为线程之间的资源竞争是偶发的，大多数情况下不会发生冲突，因此不会在操作前加锁</p>
<p>乐观锁采用 <strong>“先检查再更新”</strong> 的方式进行控制，一般通过 <strong>CAS 机制</strong> 实现，在读取数据时不加锁，在更新时，通过对比数据是否被修改来决定是否成功更新，如果检测到冲突（数据已被其他线程修改），则重试或失败。适合读多写少或并发量大但冲突概率低的业务场景（如计数器、缓存更新等）</p>
<h2 id="21-Java-中实现乐观锁的常见方式？"><a href="#21-Java-中实现乐观锁的常见方式？" class="headerlink" title="21# Java 中实现乐观锁的常见方式？"></a>21# Java 中实现乐观锁的常见方式？</h2><table>
<thead>
<tr>
<th>实现方式</th>
<th>原理</th>
<th>场景适用</th>
<th>优点</th>
</tr>
</thead>
<tbody><tr>
<td>CAS 原子操作</td>
<td>比较并交换（无锁）</td>
<td>高并发、无共享状态的并发控制</td>
<td>快速、无阻塞</td>
</tr>
<tr>
<td>版本号控制</td>
<td>基于值的一致性检测</td>
<td>ORM 框架、数据库并发更新</td>
<td>精确控制、简单可靠</td>
</tr>
<tr>
<td>时间戳控制</td>
<td>基于时间的一致性检测</td>
<td>对更新时序敏感的场景</td>
<td>直观、可追踪</td>
</tr>
</tbody></table>
<ol>
<li><strong>CAS 操作：</strong> CAS 是乐观锁的基础。Java 提供了 <code>java.util.concurrent.atomic</code> 包中的原子类（如 <code>AtomicInteger</code>、<code>AtomicLong</code>），这些类使用 CAS 操作实现了线程安全的原子操作，可以用来实现乐观锁</li>
<li><strong>版本号控制</strong>：为共享资源维护一个“版本号”字段（或称 <code>version</code> &#x2F; <code>revision</code>），在更新前后对比版本号是否一致</li>
<li><strong>时间戳</strong>：使用数据的<strong>更新时间戳</strong>进行冲突检测。在更新数据时，在比较时间戳，如果当前时间戳大于数据的时间戳，则说明数据已经被其他线程更新，更新失败</li>
</ol>
<h2 id="22-CAS-有什么缺点？"><a href="#22-CAS-有什么缺点？" class="headerlink" title="22# CAS 有什么缺点？"></a>22# CAS 有什么缺点？</h2><ol>
<li><strong>ABA 问题</strong>：CAS 更新的过程中，当读取到的值是 A，然后准备赋值的时候仍然是 A，但是实际上有可能 A 的值被改成了 B，然后又被改回了 A，这个 CAS 更新的漏洞就叫做 ABA。只是 ABA 的问题大部分场景下都不影响并发的最终效果。Java 中有 <code>AtomicStampedReference</code> 来解决这个问题，它加入了预期标志和更新后标志两个字段，更新时不光检查值，还要检查当前的标志是否等于预期标志，全部相等的话才会更新</li>
<li><strong>循环时间长开销大</strong>：自旋 CAS 的方式如果长时间不成功，会给 CPU 带来很大的开销</li>
<li><strong>只能保证一个共享变量的原子操作</strong>：CAS 只能保证<strong>单个变量</strong>的原子更新。对于多个变量的复合操作，CAS 无法直接确保整体的原子性，容易产生中间状态或数据不一致的问题。可以使用 <code>AtomicReference</code> 进行对象整体引用的原子替换，对于复杂的多变量一致性需求，仍需使用传统的同步机制（如 <code>synchronized</code> 或 <code>ReentrantLock</code>）</li>
</ol>
<h2 id="23-为什么不能所有的锁都使用-CAS？"><a href="#23-为什么不能所有的锁都使用-CAS？" class="headerlink" title="23# 为什么不能所有的锁都使用 CAS？"></a>23# 为什么不能所有的锁都使用 CAS？</h2><ol>
<li><strong>自旋重试开销大，浪费 CPU 资源</strong>：当 CAS 失败时，线程不会挂起，而是不断地进行重试，大量线程同时自旋，频繁占用 CPU，会导致系统负载升高，甚至出现性能下降</li>
<li><strong>无法处理复杂的临界区逻辑</strong>：CAS 适合用于更新<strong>简单变量（如整数、引用）<strong>的场景，但不适合处理具有</strong>复杂临界区逻辑</strong>的同步问题（如多个变量同时更新、存在阻塞等待、必须保证某段代码原子执行）</li>
<li><strong>缺乏阻塞机制，不适用于等待&#x2F;唤醒模型</strong>：CAS 本身没有提供线程挂起与唤醒机制，一旦失败只能选择不停地重试</li>
</ol>
<h2 id="24-volatile-关键字有什么作用？"><a href="#24-volatile-关键字有什么作用？" class="headerlink" title="24# volatile 关键字有什么作用？"></a>24# volatile 关键字有什么作用？</h2><p><strong>一、保证可见性</strong></p>
<p>当一个变量被声明为 <code>volatile</code> 时，它保证了<strong>该变量对所有线程的可见性</strong>。一个线程对 <code>volatile</code> 变量的写操作，<strong>会立即刷新到主内存</strong>，其他线程在读取该变量时，<strong>总是直接从主内存中获取值</strong>，而不是从线程本地缓存中读取， 这样可以避免由于线程工作内存（缓存）不同步导致的数据不一致问题</p>
<p><strong>二、禁止指令重排序）</strong></p>
<p><code>volatile</code> 可以通过插入<strong>内存屏障</strong>来禁止特定类型的指令重排序，从而在一定程度上保证有序性：</p>
<ul>
<li><strong>写屏障</strong>：在对 <code>volatile</code> 变量写入之前插入。在 <code>volatile</code> 写之前的所有普通写操作在内存中都可见，防止这些写操作被重排序到 <code>volatile</code> 写之后</li>
<li><strong>读屏障</strong>：在读取 <code>volatile</code> 变量之后插入。防止后续普通读操作被提前到 <code>volatile</code> 读操作之前执行，确保读取的是最新数据</li>
<li><strong>写-读屏障</strong>：在 <code>volatile</code> 写之后和 <code>volatile</code> 读之间。<code>volatile</code> 写之前的所有写操作在 <code>volatile</code> 读之前对其他线程可见；同时防止 <code>volatile</code> 读之后的操作被重排到前面</li>
</ul>
<h2 id="25-指令重排序的原理是什么？"><a href="#25-指令重排序的原理是什么？" class="headerlink" title="25# 指令重排序的原理是什么？"></a>25# 指令重排序的原理是什么？</h2><p>为了提升程序运行效率，<strong>编译器</strong>和<strong>CPU处理器</strong>通常会对指令执行顺序进行优化，称为<strong>指令重排序</strong>。这是一种在保证单线程语义不变的前提下，重新调整代码执行顺序的技术，它必须遵守以下两个核心原则：</p>
<ol>
<li><p><strong>单线程语义等价</strong>：重排序不能改变<strong>单线程环境下程序的执行结果</strong>。换句话说，从单线程的角度看，重排序前后程序的行为应保持一致</p>
</li>
<li><p>**遵守数据依赖性约束：如果两条语句存在数据依赖关系（如读写同一个变量），它们的执行顺序不能被重排</p>
<ul>
<li><p>写后读（Write → Read）</p>
</li>
<li><p>写后写（Write → Write）</p>
</li>
<li><p>读后写（Read → Write）</p>
</li>
</ul>
</li>
</ol>
<p>所以重排序不会对单线程有影响，只会破坏多线程的执行语义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// A</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;  <span class="comment">// B</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;  <span class="comment">// C</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>C</code> 依赖 <code>A</code> 和 <code>B</code>，即它需要在 <code>A</code> 和 <code>B</code> 之后执行</li>
<li>因此，<strong><code>C</code> 不能被重排序</strong>到 <code>A</code> 或 <code>B</code> 之前</li>
<li>但是 <code>A</code> 和 <code>B</code> 之间没有依赖关系，它们的执行顺序可以被编译器或处理器重排</li>
</ul>
<p>虽然在<strong>单线程中</strong>重排序不会影响最终结果，但在<strong>多线程环境下</strong>，不同线程看到的执行顺序可能不一致，从而引发不可预期的问题，尤其是涉及共享变量的读写操作时。因此，Java 提供了 <code>volatile</code> 关键字和 <code>synchronized</code> 等机制，来<strong>禁止特定的重排序</strong>，确保在多线程下的可见性和有序性</p>
<h2 id="26-volatile-能保证线程安全吗？"><a href="#26-volatile-能保证线程安全吗？" class="headerlink" title="26# volatile 能保证线程安全吗？"></a>26# volatile 能保证线程安全吗？</h2><p><code>volatile</code> 关键字<strong>只能保证变量的可见性</strong>，<strong>不能保证原子性</strong>，因此 <strong>并不能完全保证线程安全</strong></p>
<ul>
<li><code>volatile</code> 并不能保证原子性（如 <code>i++</code> 操作就不是原子的）</li>
<li>如果需要保证原子性，应考虑使用 <code>synchronized</code> 或原子类（如 <code>AtomicInteger</code>）</li>
<li>它适用于状态标志类变量（如 <code>stopFlag</code>、<code>ready</code> 等），但不适合用于涉及复合操作（读-改-写）的逻辑</li>
</ul>
<h2 id="27-volatile-与-sychronized-的区别？"><a href="#27-volatile-与-sychronized-的区别？" class="headerlink" title="27# volatile 与 sychronized 的区别？"></a>27# volatile 与 sychronized 的区别？</h2><table>
<thead>
<tr>
<th>特性</th>
<th><code>volatile</code></th>
<th><code>synchronized</code></th>
</tr>
</thead>
<tbody><tr>
<td>可见性</td>
<td>✅ 保证</td>
<td>✅ 保证</td>
</tr>
<tr>
<td>原子性</td>
<td>❌ 不保证</td>
<td>✅ 保证（代码块原子执行）</td>
</tr>
<tr>
<td>互斥性</td>
<td>❌ 无</td>
<td>✅ 存在</td>
</tr>
<tr>
<td>禁止重排序</td>
<td>✅ 有效</td>
<td>✅ 间接实现（通过内存语义）</td>
</tr>
<tr>
<td>使用成本</td>
<td>较低（无锁，非阻塞）</td>
<td>较高（可能阻塞，涉及上下文切换）</td>
</tr>
<tr>
<td>适用场景</td>
<td>状态标志、单例懒加载等</td>
<td>临界区保护、资源读写同步</td>
</tr>
</tbody></table>
<p><strong>一、synchronized 重量级同步机制</strong></p>
<ul>
<li><strong>作用</strong>：解决多线程访问共享资源时可能出现的竞态条件和数据不一致问题，<strong>保证线程安全</strong></li>
<li><strong>特性</strong>：<ul>
<li>保证<strong>互斥性</strong>（同一时刻只有一个线程能执行同步代码块）</li>
<li>保证<strong>可见性</strong>（进入同步块前会将线程工作内存与主内存同步）</li>
<li>隐式<strong>原子性保障</strong>（对共享资源的操作是原子的）</li>
</ul>
</li>
<li><strong>使用方式</strong>：可用于方法或代码块，加锁的对象可以是类、实例或任意对象</li>
<li><strong>性能</strong>：开销较大，尤其在高并发下容易导致线程阻塞和上下文切换</li>
</ul>
<hr>
<p><strong>二、volatile 轻量级可见性保证</strong></p>
<ul>
<li><strong>作用</strong>：用于保证变量在多线程环境下的<strong>可见性</strong>和<strong>禁止指令重排序</strong>，<strong>不保证原子性</strong></li>
<li><strong>特性</strong>：<ul>
<li><strong>不具备互斥性</strong>，无法保证操作的原子性</li>
<li>保证<strong>可见性</strong>（修改立即对其他线程可见）</li>
<li>禁止<strong>指令重排序</strong>（通过内存屏障防止重排序破坏执行语义）</li>
</ul>
</li>
<li><strong>使用方式</strong>：用于修饰变量，一般用于状态标志、配置开关等场景</li>
<li><strong>性能</strong>：非常轻量，线程不会阻塞</li>
</ul>
<h2 id="28-什么是公平锁和非公平锁？"><a href="#28-什么是公平锁和非公平锁？" class="headerlink" title="28# 什么是公平锁和非公平锁？"></a>28# 什么是公平锁和非公平锁？</h2><p><strong>一、公平锁</strong></p>
<ul>
<li><strong>定义</strong>：按照线程<strong>请求锁的顺序</strong>来获取锁，先请求的线程先获得锁，后请求的线程排队等待</li>
<li><strong>特点</strong>：类似 “排队买票”，线程按照先来先服务的原则依次执行。每个线程都有公平的机会获得锁，不容易发生<strong>线程饥饿</strong></li>
<li><strong>优点</strong>：公平性强，避免某些线程长时间得不到锁</li>
<li><strong>缺点</strong>：等待队列的调度成本较高，频繁上下文切换会降低<strong>吞吐量</strong>和<strong>整体性能</strong></li>
</ul>
<hr>
<p><strong>二、 非公平锁</strong></p>
<ul>
<li><strong>定义</strong>：线程在尝试获取锁时<strong>不考虑等待队列的顺序</strong>，先尝试<strong>直接获取锁</strong>，获取失败才进入队列排队等待。</li>
<li><strong>特点</strong>：类似 “插队”，后来的线程可能比排队线程更早获得锁。提高了竞争成功的可能性，但可能导致部分线程长时间得不到锁（<strong>线程饥饿</strong>）</li>
<li><strong>优点</strong>：整体<strong>性能更高</strong>，<strong>吞吐量更大</strong>，减少线程切换</li>
<li><strong>缺点</strong>：公平性较差，某些线程可能长期 “饿死”</li>
</ul>
<h2 id="29-非公平锁吞吐量为什么比公平锁大？"><a href="#29-非公平锁吞吐量为什么比公平锁大？" class="headerlink" title="29# 非公平锁吞吐量为什么比公平锁大？"></a>29# 非公平锁吞吐量为什么比公平锁大？</h2><p>主要原因在于其<strong>减少了线程上下文切换和排队等待</strong>的开销。以下是两者执行流程的对比说明：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>公平锁</th>
<th>非公平锁</th>
</tr>
</thead>
<tbody><tr>
<td>获取顺序</td>
<td>严格按排队顺序，先来先得</td>
<td>不保证顺序，可能“插队”</td>
</tr>
<tr>
<td>性能表现</td>
<td>有更多上下文切换，性能相对较低</td>
<td>避免频繁挂起与恢复，性能更优</td>
</tr>
<tr>
<td>实现机制</td>
<td>线程入队 → 挂起 → 唤醒 → 获取锁</td>
<td>CAS尝试获取 → 失败则入队等待</td>
</tr>
<tr>
<td>吞吐量</td>
<td>相对较低</td>
<td>相对较高</td>
</tr>
<tr>
<td>是否可能饥饿</td>
<td>否，公平调度</td>
<td>是，排在后面的线程可能长时间得不到锁</td>
</tr>
</tbody></table>
<p><strong>一、公平锁执行流程</strong></p>
<ul>
<li>当线程尝试获取锁时，会<strong>先被加入到等待队列的尾部</strong>，然后<strong>挂起（休眠）</strong>，等待被调度</li>
<li>当前持有锁的线程释放锁后，会<strong>唤醒队列中最前面的线程</strong>来尝试获取锁</li>
<li>整个过程保证了 “先来先服务” 的公平性，每个等待线程需要经历从<strong>运行态 → 阻塞态 → 运行态</strong>的切换，这些状态切换涉及<strong>用户态与内核态之间的转换</strong>，这是一种昂贵的操作</li>
<li>因此，在高并发场景下，公平锁的<strong>上下文切换频繁</strong>，导致<strong>整体性能下降、吞吐量变</strong></li>
</ul>
<hr>
<p><strong>二、非公平锁执行流程</strong></p>
<ul>
<li>当线程尝试获取锁时，会<strong>先直接通过 CAS 操作抢占锁</strong>：如果抢到锁，就直接执行，无需排队；如果没抢到，再进入等待队列排队等待下一次竞争机会</li>
<li>由于不强制按照排队顺序执行，非公平锁能<strong>减少线程挂起&#x2F;恢复的频率</strong>，避免了大量上下文切换，<strong>线程有更高的概率 “插队” 获取锁</strong>，因此锁的利用效率更高</li>
<li>这使得非公平锁在高并发环境下的<strong>响应更快，吞吐量更大</strong></li>
</ul>
<h2 id="30-synchronized-是公平锁吗？"><a href="#30-synchronized-是公平锁吗？" class="headerlink" title="30# synchronized 是公平锁吗？"></a>30# synchronized 是公平锁吗？</h2><p>不是。<code>synchronized</code> 并<strong>不保证公平性</strong>，因此它并不是一种公平锁。在多线程竞争锁资源时，<code>synchronized</code> 采用的是<strong>非公平策略</strong>：当锁被释放时，<strong>所有等待线程都会同时竞争该锁</strong>，谁先抢到谁执行，线程的获取顺序<strong>不一定按照等待的先后顺序</strong></p>
<p>相比之下，<code>ReentrantLock</code> 是 Java 中提供的<strong>可重入锁</strong>，它<strong>支持公平和非公平两种模式</strong>，默认情况下，<code>ReentrantLock</code> 使用的是非公平策略；若需要公平性，可以通过构造方法 <code>new ReentrantLock(true)</code> 来显式指定为<strong>公平锁</strong></p>
<h2 id="31-ReentrantLock是怎么实现公平锁的？"><a href="#31-ReentrantLock是怎么实现公平锁的？" class="headerlink" title="31# ReentrantLock是怎么实现公平锁的？"></a>31# ReentrantLock是怎么实现公平锁的？</h2><p><code>ReentrantLock</code> 通过 <strong>Sync 内部类</strong>（继承自 AQS） 来区分 “公平锁” 和 “非公平锁”。二者在<strong>获取锁</strong>时的关键分支不同：</p>
<p><del><strong>太长不看版</strong></del></p>
<table>
<thead>
<tr>
<th>比较维度</th>
<th>公平锁 (<code>tryAcquire</code>)</th>
<th>非公平锁 (<code>nonfairTryAcquire</code>)</th>
</tr>
</thead>
<tbody><tr>
<td>获取策略</td>
<td>先检查 <code>hasQueuedPredecessors()</code>，前驱为空才能抢锁</td>
<td>直接 CAS 抢锁，失败后再排队</td>
</tr>
<tr>
<td>性能</td>
<td>上下文切换多，吞吐量稍低</td>
<td>吞吐量高，但可能产生线程饥饿</td>
</tr>
<tr>
<td>场景选择</td>
<td>需要严格先来先得 &#x2F; 避免饥饿</td>
<td>追求吞吐量、对公平性不敏感</td>
</tr>
</tbody></table>
<p><strong>公平锁源码（节选）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();                 <span class="comment">// ① 读锁状态</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ② “排队检查”：AQS 队列前面是否还有线程？</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">// 公平锁核心：必须排第一</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// ③ 可重入</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>核心语句</strong>：<code>hasQueuedPredecessors()</code></p>
<ul>
<li>返回 <code>true</code> ⇒ 队列中已有前驱线程，当前线程<strong>不得“插队”</strong>，必须排队</li>
<li>返回 <code>false</code> ⇒ 当前线程位于队首，可立即 CAS 抢锁</li>
</ul>
<p>因此，公平锁 <strong>严格按照先来后到</strong> 的排队顺序获取锁，避免了饿死现象，但带来了更多<strong>上下文切换</strong>成本</p>
<hr>
<p> <strong>非公平锁源码（节选）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();                 <span class="comment">// ① 读锁状态</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ② 直接 CAS 抢锁，不看队列</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// ③ 可重入</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>没有队列检查</strong>：线程一来就尝试 CAS 抢锁，成功则立即进入临界区，失败再进入队列挂起</li>
<li>好处：<strong>吞吐量更高</strong>（锁刚释放时附近线程可立即命中锁）</li>
<li>风险：可能出现“插队”，导致等待队列里的某些线程<strong>长时间得不到锁</strong>（轻度饥饿）</li>
</ul>
<hr>
<p><strong><code>tryLock()</code> 的特例</strong></p>
<p>无论 <code>ReentrantLock</code> 创建时指定的是公平 (<code>new ReentrantLock(true)</code>) 还是非公平模式，<strong><code>tryLock()</code> 一律使用非公平策略</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);   <span class="comment">// 始终调用非公平实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tryLock()</code> 本身语义就是“立即尝试一次”，所以可以“插队”成功，而不保证排队顺序</p>
<h2 id="32-什么情况会产生死锁问题？如何解决？"><a href="#32-什么情况会产生死锁问题？如何解决？" class="headerlink" title="32# 什么情况会产生死锁问题？如何解决？"></a>32# 什么情况会产生死锁问题？如何解决？</h2><p>死锁的发生必须<strong>同时满足以下四个条件</strong>：</p>
<ol>
<li><strong>互斥条件</strong>：某个资源一次只能被一个线程占用，不能共享使用</li>
<li><strong>占有且等待条件</strong>： 线程已持有至少一个资源，并且在等待获取其他被别的线程占用的资源，<strong>不释放当前已有资源</strong></li>
<li><strong>不可抢占条件</strong>：线程已获取的资源在未使用完之前<strong>不能被强行剥夺</strong>，只能线程自己释放</li>
<li><strong>循环等待条件</strong>：存在一个线程资源的循环等待链，即线程 A 等待线程 B 占用的资源，而线程 B 又在等待线程 A 的资源</li>
</ol>
<p>只要<strong>打破任意一个死锁条件</strong>，就可以有效避免死锁。最常见的并且可行的就是<strong>使用资源有序分配法，来破环环路等待条件</strong>：给资源编号，规定线程必须<strong>按照固定顺序申请资源</strong>，例如，无论线程 A 还是线程 B，始终按照 “先申请资源 R1，再申请资源 R2” 的顺序来获取资源</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="1-介绍一下线程池的工作原理"><a href="#1-介绍一下线程池的工作原理" class="headerlink" title="1# 介绍一下线程池的工作原理"></a>1# 介绍一下线程池的工作原理</h2><img src="https://cdn.xiaolincoding.com//picgo/1719389039034-0de42388-4ec6-44a6-9583-5d018e5cb4f3.png" alt="线程池的工作原理" style="zoom: 67%;" />

<p>线程池的主要作用是<strong>复用线程资源，避免频繁创建和销毁线程带来的性能开销</strong>。它通过预先创建一定数量的线程，并维护一个任务队列来管理并发任务，从而提高系统整体吞吐量和响应速度</p>
<p>线程池的设计理念是通过<strong>线程重用 + 队列排队 + 最大并发限制</strong>来管理资源和任务调度，它的典型执行策略是：</p>
<ul>
<li><strong>优先使用核心线程</strong></li>
<li><strong>核心线程满 → 入队列</strong></li>
<li><strong>队列满 → 创建非核心线程（直到最大线程数）</strong></li>
<li><strong>超出最大线程数 → 执行拒绝策略</strong></li>
</ul>
<h2 id="2-线程池的参数有哪些？"><a href="#2-线程池的参数有哪些？" class="headerlink" title="2# 线程池的参数有哪些？"></a>2# 线程池的参数有哪些？</h2><ol>
<li><p><strong><code>corePoolSize</code>（核心线程数）</strong>：线程池中<strong>常驻的线程数量</strong>。即使这些线程处于空闲状态，也不会被销毁，除非设置了 <code>allowCoreThreadTimeOut(true)</code></p>
</li>
<li><p><strong><code>maximumPoolSize</code>（最大线程数）</strong>：线程池中允许创建的<strong>最大线程数量</strong>。当任务过多、核心线程和队列都满时，线程池才会继续创建新线程，直到达到该上限</p>
</li>
<li><p><strong><code>keepAliveTime</code>（空闲线程存活时间）</strong>：当线程数<strong>大于核心线程数</strong>时，空闲线程在达到该时间后将被销毁，以节省资源</p>
</li>
<li><p><strong><code>unit</code>（时间单位）</strong>：<code>keepAliveTime</code> 的时间单位，例如 <code>TimeUnit.SECONDS</code>、<code>TimeUnit.MILLISECONDS</code> 等。</p>
</li>
<li><p><strong><code>workQueue</code>（任务队列）</strong>：用来保存<strong>待执行的任务</strong>。当所有核心线程都在忙时，新的任务会被加入该队列等待执行。常见实现包括：</p>
<ul>
<li><p><code>ArrayBlockingQueue</code>（有界队列）</p>
</li>
<li><p><code>LinkedBlockingQueue</code>（无界队列）</p>
</li>
<li><p><code>SynchronousQueue</code>（直接交付）</p>
</li>
<li><p><code>PriorityBlockingQueue</code>（优先级队列）</p>
</li>
</ul>
</li>
<li><p><strong><code>threadFactory</code>（线程工厂）</strong>：用于自定义线程的创建方式，通常可用来设置线程名称、优先级、是否为守护线程等</p>
</li>
<li><p><strong><code>handler</code>（拒绝策略）</strong>：当线程池<strong>达到最大线程数并且任务队列已满</strong>时的处理策略</p>
</li>
</ol>
<h2 id="3-线程池有哪些拒绝策略？"><a href="#3-线程池有哪些拒绝策略？" class="headerlink" title="3# 线程池有哪些拒绝策略？"></a>3# 线程池有哪些拒绝策略？</h2><ul>
<li><p><code>AbortPolicy</code>（抛出异常策略）：默认策略，直接<strong>抛出 <code>RejectedExecutionException</code> 异常</strong>，提醒程序任务已被拒绝处理</p>
</li>
<li><p><code>CallerRunsPolicy</code>（调用者执行策略）：由提交任务的线程（通常是主线程）<strong>直接执行该任务</strong>，从而降低任务提交的速度，避免任务快速堆积</p>
</li>
<li><p><code>DiscardPolicy</code>（静默丢弃策略）：<strong>不抛异常，也不执行被拒绝的任务</strong>，直接丢弃任务</p>
</li>
<li><p><code>DiscardOldestPolicy</code>（丢弃最旧任务策略）：<strong>丢弃任务队列中最早的任务</strong>，然后尝试重新提交当前任务</p>
</li>
</ul>
<p>此外，通过实现 <code>RejectedExecutionHandler</code> 接口，可以根据业务需求编写自定义拒绝策略，例如记录日志、报警、持久化任务等：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomRejectHandler</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义处理逻辑，如记录日志、发送告警、持久化等</span></span><br><span class="line">        System.out.println(<span class="string">&quot;任务被拒绝：&quot;</span> + r.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-如何设置线程池参数？"><a href="#4-如何设置线程池参数？" class="headerlink" title="4# 如何设置线程池参数？"></a>4# 如何设置线程池参数？</h2><p><strong>核心线程数（<code>corePoolSize</code>）设置原则：</strong></p>
<ul>
<li><p><strong>CPU 密集型任务</strong>（如加解密、图像处理等）：<code>corePoolSize = CPU 核数 + 1</code>，避免线程频繁上下文切换，充分利用每个核心</p>
</li>
<li><p><strong>IO 密集型任务</strong>（如网络、数据库访问）：<code>corePoolSize = CPU 核数 × 2</code> 或更高，线程大部分时间阻塞于 IO，适当提高线程数以提升吞吐</p>
</li>
</ul>
<p><strong>场景一：电商高并发请求处理</strong>，突发流量高、任务处理快、对响应时间敏感</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">16</span>,                     <span class="comment">// corePoolSize（假设8核CPU × 2）</span></span><br><span class="line">    <span class="number">32</span>,                     <span class="comment">// maximumPoolSize，短时扩容</span></span><br><span class="line">    <span class="number">10</span>, TimeUnit.SECONDS,   <span class="comment">// 非核心线程空闲 10 秒后回收</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(), <span class="comment">// 无缓冲，任务直达线程</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy() <span class="comment">// 拒绝策略：快速失败</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>SynchronousQueue</code> 保证任务直达线程，响应及时</li>
<li>非核心线程可临时扩容，适应突发流量</li>
<li>拒绝策略使用 <code>AbortPolicy</code>，快速失败，结合前端提示“活动火爆”与缓存降级，保护系统稳定</li>
</ul>
<hr>
<p><strong>场景二：后台批处理或日志分析</strong>，流量稳定、任务耗时长、允许延迟</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">8</span>,                             <span class="comment">// 固定线程数，避免资源波动</span></span><br><span class="line">    <span class="number">8</span>,</span><br><span class="line">    <span class="number">0</span>, TimeUnit.SECONDS,           <span class="comment">// 线程始终保留，不回收</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1000</span>), <span class="comment">// 有界队列，容量1000</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="comment">// 调用线程兜底执行</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>限制线程数量，避免资源过载</li>
<li>队列缓冲大量任务，适用于慢速处理</li>
<li>使用 <code>CallerRunsPolicy</code>，队列满时由调用线程执行任务，起到背压效果</li>
<li>配合监控系统，当队列使用率超过阈值（如 80%）可自动触发扩容或报警</li>
</ul>
<hr>
<p><strong>场景三：微服务中处理 HTTP 请求</strong>，IO 密集型，依赖下游服务响应，需考虑请求超时和排队时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">16</span>,                            <span class="comment">// 8 核 CPU × 2，适应 IO 阻塞</span></span><br><span class="line">    <span class="number">64</span>,                            <span class="comment">// 最大线程数，支持更多并发</span></span><br><span class="line">    <span class="number">60</span>, TimeUnit.SECONDS,          <span class="comment">// 非核心线程空闲 1 分钟后回收</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">200</span>), <span class="comment">// 有界队列，防止OOM</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CustomRetryPolicy</span>()         <span class="comment">// 自定义拒绝策略</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>较高的最大线程数应对下游慢响应</li>
<li>有界队列防止内存泄露</li>
<li>自定义拒绝策略（例如将任务放入 Redis 或消息队列）实现异步重试或降级</li>
<li>可配合服务熔断、限流等机制构建完整容灾链路</li>
</ul>
<h2 id="5-核心线程数设置为-0-可以吗？"><a href="#5-核心线程数设置为-0-可以吗？" class="headerlink" title="5# 核心线程数设置为 0 可以吗？"></a>5# 核心线程数设置为 0 可以吗？</h2><p>可以，当核心线程数为 0 的时候，会创建一个非核心线程进行执行</p>
<p>任务提交后，<strong>任务会先尝试加入任务队列</strong>，如果当前没有线程在运行（即 <code>workerCount == 0</code>），则会创建一个<strong>非核心线程</strong>来处理队列中的任务，当任务处理完毕，且该线程处于空闲状态超过 <code>keepAliveTime</code>，它也会被回收</p>
<h2 id="6-线程池种类有哪些？"><a href="#6-线程池种类有哪些？" class="headerlink" title="6# 线程池种类有哪些？"></a>6# 线程池种类有哪些？</h2><p>Java 提供了多种内置线程池，位于 <code>java.util.concurrent.Executors</code> 工具类中，适用于不同的任务调度场景：</p>
<ol>
<li><p><strong>ScheduledThreadPool</strong></p>
<ul>
<li><p><strong>功能：</strong> 支持<strong>定时执行</strong>或<strong>周期性执行</strong>任务</p>
</li>
<li><p><strong>适用场景：</strong> 适合需要在固定时间间隔内重复执行任务的场景，例如：每隔 10 秒执行一次日志清理任务</p>
</li>
<li><p><strong>核心特点：</strong> 使用 <code>ScheduledExecutorService</code> 接口，可通过 <code>schedule()</code> 或 <code>scheduleAtFixedRate()</code> 方法配置延迟或周期性任务</p>
</li>
</ul>
</li>
<li><p><strong>FixedThreadPool</strong></p>
<ul>
<li><p><strong>功能：</strong> 创建一个固定线程数量的线程池</p>
</li>
<li><p><strong>适用场景：</strong> 稳定并发量的业务场景，如处理日志、消息消费等</p>
</li>
<li><p><strong>核心特点：</strong></p>
<ul>
<li>核心线程数 &#x3D; 最大线程数，线程数固定</li>
<li>超过线程数的任务会被放入阻塞队列等待执行</li>
<li>队列满时不会再扩展线程数量，可能触发拒绝策略</li>
<li>线程空闲不会被销毁，长期占用资源</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>CachedThreadPool</strong></p>
<ul>
<li><p><strong>功能：</strong> 创建一个可以无限扩展线程数量的线程池（理论上最大线程数为 <code>Integer.MAX_VALUE</code>）</p>
</li>
<li><p><strong>适用场景：</strong> 适合执行大量、短生命周期的异步任务</p>
</li>
<li><p><strong>核心特点：</strong></p>
<ul>
<li>使用 <code>SynchronousQueue</code> 作为任务队列（容量为 0，不存储任务，只做转交）</li>
<li>没有核心线程，任务来就创建线程</li>
<li>空闲线程在 60 秒后回收</li>
<li>创建和销毁线程代价相对较高，慎用</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>SingleThreadExecutor</strong></p>
<ul>
<li><p><strong>功能：</strong> 创建一个只有<strong>单个工作线程</strong>的线程池</p>
</li>
<li><p><strong>适用场景：</strong> 所有任务需要<strong>严格按照提交顺序</strong>执行的场景</p>
</li>
<li><p><strong>核心特点：</strong></p>
<ul>
<li>使用一个线程串行执行所有任务</li>
<li>线程异常退出时，会自动创建新的线程保障执行连续性</li>
<li>类似 <code>FixedThreadPool(1)</code>，但具备更强的顺序性保障</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>SingleThreadScheduledExecutor</strong></p>
<ul>
<li><p><strong>功能：</strong> 单线程版本的 <code>ScheduledThreadPool</code>，支持定时和周期性任务调度</p>
</li>
<li><p><strong>适用场景：</strong> 需要按顺序、定时执行任务的单线程场景</p>
</li>
<li><p><strong>核心特点：</strong></p>
<ul>
<li>内部只有一个线程</li>
<li>能保证任务按顺序定时执行</li>
<li>是 <code>ScheduledThreadPoolExecutor</code> 的特例</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>是否固定线程</th>
<th>是否支持定时</th>
<th>是否支持扩容</th>
<th>是否保证顺序</th>
</tr>
</thead>
<tbody><tr>
<td><code>FixedThreadPool</code></td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td><code>CachedThreadPool</code></td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td><code>ScheduledThreadPool</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td><code>SingleThreadExecutor</code></td>
<td>✅（1个）</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td><code>SingleThreadScheduledExecutor</code></td>
<td>✅（1个）</td>
<td>✅</td>
<td>❌</td>
<td>✅</td>
</tr>
</tbody></table>
<h2 id="7-线程池一般是怎么用的？"><a href="#7-线程池一般是怎么用的？" class="headerlink" title="7# 线程池一般是怎么用的？"></a>7# 线程池一般是怎么用的？</h2><p>Java 中的 <code>Executors</code> 类定义了一些快捷的工具方法，来帮助我们快速创建线程池。《阿里巴巴 Java 开发手册》中提到，禁止使用这些方法来创建线程池，而应该手动 <code>new ThreadPoolExecutor</code> 来创建线程池</p>
<p>为什么尽量不要用 <code>Executors</code> 快捷工厂？</p>
<table>
<thead>
<tr>
<th><code>Executors</code> 工厂方法</th>
<th>潜在风险</th>
<th>典型事故场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>newFixedThreadPool</code></td>
<td><strong>无界阻塞队列</strong>任务持续堆积 → 内存飙升</td>
<td>高并发秒杀、批量导入，队列挤满导致 OOM</td>
</tr>
<tr>
<td><code>newCachedThreadPool</code></td>
<td><strong>线程无限制增长</strong> (<code>Integer.MAX_VALUE</code>)快速消耗 CPU &#x2F; 句柄</td>
<td>下游接口持续超时，线程池疯狂扩容抢锁、最终拖垮机器</td>
</tr>
</tbody></table>
<ul>
<li>我们需要根据自己的场景、并发情况来评估线程池的几个核心参数，确保线程池的工作行为符合需求，一般都需要设置有界的工作队列和可控的线程数</li>
<li>任何时候，都应该为自定义线程池指定有意义的名称，以方便排查问题。当出现线程数量暴增、线程死锁、线程占用大量 CPU、线程执行出现异常等问题时，我们往往会抓取线程栈。此时，有意义的线程名称，就可以方便我们定位问题</li>
</ul>
<p>除了建议手动声明线程池以外，我还建议用一些监控手段来观察线程池的状态。线程池这个组件往往会表现得任劳任怨、默默无闻，除非是出现了拒绝策略，否则压力再大都不会抛出一个异常。如果我们能提前观察到线程池队列的积压，或者线程数量的快速膨胀，往往可以提早发现并解决问题。</p>
<h2 id="8-线程池中-shutdown-、shutdownNow-这两个方法有什么作用？"><a href="#8-线程池中-shutdown-、shutdownNow-这两个方法有什么作用？" class="headerlink" title="8# 线程池中 shutdown ()、shutdownNow() 这两个方法有什么作用？"></a>8# 线程池中 shutdown ()、shutdownNow() 这两个方法有什么作用？</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>行为特征</th>
</tr>
</thead>
<tbody><tr>
<td><code>shutdown()</code></td>
<td>优雅关闭：执行中的任务继续，等待队列中的任务照常处理</td>
</tr>
<tr>
<td><code>shutdownNow()</code></td>
<td>强制关闭：中断正在执行的任务，清空队列，立即返回未处理任务</td>
</tr>
<tr>
<td>共同点</td>
<td>都会拒绝新的任务提交，线程池状态都会改变，最终尝试终止线程池</td>
</tr>
</tbody></table>
<p><strong>一、<code>shutdown()</code></strong></p>
<p>调用 <code>shutdown()</code> 方法后，线程池的状态将被设置为 <code>SHUTDOWN</code>，此时：</p>
<ul>
<li>已提交但尚未执行的任务<strong>会继续排队等待执行</strong></li>
<li>正在执行的任务<strong>会继续执行直至完成</strong></li>
<li>线程池<strong>不再接收新的任务提交</strong>，否则会抛出 <code>RejectedExecutionException</code> 异常</li>
<li><strong>不会中断正在运行的线程</strong></li>
</ul>
<p>适用于<strong>优雅关闭线程池</strong>的场景</p>
<hr>
<p><strong>二、<code>shutdownNow()</code></strong></p>
<p>调用 <code>shutdownNow()</code> 方法后，线程池状态被设置为 <code>STOP</code>，并执行如下操作：</p>
<ul>
<li><strong>立即中断所有正在运行的线程</strong>（通过 <code>Thread.interrupt()</code> 实现）</li>
<li><strong>放弃队列中尚未执行的任务</strong>，并将这些任务作为 <code>List&lt;Runnable&gt;</code> 返回</li>
<li>同样<strong>不再接受新的任务提交</strong></li>
</ul>
<p>但请注意：<code>Thread.interrupt()</code> 仅能中断那些处于阻塞状态（如 <code>sleep()</code>、<code>wait()</code>、<code>join()</code>、<code>Condition.await()</code>、定时锁等）的线程，对于纯计算类任务并无实际中断效果</p>
<p>因此，调用 <code>shutdownNow()</code> 并不意味着线程池能够<strong>立即关闭</strong>，它可能仍需等待某些任务结束才能真正终止</p>
<h2 id="9-提交给线程池的任务可以撤回吗？"><a href="#9-提交给线程池的任务可以撤回吗？" class="headerlink" title="9# 提交给线程池的任务可以撤回吗？"></a>9# 提交给线程池的任务可以撤回吗？</h2><p>可以。在 Java 中，当向线程池提交任务时，会返回一个 <code>Future</code> 对象。通过这个对象，可以对任务的执行过程进行控制，例如：获取任务执行结果、判断任务是否完成、尝试取消任务执行</p>
<p><code>Future</code> 接口提供了 <code>cancel(boolean mayInterruptIfRunning)</code> 方法，用于取消任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>mayInterruptIfRunning = true</code>：如果任务正在运行，尝试中断该任务（调用 <code>Thread.interrupt()</code>）</li>
<li><code>mayInterruptIfRunning = false</code>：如果任务已启动，则不会中断，仅取消尚未开始的任务</li>
</ul>
<p>此外，<code>Future</code> 还提供了以下常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;   <span class="comment">// 判断任务是否已取消</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;        <span class="comment">// 判断任务是否已完成（成功/失败/取消都算完成）</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">()</span>;                 <span class="comment">// 获取任务结果（阻塞直到结果返回或异常抛出）</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span>; <span class="comment">// 限时获取任务结果</span></span><br></pre></td></tr></table></figure>

<p>取消线程池中的任务示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CancelTaskDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        Future&lt;?&gt; future = service.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟耗时任务</span></span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;任务完成&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务被中断&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 等待任务完成</span></span><br><span class="line">            future.get(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException | TimeoutException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务超时，尝试取消...&quot;</span>);</span><br><span class="line">            <span class="comment">// 超时后尝试取消任务（允许中断）</span></span><br><span class="line">            future.cancel(<span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            service.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><h2 id="1-多线程打印奇偶数，怎么控制打印的顺序？"><a href="#1-多线程打印奇偶数，怎么控制打印的顺序？" class="headerlink" title="1# 多线程打印奇偶数，怎么控制打印的顺序？"></a>1# 多线程打印奇偶数，怎么控制打印的顺序？</h2><p><strong>交替打印奇偶数（<code>wait/notify</code> 方案）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintOddEven</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">odd</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; printNumber(<span class="literal">true</span>),  <span class="string">&quot;OddThread&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">even</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; printNumber(<span class="literal">false</span>), <span class="string">&quot;EvenThread&quot;</span>);</span><br><span class="line">        odd.start();</span><br><span class="line">        even.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@param</span> printOdd true 打印奇数，false 打印偶数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printNumber</span><span class="params">(<span class="type">boolean</span> printOdd)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="keyword">if</span> (counter &gt; MAX) &#123;</span><br><span class="line">                    LOCK.notifyAll();          <span class="comment">// 唤醒对方后退出</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((counter &amp; <span class="number">1</span>) == (printOdd ? <span class="number">1</span> : <span class="number">0</span>)) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%s : %d%n&quot;</span>,</span><br><span class="line">                            Thread.currentThread().getName(), counter++);</span><br><span class="line">                    LOCK.notifyAll();          <span class="comment">// 打印完唤醒对方</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123; LOCK.wait(); &#125;       <span class="comment">// 条件不满足，挂起</span></span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么能交替输出？</strong></p>
<ol>
<li><strong>共享状态</strong>：<code>counter</code> 决定当前应打印奇数还是偶数</li>
<li><strong>互斥</strong>：<code>synchronized (LOCK)</code> 保证同一时刻只有一个线程在修改 <code>counter</code></li>
<li><strong>协作</strong>：打印线程完成一次输出后调用 <code>notifyAll()</code>，提醒对方线程条件可能满足,如果发现当前不该自己打印，则调用 <code>wait()</code> 释放锁并挂起，等待被唤醒</li>
</ol>
<p>这样就形成了“<strong>打印 → 唤醒对方 → 自己等待</strong>”的循环，保证奇、偶顺序交替</p>
<p><strong>注意</strong>：<code>notifyAll()</code> 比 <code>notify()</code> 更安全，避免“假唤醒”或只有单线程等待场景时对方仍沉睡</p>
<h2 id="2-单例模型既然已经用了-synchronized，为什么还要在加-volatile？"><a href="#2-单例模型既然已经用了-synchronized，为什么还要在加-volatile？" class="headerlink" title="2# 单例模型既然已经用了 synchronized，为什么还要在加 volatile？"></a>2# 单例模型既然已经用了 synchronized，为什么还要在加 volatile？</h2><p>使用 <code>synchronized</code> 和 <code>volatile</code> 一起，可以创建一个既线程安全又能正确初始化的单例模式，避免了多线程环境下的各种潜在问题。这是一种比较完善的线程安全的单例模式实现方式，尤其适用于高并发环境</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>synchronized</code> 关键字的作用用于确保在多线程环境下，只有一个线程能够进入同步块（这里是 <code>synchronized (Singleton.class)</code>）。在创建单例对象时，通过 <code>synchronized</code> 保证了创建过程的线程安全性，避免多个线程同时创建多个单例对象</p>
<p><code>volatile</code> 确保了对象引用的可见性和创建过程的有序性，避免了由于指令重排序而导致的错误</p>
<p><code>instance = new Singleton();</code> 这行代码并不是一个原子操作，它实际上可以分解为以下几个步骤：</p>
<ul>
<li>分配内存空间。</li>
<li>实例化对象。</li>
<li>将对象引用赋值给 <code>instance</code>。</li>
</ul>
<p>由于 Java 内存模型允许编译器和处理器对指令进行重排序，在没有 <code>volatile</code> 的情况下，可能会出现重排序，例如先将对象引用赋值给 <code>instance</code>，但对象的实例化操作尚未完成</p>
<p>这样，其他线程在检查 <code>instance == null</code> 时，会认为单例已经创建，从而得到一个未完全初始化的对象，导致错误</p>
<p><code>volatile</code> 可以保证变量的可见性和禁止指令重排序。它确保对 <code>instance</code> 的修改对所有线程都是可见的，并且保证了上述三个步骤按顺序执行，避免了在单例创建过程中因指令重排序而导致的问题</p>
<h2 id="3-3-个线程并发执行，1-个线程等待这三个线程全部执行完在执行，怎么实现？"><a href="#3-3-个线程并发执行，1-个线程等待这三个线程全部执行完在执行，怎么实现？" class="headerlink" title="3# 3 个线程并发执行，1 个线程等待这三个线程全部执行完在执行，怎么实现？"></a>3# 3 个线程并发执行，1 个线程等待这三个线程全部执行完在执行，怎么实现？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatchDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">workers</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(workers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 个工作线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= workers; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Worker-&quot;</span> + id + <span class="string">&quot; working...&quot;</span>);</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;Worker-&quot;</span> + id + <span class="string">&quot; done.&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    latch.countDown();         <span class="comment">// 完成后递减计数</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有工作线程结束</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Awaiting completion of workers...&quot;</span>);</span><br><span class="line">                latch.await();                 <span class="comment">// 阻塞，直到计数=0</span></span><br><span class="line">                System.out.println(<span class="string">&quot;All workers finished. Main task starts.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Coordinator&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码说明</strong></p>
<ol>
<li><code>CountDownLatch latch = new CountDownLatch(3);</code><br> 创建一个计数器，初始值为 3，代表有 3 个线程需要 “倒计时”</li>
<li>每个线程在执行完任务后，调用 <code>latch.countDown()</code> 将计数器减 1</li>
<li>第 4 个线程调用 <code>latch.await()</code>，阻塞等待直到计数器变为 0，再继续执行自己的任务</li>
</ol>
<h2 id="4-假设两个线程并发读写同一个整型变量，初始值为零，每个线程加-50-次，结果可能是什么？"><a href="#4-假设两个线程并发读写同一个整型变量，初始值为零，每个线程加-50-次，结果可能是什么？" class="headerlink" title="4# 假设两个线程并发读写同一个整型变量，初始值为零，每个线程加 50 次，结果可能是什么？"></a>4# 假设两个线程并发读写同一个整型变量，初始值为零，每个线程加 50 次，结果可能是什么？</h2><p>在没有任何同步机制的情况下，两个线程并发对同一个整型变量进行 50 次加 1 操作，最终结果可能是 100，也可能小于 100，最坏的结果是 50，也就是最终的结果可能是在 [50, 100] </p>
<p><strong>原因</strong></p>
<p><code>num++</code> 操作并不是原子操作，它实际包含以下三个步骤：</p>
<ol>
<li>读取变量的当前值</li>
<li>将值加 1</li>
<li>将新值写回变量</li>
</ol>
<p>在多线程环境中，如果两个线程同时读取了相同的值并分别加 1，然后再写回，就会导致 “加 1” 操作丢失，从而导致最终结果小于预期</p>
<p><strong>解决方案一：使用 AtomicInteger</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerAddition</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                num.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                num.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;最终结果: &quot;</span> + num.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案二：使用 synchronized 或 ReentrantLock</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedAddition</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;最终结果: &quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>八股文笔记 #4 Java JVM</title>
    <url>/2025/09/11/boilerplate-answers-4-java-jvm/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><h2 id="1-介绍一下-JVM-的内存模型"><a href="#1-介绍一下-JVM-的内存模型" class="headerlink" title="1# 介绍一下 JVM 的内存模型"></a>1# 介绍一下 JVM 的内存模型</h2><p>在 JDK 8 中，JVM 的运行时内存主要分为以下几个部分：程序计数器、虚拟机栈、本地方法栈、堆、方法区（元空间），以及不属于规范规定但常用的直接内存。</p>
<ul>
<li><strong>程序计数器</strong>：可以看作是当前线程所执行的字节码的行号指示器，用于存储当前线程正在执行的 Java 方法的 JVM 指令地址。如果线程执行的是 Native 方法，计数器值为 null。是唯一一个在 Java 虚拟机规范中没有规定任何 <code>OutOfMemoryError</code> 情况的区域，生命周期与线程相同。</li>
<li><strong>Java 虚拟机栈</strong>：每个线程都有自己独立的 Java 虚拟机栈，生命周期与线程相同。每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。可能会抛出 <code>StackOverflowError</code> 和 <code>OutOfMemoryError</code> 异常。</li>
<li><strong>本地方法栈</strong>：与 Java 虚拟机栈类似，主要为虚拟机使用到的 Native 方法服务，在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。本地方法执行时也会创建栈帧，同样可能出现 <code>StackOverflowError</code> 和 <code>OutOfMemoryError</code> 两种错误。</li>
<li><strong>Java 堆</strong>：是 JVM 中最大的一块内存区域，被所有线程共享，在虚拟机启动时创建，用于存放对象实例。从内存回收角度，堆被划分为新生代和老年代，新生代又分为 Eden 区和两个 Survivor 区（From Survivor 和 To Survivor）。如果在堆中没有内存完成实例分配，并且堆也无法扩展时会抛出 <code>OutOfMemoryError</code> 异常。</li>
<li><strong>方法区（元空间）</strong>：在 JDK 1.8 及以后的版本中，方法区被元空间取代，使用本地内存。用于存储已被虚拟机加载的类信息、常量、静态变量等数据。虽然方法区被描述为堆的逻辑部分，但有 “非堆” 的别名。方法区可以选择不实现垃圾收集，内存不足时会抛出 <code>OutOfMemoryError</code> 异常。</li>
<li><strong>运行时常量池</strong>：是方法区的一部分，用于存放编译期生成的各种字面量和符号引用，具有动态性，运行时也可将新的常量放入池中。当无法申请到足够内存时，会抛出 <code>OutOfMemoryError</code> 异常。</li>
<li><strong>直接内存</strong>：不属于 JVM 运行时数据区的一部分，通过 NIO 类引入，是一种堆外内存，可以显著提高 I&#x2F;O 性能。直接内存的使用受到本机总内存的限制，若分配不当，可能导致 <code>OutOfMemoryError</code> 异常。</li>
</ul>
<h1 id="类初始化和类加载"><a href="#类初始化和类加载" class="headerlink" title="类初始化和类加载"></a>类初始化和类加载</h1><h2 id="1-创建对象的过程？"><a href="#1-创建对象的过程？" class="headerlink" title="1# 创建对象的过程？"></a>1# 创建对象的过程？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1713516384566-e820b967-73ce-49a4-a6e6-36af9a38ebc4.webp" alt="img">在Java中创建对象的过程包括以下几个步骤：</p>
<ol>
<li><strong>类加载检查</strong>：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在<strong>常量池</strong>中定位到一个类的<strong>符号引用</strong>，并且检查这个符号引用代表的类是否已被<strong>加载过、解析和初始化</strong>过。如果没有，那必须先执行相应的<strong>类加载过程</strong>。</li>
<li><strong>分配内存</strong>：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的<strong>内存大小</strong>在<strong>类加载</strong>完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。</li>
<li><strong>初始化零值</strong>：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li>
<li><strong>进行必要设置，比如对象头</strong>：初始化零值完成之后，虚拟机要对对象进行<strong>必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在<strong>对象头</strong>中。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li>
<li><strong>执行 init 方法</strong>：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始——构造函数，即class文件中的方法还没有执行，所有的字段都还为零，<strong>对象需要的其他资源和状态信息</strong>还没有按照预定的意图构造好。所以一般来说，执行 new 指令之后会接着执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全被构造出来。</li>
</ol>
<h2 id="2-讲一下类加载过程？"><a href="#2-讲一下类加载过程？" class="headerlink" title="2# 讲一下类加载过程？"></a>2# 讲一下类加载过程？</h2><p>类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括以下 7 个阶段：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1719491354969-a7c861d7-531e-45d3-a4aa-4696710ec297.webp" alt="类加载过程"></p>
<ul>
<li><p><strong>加载</strong>：通过类的全限定名（包名 + 类名），获取到该类的.class文件的二进制字节流，将二进制字节流所代表的静态存储结构，转化为方法区运行时的数据结构，在内存中生成一个代表该类的 Java.lang.Class 对象，作为方法区这个类的各种数据的访问入口</p>
</li>
<li><p>连接</p>
<p>：验证、准备、解析 3 个阶段统称为连接。</p>
<ul>
<li><strong>验证</strong>：确保class文件中的字节流包含的信息，符合当前虚拟机的要求，保证这个被加载的class类的正确性，不会危害到虚拟机的安全。验证阶段大致会完成以下四个阶段的检验动作：文件格式校验、元数据验证、字节码验证、符号引用验证</li>
<li><strong>准备</strong>：为类中的静态字段分配内存，并设置默认的初始值，比如int类型初始值是0。被final修饰的static字段不会设置，因为final在编译的时候就分配了</li>
<li><strong>解析</strong>：解析阶段是虚拟机将常量池的「符号引用」直接替换为「直接引用」的过程。符号引用是以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用的时候可以无歧义地定位到目标即可。直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄，直接引用是和虚拟机实现的内存布局相关的。如果有了直接引用， 那引用的目标必定已经存在在内存中了。</li>
</ul>
</li>
<li><p><strong>初始化</strong>：初始化是整个类加载过程的最后一个阶段，初始化阶段简单来说就是执行类的构造器方法（() ），要注意的是这里的构造器方法()并不是开发者写的，而是编译器自动生成的。</p>
</li>
<li><p><strong>使用</strong>：使用类或者创建对象</p>
</li>
<li><p>卸载：一个类要被JVM卸载，条件非常苛刻，</p>
<p>需要同时满足以下三点：</p>
<ul>
<li><strong>该类所有的实例都已经被回收</strong>：这是最显而易见的前提。如果堆中还存在这个类的任何一个实例对象，那么定义这个对象的Class对象肯定不能被卸载。</li>
<li><strong>加载该类的 ClassLoader 已经被回收</strong>：这是<strong>最关键也是最难满足的条件</strong>。类与其加载器是双向绑定的共生关系。一个类由哪个类加载器加载，这个信息是存储在Class对象里的。要卸载一个类，必须先卸载加载它的类加载器。</li>
<li><strong>类对应的 Java.lang.Class 对象没有任何地方被引用</strong>：不能在任何地方通过反射（如静态字段、全局变量）、静态变量、JNI等途径引用到这个Class对象。一旦这个Class对象还存在强引用，GC就不会回收它，那么这个类也就不会被卸载。</li>
</ul>
</li>
</ul>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="1-垃圾回收是什么？如何触发垃圾回收？"><a href="#1-垃圾回收是什么？如何触发垃圾回收？" class="headerlink" title="1# 垃圾回收是什么？如何触发垃圾回收？"></a>1# 垃圾回收是什么？如何触发垃圾回收？</h2><p>垃圾回收是 JVM 提供的一种 <strong>自动内存管理机制</strong>。它会自动识别并释放程序中 <strong>不再被引用的对象</strong> 所占用的堆内存，从而避免内存泄漏和手动管理内存带来的错误。<br> 换句话说，GC 的作用就是让开发者不用像 C&#x2F;C++ 那样手动释放内存，而是把内存清理工作交给 JVM 来完成。</p>
<p><strong>垃圾回收的触发时机</strong></p>
<ol>
<li><strong>内存不足</strong>：当 JVM 检测到堆空间不足以分配新对象时，会自动触发垃圾回收。</li>
<li><strong>手动请求</strong>：开发者可以调用 <code>System.gc()</code> 或 <code>Runtime.getRuntime().gc()</code> 来“建议”JVM 执行垃圾回收。但这只是建议，是否立即执行取决于 JVM。</li>
<li><strong>JVM 参数控制</strong>：运行应用时可以通过参数（如 <code>-Xmx</code> 设置最大堆大小，<code>-Xms</code> 设置初始堆大小）来影响垃圾回收的频率和行为。</li>
<li><strong>内部策略</strong>：垃圾收集器内部会根据对象创建速率、内存使用情况等设定阈值，当条件达到时触发回收。</li>
</ol>
<p><strong>如何判断对象是垃圾？</strong></p>
<p>JVM 需要判断哪些对象已经“不可达”，从而可以被回收。常见的两种方法是：</p>
<ol>
<li><strong>引用计数法（Reference Counting）</strong></li>
</ol>
<ul>
<li><strong>原理</strong>：为对象维护一个引用计数器，每当有一个引用指向它时计数 +1，引用失效时计数 -1。当计数变为 0 时，对象被认为不再可用，可以回收。</li>
<li><strong>缺点</strong>：无法处理循环引用。例如对象 A 引用 B，B 又引用 A，但它们已经不再被其他地方使用时，引用计数仍大于 0，导致无法被回收。</li>
</ul>
<ol start="2">
<li><strong>可达性分析算法（Reachability Analysis）</strong></li>
</ol>
<p>这是 <strong>Java 虚拟机主要采用的垃圾判断方式</strong>。</p>
<ul>
<li><strong>原理</strong>：从一组被称为 <strong>GC Roots</strong> 的对象出发，沿着引用链向下搜索，能被 GC Roots 直接或间接关联到的对象都是“存活的”。如果某个对象和 GC Roots 之间没有任何引用链相连，则被视为“不可达”，可以被回收。</li>
<li><strong>GC Roots 包括</strong>：<ul>
<li>虚拟机栈（栈帧中本地变量表）中的引用对象</li>
<li>方法区中类的静态属性引用的对象</li>
<li>本地方法栈中 JNI（Native 方法）引用的对象</li>
<li>活跃线程对象</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>八股文笔记 #5 Java Spring</title>
    <url>/2025/09/17/boilerplate-answers-5-java-spring/</url>
    <content><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="1-说一下你对-Spring-的理解"><a href="#1-说一下你对-Spring-的理解" class="headerlink" title="1# 说一下你对 Spring 的理解"></a>1# 说一下你对 Spring 的理解</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1712650311366-b499469c-5afd-4be9-bad3-d787de86bf98.png" alt="img"></p>
<span id="more"></span>

<p>Spring框架核心特性包括：</p>
<ul>
<li><strong>IoC容器</strong>：Spring通过控制反转实现了对象的创建和对象间的依赖关系管理。开发者只需要定义好Bean及其依赖关系，Spring容器负责创建和组装这些对象。</li>
<li><strong>AOP</strong>：面向切面编程，允许开发者定义横切关注点，例如事务管理、安全控制等，独立于业务逻辑的代码。通过AOP，可以将这些关注点模块化，提高代码的可维护性和可重用性。</li>
<li><strong>事务管理</strong>：Spring提供了一致的事务管理接口，支持声明式和编程式事务。开发者可以轻松地进行事务管理，而无需关心具体的事务API。</li>
<li><strong>MVC框架</strong>：Spring MVC是一个基于Servlet API构建的Web框架，采用了模型-视图-控制器（MVC）架构。它支持灵活的URL到页面控制器的映射，以及多种视图技术。</li>
</ul>
<h2 id="2-Spring-是怎么管理对象的？"><a href="#2-Spring-是怎么管理对象的？" class="headerlink" title="2# Spring 是怎么管理对象的？"></a>2# Spring 是怎么管理对象的？</h2><ul>
<li>核心是 <strong>IoC（控制反转）容器</strong>，由 <code>ApplicationContext</code> 管理对象（Bean）。</li>
<li>Spring 负责对象的：<strong>创建 → 初始化 → 生命周期管理 → 销毁</strong>。</li>
<li>Bean 定义写在注解&#x2F;XML&#x2F;配置类里，Spring 容器启动时会扫描并实例化。</li>
<li>注入依赖时用 <strong>依赖注入（DI）</strong>，避免开发者手动 <code>new</code> 对象。</li>
</ul>
<h2 id="3-Autowired-和-Resource-的区别？"><a href="#3-Autowired-和-Resource-的区别？" class="headerlink" title="3# @Autowired 和 @Resource 的区别？"></a>3# @Autowired 和 @Resource 的区别？</h2><ul>
<li><code>@Autowired</code>（Spring 提供）：默认 <strong>按类型</strong> 注入，需要配合 <code>@Qualifier</code> 指定 Bean 名称。</li>
<li><code>@Resource</code>（JDK 提供）：默认 <strong>按名称</strong> 注入，找不到再按类型。</li>
<li>依赖冲突时：<ul>
<li><code>@Autowired</code> 必须配合 <code>@Qualifier</code> 或 <code>@Primary</code>。</li>
<li><code>@Resource</code> 直接指定 <code>name</code>。</li>
</ul>
</li>
</ul>
<h2 id="4-Spring-的核心思想说说你的理解？"><a href="#4-Spring-的核心思想说说你的理解？" class="headerlink" title="4# Spring 的核心思想说说你的理解？"></a>4# Spring 的核心思想说说你的理解？</h2><table>
<thead>
<tr>
<th><strong>核心思想</strong></th>
<th><strong>解决的问题</strong></th>
<th><strong>实现手段</strong></th>
<th><strong>典型应用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>IOC</strong></td>
<td>对象创建与依赖管理的高耦合</td>
<td>容器管理Bean生命周期</td>
<td>动态替换数据库实现、服务组装</td>
</tr>
<tr>
<td><strong>DI</strong></td>
<td>依赖关系的硬编码问题</td>
<td>Setter&#x2F;构造器&#x2F;注解注入</td>
<td>注入数据源、服务层依赖DAO层</td>
</tr>
<tr>
<td><strong>AOP</strong></td>
<td>横切逻辑分散在业务代码中</td>
<td>动态代理与切面配置</td>
<td>日志、事务、权限校验统一处理</td>
</tr>
</tbody></table>
<p>Spring通过这IOC、DI、AOP三大核心思想，实现了轻量级、高内聚低耦合的企业级应用开发框架，成为Java生态中不可或缺的基石。</p>
<h2 id="5-依赖倒置，依赖注入，控制反转分别是什么？"><a href="#5-依赖倒置，依赖注入，控制反转分别是什么？" class="headerlink" title="5# 依赖倒置，依赖注入，控制反转分别是什么？"></a>5# 依赖倒置，依赖注入，控制反转分别是什么？</h2><ul>
<li>控制反转：“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。</li>
<li>依赖注入：依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。</li>
<li>依赖倒置：这条原则跟控制反转有点类似，主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。</li>
</ul>
<h2 id="6-怎么理解-Spring-IoC？"><a href="#6-怎么理解-Spring-IoC？" class="headerlink" title="6# 怎么理解 Spring IoC？"></a>6# 怎么理解 Spring IoC？</h2><p><strong>IOC</strong>：Inversion Of Control，即控制反转，是一种设计思想。在传统的 Java SE 程序设计中，我们直接在对象内部通过 new 的方式来创建对象，是程序主动创建依赖对象；</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1716790809843-e520e960-fb95-4511-aa30-73966361320a.webp" alt="img"></p>
<p>而在Spring程序设计中，IOC 是有专门的容器去控制对象。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1716790809860-74256f8b-3a96-485c-8aa1-11fa5dfb7640.webp" alt="img"></p>
<p><strong>所谓控制</strong>就是对象的创建、初始化、销毁。</p>
<ul>
<li>创建对象：原来是 new 一个，现在是由 Spring 容器创建。</li>
<li>初始化对象：原来是对象自己通过构造器或者 setter 方法给依赖的对象赋值，现在是由 Spring 容器自动注入。</li>
<li>销毁对象：原来是直接给对象赋值 null 或做一些销毁操作，现在是 Spring 容器管理生命周期负责销毁对象。</li>
</ul>
<p>总结：IOC 解决了繁琐的对象生命周期的操作，解耦了我们的代码。<strong>所谓反转</strong>：其实是反转的控制权，前面提到是由 Spring 来控制对象的生命周期，那么对象的控制就完全脱离了我们的控制，控制权交给了 Spring 。这个反转是指：我们由对象的控制者变成了 IOC 的被动控制者。</p>
<h2 id="7-Spring-的-AOP-介绍一下"><a href="#7-Spring-的-AOP-介绍一下" class="headerlink" title="7# Spring 的 AOP 介绍一下"></a>7# Spring 的 AOP 介绍一下</h2><p>Spring AOP是Spring框架中的一个重要模块，用于实现面向切面编程。</p>
<p>我们知道，Java 就是一门面向对象编程的语言，在 OOP 中最小的单元就是“Class 对象”，但是在 AOP 中最小的单元是“切面”。一个“切面”可以包含很多种类型和对象，对它们进行模块化管理，例如事务管理。</p>
<p>在面向切面编程的思想里面，把功能分为两种</p>
<ul>
<li><strong>核心业务</strong>：登陆、注册、增、删、改、查、都叫核心业务</li>
<li><strong>周边功能</strong>：日志、事务管理这些次要的为周边业务</li>
</ul>
<p>在面向切面编程中，核心业务功能和周边功能是分别独立进行开发，两者不是耦合的，然后把切面功能和核心业务功能 “编织” 在一起，这就叫AOP。</p>
<p>AOP能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>
<p>在 AOP 中有以下几个概念：</p>
<ul>
<li><strong>AspectJ</strong>：切面，只是一个概念，没有具体的接口或类与之对应，是 Join point，Advice 和 Pointcut 的一个统称。</li>
<li><strong>Join point</strong>：连接点，指程序执行过程中的一个点，例如方法调用、异常处理等。在 Spring AOP 中，仅支持方法级别的连接点。</li>
<li><strong>Advice</strong>：通知，即我们定义的一个切面中的横切逻辑，有“around”，“before”和“after”三种类型。在很多的 AOP 实现框架中，Advice 通常作为一个拦截器，也可以包含许多个拦截器作为一条链路围绕着 Join point 进行处理。</li>
<li><strong>Pointcut</strong>：切点，用于匹配连接点，一个 AspectJ 中包含哪些 Join point 需要由 Pointcut 进行筛选。</li>
<li><strong>Introduction</strong>：引介，让一个切面可以声明被通知的对象实现任何他们没有真正实现的额外的接口。例如可以让一个代理对象代理两个目标类。</li>
<li><strong>Weaving</strong>：织入，在有了连接点、切点、通知以及切面，如何将它们应用到程序中呢？没错，就是织入，在切点的引导下，将通知逻辑插入到目标方法上，使得我们的通知逻辑在方法调用时得以执行。</li>
<li><strong>AOP proxy</strong>：AOP 代理，指在 AOP 实现框架中实现切面协议的对象。在 Spring AOP 中有两种代理，分别是 JDK 动态代理和 CGLIB 动态代理。</li>
<li><strong>Target object</strong>：目标对象，就是被代理的对象。</li>
</ul>
<p>Spring AOP 是基于 JDK 动态代理和 Cglib 提升实现的，两种代理方式都属于运行时的一个方式，所以它没有编译时的一个处理，那么因此 Spring 是通过 Java 代码实现的。</p>
<h2 id="8-Spring-AOP-主要想解决什么问题？"><a href="#8-Spring-AOP-主要想解决什么问题？" class="headerlink" title="8# Spring AOP 主要想解决什么问题？"></a>8# Spring AOP 主要想解决什么问题？</h2><p>它的目的是对于面向对象思维的一种补充，而不是像引入命令式、函数式编程思维让他顺应另一种开发场景。在我个人的理解下AOP更像是一种对于不支持多继承的弥补，除开对象的主要特征（我更喜欢叫“强共性”）被抽象为了一条继承链路，对于一些“弱共性”，AOP可以统一对他们进行抽象和集中处理。</p>
<p>举一个简单的例子，打印日志。需要打印日志可能是许多对象的一个共性，这在企业级开发中十分常见，但是日志的打印并不反应这个对象的主要共性。而日志的打印又是一个具体的内容，它并不抽象，所以它的工作也不可以用接口来完成。而如果利用继承，打印日志的工作又横跨继承树下面的多个同级子节点，强行侵入到继承树内进行归纳会干扰这些强共性的区分。</p>
<p>这时候，我们就需要AOP了。AOP首先在一个Aspect（切面）里定义了一些Advice（增强），其中包含具体实现的代码，同时整理了切入点，切入点的粒度是方法。最后，我们将这些Advice织入到对象的方法上，形成了最后执行方法时面对的完整方法。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1716791217083-132fe2ba-706a-4d8d-aef3-1617a2046585.png" alt="img"></p>
<h2 id="9-Spring-AOP-的原理了解吗？"><a href="#9-Spring-AOP-的原理了解吗？" class="headerlink" title="9# Spring AOP 的原理了解吗？"></a>9# Spring AOP 的原理了解吗？</h2><p>Spring AOP的实现依赖于<strong>动态代理技术</strong>。动态代理是在运行时动态生成代理对象，而不是在编译时。它允许开发者在运行时指定要代理的接口和行为，从而实现在不修改源码的情况下增强方法的功能。</p>
<p>Spring AOP支持两种动态代理：</p>
<ul>
<li><strong>基于JDK的动态代理</strong>：使用java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口实现。这种方式需要代理的类实现一个或多个接口。</li>
<li><strong>基于CGLIB的动态代理</strong>：当被代理的类没有实现接口时，Spring会使用CGLIB库生成一个被代理类的子类作为代理。CGLIB（Code Generation Library）是一个第三方代码生成库，通过继承方式实现代理。</li>
</ul>
<h2 id="10-AOP-实现有哪些注解？"><a href="#10-AOP-实现有哪些注解？" class="headerlink" title="10# AOP 实现有哪些注解？"></a>10# AOP 实现有哪些注解？</h2><p>常用的注解包括：</p>
<ul>
<li>@Aspect：用于定义切面，标注在切面类上。</li>
<li>@Pointcut：定义切点，标注在方法上，用于指定连接点。</li>
<li>@Before：在方法执行之前执行通知。</li>
<li>@After：在方法执行之后执行通知。</li>
<li>@Around：在方法执行前后都执行通知。</li>
<li>@AfterReturning：在方法执行后返回结果后执行通知。</li>
<li>@AfterThrowing：在方法抛出异常后执行通知。</li>
<li>@Advice：通用的通知类型，可以替代@Before、@After等。</li>
</ul>
<h2 id="11-依赖注入了解吗？怎么实现依赖注入的？"><a href="#11-依赖注入了解吗？怎么实现依赖注入的？" class="headerlink" title="11# 依赖注入了解吗？怎么实现依赖注入的？"></a>11# 依赖注入了解吗？怎么实现依赖注入的？</h2><p>在传统编程中，当一个类需要使用另一个类的对象时，通常会在该类内部通过<code>new</code>关键字来创建依赖对象，这使得类与类之间的耦合度较高。</p>
<p>而依赖注入则是将对象的创建和依赖关系的管理交给 Spring 容器来完成，类只需要声明自己所依赖的对象，容器会在运行时将这些依赖对象注入到类中，从而降低了类与类之间的耦合度，提高了代码的可维护性和可测试性。</p>
<p>具体到Spring中，常见的依赖注入的实现方式，比如构造器注入、Setter方法注入，还有字段注入。</p>
<ul>
<li>**构造器注入：**通过构造函数传递依赖对象，保证对象初始化时依赖已就绪。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造器注入（Spring 4.3+ 自动识别单构造器，无需显式@Autowired）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>**Setter 方法注入：**通过 Setter 方法设置依赖，灵活性高，但依赖可能未完全初始化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PaymentGateway gateway;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGateway</span><span class="params">(PaymentGateway gateway)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gateway = gateway;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>**字段注入：**直接通过 <code>@Autowired</code> 注解字段，代码简洁但隐藏依赖关系，不推荐生产代码。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderRepository orderRepository;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="12-Bean-的生命周期？"><a href="#12-Bean-的生命周期？" class="headerlink" title="12# Bean 的生命周期？"></a>12# Bean 的生命周期？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1719570477922-ad595a67-be98-4272-9e13-8ad73dd75c13.png" alt="img"></p>
<ol>
<li>Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化</li>
<li>Bean实例化后对将Bean的引入和值注入到Bean的属性中</li>
<li>如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法</li>
<li>如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入</li>
<li>如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。</li>
<li>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。</li>
<li>如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用</li>
<li>如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。</li>
<li>此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。</li>
<li>如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用</li>
</ol>
<h2 id="13-Bean的作用域有哪些？"><a href="#13-Bean的作用域有哪些？" class="headerlink" title="13# Bean的作用域有哪些？"></a>13# Bean的作用域有哪些？</h2><p>Spring框架中的Bean作用域（Scope）定义了Bean的生命周期和可见性。不同的作用域影响着Spring容器如何管理这些Bean的实例，包括它们如何被创建、如何被销毁以及它们是否可以被多个用户共享。</p>
<p>Spring支持几种不同的作用域，以满足不同的应用场景需求。以下是一些主要的Bean作用域：</p>
<ul>
<li><strong>Singleton（单例）</strong>：在整个应用程序中只存在一个 Bean 实例。默认作用域，Spring 容器中只会创建一个 Bean 实例，并在容器的整个生命周期中共享该实例。</li>
<li><strong>Prototype（原型）</strong>：每次请求时都会创建一个新的 Bean 实例。次从容器中获取该 Bean 时都会创建一个新实例，适用于状态非常瞬时的 Bean。</li>
<li><strong>Request（请求）</strong>：每个 HTTP 请求都会创建一个新的 Bean 实例。仅在 Spring Web 应用程序中有效，每个 HTTP 请求都会创建一个新的 Bean 实例，适用于 Web 应用中需求局部性的 Bean。</li>
<li><strong>Session（会话）</strong>：Session 范围内只会创建一个 Bean 实例。该 Bean 实例在用户会话范围内共享，仅在 Spring Web 应用程序中有效，适用于与用户会话相关的 Bean。</li>
<li><strong>Application</strong>：当前 ServletContext 中只存在一个 Bean 实例。仅在 Spring Web 应用程序中有效，该 Bean 实例在整个 ServletContext 范围内共享，适用于应用程序范围内共享的 Bean。</li>
<li><strong>WebSocket（Web套接字）</strong>：在 WebSocket 范围内只存在一个 Bean 实例。仅在支持 WebSocket 的应用程序中有效，该 Bean 实例在 WebSocket 会话范围内共享，适用于 WebSocket 会话范围内共享的 Bean。</li>
<li><strong>Custom scopes（自定义作用域）</strong>：Spring 允许开发者定义自定义的作用域，通过实现 Scope 接口来创建新的 Bean 作用域。</li>
</ul>
<p>在Spring配置文件中，可以通过<code>&lt;bean&gt;</code>标签的scope属性来指定Bean的作用域。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.MyBeanClass&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>在Spring Boot或基于Java的配置中，可以通过@Scope注解来指定Bean的作用域。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>  </span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> MyBeanClass <span class="title function_">myBean</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBeanClass</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h2 id="1-MVC-分层介绍一下"><a href="#1-MVC-分层介绍一下" class="headerlink" title="1# MVC 分层介绍一下"></a>1# MVC 分层介绍一下</h2><p>MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。</p>
<ul>
<li><strong>视图(view)： 为用户提供使用界面，与用户直接进行交互。</strong></li>
<li><strong>模型(model)： 代表一个存取数据的对象或 JAVA POJO（Plain Old Java Object，简单java对象）。它也可以带有逻辑，主要用于承载数据，并对用户提交请求进行计算的模块。模型分为两类，一类称为数据承载 Bean，一类称为业务处理Bean。所谓数据承载 Bean 是指实体类（如：User类），专门为用户承载业务数据的；而业务处理 Bean 则是指Service 或 Dao 对象， 专门用于处理用户提交请求的。</strong></li>
<li><strong>控制器(controller)： 用于将用户请求转发给相应的 Model 进行处理，并根据 Model 的计算结果向用户提供相应响应。它使视图与模型分离。</strong></li>
</ul>
<p><img src="https://cdn.xiaolincoding.com//picgo/1713944902120-e35c2b4f-e290-4973-aa1a-3193af3bb371.png" alt="img"></p>
<p>流程步骤：</p>
<ol>
<li><strong>用户通过View 页面向服务端提出请求，可以是表单请求、超链接请求、AJAX 请求等；</strong></li>
<li><strong>服务端 Controller 控制器接收到请求后对请求进行解析，找到相应的Model，对用户请求进行处理Model 处理；</strong></li>
<li><strong>将处理结果再交给 Controller（控制器其实只是起到了承上启下的作用）；</strong></li>
<li><strong>根据处理结果找到要作为向客户端发回的响应View 页面，页面经渲染后发送给客户端。</strong></li>
</ol>
<h2 id="2-了解-Spring-MVC-的处理流程吗？"><a href="#2-了解-Spring-MVC-的处理流程吗？" class="headerlink" title="2# 了解 Spring MVC 的处理流程吗？"></a>2# 了解 Spring MVC 的处理流程吗？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1716791047520-ac0d9673-be0a-4005-8732-30bdedc8f1af.webp" alt="img"></p>
<p>Spring MVC的工作流程如下：</p>
<ol>
<li>用户发送请求至前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求调用处理器映射器HandlerMapping。</li>
<li>处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet。</li>
<li>DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作</li>
<li>执行处理器Handler(Controller，也叫页面控制器)。</li>
<li>Handler执行完成返回ModelAndView</li>
<li>HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet</li>
<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li>
<li>ViewReslover解析后返回具体View</li>
<li>DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）。</li>
<li>DispatcherServlet响应用户。</li>
</ol>
<p><strong>简单记忆</strong></p>
<ol>
<li>请求进入 <strong>DispatcherServlet</strong>。</li>
<li>DispatcherServlet → HandlerMapping：找到 Controller 和方法。</li>
<li>HandlerAdapter 调用对应的 Controller 方法。</li>
<li>方法执行后返回 ModelAndView。</li>
<li>DispatcherServlet → ViewResolver：解析视图。</li>
<li>渲染结果返回给客户端。</li>
</ol>
<p>简化答法：<strong>前端控制器 → 映射 → 适配器 → 控制器 → 视图解析器 → 返回结果</strong>。</p>
<h2 id="3-拦截器和过滤器的区别？"><a href="#3-拦截器和过滤器的区别？" class="headerlink" title="3# 拦截器和过滤器的区别？"></a>3# 拦截器和过滤器的区别？</h2><ul>
<li><strong>拦截器（Interceptor）</strong>：Spring MVC 提供，基于 <strong>AOP</strong>，拦截的是 <strong>Controller 方法</strong>，只能拦 HTTP 请求。</li>
<li><strong>过滤器（Filter）</strong>：Servlet 规范提供，拦截的是 <strong>所有资源</strong>（包括 JSP、静态资源、Servlet）。</li>
<li>生命周期：<ul>
<li>过滤器由容器（Tomcat）管理。</li>
<li>拦截器由 Spring 容器管理。</li>
</ul>
</li>
</ul>
<h2 id="4-你是怎么做全局异常处理的？"><a href="#4-你是怎么做全局异常处理的？" class="headerlink" title="4# 你是怎么做全局异常处理的？"></a>4# 你是怎么做全局异常处理的？</h2><ul>
<li>使用 <code>@ControllerAdvice + @ExceptionHandler</code>。</li>
<li>好处：统一返回格式，避免到处写 <code>try-catch</code>。</li>
<li>典型写法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ControllerAdvice</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line">    @ExceptionHandler(Exception.class)</span><br><span class="line">    public ResponseEntity&lt;String&gt; handle(Exception e) &#123;</span><br><span class="line">        return ResponseEntity.status(500).body(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><h2 id="1-自动装配原理是什么？"><a href="#1-自动装配原理是什么？" class="headerlink" title="1# 自动装配原理是什么？"></a>1# 自动装配原理是什么？</h2><p><strong>自动装配是什么？</strong></p>
<p>自动装配就是 <strong>Spring Boot 根据引入的依赖和配置，自动帮我们把相关的 Bean 装配到 IoC 容器中</strong>，省去了繁琐的 XML 或 @Bean 配置。比如只要引入 spring-boot-starter-data-redis 依赖，就能直接使用 RedisTemplate。</p>
<hr>
<p><strong>自动装配原理（核心流程）</strong></p>
<ol>
<li><strong>入口注解</strong><ul>
<li><code>@SpringBootApplication = @SpringBootConfiguration + @EnableAutoConfiguration + @ComponentScan</code></li>
<li>其中 <strong><code>@EnableAutoConfiguration</code> 是核心</strong>。</li>
</ul>
</li>
<li><strong>关键机制</strong><ul>
<li><code>@EnableAutoConfiguration</code> → <code>@Import(AutoConfigurationImportSelector.class)</code></li>
<li><code>AutoConfigurationImportSelector</code> 的作用：<ul>
<li><strong>扫描</strong>：从 <code>META-INF/spring.factories</code> 里读取所有自动配置类</li>
<li><strong>过滤</strong>：根据 <code>@ConditionalOnXxx</code> 条件注解筛选（类存在、配置开关、Bean 存在等）</li>
<li><strong>排序</strong>：根据 <code>@AutoConfigureOrder</code>、<code>@AutoConfigureBefore/After</code> 排序</li>
<li><strong>导入</strong>：把满足条件的自动配置类注册到 IoC 容器</li>
</ul>
</li>
</ul>
</li>
<li><strong>条件装配</strong><ul>
<li>自动配置类里常用 <code>@ConditionalOnXxx</code> 注解，比如：<ul>
<li><code>@ConditionalOnClass</code>（类存在才装配）</li>
<li><code>@ConditionalOnMissingBean</code>（没有 Bean 才装配）</li>
<li><code>@ConditionalOnProperty</code>（配置开启才装配）</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<p><strong>总结口诀</strong></p>
<ul>
<li><strong>入口</strong>：<code>@SpringBootApplication</code></li>
<li><strong>核心</strong>：<code>@EnableAutoConfiguration</code></li>
<li><strong>关键类</strong>：<code>AutoConfigurationImportSelector</code></li>
<li><strong>步骤</strong>：扫描 → 过滤 → 排序 → 导入</li>
<li><strong>依据</strong>：<code>META-INF/spring.factories</code> + <code>@ConditionalOnXxx</code></li>
</ul>
<h2 id="2-Spring-Boot-有哪些重要的注解？"><a href="#2-Spring-Boot-有哪些重要的注解？" class="headerlink" title="2# Spring Boot 有哪些重要的注解？"></a>2# Spring Boot 有哪些重要的注解？</h2><p>Spring Boot 中一些常用的注解包括：</p>
<ul>
<li><strong>@SpringBootApplication</strong>：用于标注主应用程序类，标识一个Spring Boot应用程序的入口点，同时启用自动配置和组件扫描。</li>
<li><strong>@Controller</strong>：标识控制器类，处理HTTP请求。</li>
<li><strong>@RestController</strong>：结合@Controller和@ResponseBody，返回RESTful风格的数据。</li>
<li><strong>@Service</strong>：标识服务类，通常用于标记业务逻辑层。</li>
<li><strong>@Repository</strong>：标识数据访问组件，通常用于标记数据访问层。</li>
<li><strong>@Component</strong>：通用的Spring组件注解，表示一个受Spring管理的组件。</li>
<li><strong>@Autowired</strong>：用于自动装配Spring Bean。</li>
<li><strong>@Value</strong>：用于注入配置属性值。</li>
<li><strong>@RequestMapping</strong>：用于映射HTTP请求路径到Controller的处理方法。</li>
<li><strong>@GetMapping</strong>、@PostMapping、@PutMapping、@DeleteMapping：简化@RequestMapping的GET、POST、PUT和DELETE请求。</li>
</ul>
<p>另外，一个与配置相关的重要注解是：</p>
<ul>
<li><strong>@Configuration</strong>：用于指定一个类为配置类，其中定义的bean会被Spring容器管理。通常与@Bean配合使用，@Bean用于声明一个Bean实例，由Spring容器进行管理。</li>
</ul>
<h2 id="3-Spring-Boot-怎么开启事务？"><a href="#3-Spring-Boot-怎么开启事务？" class="headerlink" title="3# Spring Boot 怎么开启事务？"></a>3# Spring Boot 怎么开启事务？</h2><p>在 Spring Boot 中开启事务非常简单，只需在服务层的方法上添加 <code>@Transactional</code> 注解即可。</p>
<p>例如，假设我们有一个 UserService 接口，其中有一个保存用户的方法 saveUser()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们希望在这个方法中开启事务，只需在该方法上添加 <code>@Transactional</code> 注解，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，当调用 saveUser() 方法时，Spring 就会自动为该方法开启一个事务。如果方法执行成功，事务会自动提交；如果方法执行失败，事务会自动回滚。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<h2 id="4-Spring-Boot-怎么做到导入就可以直接使用的？"><a href="#4-Spring-Boot-怎么做到导入就可以直接使用的？" class="headerlink" title="4# Spring Boot 怎么做到导入就可以直接使用的？"></a>4# Spring Boot 怎么做到导入就可以直接使用的？</h2><p>这个主要依赖于自动配置、起步依赖和条件注解等特性。</p>
<p><strong>起步依赖</strong></p>
<p>起步依赖是一种特殊的 Maven 或 Gradle 依赖，它将项目所需的一系列依赖打包在一起。例如，<code>spring-boot-starter-web</code> 这个起步依赖就包含了 Spring Web MVC、Tomcat 等构建 Web 应用所需的核心依赖。</p>
<p>开发者只需在项目中添加一个起步依赖，Maven 或 Gradle 就会自动下载并管理与之关联的所有依赖，避免了手动添加大量依赖的繁琐过程。</p>
<p>比如，在 <code>pom.xml</code> 中添加 <code>spring-boot-starter-web</code> 依赖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>自动配置</strong></p>
<p>Spring Boot 的自动配置机制会根据类路径下的依赖和开发者的配置，自动创建和配置应用所需的 Bean。它通过 <code>@EnableAutoConfiguration</code> 注解启用，该注解会触发 Spring Boot 去查找 <code>META - INF/spring.factories</code> 文件。</p>
<p><code>spring.factories</code> 文件中定义了一系列自动配置类，Spring Boot 会根据当前项目的依赖情况，选择合适的自动配置类进行加载。例如，如果项目中包含 <code>spring-boot-starter-web</code> 依赖，Spring Boot 会加载 <code>WebMvcAutoConfiguration</code> 类，该类会自动配置 Spring MVC 的相关组件，如 DispatcherServlet、视图解析器等。</p>
<p>开发者可以通过自定义配置来覆盖自动配置的默认行为。如果开发者在 <code>application.properties</code> 或 <code>application.yml</code> 中定义了特定的配置，或者在代码中定义了同名的 Bean，Spring Boot 会优先使用开发者的配置。</p>
<hr>
<p><strong>条件注解</strong></p>
<p>条件注解用于控制 Bean 的创建和加载，只有在满足特定条件时，才会创建相应的 Bean。Spring Boot 的自动配置类中广泛使用了条件注解，如 <code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code> 等。</p>
<p>比如，<code>@ConditionalOnClass</code> 表示只有当类路径中存在指定的类时，才会创建该 Bean。例如，在 <code>WebMvcAutoConfiguration</code> 类中，可能会有如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">// 配置相关的 Bean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码表示只有当类路径中存在 <code>Servlet</code>、<code>DispatcherServlet</code> 和 <code>WebMvcConfigurer</code> 类时，才会加载 <code>WebMvcAutoConfiguration</code> 类中的配置。</p>
<h2 id="5-Spring-Boot-过滤器和拦截器说一下？"><a href="#5-Spring-Boot-过滤器和拦截器说一下？" class="headerlink" title="5# Spring Boot 过滤器和拦截器说一下？"></a>5# Spring Boot 过滤器和拦截器说一下？</h2><p>在 Spring Boot 中，过滤器（Filter）和拦截器（Interceptor）是用于处理请求和响应的两种不同机制。</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>过滤器（Filter）</strong></th>
<th><strong>拦截器（Interceptor）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>规范&#x2F;框架</strong></td>
<td>Servlet规范（<code>javax.servlet.Filter</code>）</td>
<td>Spring MVC框架（<code>org.springframework.web.servlet.HandlerInterceptor</code>）</td>
</tr>
<tr>
<td><strong>作用范围</strong></td>
<td>全局（所有请求、静态资源）</td>
<td>Controller层（仅拦截Spring管理的请求）</td>
</tr>
<tr>
<td><strong>执行顺序</strong></td>
<td>在Servlet之前执行</td>
<td>在DispatcherServlet之后、Controller方法前后执行</td>
</tr>
<tr>
<td><strong>依赖注入支持</strong></td>
<td>无法直接注入Spring Bean（需间接获取）</td>
<td>支持自动注入Spring Bean</td>
</tr>
<tr>
<td><strong>触发时机</strong></td>
<td><code>doFilter()</code>在请求前&#x2F;响应后被调用</td>
<td><code>preHandle</code>、<code>postHandle</code>、<code>afterCompletion</code>分阶段触发</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>全局请求处理（编码、日志、安全）</td>
<td>业务逻辑相关的处理（权限、参数校验）</td>
</tr>
</tbody></table>
<p>过滤器是 Java Servlet 规范中的一部分，它可以对进入 Servlet 容器的请求和响应进行预处理和后处理。过滤器通过实现 <code>javax.servlet.Filter</code> 接口，并重写其中的 <code>init</code>、<code>doFilter</code> 和 <code>destroy</code> 方法来完成相应的逻辑。当请求进入 Servlet 容器时，会按照配置的顺序依次经过各个过滤器，然后再到达目标 Servlet 或控制器；响应返回时，也会按照相反的顺序再次经过这些过滤器。</p>
<p>拦截器是 Spring 框架提供的一种机制，它可以对控制器方法的执行进行拦截。拦截器通过实现 <code>org.springframework.web.servlet.HandlerInterceptor</code> 接口，并重写其中的 <code>preHandle</code>、<code>postHandle</code> 和 <code>afterCompletion</code> 方法来完成相应的逻辑。当请求到达控制器时，会先经过拦截器的 <code>preHandle</code> 方法，如果该方法返回 <code>true</code>，则继续执行后续的控制器方法和其他拦截器；在控制器方法执行完成后，会调用拦截器的 <code>postHandle</code> 方法；最后，在请求处理完成后，会调用拦截器的 <code>afterCompletion</code> 方法。</p>
<p>过滤器和拦截器的区别如下：</p>
<ul>
<li><strong>所属规范</strong>：过滤器是 Java Servlet 规范的一部分，而拦截器是 Spring 框架提供的机制。</li>
<li><strong>执行顺序</strong>：过滤器在请求进入 Servlet 容器后，在到达目标 Servlet 或控制器之前执行；拦截器在请求到达控制器之后，在控制器方法执行前后执行。</li>
<li><strong>使用范围</strong>：过滤器可以对所有类型的请求进行过滤，包括静态资源请求；拦截器只能对 Spring MVC 控制器的请求进行拦截。</li>
<li><strong>功能特性</strong>：过滤器主要用于对请求和响应进行预处理和后处理，如字符编码处理、请求日志记录等；拦截器可以更细粒度地控制控制器方法的执行，如权限验证、性能监控等。</li>
</ul>
<h2 id="6-Spring-Boot-为什么能开箱即用？"><a href="#6-Spring-Boot-为什么能开箱即用？" class="headerlink" title="6# Spring Boot 为什么能开箱即用？"></a>6# Spring Boot 为什么能开箱即用？</h2><ul>
<li><strong>自动配置</strong>：根据依赖和配置文件，自动帮你创建 Bean。</li>
<li><strong>Starter 机制</strong>：常用功能打包成 Starter，加入依赖就能用。</li>
<li>内嵌 Tomcat&#x2F;Jetty，直接运行 <code>main</code> 方法即可启动。</li>
</ul>
<h2 id="7-Spring-Boot-自动配置是怎么实现的？"><a href="#7-Spring-Boot-自动配置是怎么实现的？" class="headerlink" title="7# Spring Boot 自动配置是怎么实现的？"></a>7# Spring Boot 自动配置是怎么实现的？</h2><ul>
<li>关键注解：<code>@EnableAutoConfiguration</code>（被 <code>@SpringBootApplication</code> 包含）。</li>
<li>它会扫描 <code>META-INF/spring.factories</code> 文件，把里面声明的 <code>@Configuration</code> 类加载进来。</li>
<li>配合 <code>@ConditionalOnClass</code> &#x2F; <code>@ConditionalOnMissingBean</code> 等条件注解，决定是否生效。</li>
</ul>
<h2 id="8-Starter-的原理？"><a href="#8-Starter-的原理？" class="headerlink" title="8# Starter 的原理？"></a>8# Starter 的原理？</h2><ul>
<li>Starter 本质就是一个 <strong>Maven 依赖 + 自动配置类</strong>。</li>
<li>里面写好依赖库、配置类，Spring Boot 会自动加载。</li>
<li>例子：<code>spring-boot-starter-web</code> → 自动配置 Spring MVC、Tomcat。</li>
</ul>
<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="1-与传统的-JDBC-相比，MyBatis-的优点？"><a href="#1-与传统的-JDBC-相比，MyBatis-的优点？" class="headerlink" title="1# 与传统的 JDBC 相比，MyBatis 的优点？"></a>1# 与传统的 JDBC 相比，MyBatis 的优点？</h2><ul>
<li>基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任 何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供 XML 标签，支持编写动态 SQL 语句，并可重用。</li>
<li>与 JDBC 相比，减少了 50%以上的代码量，消除了 JDBC 大量冗余的代码，不 需要手动开关连接；</li>
<li>很好的与各种数据库兼容，因为 MyBatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis 都支持。</li>
<li>能够与 Spring 很好的集成，开发效率高</li>
<li>提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射 标签，支持对象关系组件维护。</li>
</ul>
<h2 id="9-MyBatis-和-Hibernate-的区别？"><a href="#9-MyBatis-和-Hibernate-的区别？" class="headerlink" title="9. MyBatis 和 Hibernate 的区别？"></a>9. MyBatis 和 Hibernate 的区别？</h2><ul>
<li>Hibernate：全自动 ORM，SQL 由框架生成。开发效率高，但 SQL 不可控。</li>
<li>MyBatis：半自动 ORM，SQL 需要开发者写，灵活、可控，性能调优方便。</li>
</ul>
<h2 id="10-MyBatis-一级缓存、二级缓存原理？"><a href="#10-MyBatis-一级缓存、二级缓存原理？" class="headerlink" title="10. MyBatis 一级缓存、二级缓存原理？"></a>10. MyBatis 一级缓存、二级缓存原理？</h2><ul>
<li><strong>一级缓存</strong>：默认开启，作用域是 <code>SqlSession</code>。同一个会话内执行相同 SQL，会从缓存中取。</li>
<li><strong>二级缓存</strong>：需要手动开启，作用域是 Mapper namespace，多个 SqlSession 共享。</li>
<li>原理：查询结果存入 <code>Map</code>，key 是 SQL + 参数。</li>
</ul>
<h2 id="11-MyBatis-是如何把接口方法和-SQL-绑定的？（动态代理）"><a href="#11-MyBatis-是如何把接口方法和-SQL-绑定的？（动态代理）" class="headerlink" title="11. MyBatis 是如何把接口方法和 SQL 绑定的？（动态代理）"></a>11. MyBatis 是如何把接口方法和 SQL 绑定的？（动态代理）</h2><ul>
<li>MyBatis 会为 Mapper 接口生成 <strong>JDK 动态代理对象</strong>。</li>
<li>代理对象执行时，会根据方法名找到对应的 <strong>MappedStatement（SQL 映射）</strong>，再交给 Executor 执行。</li>
</ul>
<h1 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h1><h2 id="1-了解-Spring-Cloud-吗，说一下他和-Spring-Boot-的区别"><a href="#1-了解-Spring-Cloud-吗，说一下他和-Spring-Boot-的区别" class="headerlink" title="1# 了解 Spring Cloud 吗，说一下他和 Spring Boot 的区别"></a>1# 了解 Spring Cloud 吗，说一下他和 Spring Boot 的区别</h2><p>Spring Boot是用于构建单个Spring应用的框架，而Spring Cloud则是用于构建分布式系统中的微服务架构的工具，Spring Cloud提供了服务注册与发现、负载均衡、断路器、网关等功能。</p>
<p>两者可以结合使用，通过Spring Boot构建微服务应用，然后用Spring Cloud来实现微服务架构中的各种功能。</p>
<h2 id="2-用过哪些微服务组件？"><a href="#2-用过哪些微服务组件？" class="headerlink" title="2# 用过哪些微服务组件？"></a>2# 用过哪些微服务组件？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1715933382453-968d55a3-059b-423d-9f67-0ebf732fc400.png" alt="img"></p>
<p>微服务常用的组件：</p>
<ul>
<li><strong>注册中心</strong>：注册中心是微服务架构最核心的组件。它起到的作用是对新节点的注册与状态维护，<strong>解决了「如何发现新节点以及检查各节点的运行状态的问题」</strong>。微服务节点在启动时会将自己的服务名称、IP、端口等信息在注册中心登记，注册中心会定时检查该节点的运行状态。注册中心通常会采用心跳机制最大程度保证已登记过的服务节点都是可用的。</li>
<li><strong>负载均衡</strong>：负载均衡<strong>解决了「如何发现服务及负载均衡如何实现的问题」</strong>，通常微服务在互相调用时，并不是直接通过IP、端口进行访问调用。而是先通过服务名在注册中心查询该服务拥有哪些节点，注册中心将该服务可用节点列表返回给服务调用者，这个过程叫服务发现，因服务高可用的要求，服务调用者会接收到多个节点，必须要从中进行选择。因此服务调用者一端必须内置负载均衡器，通过负载均衡策略选择合适的节点发起实质性的通信请求。</li>
<li><strong>服务通信</strong>：服务通信组件解决了「<strong>服务间如何进行消息通信的问题</strong>」，服务间通信采用轻量级协议，通常是HTTP RESTful风格。但因为RESTful风格过于灵活，必须加以约束，通常应用时对其封装。例如在SpringCloud中就提供了Feign和RestTemplate两种技术屏蔽底层的实现细节，所有开发者都是基于封装后统一的SDK进行开发，有利于团队间的相互合作。</li>
<li><strong>配置中心</strong>：配置中心主要解决了「<strong>如何集中管理各节点配置文件的问题</strong>」，在微服务架构下，所有的微服务节点都包含自己的各种配置文件，如jdbc配置、自定义配置、环境配置、运行参数配置等。要知道有的微服务可能可能有几十个节点，如果将这些配置文件分散存储在节点上，发生配置更改就需要逐个节点调整，将给运维人员带来巨大的压力。配置中心便由此而生，通过部署配置中心服务器，将各节点配置文件从服务中剥离，集中转存到配置中心。一般配置中心都有UI界面，方便实现大规模集群配置调整。</li>
<li><strong>集中式日志管理</strong>：集中式日志主要是解决了「<strong>如何收集各节点日志并统一管理的问题</strong>」。微服务架构默认将应用日志分别保存在部署节点上，当需要对日志数据和操作数据进行数据分析和数据统计时，必须收集所有节点的日志数据。那么怎么高效收集所有节点的日志数据呢？业内常见的方案有ELK、EFK。通过搭建独立的日志收集系统，定时抓取各节点增量日志形成有效的统计报表，为统计和分析提供数据支撑。</li>
<li>分布式链路追踪：分布式链路追踪解决了「<strong>如何直观的了解各节点间的调用链路的问题</strong>」。系统中一个复杂的业务流程，可能会出现连续调用多个微服务，我们需要了解完整的业务逻辑涉及的每个微服务的运行状态，通过可视化链路图展现，可以帮助开发人员快速分析系统瓶颈及出错的服务。</li>
<li><strong>服务保护</strong>：服务保护主要是解决了「<strong>如何对系统进行链路保护，避免服务雪崩的问题</strong>」。在业务运行时，微服务间互相调用支撑，如果某个微服务出现高延迟导致线程池满载，或是业务处理失败。这里就需要引入服务保护组件来实现高延迟服务的快速降级，避免系统崩溃。</li>
</ul>
<p>SpringCloud Alibaba实现的微服务架构：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1715933831252-4dbe4ae0-8072-4512-b54b-39ea5e8b3153.png" alt="img"></p>
<ul>
<li>SpringCloud Alibaba中使用<strong>Alibaba Nacos</strong>组件实现<strong>注册中心</strong>，Nacos提供了一组简单易用的特性集，可快速实现动态服务发现、服务配置、服务元数据及流量管理。</li>
<li>SpringCloud Alibaba 使用<strong>Nacos服务端均衡</strong>实现负载均衡，与Ribbon在调用端负载不同，Nacos是在服务发现的同时利用负载均衡返回服务节点数据。</li>
<li>SpringCloud Alibaba 使用<strong>Netflix Feign</strong>和<strong>Alibaba Dubbo</strong>组件来实现服务通行，前者与SpringCloud采用了相同的方案，后者则是对自家的<strong>RPC 框架Dubbo</strong>也给予支持，为服务间通信提供另一种选择。</li>
<li>SpringCloud Alibaba 在<strong>API服务网关</strong>组件中，使用与SpringCloud相同的组件，即：<strong>SpringCloud Gateway</strong>。</li>
<li>SpringCloud Alibaba在配置中心组件中使用<strong>Nacos内置配置中心</strong>，Nacos内置的配置中心，可将配置信息<strong>存储保存在指定数据库</strong>中</li>
<li>SpringCloud Alibaba在原有的<strong>ELK方案</strong>外，还可以使用阿里云日志服务（LOG）实现日志集中式管理。</li>
<li>SpringCloud Alibaba在<strong>分布式链路组件</strong>中采用与SpringCloud相同的方案，即：<strong>Sleuth&#x2F;Zipkin Server</strong>。</li>
<li>SpringCloud Alibaba使用<strong>Alibaba Sentinel</strong>实现系统保护，Sentinel不仅功能更强大，实现系统保护比Hystrix更优雅，而且还拥有更好的UI界面。</li>
</ul>
<h2 id="12-注册中心宕机了怎么办？"><a href="#12-注册中心宕机了怎么办？" class="headerlink" title="12. 注册中心宕机了怎么办？"></a>12. 注册中心宕机了怎么办？</h2><ul>
<li><strong>Eureka</strong>：有自我保护机制，短时间内还能维持服务发现。</li>
<li><strong>Nacos</strong>：支持 AP&#x2F;CP 切换，推荐部署集群，避免单点故障。</li>
</ul>
<h2 id="13-Feign-是怎么实现远程调用的？"><a href="#13-Feign-是怎么实现远程调用的？" class="headerlink" title="13. Feign 是怎么实现远程调用的？"></a>13. Feign 是怎么实现远程调用的？</h2><ul>
<li>本质是 <strong>声明式 HTTP 客户端</strong>。</li>
<li>通过 JDK 动态代理，拦截接口方法调用 → 构造 HTTP 请求 → 发送远程调用。</li>
<li>底层默认用 Ribbon（负载均衡）+ RestTemplate，或者 OpenFeign + HTTPClient。</li>
</ul>
<h2 id="14-Gateway-的核心功能？"><a href="#14-Gateway-的核心功能？" class="headerlink" title="14. Gateway 的核心功能？"></a>14. Gateway 的核心功能？</h2><ul>
<li>路由转发：请求 → 目标服务。</li>
<li>过滤器：日志、权限校验、参数处理。</li>
<li>负载均衡：整合注册中心，实现动态路由。</li>
<li>限流熔断：基于 Resilience4j、Redis 实现。</li>
</ul>
<h2 id="15-你们项目里怎么做统一鉴权的？"><a href="#15-你们项目里怎么做统一鉴权的？" class="headerlink" title="15. 你们项目里怎么做统一鉴权的？"></a>15. 你们项目里怎么做统一鉴权的？</h2><ul>
<li>在 <strong>Gateway</strong> 里加全局过滤器：<ul>
<li>拦截请求，校验 Token（JWT&#x2F;Redis）。</li>
<li>不通过 → 拦截返回 401。</li>
<li>通过 → 请求继续转发到微服务。</li>
</ul>
</li>
</ul>
<h2 id="16-配置中心怎么实现动态刷新？"><a href="#16-配置中心怎么实现动态刷新？" class="headerlink" title="16. 配置中心怎么实现动态刷新？"></a>16. 配置中心怎么实现动态刷新？</h2><ul>
<li>Spring Cloud Config &#x2F; Nacos Config 支持 <strong>长轮询&#x2F;消息推送</strong>。</li>
<li>Spring Boot 应用里加 <code>@RefreshScope</code>，当配置中心推送更新时，Bean 会重新加载配置。</li>
</ul>
<h2 id="17-什么是服务雪崩？怎么解决？"><a href="#17-什么是服务雪崩？怎么解决？" class="headerlink" title="17. 什么是服务雪崩？怎么解决？"></a>17. 什么是服务雪崩？怎么解决？</h2><ul>
<li><strong>服务雪崩</strong>：一个服务不可用，导致调用它的服务阻塞，最终整个系统不可用。</li>
<li>解决办法：<ul>
<li>限流（RateLimit）</li>
<li>熔断（CircuitBreaker）</li>
<li>隔离（线程池&#x2F;舱壁模式）</li>
<li>降级（返回默认结果）</li>
</ul>
</li>
</ul>
<h2 id="18-熔断和限流有什么区别？"><a href="#18-熔断和限流有什么区别？" class="headerlink" title="18. 熔断和限流有什么区别？"></a>18. 熔断和限流有什么区别？</h2><ul>
<li><strong>熔断</strong>：下游服务不可用时，快速失败，避免请求堆积。</li>
<li><strong>限流</strong>：控制请求流量（QPS），保护系统不被压垮。</li>
<li>类比：<ul>
<li>熔断 &#x3D; 停电时保险丝断开。</li>
<li>限流 &#x3D; 水龙头限流阀。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>八股文笔记 #6 计算机网络</title>
    <url>/2025/09/23/boilerplate-answers-6-computer-network/</url>
    <content><![CDATA[<h1 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h1><h2 id="1-OSI-模型"><a href="#1-OSI-模型" class="headerlink" title="1# OSI 模型"></a>1# OSI 模型</h2><p>为了使得多种设备能通过网络相互通信，和为了解决各种不同设备在网络互联中的兼容性问题，国际标准化组织制定了开放式系统互联通信参考模型（<em>Open System Interconnection Reference Model</em>），也就是 OSI 网络模型，该模型主要有 7 层，分别是应用层、表示层、会话层、传输层、网络层、数据链路层以及物理层。</p>
<span id="more"></span>

<p><img src="https://cdn.xiaolincoding.com//picgo/1721097268006-12c71992-11b3-4a8e-9d05-35ad3e0ab86e.png" alt="img"></p>
<p>每一层负责的职能都不同，如下：</p>
<ul>
<li>应用层，负责给应用程序提供统一的接口；</li>
<li>表示层，负责把数据转换成兼容另一个系统能识别的格式；</li>
<li>会话层，负责建立、管理和终止表示层实体之间的通信会话；</li>
<li>传输层，负责端到端的数据传输；</li>
<li>网络层，负责数据的路由、转发、分片；</li>
<li>数据链路层，负责数据的封帧和差错检测，以及 MAC 寻址；</li>
<li>物理层，负责在物理网络中传输数据帧；</li>
</ul>
<p>由于 OSI 模型实在太复杂，提出的也只是概念理论上的分层，并没有提供具体的实现方案。</p>
<p>事实上，我们比较常见，也比较实用的是四层模型，即 TCP&#x2F;IP 网络模型，Linux 系统正是按照这套网络模型来实现网络协议栈的。</p>
<h2 id="2-TCP-IP-模型"><a href="#2-TCP-IP-模型" class="headerlink" title="2# TCP&#x2F;IP 模型"></a>2# TCP&#x2F;IP 模型</h2><p>TCP&#x2F;IP协议被组织成四个概念层，其中有三层对应于ISO参考模型中的相应层。ICP&#x2F;IP协议族并不包含物理层和数据链路层，因此它不能独立完成整个计算机网络系统的功能，必须与许多其他的协议协同工作。TCP&#x2F;IP 网络通常是由上到下分成 4 层，分别是<strong>应用层，传输层，网络层和网络接口层</strong>。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1721097233614-f7cd6378-32d9-4cb8-9e60-e70b95bb3759.png" alt="img"></p>
<ul>
<li>应用层 支持 HTTP、SMTP 等最终用户进程</li>
<li>传输层 处理主机到主机的通信（TCP、UDP）</li>
<li>网络层 寻址和路由数据包（IP 协议）</li>
<li>链路层 通过网络的物理电线、电缆或无线信道移动比特</li>
</ul>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="1-应用层有哪些协议？"><a href="#1-应用层有哪些协议？" class="headerlink" title="1# 应用层有哪些协议？"></a>1# 应用层有哪些协议？</h2><p>HTTP、HTTPS、CDN、DNS、FTP 都是应用层协议</p>
<h2 id="2-HTTP-报文有哪些部分？"><a href="#2-HTTP-报文有哪些部分？" class="headerlink" title="2# HTTP 报文有哪些部分？"></a>2# HTTP 报文有哪些部分？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1721710466863-78bf586d-a25c-4fe4-bf27-5dd576b998c8.png" alt="img"></p>
<p>分请求报文和响应报文来说明。</p>
<p><strong>请求报文：</strong></p>
<ul>
<li>请求行：包含请求方法、请求目标（URL或URI）和HTTP协议版本。</li>
<li>请求头部：包含关于请求的附加信息，如Host、User-Agent、Content-Type等。</li>
<li>空行：请求头部和请求体之间用空行分隔。</li>
<li>请求体：可选，包含请求的数据，通常用于POST请求等需要传输数据的情况。</li>
</ul>
<p><strong>响应报文：</strong></p>
<ul>
<li>状态行：包含HTTP协议版本、状态码和状态信息。</li>
<li>响应头部：包含关于响应的附加信息，如Content-Type、Content-Length等。</li>
<li>空行：响应头部和响应体之间用空行分隔。</li>
<li>响应体：包含响应的数据，通常是服务器返回的HTML、JSON等内容。</li>
</ul>
<h2 id="3-HTTP-常用的状态码？"><a href="#3-HTTP-常用的状态码？" class="headerlink" title="3# HTTP 常用的状态码？"></a>3# HTTP 常用的状态码？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1716787749083-7ae2de46-8e84-492e-8ba4-a1521e533e08.webp" alt="img"></p>
<p>HTTP 状态码分为 5 大类</p>
<ul>
<li>1xx 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</li>
<li>2xx 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</li>
<li>3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</li>
<li>4xx 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</li>
<li>5xx 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</li>
</ul>
<p>其中常见的具体状态码有：</p>
<ul>
<li>200：请求成功；</li>
<li>301：永久重定向；302：临时重定向；</li>
<li>404：无法找到此页面；405：请求的方法类型不支持；</li>
<li>500：服务器内部出错。</li>
</ul>
<h2 id="4-HTTP-层请求的类型有哪些？"><a href="#4-HTTP-层请求的类型有哪些？" class="headerlink" title="4# HTTP 层请求的类型有哪些？"></a>4# HTTP 层请求的类型有哪些？</h2><ul>
<li>GET：用于请求获取指定资源，通常用于获取数据。</li>
<li>POST：用于向服务器提交数据，通常用于提交表单数据或进行资源的创建。</li>
<li>PUT：用于向服务器更新指定资源，通常用于更新已存在的资源。</li>
<li>DELETE：用于请求服务器删除指定资源。</li>
<li>HEAD：类似于GET请求，但只返回资源的头部信息，用于获取资源的元数据而不获取实际内容。</li>
</ul>
<h2 id="5-HTTP的长连接是什么？"><a href="#5-HTTP的长连接是什么？" class="headerlink" title="5# HTTP的长连接是什么？"></a>5# HTTP的长连接是什么？</h2><p>HTTP 协议采用的是「请求-应答」的模式，也就是客户端发起了请求，服务端才会返回响应，一来一回这样子。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725231702564.png" alt="image-20240725231702564"></p>
<p>由于 HTTP 是基于 TCP 传输协议实现的，客户端与服务端要进行 HTTP 通信前，需要先建立 TCP 连接，然后客户端发送 HTTP 请求，服务端收到后就返回响应，至此「请求-应答」的模式就完成了，随后就会释放 TCP 连接。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725231648038.png" alt="image-20240725231648038"></p>
<p>如果每次请求都要经历这样的过程：建立 TCP -&gt; 请求资源 -&gt; 响应资源 -&gt; 释放连接，那么此方式就是 <strong>HTTP 短连接</strong>，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725231628356.png" alt="image-20240725231628356"></p>
<p>这样实在太累人了，一次连接只能请求一次资源。</p>
<p>能不能在第一个 HTTP 请求完后，先不断开 TCP 连接，让后续的 HTTP 请求继续使用此连接？</p>
<p>当然可以，HTTP 的 Keep-Alive 就是实现了这个功能，可以使用同一个 TCP 连接来发送和接收多个 HTTP 请求&#x2F;应答，避免了连接建立和释放的开销，这个方法称为 <strong>HTTP 长连接</strong>。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725231558255.png" alt="image-20240725231558255"></p>
<p>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p>
<h2 id="6-HTTP-1-1-怎么对请求做拆包，具体来说怎么拆的？"><a href="#6-HTTP-1-1-怎么对请求做拆包，具体来说怎么拆的？" class="headerlink" title="6# HTTP 1.1 怎么对请求做拆包，具体来说怎么拆的？"></a>6# HTTP 1.1 怎么对请求做拆包，具体来说怎么拆的？</h2><p>在HTTP&#x2F;1.1中，请求的拆包是通过”Content-Length”头字段来进行的。该字段指示了请求正文的长度，服务器可以根据该长度来正确接收和解析请求。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725231532943.png" alt="image-20240725231532943"></p>
<p>具体来说，当客户端发送一个HTTP请求时，会在请求头中添加”Content-Length”字段，该字段的值表示请求正文的字节数。</p>
<p>服务器在接收到请求后，会根据”Content-Length”字段的值来确定请求的长度，并从请求中读取相应数量的字节，直到读取完整个请求内容。</p>
<p>这种基于”Content-Length”字段的拆包机制可以确保服务器正确接收到完整的请求，避免了请求的丢失或截断问题。</p>
<h2 id="7-HTTP-断点重传是什么？"><a href="#7-HTTP-断点重传是什么？" class="headerlink" title="7# HTTP 断点重传是什么？"></a>7# HTTP 断点重传是什么？</h2><p>断点续传是HTTP&#x2F;1.1协议支持的特性。实现断点续传的功能，需要客户端记录下当前的下载进度，并在需要续传的时候通知服务端本次需要下载的内容片段。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1737790649434-0bb21e8e-faae-44c7-9f7b-2f677c38b39d.webp" alt="img">一个最简单的断点续传流程如下：</p>
<ol>
<li>客户端开始下载一个1024K的文件，服务端发送Accept-Ranges: bytes来告诉客户端，其支持带Range的请求</li>
<li>假如客户端下载了其中512K时候网络突然断开了，过了一会网络可以了，客户端再下载时候，需要在HTTP头中申明本次需要续传的片段：Range:bytes&#x3D;512000-这个头通知服务端从文件的512K位置开始传输文件，直到文件内容结束</li>
<li>服务端收到断点续传请求，从文件的512K位置开始传输，并且在HTTP头中增加：Content-Range:bytes 512000-&#x2F;1024000,Content-Length: 512000。并且此时服务端返回的HTTP状态码应该是206 Partial Content。如果客户端传递过来的Range超过资源的大小,则响应416 Requested Range Not Satisfiable</li>
</ol>
<p>通过上面流程可以看出：断点续传中4个HTTP头不可少的，<strong>分别是Range头、Content-Range头、Accept-Ranges头、Content-Length头</strong>。其中第一个Range头是客户端发过来的，后面3个头需要服务端发送给客户端。下面是它们的说明：</p>
<ul>
<li>**Accept-Ranges: bytes：**这个值声明了可被接受的每一个范围请求, 大多数情况下是字节数 bytes</li>
<li>**Range: bytes&#x3D;开始位置-结束位置：**Range是浏览器告知服务器所需分部分内容范围的消息头。</li>
</ul>
<h2 id="8-HTTP-为什么不安全？"><a href="#8-HTTP-为什么不安全？" class="headerlink" title="8# HTTP 为什么不安全？"></a>8# HTTP 为什么不安全？</h2><p>HTTP 由于是明文传输，所以安全上存在以下三个风险：</p>
<ul>
<li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容，用户号容易没。</li>
<li><strong>篡改风险</strong>，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。</li>
<li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com//picgo/1719381758323-e2bd2f7b-d599-4b23-b258-b8620ac52808.jpeg" alt="img"></p>
<p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加入了 SSL&#x2F;TLS 协议，可以很好的解决了上述的风险：</p>
<ul>
<li><strong>信息加密</strong>：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</li>
<li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</li>
<li><strong>身份证书</strong>：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</li>
</ul>
<h2 id="9-HTTP-和-HTTPS-的区别？"><a href="#9-HTTP-和-HTTPS-的区别？" class="headerlink" title="9# HTTP 和 HTTPS 的区别？"></a>9# HTTP 和 HTTPS 的区别？</h2><p>区别主要有以下四点：</p>
<ul>
<li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li>
<li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ul>
<h2 id="10-HTTPS-握手过程说一下"><a href="#10-HTTPS-握手过程说一下" class="headerlink" title="10# HTTPS 握手过程说一下"></a>10# HTTPS 握手过程说一下</h2><p>传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的，在将 TLS 证书部署服务端时，证书文件其实就是服务端的公钥，会在 TLS 握手阶段传递给客户端，而服务端的私钥则一直留在服务端，一定要确保私钥不能被窃取。</p>
<p>在 RSA 密钥协商算法中，客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端。根据非对称加密算法，公钥加密的消息仅能通过私钥解密，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息。</p>
<p>我用 Wireshark 工具抓了用 RSA 密钥交换的 TLS 握手过程，你可以从下面看到，一共经历了四次握手：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1716097892426-58902c14-da4f-40fc-9199-94752fc5368b.webp" alt="img"></p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1716097892465-985f6cfe-66c8-4384-aabd-840821de1b66.webp" alt="img"></p>
<blockquote>
<p>TLS 第一次握手</p>
</blockquote>
<p>首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。在这一步，客户端主要向服务器发送以下信息：</p>
<ul>
<li>（1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。</li>
<li>（2）客户端生产的随机数（Client Random），后面用于生成「会话秘钥」条件之一。</li>
<li>（3）客户端支持的密码套件列表，如 RSA 加密算法。</li>
</ul>
<blockquote>
<p>TLS 第二次握手</p>
</blockquote>
<p>服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello。服务器回应的内容有如下内容：</p>
<ul>
<li>（1）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。</li>
<li>（2）服务器生产的随机数（Server Random），也是后面用于生产「会话秘钥」条件之一。</li>
<li>（3）确认的密码套件列表，如 RSA 加密算法。（4）服务器的数字证书。</li>
</ul>
<blockquote>
<p>TLS 第三次握手</p>
</blockquote>
<p>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</p>
<p>如果证书没有问题，客户端会<strong>从数字证书中取出服务器的公钥</strong>，然后使用它加密报文，向服务器发送如下信息：</p>
<ul>
<li>（1）一个随机数（pre-master key）。该随机数会被服务器公钥加密。</li>
<li>（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li>
<li>（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</li>
</ul>
<p>上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。</p>
<p><strong>服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p>
<blockquote>
<p>TLS 第四次握手</p>
</blockquote>
<p>服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。</p>
<p>然后，向客户端发送最后的信息：</p>
<ul>
<li>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li>
<li>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</li>
</ul>
<p>至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</p>
<h2 id="11-HTTPS-是如何防范中间人的攻击？"><a href="#11-HTTPS-是如何防范中间人的攻击？" class="headerlink" title="11# HTTPS 是如何防范中间人的攻击？"></a>11# HTTPS 是如何防范中间人的攻击？</h2><p>主要通过加密和身份校验机制来防范中间人攻击的:</p>
<ul>
<li>加密：https 握手期间会通过非对称加密的方式来协商出对称加密密钥。</li>
<li>身份校验：服务器会向证书颁发机构申请数字证书，证书中包含了服务器的公钥和其他相关信息。当客户端与服务器建立连接时，服务器会将证书发送给客户端。客户端会验证证书的合法性，包括检查证书的有效期、颁发机构的信任等。如果验证通过，客户端会使用证书中的公钥来加密通信数据，并将加密后的数据发送给服务器，然后由服务端用私钥解密。</li>
</ul>
<p>中间人攻击的关键在于攻击者冒充服务器与客户端建立连接，并同时与服务器建立连接。</p>
<p>但由于攻击者无法获得服务器的私钥，因此无法正确解密客户端发送的加密数据。同时，客户端会在建立连接时验证服务器的证书，如果证书验证失败或存在问题，客户端会发出警告或中止连接。</p>
<h2 id="12-HTTP-1-1-和-2-0-的区别是什么？"><a href="#12-HTTP-1-1-和-2-0-的区别是什么？" class="headerlink" title="12# HTTP 1.1 和 2.0 的区别是什么？"></a>12# HTTP 1.1 和 2.0 的区别是什么？</h2><p>HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进：</p>
<ul>
<li><strong>头部压缩</strong>：HTTP&#x2F;2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。这就是所谓的 HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就<strong>提高速度</strong>了。</li>
<li><strong>二进制格式</strong>：HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这<strong>增加了数据传输的效率</strong>。</li>
<li><strong>并发传</strong>输：引出了 Stream 概念，多个 Stream 复用在一条 TCP 连接。解决了HTTP&#x2F;1.1 队头阻塞的问题：</li>
<li><strong>服务器主动推送资源</strong>：HTTP&#x2F;2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务端不再是被动地响应，可以<strong>主动</strong>向客户端发送消息。</li>
</ul>
<h2 id="13-HTTP-进行-TCP-连接之后，在什么情况下会中断"><a href="#13-HTTP-进行-TCP-连接之后，在什么情况下会中断" class="headerlink" title="13# HTTP 进行 TCP 连接之后，在什么情况下会中断"></a>13# HTTP 进行 TCP 连接之后，在什么情况下会中断</h2><ul>
<li>当服务端或者客户端执行 close 系统调用的时候，会发送FIN报文，就会进行四次挥手的过程</li>
<li>当发送方发送了数据之后，接收方超过一段时间没有响应ACK报文，发送方重传数据达到最大次数的时候，就会断开TCP连接</li>
<li>当HTTP长时间没有进行请求和响应的时候，超过一定的时间，就会释放连接</li>
</ul>
<h2 id="14-HTTP、SOCKET-和-TCP-的区别"><a href="#14-HTTP、SOCKET-和-TCP-的区别" class="headerlink" title="14# HTTP、SOCKET 和 TCP 的区别"></a>14# HTTP、SOCKET 和 TCP 的区别</h2><p>HTTP是应用层协议，定义了客户端和服务器之间交换的数据格式和规则；Socket是通信的一端，提供了网络通信的接口；TCP是传输层协议，负责在网络中建立可靠的数据传输连接。它们在网络通信中扮演不同的角色和层次。</p>
<ul>
<li>HTTP是一种用于传输超文本数据的应用层协议，用于在客户端和服务器之间传输和显示Web页面。</li>
<li>Socket是计算机网络中的一种抽象，用于描述通信链路的一端，提供了底层的通信接口，可实现不同计算机之间的数据交换。</li>
<li>TCP是一种面向连接的、可靠的传输层协议，负责在通信的两端之间建立可靠的数据传输连接。</li>
</ul>
<h2 id="15-为什么有-HTTP-协议了？还要用-RPC？"><a href="#15-为什么有-HTTP-协议了？还要用-RPC？" class="headerlink" title="15# 为什么有 HTTP 协议了？还要用 RPC？"></a>15# 为什么有 HTTP 协议了？还要用 RPC？</h2><ul>
<li>RPC 本质上不算是协议，而是一种调用方式，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，不一定非得基于 TCP 协议。</li>
<li>从发展历史来说，HTTP 主要用于 B&#x2F;S 架构，而 RPC 更多用于 C&#x2F;S 架构。但现在其实已经没分那么清了，B&#x2F;S 和 C&#x2F;S 在慢慢融合。很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。</li>
<li>RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP&#x2F;1.1 性能要更好，所以大部分公司内部都还在使用 RPC。</li>
<li>HTTP&#x2F;2.0在 HTTP&#x2F;1.1的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。</li>
</ul>
<h2 id="16-HTTP-长连接与-WebSocket-有什么区别？"><a href="#16-HTTP-长连接与-WebSocket-有什么区别？" class="headerlink" title="16# HTTP 长连接与 WebSocket 有什么区别？"></a>16# HTTP 长连接与 WebSocket 有什么区别？</h2><ul>
<li><strong>全双工和半双工</strong>：TCP 协议本身是<strong>全双工</strong>的，但我们最常用的 HTTP&#x2F;1.1，虽然是基于 TCP 的协议，但它是<strong>半双工</strong>的，对于大部分需要服务器主动推送数据到客户端的场景，都不太友好，因此我们需要使用支持全双工的 WebSocket 协议。</li>
<li><strong>应用场景区别</strong>：在 HTTP&#x2F;1.1 里，只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用<strong>定时轮询或者长轮询</strong>的方式实现<strong>服务器推送</strong>(comet)的效果。对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用 WebSocket 协议。</li>
</ul>
<h2 id="17-HTTP-到底是不是无状态的？"><a href="#17-HTTP-到底是不是无状态的？" class="headerlink" title="17# HTTP 到底是不是无状态的？"></a>17# HTTP 到底是不是无状态的？</h2><p>HTTP是无状态的，这意味着每个请求都是独立的，服务器不会在多个请求之间保留关于客户端状态的信息。在每个HTTP请求中，服务器不会记住之前的请求或会话状态，因此每个请求都是相互独立的。</p>
<p>虽然HTTP本身是无状态的，但可以通过一些机制来实现状态保持，其中最常见的方式是使用Cookie和Session来跟踪用户状态。通过在客户端存储会话信息或状态信息，服务器可以识别和跟踪特定用户的状态，以提供一定程度的状态保持功能。</p>
<h2 id="18-携带-Cookie-的-HTTP-请求是有状态还是无状态的？Cookie-是-HTTP-协议簇的一部分，那为什么还说-HTTP-是无状态的？"><a href="#18-携带-Cookie-的-HTTP-请求是有状态还是无状态的？Cookie-是-HTTP-协议簇的一部分，那为什么还说-HTTP-是无状态的？" class="headerlink" title="18# 携带 Cookie 的 HTTP 请求是有状态还是无状态的？Cookie 是 HTTP 协议簇的一部分，那为什么还说 HTTP 是无状态的？"></a>18# 携带 Cookie 的 HTTP 请求是有状态还是无状态的？Cookie 是 HTTP 协议簇的一部分，那为什么还说 HTTP 是无状态的？</h2><p>携带Cookie的HTTP请求实际上是可以在一定程度上实现状态保持的，因为Cookie是用来在客户端存储会话信息和状态信息的一种机制。当浏览器发送包含Cookie的HTTP请求时，服务器可以通过读取这些Cookie来识别用户、管理会话状态以及保持特定的用户状态。因此，可以说即使HTTP本身是无状态的协议，但通过Cookie的使用可以实现一定程度的状态保持功能。</p>
<p>HTTP被描述为“无状态”的主要原因是每个HTTP请求都是独立的，服务器并不保存关于客户端的状态信息，每个请求都需要提供足够的信息来理解请求的意图。这样的设计使得Web系统更具有规模化和简单性，但也导致了一些挑战，比如需要额外的机制来处理用户状态和会话管理。</p>
<p>虽然Cookie是HTTP协议簇的一部分，但是HTTP协议在设计初衷上仍然保持无状态特性，即每个请求都是相互独立的。使用Cookie只是在无状态协议下的一种补充机制，用于在客户端存储状态信息以实现状态保持。</p>
<h2 id="19-Cookie-和-Session-有什么区别？"><a href="#19-Cookie-和-Session-有什么区别？" class="headerlink" title="19# Cookie 和 Session 有什么区别？"></a>19# Cookie 和 Session 有什么区别？</h2><p>Cookie和Session都是Web开发中用于跟踪用户状态的技术，但它们在存储位置、数据容量、安全性以及生命周期等方面存在显著差异：</p>
<ul>
<li>**存储位置：**Cookie的数据存储在客户端（通常是浏览器）。当浏览器向服务器发送请求时，会自动附带Cookie中的数据。Session的数据存储在服务器端。服务器为每个用户分配一个唯一的Session ID，这个ID通常通过Cookie或URL重写的方式发送给客户端，客户端后续的请求会带上这个Session ID，服务器根据ID查找对应的Session数据。</li>
<li>**数据容量：**单个Cookie的大小限制通常在4KB左右，而且大多数浏览器对每个域名的总Cookie数量也有限制。由于Session存储在服务器上，理论上不受数据大小的限制，主要受限于服务器的内存大小。</li>
<li>**安全性：**Cookie相对不安全，因为数据存储在客户端，容易受到XSS（跨站脚本攻击）的威胁。不过，可以通过设置HttpOnly属性来防止JavaScript访问，减少XSS攻击的风险，但仍然可能受到CSRF（跨站请求伪造）的攻击。Session通常认为比Cookie更安全，因为敏感数据存储在服务器端。但仍然需要防范Session劫持（通过获取他人的Session ID）和会话固定攻击。</li>
<li>**生命周期：**Cookie可以设置过期时间，过期后自动删除。也可以设置为会话Cookie，即浏览器关闭时自动删除。Session在默认情况下，当用户关闭浏览器时，Session结束。但服务器也可以设置Session的超时时间，超过这个时间未活动，Session也会失效。</li>
<li>**性能：**使用Cookie时，因为数据随每个请求发送到服务器，可能会影响网络传输效率，尤其是在Cookie数据较大时。使用Session时，因为数据存储在服务器端，每次请求都需要查询服务器上的Session数据，这可能会增加服务器的负载，特别是在高并发场景下。</li>
</ul>
<h2 id="20-Token，Session，Cookie-的区别？"><a href="#20-Token，Session，Cookie-的区别？" class="headerlink" title="20# Token，Session，Cookie 的区别？"></a>20# Token，Session，Cookie 的区别？</h2><ul>
<li>session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session，依赖cookie。</li>
<li>cookie类似一个令牌，装有sessionId，存储在客户端，浏览器通常会自动添加。</li>
<li>token也类似一个令牌，无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户，需要开发者手动添加。</li>
</ul>
<h2 id="21-如果客户端禁用了-Cookie，Session-还能用吗？"><a href="#21-如果客户端禁用了-Cookie，Session-还能用吗？" class="headerlink" title="21# 如果客户端禁用了 Cookie，Session 还能用吗？"></a>21# 如果客户端禁用了 Cookie，Session 还能用吗？</h2><p><strong>默认情况下禁用 Cookie 后，Session 是无法正常使用的</strong>，因为大多数 Web 服务器都是依赖于 Cookie 来传递 Session 的会话 ID 的。</p>
<p>客户端浏览器禁用 Cookie 时，服务器将无法把会话 ID 发送给客户端，客户端也无法在后续请求中携带会话 ID 返回给服务器，从而导致服务器无法识别用户会话。</p>
<p>但是，有几种方法可以绕过这个问题，尽管它们可能会引入额外的复杂性和&#x2F;或降低用户体验：</p>
<ol>
<li>**URL重写：**每当服务器响应需要保持状态的请求时，将Session ID附加到URL中作为参数。例如，原本的链接<a href="http://example.com/page%E5%8F%98%E4%B8%BAhttp://example.com/page;jsessionid=XXXXXX%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E9%9C%80%E8%A6%81%E7%9B%B8%E5%BA%94%E5%9C%B0%E8%A7%A3%E6%9E%90">http://example.com/page变为http://example.com/page;jsessionid=XXXXXX，服务器端需要相应地解析</a> URL 来获取 Session ID，并维护用户的会话状态。这种方式的缺点是URL变得不那么整洁，且如果用户通过电子邮件或其他方式分享了这样的链接，可能导致Session ID的意外泄露。</li>
<li><strong>隐藏表单字段</strong>：在每个需要Session信息的HTML表单中包含一个隐藏字段，用来存储Session ID。当表单提交时，Session ID随表单数据一起发送回服务器，服务器通过解析表单数据中的 Session ID 来获取用户的会话状态。这种方法仅适用于通过表单提交的交互模式，不适合链接点击或Ajax请求。</li>
</ol>
<h2 id="22-如果我把数据存储到-LocalStorage，和-Cookie-有什么区别？"><a href="#22-如果我把数据存储到-LocalStorage，和-Cookie-有什么区别？" class="headerlink" title="22# 如果我把数据存储到 LocalStorage，和 Cookie 有什么区别？"></a>22# 如果我把数据存储到 LocalStorage，和 Cookie 有什么区别？</h2><ul>
<li>存储容量: Cookie 的存储容量通常较小,每个 Cookie 的大小限制在几 KB 左右。而 LocalStorage 的存储容量通常较大,一般限制在几 MB 左右。因此,如果需要存储大量数据，LocalStorage 通常更适合;</li>
<li>数据发送: Cookie 在每次 HTTP 请求中都会自动发送到服务器,这使得 Cookie 适合用于在客户端和服务器之间传递数据。而 localStorage 的数据不会自动发送到服务器,它仅在浏览器端存储数据,因此 LocalStorage 适合用于在同一域名下的不同页面之间共享数据;</li>
<li>生命周期：Cookie 可以设置一个过期时间,使得数据在指定时间后自动过期。而 LocalStorage 的数据将永久存储在浏览器中,除非通过 JavaScript 代码手动删除;</li>
<li>安全性：Cookie 的安全性较低,因为 Cookie 在每次 HTTP 请求中都会自动发送到服务器,存在被窃取或篡改的风险。而 LocalStorage 的数据仅在浏览器端存储,不会自动发送到服务器,相对而言更安全一些。</li>
</ul>
<h2 id="23-什么数据应该存在到-Cookie，什么数据存放到-LocalStorage"><a href="#23-什么数据应该存在到-Cookie，什么数据存放到-LocalStorage" class="headerlink" title="23# 什么数据应该存在到 Cookie，什么数据存放到 LocalStorage"></a>23# 什么数据应该存在到 Cookie，什么数据存放到 LocalStorage</h2><p>Cookie 适合用于在客户端和服务器之间传递数据、跨域访问和设置过期时间，而 LocalStorage 适合用于在同一域名下的不同页面之间共享数据、存储大量数据和永久存储数据。</p>
<h2 id="24-JWT-令牌和传统方式有什么区别？"><a href="#24-JWT-令牌和传统方式有什么区别？" class="headerlink" title="24# JWT 令牌和传统方式有什么区别？"></a>24# JWT 令牌和传统方式有什么区别？</h2><ul>
<li>无状态性：JWT是无状态的令牌，不需要在服务器端存储会话信息。相反，JWT令牌中包含了所有必要的信息，如用户身份、权限等。这使得JWT在分布式系统中更加适用，可以方便地进行扩展和跨域访问。</li>
<li>安全性：JWT使用密钥对令牌进行签名，确保令牌的完整性和真实性。只有持有正确密钥的服务器才能对令牌进行验证和解析。这种方式比传统的基于会话和Cookie的验证更加安全，有效防止了CSRF（跨站请求伪造）等攻击。</li>
<li>跨域支持：JWT令牌可以在不同域之间传递，适用于跨域访问的场景。通过在请求的头部或参数中携带JWT令牌，可以实现无需Cookie的跨域身份验证。</li>
</ul>
<h2 id="25-JWT-令牌都有哪些字段？"><a href="#25-JWT-令牌都有哪些字段？" class="headerlink" title="25# JWT 令牌都有哪些字段？"></a>25# JWT 令牌都有哪些字段？</h2><p>JWT令牌由三个部分组成：头部（Header）、载荷（Payload）和签名（Signature）。其中，头部和载荷均为JSON格式，使用Base64编码进行序列化，而签名部分是对头部、载荷和密钥进行签名后的结果。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725231451188.png" alt="image-20240725231451188"></p>
<h2 id="26-JWT-令牌为什么能解决集群部署，什么是集群部署？"><a href="#26-JWT-令牌为什么能解决集群部署，什么是集群部署？" class="headerlink" title="26# JWT 令牌为什么能解决集群部署，什么是集群部署？"></a>26# JWT 令牌为什么能解决集群部署，什么是集群部署？</h2><p>在传统的基于会话和Cookie的身份验证方式中，会话信息通常存储在服务器的内存或数据库中。但在集群部署中，不同服务器之间没有共享的会话信息，这会导致用户在不同服务器之间切换时需要重新登录，或者需要引入额外的共享机制（如Redis），增加了复杂性和性能开销。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/redis_session.webp" alt="img"></p>
<p>而JWT令牌通过在令牌中包含所有必要的身份验证和会话信息，使得服务器无需存储会话信息，从而解决了集群部署中的身份验证和会话管理问题。当用户进行登录认证后，服务器将生成一个JWT令牌并返回给客户端。客户端在后续的请求中携带该令牌，服务器可以通过对令牌进行验证和解析来获取用户身份和权限信息，而无需访问共享的会话存储。</p>
<p>由于JWT令牌是自包含的，服务器可以独立地对令牌进行验证，而不需要依赖其他服务器或共享存储。这使得集群中的每个服务器都可以独立处理请求，提高了系统的可伸缩性和容错性。</p>
<h2 id="27-JWT-的缺点是什么？"><a href="#27-JWT-的缺点是什么？" class="headerlink" title="27# JWT 的缺点是什么？"></a>27# JWT 的缺点是什么？</h2><p>JWT 一旦派发出去，在失效之前都是有效的，没办法即使撤销JWT。</p>
<p>要解决这个问题的话，得在业务层增加判断逻辑，比如增加**黑名单机制。**使用内存数据库比如 Redis 维护一个黑名单，如果想让某个 JWT 失效的话就直接将这个 JWT 加入到 <strong>黑名单</strong> 即可。然后，每次使用 JWT 进行请求的话都会先判断这个 JWT 是否存在于黑名单中。</p>
<h2 id="28-JWT-令牌如果泄露了，怎么解决，JWT是怎么做的？"><a href="#28-JWT-令牌如果泄露了，怎么解决，JWT是怎么做的？" class="headerlink" title="28# JWT 令牌如果泄露了，怎么解决，JWT是怎么做的？"></a>28# JWT 令牌如果泄露了，怎么解决，JWT是怎么做的？</h2><ul>
<li>及时失效令牌：当检测到JWT令牌泄露或存在风险时，可以立即将令牌标记为失效状态。服务器在接收到带有失效标记的令牌时，会拒绝对其进行任何操作，从而保护用户的身份和数据安全。</li>
<li>刷新令牌：JWT令牌通常具有一定的有效期，过期后需要重新获取新的令牌。当检测到令牌泄露时，可以主动刷新令牌，即重新生成一个新的令牌，并将旧令牌标记为失效状态。这样，即使泄露的令牌被恶意使用，也会很快失效，减少了被攻击者滥用的风险。</li>
<li>使用黑名单：服务器可以维护一个令牌的黑名单，将泄露的令牌添加到黑名单中。在接收到令牌时，先检查令牌是否在黑名单中，如果在则拒绝操作。这种方法需要服务器维护黑名单的状态，对性能有一定的影响，但可以有效地保护泄露的令牌不被滥用。</li>
</ul>
<h2 id="29-前端是如何存储-JWT-的？"><a href="#29-前端是如何存储-JWT-的？" class="headerlink" title="29# 前端是如何存储 JWT 的？"></a>29# 前端是如何存储 JWT 的？</h2><p>JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案。互联网服务离不开用户认证。</p>
<p>一般流程如下：</p>
<ol>
<li>用户向服务器发送用户名和密码。</li>
<li>服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</li>
<li>服务器向用户返回一个 session_id，写入用户的 Cookie。</li>
<li>用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</li>
<li>服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</li>
</ol>
<p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p>
<p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p>
<p>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p>
<p>另一种方案是服务器索性不保存 session 数据了，<strong>所有数据都保存在客户端，每次请求都发回服务器</strong>。J<strong>WT 就是这种方案的一个代表。</strong></p>
<p>客户端收到服务器返回的 JWT，<strong>可以储存在 Local Storage 里面，也可以储存在Cookie里面，还可以存储在Session Storage里面。下面将说明存在上述各个地方的优劣势：</strong></p>
<blockquote>
<p>Local Storage（本地存储）</p>
</blockquote>
<ul>
<li><strong>优点</strong>：Local Storage 提供了较大的存储空间（一般为5MB），且不会随着HTTP请求一起发送到服务器，因此不会出现在HTTP缓存或日志中。</li>
<li><strong>缺点</strong>：存在XSS（跨站脚本攻击）的风险，恶意脚本可以通过JavaScript访问到存储在Local Storage中的JWT，从而盗取用户凭证。</li>
</ul>
<blockquote>
<p>Session Storage（会话存储）</p>
</blockquote>
<ul>
<li><strong>优点</strong>：与Local Storage类似，但仅限于当前浏览器窗口或标签页，当窗口关闭后数据会被清除，这在一定程度上减少了数据泄露的风险。</li>
<li><strong>缺点</strong>：用户体验可能受影响，因为刷新页面或在新标签页打开相同应用时需要重新认证。</li>
</ul>
<blockquote>
<p>Cookie</p>
</blockquote>
<ul>
<li><strong>优点</strong>：可以设置HttpOnly标志来防止通过JavaScript访问，减少XSS攻击的风险；可以利用Secure标志确保仅通过HTTPS发送，增加安全性。</li>
<li><strong>缺点</strong>：大小限制较小（通常4KB），并且每次HTTP请求都会携带Cookie，可能影响性能；设置不当可能会受到CSRF（跨站请求伪造）攻击。</li>
</ul>
<h2 id="30-DNS-的全称了解么？"><a href="#30-DNS-的全称了解么？" class="headerlink" title="30# DNS 的全称了解么？"></a>30# DNS 的全称了解么？</h2><p>DNS的全称是Domain Name System（域名系统），它是互联网中用于将域名转换为对应IP地址的分布式数据库系统。DNS扮演着重要的角色，使得人们可以通过易记的域名访问互联网资源，而无需记住复杂的IP地址。</p>
<p>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 <a href="http://www.server.com,这里的句点代表了不同层次之间的**界限**./">www.server.com，这里的句点代表了不同层次之间的**界限**。</a></p>
<p>DNS 的默认端口号是53。</p>
<p>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。</p>
<p>毕竟域名是外国人发明，所以思维和中国人相反，比如说一个城市地点的时候，外国喜欢从小到大的方式顺序说起（如 XX 街道 XX 区 XX 市 XX 省），而中国则喜欢从大到小的顺序（如 XX 省 XX 市 XX 区 XX 街道）。</p>
<p>实际上域名最后还有一个点，比如 <a href="http://www.server.com.,这个最后的一个点代表根域名./">www.server.com.，这个最后的一个点代表根域名。</a></p>
<p>也就是，. 根域是在最顶层，它的下一层就是 .com 顶级域，再下面是 server.com。</p>
<p>所以域名的层级关系类似一个树状结构：</p>
<ul>
<li>根 DNS 服务器（.）</li>
<li>顶级域 DNS 服务器（.com）</li>
<li>权威 DNS 服务器（server.com）</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/5.jpg" alt="DNS 树状结构"></p>
<p>根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。</p>
<p>这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。</p>
<p>因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。</p>
<h2 id="31-DNS-域名解析的工作流程？"><a href="#31-DNS-域名解析的工作流程？" class="headerlink" title="31# DNS 域名解析的工作流程？"></a>31# DNS 域名解析的工作流程？</h2><ol>
<li>客户端首先会发出一个 DNS 请求，问 <a href="http://www.server.com/">www.server.com</a> 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP&#x2F;IP 设置中填写的 DNS 服务器地址）。</li>
<li>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 <a href="http://www.server.com,则它直接返回/">www.server.com，则它直接返回</a> IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 <a href="http://www.server.com/">www.server.com</a> 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。</li>
<li>根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“<a href="http://www.server.com/">www.server.com</a> 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”</li>
<li>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 <a href="http://www.server.com/">www.server.com</a> 的 IP 地址吗？”</li>
<li>顶级域名服务器说：“我给你负责 <a href="http://www.server.com/">www.server.com</a> 区域的权威 DNS 服务器的地址，你去问它应该能问到”。</li>
<li>本地 DNS 于是转向问权威 DNS 服务器：“老三，<a href="http://www.server.com对应的IP是啥呀？”">www.server.com对应的IP是啥呀？”</a> server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li>
<li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li>
<li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li>
</ol>
<p>至此，我们完成了 DNS 的解析过程。现在总结一下，整个过程我画成了一个图。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1715326531135-c1f081dd-89e1-4b31-94e4-95a76f9fcba4.png" alt="img"></p>
<h2 id="32-DNS-的底层使用-TCP-还是-UDP？"><a href="#32-DNS-的底层使用-TCP-还是-UDP？" class="headerlink" title="32# DNS 的底层使用 TCP 还是 UDP？"></a>32# DNS 的底层使用 TCP 还是 UDP？</h2><p>DNS 基于UDP协议实现，DNS使用UDP协议进行域名解析和数据传输。因为基于UDP实现DNS能够提供低延迟、简单快速、轻量级的特性，更适合DNS这种需要快速响应的域名解析服务。</p>
<ul>
<li><strong>低延迟：</strong> UDP是一种无连接的协议，不需要在数据传输前建立连接，因此可以减少传输时延，适合DNS这种需要快速响应的应用场景。</li>
<li><strong>简单快速：</strong> UDP相比于TCP更简单，没有TCP的连接管理和流量控制机制，传输效率更高，适合DNS这种需要快速传输数据的场景。</li>
<li><strong>轻量级</strong>：UDP头部较小，占用较少的网络资源，对于小型请求和响应来说更加轻量级，适合DNS这种频繁且短小的数据交换。</li>
</ul>
<p>尽管 UDP 存在丢包和数据包损坏的风险，但在 DNS 的设计中，这些风险是可以被容忍的。DNS 使用了一些机制来提高可靠性，例如查询超时重传、请求重试、缓存等，以确保数据传输的可靠性和正确性。</p>
<h2 id="33-Nginx-有哪些负载均衡算法？"><a href="#33-Nginx-有哪些负载均衡算法？" class="headerlink" title="33# Nginx 有哪些负载均衡算法？"></a>33# Nginx 有哪些负载均衡算法？</h2><p>Nginx支持的负载均衡算法包括：</p>
<ul>
<li><strong>轮询</strong>：按照顺序依次将请求分配给后端服务器。这种算法最简单，但是也无法处理某个节点变慢或者客户端操作有连续性的情况。</li>
<li><strong>IP哈希</strong>：根据客户端IP地址的哈希值来确定分配请求的后端服务器。适用于需要保持同一客户端的请求始终发送到同一台后端服务器的场景，如会话保持。</li>
<li><strong>URL哈希</strong>：按访问的URL的哈希结果来分配请求，使每个URL定向到一台后端服务器，可以进一步提高后端缓存服务器的效率。</li>
<li><strong>最短响应时间</strong>：按照后端服务器的响应时间来分配请求，响应时间短的优先分配。适用于后端服务器性能不均的场景，能够将请求发送到响应时间快的服务器，实现负载均衡。</li>
<li><strong>加权轮询</strong>：按照权重分配请求给后端服务器，权重越高的服务器获得更多的请求。适用于后端服务器性能不同的场景，可以根据服务器权重分配请求，提高高性能服务器的利用率。</li>
</ul>
<h2 id="34-Nginx-位于七层网络结构中的哪一层？"><a href="#34-Nginx-位于七层网络结构中的哪一层？" class="headerlink" title="34# Nginx 位于七层网络结构中的哪一层？"></a>34# Nginx 位于七层网络结构中的哪一层？</h2><p>应用层，nginx 是七层负载均衡。</p>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="1-说一下-TCP-的头部"><a href="#1-说一下-TCP-的头部" class="headerlink" title="1# 说一下 TCP 的头部"></a>1# 说一下 TCP 的头部</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1718240465754-594d5aab-cb68-408a-b228-70fd33b094f4.png" alt="img"></p>
<p>标注颜色的表示与本文关联比较大的字段，其他字段不做详细阐述。</p>
<p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p>
<p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p>
<p><strong>控制位：</strong></p>
<ul>
<li><em>ACK</em>：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。</li>
<li><em>RST</em>：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。</li>
<li><em>SYN</em>：该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li>
<li><em>FIN</em>：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。</li>
</ul>
<h2 id="2-TCP-三次握手过程说一下？"><a href="#2-TCP-三次握手过程说一下？" class="headerlink" title="2# TCP 三次握手过程说一下？"></a>2# TCP 三次握手过程说一下？</h2><p>TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而<strong>建立连接是通过三次握手来进行的</strong>。三次握手的过程如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1719902940519-03556a12-819b-42b4-b6f7-41b4448d9d99.png" alt="img"></p>
<ul>
<li>一开始，客户端和服务端都处于 CLOSE 状态。先是服务端主动监听某个端口，处于 LISTEN 状态</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com//picgo/1719902940838-34aa5e22-9e44-4057-968f-bd94d39a9073.png" alt="img"></p>
<ul>
<li>客户端会随机初始化序号（client_isn），将此序号置于 TCP 首部的「序号」字段中，同时把 SYN 标志位置为 1，表示 SYN 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态。</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com//picgo/1719902940971-c775098c-d03e-4059-b5ca-cd8594ac0ef5.png" alt="img"></p>
<ul>
<li>服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（server_isn），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1, 接着把 SYN 和 ACK 标志位置为 1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态。</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com//picgo/1719902940762-a8cb1769-ed0d-4f73-aedf-116d918f23e3.png" alt="img"></p>
<ul>
<li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次「确认应答号」字段填入 server_isn + 1 ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 ESTABLISHED 状态。</li>
<li>服务端收到客户端的应答报文后，也进入 ESTABLISHED 状态。</li>
</ul>
<p>从上面的过程可以发现<strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong>，这也是面试常问的题。</p>
<p>一旦完成三次握手，双方都处于 ESTABLISHED 状态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了。</p>
<h2 id="3-TCP-为什么需要三次握手建立连接？"><a href="#3-TCP-为什么需要三次握手建立连接？" class="headerlink" title="3# TCP 为什么需要三次握手建立连接？"></a>3# TCP 为什么需要三次握手建立连接？</h2><p>三次握手的原因：</p>
<ul>
<li>三次握手才可以阻止重复历史连接的初始化（主要原因）</li>
<li>三次握手才可以同步双方的初始序列号</li>
<li>三次握手才可以避免资源浪费</li>
</ul>
<p><em>原因一：避免历史连接</em></p>
<p>我们来看看 RFC 793 指出的 TCP 连接使用三次握手的<strong>首要原因</strong>：</p>
<p><em>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</em></p>
<p>简单来说，三次握手的<strong>首要原因是为了防止旧的重复连接初始化造成混乱。</strong></p>
<p>我们考虑一个场景，客户端先发送了 SYN（seq &#x3D; 90）报文，然后客户端宕机了，而且这个 SYN 报文还被网络阻塞了，服务并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了 SYN（seq &#x3D; 100）报文（<em>注意！不是重传 SYN，重传的 SYN 的序列号是一样的</em>）。</p>
<p>看看三次握手是如何阻止历史连接的：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1713944607859-18e6e2b0-4f67-4bc8-9be3-f5a120d38f9f.webp" alt="img"></p>
<p>客户端连续发送多次 SYN（都是同一个四元组）建立连接的报文，在<strong>网络拥堵</strong>情况下：</p>
<ul>
<li>一个「旧 SYN 报文」比「最新的 SYN」 报文早到达了服务端，那么此时服务端就会回一个 SYN + ACK 报文给客户端，此报文中的确认号是 91（90+1）。</li>
<li>客户端收到后，发现自己期望收到的确认号应该是 100 + 1，而不是 90 + 1，于是就会回 RST 报文。</li>
<li>服务端收到 RST 报文后，就会释放连接。</li>
<li>后续最新的 SYN 抵达了服务端后，客户端与服务端就可以正常的完成三次握手了。</li>
</ul>
<p>上述中的「旧 SYN 报文」称为历史连接，TCP 使用三次握手建立连接的<strong>最主要原因就是防止「历史连接」初始化了连接</strong>。</p>
<p><strong>如果是两次握手连接，就无法阻止历史连接</strong>，那为什么 TCP 两次握手为什么无法阻止历史连接呢？</p>
<p>我先直接说结论，主要是因为<strong>在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费</strong>。</p>
<p>你想想，在两次握手的情况下，服务端在收到 SYN 报文后，就进入 ESTABLISHED 状态，意味着这时可以给对方发送数据，但是客户端此时还没有进入 ESTABLISHED 状态，假设这次是历史连接，客户端判断到此次连接为历史连接，那么就会回 RST 报文来断开连接，而服务端在第一次握手的时候就进入 ESTABLISHED 状态，所以它可以发送数据的，但是它并不知道这个是历史连接，它只有在收到 RST 报文后，才会断开连接。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1713944607907-4103122b-a6cf-412a-bddd-755573f967b8.webp" alt="img"></p>
<p>可以看到，如果采用两次握手建立 TCP 连接的场景下，服务端在向客户端发送数据前，并没有阻止掉历史连接，导致服务端建立了一个历史连接，又白白发送了数据，妥妥地浪费了服务端的资源。</p>
<p>因此，<strong>要解决这种现象，最好就是在服务端发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手</strong>。</p>
<p>所以，<strong>TCP 使用三次握手建立连接的最主要原因是防止「历史连接」初始化了连接。</strong></p>
<p><em>原因二：同步双方初始序列号</em></p>
<p>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：</p>
<ul>
<li>接收方可以去除重复的数据；</li>
<li>接收方可以根据数据包的序列号按序接收；</li>
<li>可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；</li>
</ul>
<p>可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 SYN 报文的时候，需要服务端回一个 ACK 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，<strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步。</strong></p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1713944607932-bc673dc4-6c94-45f5-a731-d583a44feba8.webp" alt="img"></p>
<p>四次握手与三次握手</p>
<p>四次握手其实也能够可靠的同步双方的初始化序号，但由于<strong>第二步和第三步可以优化成一步</strong>，所以就成了「三次握手」。</p>
<p>而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p>
<p><em>原因三：避免资源浪费</em></p>
<p>如果只有「两次握手」，当客户端发生的 SYN 报文在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN ，<strong>由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的</strong> <strong>ACK</strong> <strong>报文，所以服务端每收到一个</strong> <strong>SYN</strong> <strong>就只能先主动建立一个连接</strong>，这会造成什么情况呢？</p>
<p>如果客户端发送的 SYN 报文在网络中阻塞了，重复发送多次 SYN 报文，那么服务端在收到请求后就会<strong>建立多个冗余的无效链接，造成不必要的资源浪费。</strong></p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1713944608099-10191808-a9dc-455c-9c93-f87513b9da39.webp" alt="img"></p>
<p>即两次握手会造成消息滞留情况下，服务端重复接受无用的连接请求 SYN 报文，而造成重复分配资源。</p>
<h2 id="4-TCP-三次握手，客户端第三次发送的确认包丢失了发生什么？"><a href="#4-TCP-三次握手，客户端第三次发送的确认包丢失了发生什么？" class="headerlink" title="4# TCP 三次握手，客户端第三次发送的确认包丢失了发生什么？"></a>4# TCP 三次握手，客户端第三次发送的确认包丢失了发生什么？</h2><p>客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 ESTABLISH 状态。</p>
<p>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。</p>
<p>注意，<strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。</p>
<p>举个例子，假设 tcp_synack_retries 参数值为 2，那么当第三次握手一直丢失时，发生的过程如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1716197561528-054a85a1-c701-40a3-9051-47bc472d3331.png" alt="img"></p>
<p>具体过程：</p>
<ul>
<li>当服务端超时重传 2 次 SYN-ACK 报文后，由于 tcp_synack_retries 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（ACK 报文），那么服务端就会断开连接。</li>
</ul>
<h2 id="5-三次握手和-accept-是什么关系？-accept-做了哪些事情？"><a href="#5-三次握手和-accept-是什么关系？-accept-做了哪些事情？" class="headerlink" title="5# 三次握手和 accept 是什么关系？ accept 做了哪些事情？"></a>5# 三次握手和 accept 是什么关系？ accept 做了哪些事情？</h2><p>tcp 完成三次握手后，连接会被保存到内核的全连接队列，调用 accpet 就是从<strong>把连接取出来给用户程序使用。</strong></p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1716197756625-191dca5c-78c3-486b-bea0-f9e9d1638c52.png" alt="img"></p>
<h2 id="6-客户端发送的第一个-SYN-报文，服务器没有收到怎么办？"><a href="#6-客户端发送的第一个-SYN-报文，服务器没有收到怎么办？" class="headerlink" title="6# 客户端发送的第一个 SYN 报文，服务器没有收到怎么办？"></a>6# 客户端发送的第一个 SYN 报文，服务器没有收到怎么办？</h2><p>当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 SYN_SENT 状态。</p>
<p>在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文，而且<strong>重传的 SYN 报文的序列号都是一样的</strong>。</p>
<p>不同版本的操作系统可能超时时间不同，有的 1 秒的，也有 3 秒的，这个超时时间是写死在内核里的，如果想要更改则需要重新编译内核，比较麻烦。</p>
<p>当客户端在 1 秒后没收到服务端的 SYN-ACK 报文后，客户端就会重发 SYN 报文，那到底重发几次呢？</p>
<p>在 Linux 里，客户端的 SYN 报文最大重传次数由 tcp_syn_retries内核参数控制，这个参数是可以自定义的，默认值一般是 5。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_syn_retries</span></span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，<strong>每次超时的时间是上一次的 2 倍</strong>。</p>
<p>当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。</p>
<p>所以，总耗时是 1+2+4+8+16+32&#x3D;63 秒，大约 1 分钟左右。</p>
<p>举个例子，假设 tcp_syn_retries 参数值为 3，那么当客户端的 SYN 报文一直在网络中丢失时，会发生下图的过程：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1716197922148-8848fa15-9d0c-404d-bf5f-3c534eb62301.png" alt="img"></p>
<p>具体过程：</p>
<ul>
<li>当客户端超时重传 3 次 SYN 报文后，由于 tcp_syn_retries 为 3，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。</li>
</ul>
<h2 id="7-服务器收到第一个-SYN-报文，回复的-SYN-ACK-报文丢失了怎么办？"><a href="#7-服务器收到第一个-SYN-报文，回复的-SYN-ACK-报文丢失了怎么办？" class="headerlink" title="7# 服务器收到第一个 SYN 报文，回复的 SYN + ACK 报文丢失了怎么办？"></a>7# 服务器收到第一个 SYN 报文，回复的 SYN + ACK 报文丢失了怎么办？</h2><p>当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 SYN_RCVD 状态。</p>
<p>第二次握手的 SYN-ACK 报文其实有两个目的 ：</p>
<ul>
<li>第二次握手里的 ACK， 是对第一次握手的确认报文；</li>
<li>第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；</li>
</ul>
<p>所以，如果第二次握手丢了，就会发生比较有意思的事情，具体会怎么样呢？</p>
<p>因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是<strong>客户端就会触发超时重传机制，重传 SYN 报文</strong>。</p>
<p>然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。</p>
<p>那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是<strong>服务端这边会触发超时重传机制，重传 SYN-ACK 报文</strong>。</p>
<p>在 Linux 下，SYN-ACK 报文的最大重传次数由 tcp_synack_retries内核参数决定，默认值是 5。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_synack_retries</span></span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>因此，当第二次握手丢失了，客户端和服务端都会重传：</p>
<ul>
<li>客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 tcp_syn_retries内核参数决定；</li>
<li>服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 tcp_synack_retries 内核参数决定。</li>
</ul>
<p>举个例子，假设 tcp_syn_retries 参数值为 1，tcp_synack_retries 参数值为 2，那么当第二次握手一直丢失时，发生的过程如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1716197942561-1fa01724-1149-4d9d-88fd-060cdd38378b.png" alt="img"></p>
<p>具体过程：</p>
<ul>
<li>当客户端超时重传 1 次 SYN 报文后，由于 tcp_syn_retries 为 1，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。</li>
<li>当服务端超时重传 2 次 SYN-ACK 报文后，由于 tcp_synack_retries 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（ACK 报文），那么服务端就会断开连接。</li>
</ul>
<h2 id="8-假设客户端重传了-SYN-报文，服务端这边又收到重复的-SYN-报文怎么办？"><a href="#8-假设客户端重传了-SYN-报文，服务端这边又收到重复的-SYN-报文怎么办？" class="headerlink" title="8# 假设客户端重传了 SYN 报文，服务端这边又收到重复的 SYN 报文怎么办？"></a>8# 假设客户端重传了 SYN 报文，服务端这边又收到重复的 SYN 报文怎么办？</h2><p>会继续发送第二次握手报文。</p>
<h2 id="9-第一次握手，客户端发送-SYN-报后，服务端回复-ACK-报，那这个过程中服务端内部做了哪些工作？"><a href="#9-第一次握手，客户端发送-SYN-报后，服务端回复-ACK-报，那这个过程中服务端内部做了哪些工作？" class="headerlink" title="9# 第一次握手，客户端发送 SYN 报后，服务端回复 ACK 报，那这个过程中服务端内部做了哪些工作？"></a>9# 第一次握手，客户端发送 SYN 报后，服务端回复 ACK 报，那这个过程中服务端内部做了哪些工作？</h2><p>服务端收到客户端发起的 SYN 请求后，<strong>内核会把该连接存储到半连接队列</strong>，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，<strong>内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。</strong></p>
<p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725231318748.png" alt="image-20240725231318748"></p>
<p>不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，内核会直接丢弃，或返回 RST 包。</p>
<h2 id="10-大量-SYN-包发送给服务端服务端会发生什么事情？"><a href="#10-大量-SYN-包发送给服务端服务端会发生什么事情？" class="headerlink" title="10# 大量 SYN 包发送给服务端服务端会发生什么事情？"></a>10# 大量 SYN 包发送给服务端服务端会发生什么事情？</h2><p>有可能会导致TCP 半连接队列打满，这样<strong>当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃</strong>，导致客户端无法和服务端建立连接。</p>
<p>避免 SYN 攻击方式，可以有以下四种方法：</p>
<ul>
<li>调大 netdev_max_backlog；</li>
<li>增大 TCP 半连接队列；</li>
<li>开启 tcp_syncookies；</li>
<li>减少 SYN+ACK 重传次数</li>
</ul>
<blockquote>
<p>方式一：调大 netdev_max_backlog</p>
</blockquote>
<p>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值如下参数，默认值是 1000，我们要适当调大该参数的值，比如设置为 10000：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">net.core.netdev_max_backlog = 10000</span><br></pre></td></tr></table></figure>

<blockquote>
<p>方式二：增大 TCP 半连接队列</p>
</blockquote>
<p>增大 TCP 半连接队列，要同时增大下面这三个参数：</p>
<ul>
<li>增大 net.ipv4.tcp_max_syn_backlog</li>
<li>增大 listen() 函数中的 backlog</li>
<li>增大 net.core.somaxconn</li>
</ul>
<blockquote>
<p>方式三：开启 net.ipv4.tcp_syncookies</p>
</blockquote>
<p>开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接，相当于绕过了 SYN 半连接来建立连接。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725231252689.png" alt="image-20240725231252689"></p>
<p>具体过程：</p>
<ul>
<li>当 「 SYN 队列」满之后，后续服务端收到 SYN 包，不会丢弃，而是根据算法，计算出一个 <code>cookie</code> 值；</li>
<li>将 cookie 值放到第二次握手报文的「序列号」里，然后服务端回第二次握手给客户端；</li>
<li>服务端接收到客户端的应答报文时，服务端会检查这个 ACK 包的合法性。如果合法，将该连接对象放入到「 Accept 队列」。</li>
<li>最后应用程序通过调用 <code>accpet()</code> 接口，从「 Accept 队列」取出的连接。</li>
</ul>
<p>可以看到，当开启了 tcp_syncookies 了，即使受到 SYN 攻击而导致 SYN 队列满时，也能保证正常的连接成功建立。</p>
<p>net.ipv4.tcp_syncookies 参数主要有以下三个值：</p>
<ul>
<li>0 值，表示关闭该功能；</li>
<li>1 值，表示仅当 SYN 半连接队列放不下时，再启用它；</li>
<li>2 值，表示无条件开启功能；</li>
</ul>
<p>那么在应对 SYN 攻击时，只需要设置为 1 即可。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ echo 1 &gt; /proc/sys/net/ipv4/tcp_syncookies</span><br></pre></td></tr></table></figure>

<blockquote>
<p>方式四：减少 SYN+ACK 重传次数</p>
</blockquote>
<p>当服务端受到 SYN 攻击时，就会有大量处于 SYN_REVC 状态的 TCP 连接，处于这个状态的 TCP 会重传 SYN+ACK ，当重传超过次数达到上限后，就会断开连接。</p>
<p>那么针对 SYN 攻击的场景，我们可以减少 SYN-ACK 的重传次数，以加快处于 SYN_REVC 状态的 TCP 连接断开。</p>
<p>SYN-ACK 报文的最大重传次数由 <code>tcp_synack_retries</code>内核参数决定（默认值是 5 次），比如将 tcp_synack_retries 减少到 2 次：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ echo 2 &gt; /proc/sys/net/ipv4/tcp_synack_retries</span><br></pre></td></tr></table></figure>



<h2 id="11-TCP-四次挥手过程说一下？"><a href="#11-TCP-四次挥手过程说一下？" class="headerlink" title="11# TCP 四次挥手过程说一下？"></a>11# TCP 四次挥手过程说一下？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1712907058486-0726e0a5-8ea0-41fa-a9b0-cd17f1911df2.webp" alt="img"></p>
<p>具体过程：</p>
<ul>
<li>客户端主动调用关闭连接的函数，于是就会发送 FIN 报文，这个 FIN 报文代表客户端不会再发送数据了，进入 FIN_WAIT_1 状态；</li>
<li>服务端收到了 FIN 报文，然后马上回复一个 ACK 确认报文，此时服务端进入 CLOSE_WAIT 状态。在收到 FIN 报文的时候，TCP 协议栈会为 FIN 包插入一个文件结束符 EOF 到接收缓冲区中，服务端应用程序可以通过 read 调用来感知这个 FIN 包，这个 EOF 会被<strong>放在已排队等候的其他已接收的数据之后</strong>，所以必须要得继续 read 接收缓冲区已接收的数据；</li>
<li>接着，当服务端在 read 数据的时候，最后自然就会读到 EOF，接着 <strong>read() 就会返回 0，这时服务端应用程序如果有数据要发送的话，就发完数据后才调用关闭连接的函数，如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数</strong>，这时服务端就会发一个 FIN 包，这个 FIN 报文代表服务端不会再发送数据了，之后处于 LAST_ACK 状态；</li>
<li>客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进入 TIME_WAIT 状态；</li>
<li>服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态；</li>
<li>客户端经过 2MSL 时间之后，也进入 CLOSE 状态；</li>
</ul>
<h2 id="12-为什么4次握手中间两次不能变成一次？"><a href="#12-为什么4次握手中间两次不能变成一次？" class="headerlink" title="12# 为什么4次握手中间两次不能变成一次？"></a>12# 为什么4次握手中间两次不能变成一次？</h2><p>服务器收到客户端的 FIN 报文时，内核会马上回一个 ACK 应答报文，<strong>但是服务端应用程序可能还有数据要发送，所以并不能马上发送 FIN 报文，而是将发送 FIN 报文的控制权交给服务端应用程序</strong>：</p>
<ul>
<li>如果服务端应用程序有数据要发送的话，就发完数据后，才调用关闭连接的函数；</li>
<li>如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数，</li>
</ul>
<p>从上面过程可知，是否要发送第三次挥手的控制权不在内核，而是在被动关闭方（上图的服务端）的应用程序，因为应用程序可能还有数据要发送，由应用程序决定什么时候调用关闭连接的函数，当调用了关闭连接的函数，内核就会发送 FIN 报文了，所以服务端的 ACK 和 FIN 一般都会分开发送。</p>
<h2 id="13-第二次和第三次挥手能合并嘛"><a href="#13-第二次和第三次挥手能合并嘛" class="headerlink" title="13# 第二次和第三次挥手能合并嘛"></a>13# 第二次和第三次挥手能合并嘛</h2><p>当被动关闭方在 TCP 挥手过程中，「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1717915587991-5916d862-96df-4c8d-b749-bf750c6a81cd.png" alt="img"></p>
<h2 id="14-第三次挥手一直没发，会发生什么？"><a href="#14-第三次挥手一直没发，会发生什么？" class="headerlink" title="14# 第三次挥手一直没发，会发生什么？"></a>14# 第三次挥手一直没发，会发生什么？</h2><p>当主动方收到 ACK 报文后，会处于 FIN_WAIT2 状态，就表示主动方的发送通道已经关闭，接下来将等待对方发送 FIN 报文，关闭对方的发送通道。</p>
<p>这时，<strong>如果连接是用 shutdown 函数关闭的，连接可以一直处于 FIN_WAIT2 状态，因为它可能还可以发送或接收数据。但对于 close 函数关闭的孤儿连接，由于无法再发送和接收数据，所以这个状态不可以持续太久，而 tcp_fin_timeout 控制了这个状态下连接的持续时长</strong>，默认值是 60 秒：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1717915870664-a625c552-12a1-4f5d-9753-a8f15cf66a11.png" alt="img"></p>
<p>它意味着对于孤儿连接（调用 close 关闭的连接），如果在 60 秒后还没有收到 FIN 报文，连接就会直接关闭。</p>
<h2 id="15-第二次和第三次挥手之间，主动断开的那端能干什么"><a href="#15-第二次和第三次挥手之间，主动断开的那端能干什么" class="headerlink" title="15# 第二次和第三次挥手之间，主动断开的那端能干什么"></a>15# 第二次和第三次挥手之间，主动断开的那端能干什么</h2><p>如果主动断开的一方，是<strong>调用了 shutdown 函数来关闭连接</strong>，并且只选择了关闭发送能力且<strong>没有关闭接收能力的话</strong>，那么主动断开的一方在第二次和第三次挥手之间<strong>还可以接收数据</strong>。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1717916055950-2ad9c006-d633-47b8-94e1-d1c575d87d97.png" alt="img"></p>
<h2 id="16-断开连接时客户端-FIN-包丢失，服务端的状态是什么？"><a href="#16-断开连接时客户端-FIN-包丢失，服务端的状态是什么？" class="headerlink" title="16# 断开连接时客户端 FIN 包丢失，服务端的状态是什么？"></a>16# 断开连接时客户端 FIN 包丢失，服务端的状态是什么？</h2><p>当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 FIN_WAIT_1 状态。</p>
<p>正常情况下，如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为 FIN_WAIT2状态。</p>
<p>如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文，重发次数由 tcp_orphan_retries 参数控制。</p>
<p>当客户端重传 FIN 报文的次数超过 tcp_orphan_retries 后，就不再发送 FIN 报文，则会在等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到第二次挥手，<strong>那么客户端直接进入到 close 状态，而服务端还是ESTABLISHED状态</strong></p>
<p>举个例子，假设 tcp_orphan_retries 参数值为 3，当第一次挥手一直丢失时，发生的过程如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1717312076440-7ef52e80-6085-4bff-8569-3f409fcb9106.png" alt="img"></p>
<h2 id="17-为什么四次挥手之后要等2MSL"><a href="#17-为什么四次挥手之后要等2MSL" class="headerlink" title="17# 为什么四次挥手之后要等2MSL?"></a>17# 为什么四次挥手之后要等2MSL?</h2><p>MSL 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 TTL 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。</p>
<p>MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 <strong>MSL 应该要大于等于 TTL 消耗为 0 的时间</strong>，以确保报文已被自然消亡。</p>
<p><strong>TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了</strong>。</p>
<p>TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以<strong>一来一回需要等待 2 倍的时间</strong>。</p>
<p>比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 FIN 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。</p>
<p>可以看到 <strong>2MSL时长</strong> 这其实是相当于<strong>至少允许报文丢失一次</strong>。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。</p>
<h2 id="18-服务端出现大量的-timewait-有哪些原因"><a href="#18-服务端出现大量的-timewait-有哪些原因" class="headerlink" title="18# 服务端出现大量的 timewait 有哪些原因?"></a>18# 服务端出现大量的 timewait 有哪些原因?</h2><p>问题来了，<strong>什么场景下服务端会主动断开连接呢？</strong></p>
<ul>
<li>第一个场景：HTTP 没有使用长连接</li>
<li>第二个场景：HTTP 长连接超时</li>
<li>第三个场景：HTTP 长连接的请求数量达到上限</li>
</ul>
<p>接下来，分别介绍下。</p>
<p><em>第一个场景：HTTP 没有使用长连接</em></p>
<p>我们先来看看 HTTP 长连接（Keep-Alive）机制是怎么开启的。</p>
<p>在 HTTP&#x2F;1.0 中默认是关闭的，如果浏览器要开启 Keep-Alive，它必须在请求的 header 中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure>

<p>然后当服务器收到请求，作出回应的时候，它也被添加到响应中 header 里：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure>

<p>这样做，TCP 连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个 TCP 连接。这一直继续到客户端或服务器端提出断开连接。</p>
<p><strong>从 HTTP&#x2F;1.1 开始， 就默认是开启了 Keep-Alive</strong>，现在大多数浏览器都默认是使用 HTTP&#x2F;1.1，所以 Keep-Alive 都是默认打开的。一旦客户端和服务端达成协议，那么长连接就建立好了。</p>
<p>如果要关闭 HTTP Keep-Alive，需要在 HTTP 请求或者响应的 header 里添加 Connection:close 信息，也就是说，<strong>只要客户端和服务端任意一方的 HTTP header 中有</strong> <strong>Connection:close</strong> <strong>信息，那么就无法使用 HTTP 长连接的机制</strong>。</p>
<p>关闭 HTTP 长连接机制后，每次请求都要经历这样的过程：建立 TCP -&gt; 请求资源 -&gt; 响应资源 -&gt; 释放连接，那么此方式就是 <strong>HTTP 短连接</strong>，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1718781065480-5e3c8380-c3e8-4a60-be53-86e4b740ee37.png" alt="img"></p>
<p>在前面我们知道，只要任意一方的 HTTP header 中有 Connection:close 信息，就无法使用 HTTP 长连接机制，这样在完成一次 HTTP 请求&#x2F;处理后，就会关闭连接。</p>
<p>问题来了，<strong>这时候是客户端还是服务端主动关闭连接呢？</strong></p>
<p>在 RFC 文档中，并没有明确由谁来关闭连接，<strong>请求和响应的双方都可以主动关闭 TCP 连接。</strong></p>
<p>不过，<strong>根据大多数 Web 服务的实现，不管哪一方禁用了 HTTP Keep-Alive，都是由服务端主动关闭连接</strong>，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p>
<p><em>第二个场景：HTTP 长连接超时</em></p>
<p>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p>
<p>HTTP 长连接可以在同一个 TCP 连接上接收和发送多个 HTTP 请求&#x2F;应答，避免了连接建立和释放的开销。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1718781079200-4782f21e-345a-43ae-9374-430d316f0390.png" alt="img"></p>
<p>可能有的同学会问，如果使用了 HTTP 长连接，如果客户端完成一个 HTTP 请求后，就不再发起新的请求，此时这个 TCP 连接一直占用着不是挺浪费资源的吗？</p>
<p>对没错，所以为了避免资源浪费的情况，web 服务软件一般都会提供一个参数，用来指定 HTTP 长连接的超时时间，比如 nginx 提供的 keepalive_timeout 参数。</p>
<p>假设设置了 HTTP 长连接的超时时间是 60 秒，nginx 就会启动一个「定时器」，<strong>如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，定时器的时间一到，nginx 就会触发回调函数来关闭该连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接</strong>。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1718781079510-914b923f-2f47-48ba-b5ab-d033e2f9f33d.png" alt="img"></p>
<p>当服务端出现大量 TIME_WAIT 状态的连接时，如果现象是有大量的客户端建立完 TCP 连接后，很长一段时间没有发送数据，那么大概率就是因为 HTTP 长连接超时，导致服务端主动关闭连接，产生大量处于 TIME_WAIT 状态的连接。</p>
<p>可以往网络问题的方向排查，比如是否是因为网络问题，导致客户端发送的数据一直没有被服务端接收到，以至于 HTTP 长连接超时。</p>
<p><em>第三个场景：HTTP 长连接的请求数量达到上限</em></p>
<p>Web 服务端通常会有个参数，来定义一条 HTTP 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接。</p>
<p>比如 nginx 的 keepalive_requests 这个参数，这个参数是指一个 HTTP 长连接建立之后，nginx 就会为这个连接设置一个计数器，记录这个 HTTP 长连接上已经接收并处理的客户端请求的数量。<strong>如果达到这个参数设置的最大值时，则 nginx 会主动关闭这个长连接</strong>，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p>
<p>keepalive_requests 参数的默认值是 100 ，意味着每个 HTTP 长连接最多只能跑 100 次请求，这个参数往往被大多数人忽略，因为当 QPS (每秒请求数) 不是很高时，默认值 100 凑合够用。</p>
<p>但是，<strong>对于一些 QPS 比较高的场景，比如超过 10000 QPS，甚至达到 30000 , 50000 甚至更高，如果 keepalive_requests 参数值是 100，这时候就 nginx 就会很频繁地关闭连接，那么此时服务端上就会出大量的 TIME_WAIT 状态</strong>。</p>
<p>针对这个场景下，解决的方式也很简单，调大 nginx 的 keepalive_requests 参数就行。</p>
<h2 id="19-TCP-和-UDP-区别是什么？"><a href="#19-TCP-和-UDP-区别是什么？" class="headerlink" title="19# TCP 和 UDP 区别是什么？"></a>19# TCP 和 UDP 区别是什么？</h2><ul>
<li>连接：TCP 是面向连接的传输层协议，传输数据前先要建立连接；UDP 是不需要连接，即刻传输数据。</li>
<li>服务对象：TCP 是一对一的两点服务，即一条连接只有两个端点。UDP 支持一对一、一对多、多对多的交互通信</li>
<li>可靠性：TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议</li>
<li>拥塞控制、流量控制：TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>
<li>首部开销：TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li>
<li>传输方式：TCP 是流式传输，没有边界，但保证顺序和可靠。UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li>
</ul>
<h2 id="20-TCP-为什么可靠传输"><a href="#20-TCP-为什么可靠传输" class="headerlink" title="20# TCP 为什么可靠传输"></a>20# TCP 为什么可靠传输</h2><p>TCP协议主要通过以下几点来保证传输可靠性：连接管理、序列号、确认应答、超时重传、流量控制、拥塞控制。</p>
<ul>
<li><strong>连接管理</strong>：即三次握手和四次挥手。连接管理机制能够建立起可靠的连接，这是保证传输可靠性的前提。</li>
<li><strong>序列号</strong>：TCP将每个字节的数据都进行了编号，这就是序列号。序列号的具体作用如下：能够保证可靠性，既能防止数据丢失，又能避免数据重复。能够保证有序性，按照序列号顺序进行数据包还原。能够提高效率，基于序列号可实现多次发送，一次确认。</li>
<li><strong>确认应答</strong>：接收方接收数据之后，会回传ACK报文，报文中带有此次确认的序列号，用于告知发送方此次接收数据的情况。在指定时间后，若发送端仍未收到确认应答，就会启动超时重传。</li>
<li><strong>超时重传</strong>：超时重传主要有两种场景：数据包丢失：在指定时间后，若发送端仍未收到确认应答，就会启动超时重传，向接收端重新发送数据包。确认包丢失：当接收端收到重复数据(通过序列号进行识别)时将其丢弃，并重新回传ACK报文。</li>
<li><strong>流量控制</strong>：接收端处理数据的速度是有限的，如果发送方发送数据的速度过快，就会导致接收端的缓冲区溢出，进而导致丢包。为了避免上述情况的发生，TCP支持根据接收端的处理能力，来决定发送端的发送速度。这就是流量控制。流量控制是通过在TCP报文段首部维护一个滑动窗口来实现的。</li>
<li><strong>拥塞控制</strong>：拥塞控制就是当网络拥堵严重时，发送端减少数据发送。拥塞控制是通过发送端维护一个拥塞窗口来实现的。可以得出，发送端的发送速度，受限于滑动窗口和拥塞窗口中的最小值。拥塞控制方法分为：慢开始，拥塞避免、快重传和快恢复。</li>
</ul>
<h2 id="21-怎么用-UDP-实现-HTTP？"><a href="#21-怎么用-UDP-实现-HTTP？" class="headerlink" title="21# 怎么用 UDP 实现 HTTP？"></a>21# 怎么用 UDP 实现 HTTP？</h2><p>UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输，在http3 就用了 quic 协议。</p>
<ul>
<li>连接迁移：QUIC支持在网络变化时快速迁移连接，例如从WiFi切换到移动数据网络，以保持连接的可靠性。</li>
<li>重传机制：QUIC使用重传机制来确保丢失的数据包能够被重新发送，从而提高数据传输的可靠性。</li>
<li>前向纠错：QUIC可以使用前向纠错技术，在接收端修复部分丢失的数据，降低重传的需求，提高可靠性和传输效率。</li>
<li>拥塞控制：QUIC内置了拥塞控制机制，可以根据网络状况动态调整数据传输速率，以避免网络拥塞和丢包，提高可靠性。</li>
</ul>
<h2 id="22-TCP-粘包怎么解决？"><a href="#22-TCP-粘包怎么解决？" class="headerlink" title="22# TCP 粘包怎么解决？"></a>22# TCP 粘包怎么解决？</h2><p>粘包的问题出现是因为不知道一个用户消息的边界在哪，如果知道了边界在哪，接收方就可以通过边界来划分出有效的用户消息。</p>
<p>一般有三种方式分包的方式：</p>
<ul>
<li>固定长度的消息；</li>
<li>特殊字符作为边界；</li>
<li>自定义消息结构。</li>
</ul>
<blockquote>
<p>固定长度的消息</p>
</blockquote>
<p>这种是最简单方法，即每个用户消息都是固定长度的，比如规定一个消息的长度是 64 个字节，当接收方接满 64 个字节，就认为这个内容是一个完整且有效的消息。</p>
<p>但是这种方式灵活性不高，实际中很少用。</p>
<blockquote>
<p>特殊字符作为边界</p>
</blockquote>
<p>我们可以在两个用户消息之间插入一个特殊的字符串，这样接收方在接收数据时，读到了这个特殊字符，就把认为已经读完一个完整的消息。</p>
<p>HTTP 是一个非常好的例子。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725231144741.png" alt="image-20240725231144741"></p>
<p>HTTP 通过设置回车符、换行符作为 HTTP 报文协议的边界。</p>
<p>有一点要注意，这个作为边界点的特殊字符，如果刚好消息内容里有这个特殊字符，我们要对这个字符转义，避免被接收方当作消息的边界点而解析到无效的数据。</p>
<blockquote>
<p>自定义消息结构</p>
</blockquote>
<p>我们可以自定义一个消息结构，由包头和数据组成，其中包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大。</p>
<p>比如这个消息结构体，首先 4 个字节大小的变量来表示数据长度，真正的数据则在后面。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">struct &#123; </span><br><span class="line">    u_int32_t message_length; </span><br><span class="line">    char message_data[]; </span><br><span class="line">&#125; message;</span><br></pre></td></tr></table></figure>

<p>当接收方接收到包头的大小（比如 4 个字节）后，就解析包头的内容，于是就可以知道数据的长度，然后接下来就继续读取数据，直到读满数据的长度，就可以组装成一个完整到用户消息来处理了。</p>
<h2 id="23-TCP-的拥塞控制介绍一下？"><a href="#23-TCP-的拥塞控制介绍一下？" class="headerlink" title="23# TCP 的拥塞控制介绍一下？"></a>23# TCP 的拥塞控制介绍一下？</h2><p>一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。</p>
<p><strong>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</strong></p>
<p>所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。</p>
<p>于是，就有了<strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络。</strong></p>
<p>为了在「发送方」调节所要发送数据的量，定义了一个叫做「<strong>拥塞窗口</strong>」的概念。</p>
<p><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。发送窗口 swnd 和接收窗口 rwnd 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd &#x3D; min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</p>
<p>拥塞窗口 cwnd 变化的规则：</p>
<ul>
<li>只要网络中没有出现拥塞，cwnd 就会增大；</li>
<li>但网络中出现了拥塞，cwnd 就减少；</li>
</ul>
<p>那么怎么知道当前网络是否出现了拥塞呢？其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<strong>发生了超时重传，就会认为网络出现了拥塞。</strong></p>
<p>拥塞控制有哪些控制算法？</p>
<p>拥塞控制主要是四个算法：</p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul>
<blockquote>
<p>慢启动</p>
</blockquote>
<p>TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量，如果一上来就发大量的数据，这不是给网络添堵吗？</p>
<p>慢启动的算法记住一个规则就行：<strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。</strong></p>
<p>这里假定拥塞窗口 cwnd 和发送窗口 swnd 相等，下面举个栗子：</p>
<ul>
<li>连接建立完成后，一开始初始化 cwnd &#x3D; 1，表示可以传一个 MSS 大小的数据。</li>
<li>当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个</li>
<li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个</li>
<li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。</li>
</ul>
<p>慢启动算法的变化过程如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1719917430212-8ace0daa-f82d-4f0e-ab04-7ef0ad3c2a01.png" alt="img"></p>
<p>可以看出慢启动算法，发包的个数是<strong>指数性的增长</strong>。</p>
<p><strong>那慢启动涨到什么时候是个头呢？</strong></p>
<p>有一个叫慢启动门限 ssthresh （slow start threshold）状态变量。</p>
<ul>
<li>当 cwnd &lt; ssthresh 时，使用慢启动算法。</li>
<li>当 cwnd &gt;&#x3D; ssthresh 时，就会使用「拥塞避免算法」。</li>
</ul>
<blockquote>
<p>拥塞避免算法</p>
</blockquote>
<p>前面说道，当拥塞窗口 cwnd 「超过」慢启动门限 ssthresh 就会进入拥塞避免算法。</p>
<p>一般来说 ssthresh 的大小是 65535 字节。</p>
<p>那么进入拥塞避免算法后，它的规则是：<strong>每当收到一个 ACK 时，cwnd 增加 1&#x2F;cwnd。</strong></p>
<p>接上前面的慢启动的栗子，现假定 ssthresh 为 8：</p>
<ul>
<li>当 8 个 ACK 应答确认到来时，每个确认增加 1&#x2F;8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 MSS 大小的数据，变成了<strong>线性增长。</strong></li>
</ul>
<p>拥塞避免算法的变化过程如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1719917430410-eb035401-c38c-4819-bde7-f2e1497e9c99.png" alt="img"></p>
<p>所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。</p>
<p>就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p>
<p>当触发了重传机制，也就进入了「拥塞发生算法」。</p>
<blockquote>
<p>拥塞发生</p>
</blockquote>
<p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：</p>
<ul>
<li>超时重传</li>
<li>快速重传</li>
</ul>
<p>这两种使用的拥塞发送算法是不同的，接下来分别来说说。</p>
<p><strong>发生超时重传的拥塞发生算法</strong></p>
<p>当发生了「超时重传」，则就会使用拥塞发生算法。</p>
<p>这个时候，ssthresh 和 cwnd 的值会发生变化：</p>
<ul>
<li>ssthresh 设为 cwnd&#x2F;2，</li>
<li>cwnd 重置为 1 （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）</li>
</ul>
<p>拥塞发生算法的变化如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1719917430279-dc2d687c-6d92-4727-b24e-cff9e59f9807.png" alt="img"></p>
<p>接着，就重新开始慢启动，慢启动是会突然减少数据流的。这真是一旦「超时重传」，马上回到解放前。但是这种方式太激进了，反应也很强烈，会造成网络卡顿。</p>
<p>就好像本来在秋名山高速漂移着，突然来个紧急刹车，轮胎受得了吗。。。</p>
<p><strong>发生快速重传的拥塞发生算法</strong></p>
<p>还有更好的方式，前面我们讲过「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。</p>
<p>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下：</p>
<ul>
<li>cwnd &#x3D; cwnd&#x2F;2 ，也就是设置为原来的一半;</li>
<li>ssthresh &#x3D; cwnd;</li>
<li>进入快速恢复算法</li>
</ul>
<blockquote>
<p>快速恢复</p>
</blockquote>
<p>快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈。</p>
<p>正如前面所说，进入快速恢复之前，cwnd 和 ssthresh 已被更新了：</p>
<ul>
<li>cwnd &#x3D; cwnd&#x2F;2 ，也就是设置为原来的一半;</li>
<li>ssthresh &#x3D; cwnd;</li>
</ul>
<p>然后，进入快速恢复算法如下：</p>
<ul>
<li>拥塞窗口 cwnd &#x3D; ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；</li>
<li>重传丢失的数据包；</li>
<li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li>
<li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li>
</ul>
<p>快速恢复算法的变化过程如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1719917430413-5e478af1-3040-4a99-a325-5d9073d20a10.png" alt="img"></p>
<p>也就是没有像「超时重传」一夜回到解放前，而是还在比较高的值，后续呈线性增长。</p>
<h1 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h1><h2 id="1-什么是-DDoS-攻击？怎么防范？"><a href="#1-什么是-DDoS-攻击？怎么防范？" class="headerlink" title="1# 什么是 DDoS 攻击？怎么防范？"></a>1# 什么是 DDoS 攻击？怎么防范？</h2><p>分布式拒绝服务（DDoS）攻击是通过大规模互联网流量淹没目标服务器或其周边基础设施，以破坏目标服务器、服务或网络正常流量的恶意行为。</p>
<p>DDoS 攻击是通过连接互联网的计算机网络进行的。这些网络由计算机和其他设备（例如 IoT 设备）组成，它们感染了恶意软件，从而被攻击者远程控制。这些个体设备称为机器人（或僵尸），一组机器人则称为僵尸网络。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1720420601347-4d7774a6-276d-4e71-b3b1-0165bf009341.webp" alt="img"></p>
<p>一旦建立了僵尸网络，攻击者就可通过向每个机器人发送远程指令来发动攻击。当僵尸网络将受害者的服务器或网络作为目标时，每个机器人会将请求发送到目标的 IP 地址，这可能导致服务器或网络不堪重负，从而造成对正常流量的拒绝服务。由于每个机器人都是合法的互联网设备，因而可能很难区分攻击流量与正常流量。</p>
<p>常见的DDoS攻击包括以下几类：</p>
<ul>
<li><strong>网络层攻击</strong>：比较典型的攻击类型是UDP反射攻击，例如：NTP Flood攻击，这类攻击主要利用大流量拥塞被攻击者的网络带宽，导致被攻击者的业务无法正常响应客户访问。</li>
<li><strong>传输层攻击</strong>：比较典型的攻击类型包括SYN Flood攻击、连接数攻击等，这类攻击通过占用服务器的连接池资源从而达到拒绝服务的目的。</li>
<li><strong>会话层攻击</strong>：比较典型的攻击类型是SSL连接攻击，这类攻击占用服务器的SSL会话资源从而达到拒绝服务的目的。</li>
<li><strong>应用层攻击</strong>：比较典型的攻击类型包括DNS flood攻击、HTTP flood攻击、游戏假人攻击等，这类攻击占用服务器的应用处理资源极大的消耗服务器处理性能从而达到拒绝服务的目的。</li>
</ul>
<p>为了防范DDoS攻击，可以采取以下措施：</p>
<ul>
<li>增强网络基础设施：提升网络带宽、增加服务器的处理能力和承载能力，通过增强基础设施的能力来抵御攻击。</li>
<li>使用防火墙和入侵检测系统：配置防火墙规则，限制不必要的网络流量，阻止来自可疑IP地址的流量。入侵检测系统可以帮助及时发现并响应DDoS攻击。</li>
<li>流量清洗和负载均衡：使用专业的DDoS防护服务提供商，通过流量清洗技术过滤掉恶意流量，将合法流量转发给目标服务器。负载均衡可以将流量均匀地分发到多台服务器上，减轻单一服务器的压力。</li>
<li>配置访问控制策略：限制特定IP地址或IP段的访问，设置访问频率限制，防止过多请求集中在单个IP上。</li>
</ul>
<h2 id="2-SQL-注入问题是什么？"><a href="#2-SQL-注入问题是什么？" class="headerlink" title="2# SQL 注入问题是什么？"></a>2# SQL 注入问题是什么？</h2><p>SQL注入发生在当应用程序直接使用用户提供的输入作为SQL查询的一部分时。当用户输入被错误地用作数据库查询的一部分，而应用程序没有对其进行适当的验证和转义，就可能会发生SQL注入。</p>
<p>例如，如果一个用户输入了一个字符串来查找特定用户的信息，但应用程序将此用户输入直接用作SQL查询的一部分（例如，作为SELECT语句的一部分），而不考虑可能的安全问题，那么攻击者可能会利用这一点来执行他们自己的恶意SQL查询。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1713944021157-59014f28-e5c0-4146-bc73-dd215e748b42.png" alt="img"></p>
<p>解决SQL注入问题的方法主要有以下几种：</p>
<ol>
<li>输入验证和转义：在将用户输入用作SQL查询的一部分之前，对输入进行验证和转义。确保输入符合预期格式，并防止任何可能导致SQL注入的特殊字符。</li>
<li>使用参数化查询：使用参数化查询可以避免直接将用户输入嵌入到SQL查询中。参数化查询使用预定义的变量来接收用户输入，并将其传递给数据库引擎，而不是直接将其用作查询的一部分。这样可以防止SQL注入攻击。</li>
<li>限制数据库权限：限制数据库用户的权限，只授予他们执行所需操作所需的最低权限。攻击者可能具有比预期更多的权限，这可能会使攻击更加容易。</li>
<li>实施输入过滤：在某些情况下，实施输入过滤可以进一步减少SQL注入的风险。这可能涉及检查和过滤用户输入中的特殊字符和词汇，以排除可能的恶意输入。</li>
</ol>
<h2 id="3-CSRF-攻击是什么？"><a href="#3-CSRF-攻击是什么？" class="headerlink" title="3# CSRF 攻击是什么？"></a>3# CSRF 攻击是什么？</h2><p>CSRF（跨站请求伪造）是一种攻击手段，攻击者通过诱导用户执行恶意操作，从而获取用户数据或执行恶意代码。CSRF攻击通常通过伪造一个合法的HTTP请求来实现，这个请求看起来是合法的，但实际上是为了执行一个攻击者控制的操作。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1713943911478-25877f98-8c12-47fa-b995-7efa6cfe3283.png" alt="img"></p>
<p>解决CSRF攻击的方法主要有以下几种：</p>
<ol>
<li>验证用户会话：在服务器端对用户会话进行验证，确保请求的会话标识符与当前会话标识符匹配。这样可以防止攻击者伪造会话标识符。</li>
<li>使用双重验证：除了会话验证，还可以使用其他验证方式，例如验证码、签名验证等。这些验证方式可以增加攻击的难度。</li>
<li>防止跨站请求：通过设置CSP（内容安全策略）来防止跨站请求，限制网页中可执行的脚本源，减少攻击者诱导用户执行恶意操作的可能性。</li>
<li>避免使用自动提交表单：禁用默认的自动提交功能，要求用户在提交表单前确认操作，防止攻击者诱导用户在未经授权的情况下提交表单。</li>
<li>强制Referer头部：在服务器端检查请求的Referer头部，确保请求来自可信来源。</li>
</ol>
<h2 id="4-XSS-攻击是什么？"><a href="#4-XSS-攻击是什么？" class="headerlink" title="4# XSS 攻击是什么？"></a>4# XSS 攻击是什么？</h2><p>XSS是跨站脚本攻击，攻击者通过在Web页面中插入恶意脚本代码，然后诱使用户访问该页面，从而使得恶意脚本在用户浏览器中执行，从而盗取用户信息、会话信息等敏感数据，甚至控制用户账户。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1713943802966-8c3d3c82-c870-468b-be20-bef18f9c3901.png" alt="img"></p>
<p>XSS 攻击可以分为 3 类：存储型（持久型）、反射型（非持久型）、DOM 型。</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Cross-site_scripting#%E5%AD%98%E5%82%A8%E5%9E%8B_xss">存储型 XSS (opens new window)</a>：注入型脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器上传回并执行。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Cross-site_scripting#%E5%8F%8D%E5%B0%84%E5%9E%8B_xss">反射型 XSS (opens new window)</a>：当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web 服务器将注入脚本，比如一个错误信息，搜索结果等 返回到用户的浏览器上。由于浏览器认为这个响应来自”可信任”的服务器，所以会执行这段脚本。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Cross-site_scripting#%E5%9F%BA%E4%BA%8E_dom_%E7%9A%84_xss">基于 DOM 的 XSS (opens new window)</a>：通过修改原始的客户端代码，受害者浏览器的 DOM 环境改变，导致有效载荷的执行。也就是说，页面本身并没有变化，但由于 DOM 环境被恶意修改，有客户端代码被包含进了页面，并且意外执行。</li>
</ul>
<p>预防XSS攻击的方法主要包括以下几点：</p>
<ul>
<li>输入验证：对所有用户输入的数据进行有效性检验，过滤或转义特殊字符。例如，禁止用户输入HTML标签和JavaScript代码。</li>
<li>输出编码：在网页输出用户输入内容时，使用合适的编码方式，如HTML转义、URL编码等，防止恶意脚本注入。</li>
<li>Content Security Policy（CSP）：通过设置CSP策略，限制网页中可执行的脚本源，有效防范XSS攻击。</li>
<li>使用HttpOnly标记：在设置Cookie时，设置HttpOnly属性，使得Cookie无法被JavaScript代码读取，减少受到XSS攻击的可能。</li>
</ul>
<h2 id="5-了解过-DNS-劫持吗？"><a href="#5-了解过-DNS-劫持吗？" class="headerlink" title="5# 了解过 DNS 劫持吗？"></a>5# 了解过 DNS 劫持吗？</h2><p>DNS劫持的原理是攻击者在用户查询DNS服务器时篡改响应，将用户请求的域名映射到攻击者控制的虚假IP地址上，使用户误以为访问的是正常网站，实际上被重定向到攻击者操控的恶意网站。这种劫持可以通过植入恶意的DNS记录或劫持用户的DNS流量来实现。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1711003864558-4778f714-3a1c-43c5-82ca-1bf480cf9878.png" alt="img"></p>
]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>八股文笔记 #7 操作系统</title>
    <url>/2025/09/24/boilerplate-answers-7-operating-system/</url>
    <content><![CDATA[<h1 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h1><h2 id="1-用户态和内核态的区别？"><a href="#1-用户态和内核态的区别？" class="headerlink" title="1# 用户态和内核态的区别？"></a>1# 用户态和内核态的区别？</h2><p>内核态和用户态是操作系统中的两种运行模式。它们的主要区别在于权限和可执行的操作：</p>
<ul>
<li>内核态（Kernel Mode）：在内核态下，CPU可以执行所有的指令和访问所有的硬件资源。这种模式下的操作具有更高的权限，主要用于操作系统内核的运行。</li>
<li>用户态（User Mode）：在用户态下，CPU只能执行部分指令集，无法直接访问硬件资源。这种模式下的操作权限较低，主要用于运行用户程序。</li>
</ul>
<span id="more"></span>

<p>内核态的底层操作主要包括：内存管理、进程管理、设备驱动程序控制、系统调用等。这些操作涉及到操作系统的核心功能，需要较高的权限来执行。</p>
<p>分为内核态和用户态的原因主要有以下几点：</p>
<ul>
<li>安全性：通过对权限的划分，用户程序无法直接访问硬件资源，从而避免了恶意程序对系统资源的破坏。</li>
<li>稳定性：用户态程序出现问题时，不会影响到整个系统，避免了程序故障导致系统崩溃的风险。</li>
<li>隔离性：内核态和用户态的划分使得操作系统内核与用户程序之间有了明确的边界，有利于系统的模块化和维护。</li>
</ul>
<p>内核态和用户态的划分有助于保证操作系统的安全性、稳定性和易维护性。</p>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="1-线程和进程的区别是什么？"><a href="#1-线程和进程的区别是什么？" class="headerlink" title="1# 线程和进程的区别是什么？"></a>1# 线程和进程的区别是什么？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1712907111634-f541e01f-2da1-426f-b7a8-ce769346a93d.webp" alt="img"></p>
<ul>
<li><strong>本质区别</strong>：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</li>
<li><strong>在开销方面</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小</li>
<li><strong>稳定性方面</strong>：进程中某个线程如果崩溃了，可能会导致整个进程都崩溃。而进程中的子进程崩溃，并不会影响其他进程。</li>
<li><strong>内存分配方面</strong>：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源</li>
<li><strong>包含关系</strong>：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线</li>
</ul>
<h2 id="2-进程，线程，协程的区别是什么？"><a href="#2-进程，线程，协程的区别是什么？" class="headerlink" title="2# 进程，线程，协程的区别是什么？"></a>2# 进程，线程，协程的区别是什么？</h2><ul>
<li>首先，我们来谈谈<strong>进程</strong>。进程是操作系统中进行资源分配和调度的基本单位，它拥有自己的独立内存空间和系统资源。每个进程都有独立的堆和栈，不与其他进程共享。进程间通信需要通过特定的机制，如管道、消息队列、信号量等。由于进程拥有独立的内存空间，因此其稳定性和安全性相对较高，但同时上下文切换的开销也较大，因为需要保存和恢复整个进程的状态。</li>
<li>接下来是<strong>线程</strong>。线程是进程内的一个执行单元，也是CPU调度和分派的基本单位。与进程不同，线程共享进程的内存空间，包括堆和全局变量。线程之间通信更加高效，因为它们可以直接读写共享内存。线程的上下文切换开销较小，因为只需要保存和恢复线程的上下文，而不是整个进程的状态。然而，由于多个线程共享内存空间，因此存在数据竞争和线程安全的问题，需要通过同步和互斥机制来解决。</li>
<li>最后是<strong>协程</strong>。协程是一种用户态的轻量级线程，其调度完全由用户程序控制，而不需要内核的参与。协程拥有自己的寄存器上下文和栈，但与其他协程共享堆内存。协程的切换开销非常小，因为只需要保存和恢复协程的上下文，而无需进行内核级的上下文切换。这使得协程在处理大量并发任务时具有非常高的效率。然而，协程需要程序员显式地进行调度和管理，相对于线程和进程来说，其编程模型更为复杂。</li>
</ul>
<h2 id="3-为什么进程崩溃不会对其他进程产生很大影响"><a href="#3-为什么进程崩溃不会对其他进程产生很大影响" class="headerlink" title="3# 为什么进程崩溃不会对其他进程产生很大影响"></a>3# <strong>为什么进程崩溃不会对其他进程产生很大影响</strong></h2><p>主要是因为：</p>
<ul>
<li><strong>进程隔离性</strong>：每个进程都有自己独立的内存空间，当一个进程崩溃时，其内存空间会被操作系统回收，不会影响其他进程的内存空间。这种进程间的隔离性保证了一个进程崩溃不会直接影响其他进程的执行。</li>
<li><strong>进程独立性</strong>：每个进程都是独立运行的，它们之间不会共享资源，如文件、网络连接等。因此，一个进程的崩溃通常不会对其他进程的资源产生影响。</li>
</ul>
<h2 id="4-你说到进程是分配资源的基本单位，那么这个资源指的是什么？"><a href="#4-你说到进程是分配资源的基本单位，那么这个资源指的是什么？" class="headerlink" title="4# 你说到进程是分配资源的基本单位，那么这个资源指的是什么？"></a>4# 你说到进程是分配资源的基本单位，那么这个资源指的是什么？</h2><p>虚拟内存、文件句柄、信号量等资源。</p>
<h2 id="5-讲下为什么进程之下还要设计线程？"><a href="#5-讲下为什么进程之下还要设计线程？" class="headerlink" title="5# 讲下为什么进程之下还要设计线程？"></a>5# 讲下为什么进程之下还要设计线程？</h2><p>我们举个例子，假设你要编写一个视频播放器软件，那么该软件功能的核心模块有三个：</p>
<ul>
<li>从视频文件当中读取数据；</li>
<li>对读取的数据进行解压缩；</li>
<li>把解压缩后的视频数据播放出来；</li>
</ul>
<p>对于单进程的实现方式，我想大家都会是以下这个方式：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1720433762512-a4198969-7743-46f4-8d3f-257bbce1cc10.png" alt="img"></p>
<p>对于单进程的这种方式，存在以下问题：</p>
<ul>
<li>播放出来的画面和声音会不连贯，因为当 CPU 能力不够强的时候，Read 的时候可能进程就等在这了，这样就会导致等半天才进行数据解压和播放；</li>
<li>各个函数之间不是并发执行，影响资源的使用效率；</li>
</ul>
<p>那改进成多进程的方式：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1720433762834-7790110f-4653-42fc-b06d-dea02856abac.png" alt="img"></p>
<p>对于多进程的这种方式，依然会存在问题：</p>
<ul>
<li>进程之间如何通信，共享数据？</li>
<li>维护进程的系统开销较大，如创建进程时，分配资源、建立 PCB；终止进程时，回收资源、撤销 PCB；进程切换时，保存当前进程的状态信息；</li>
</ul>
<p>那到底如何解决呢？需要有一种新的实体，满足以下特性：</p>
<ul>
<li>实体之间可以并发运行；</li>
<li>实体之间共享相同的地址空间；</li>
</ul>
<p>这个新的实体，就是<strong>线程(</strong> <em><strong>Thread</strong></em> <strong>)</strong>，线程之间可以并发运行且共享相同的地址空间。</p>
<h2 id="6-多线程比单线程的优势，劣势？"><a href="#6-多线程比单线程的优势，劣势？" class="headerlink" title="6# 多线程比单线程的优势，劣势？"></a>6# 多线程比单线程的优势，劣势？</h2><ul>
<li>多线程比单线程的<strong>优势</strong>：提高程序的运行效率，可以充分利用多核处理器的资源，同时处理多个任务，加快程序的执行速度。</li>
<li>多线程比单线程的<strong>劣势</strong>：存在多线程数据竞争访问的问题，需要通过锁机制来保证线程安全，增加了加锁的开销，并且还会有死锁的风险。多线程会消耗更多系统资源，如CPU和内存，因为每个线程都需要占用一定的内存和处理时间。</li>
</ul>
<h2 id="7-多线程是不是越多越好，太多会有什么问题？"><a href="#7-多线程是不是越多越好，太多会有什么问题？" class="headerlink" title="7# 多线程是不是越多越好，太多会有什么问题？"></a>7# 多线程是不是越多越好，太多会有什么问题？</h2><p>多线程不一定越多越好，过多的线程可能会导致一些问题。</p>
<ul>
<li>切换开销：线程的创建和切换会消耗系统资源，包括内存和CPU。如果创建太多线程，会占用大量的系统资源，导致系统负载过高，某个线程崩溃后，可能会导致进程崩溃。</li>
<li>死锁的问题：过多的线程可能会导致竞争条件和死锁。竞争条件指的是多个线程同时访问和修改共享资源，如果没有合适的同步机制，可能会导致数据不一致或错误的结果。而死锁则是指多个线程相互等待对方释放资源，导致程序无法继续执行。</li>
</ul>
<h2 id="8-进程切换和线程切换的区别？"><a href="#8-进程切换和线程切换的区别？" class="headerlink" title="8# 进程切换和线程切换的区别？"></a>8# 进程切换和线程切换的区别？</h2><ol>
<li>进程切换：进程切换涉及到更多的内容，包括整个进程的地址空间、全局变量、文件描述符等。因此，进程切换的开销通常比线程切换大。</li>
<li>线程切换：线程切换只涉及到线程的堆栈、寄存器和程序计数器等，不涉及进程级别的资源，因此线程切换的开销较小。</li>
</ol>
<h2 id="9-线程切换为什么比进程切换快，节省了什么资源？"><a href="#9-线程切换为什么比进程切换快，节省了什么资源？" class="headerlink" title="9# 线程切换为什么比进程切换快，节省了什么资源？"></a>9# 线程切换为什么比进程切换快，节省了什么资源？</h2><p>线程切换比进程切换快是因为线程共享同一进程的地址空间和资源，线程切换时只需切换堆栈和程序计数器等少量信息，而不需要切换地址空间，避免了进程切换时需要切换内存映射表等大量资源的开销，从而节省了时间和系统资源。</p>
<h2 id="10-线程切换详细过程是怎么样的？上下文保存在哪里？"><a href="#10-线程切换详细过程是怎么样的？上下文保存在哪里？" class="headerlink" title="10# 线程切换详细过程是怎么样的？上下文保存在哪里？"></a>10# 线程切换详细过程是怎么样的？上下文保存在哪里？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725233216165.png" alt="image-20240725233216165"></p>
<p>线程切换的详细过程可以分为以下几个步骤：</p>
<ul>
<li>上下文保存：当操作系统决定切换到另一个线程时，它首先会保存当前线程的上下文信息。上下文信息包括寄存器状态、程序计数器、堆栈指针等，用于保存线程的执行状态。</li>
<li>切换到调度器：操作系统将执行权切换到调度器（Scheduler）。调度器负责选择下一个要执行的线程，并根据调度算法做出决策。</li>
<li>上下文恢复：调度器选择了下一个要执行的线程后，它会从该线程保存的上下文信息中恢复线程的执行状态。</li>
<li>切换到新线程：调度器将执行权切换到新线程，使其开始执行。</li>
</ul>
<p>上下文信息的保存通常由操作系统负责管理，具体保存在哪里取决于操作系统的实现方式。一般情况下，上下文信息会保存在线程的控制块（Thread Control Block，TCB）中。</p>
<p>TCB是操作系统用于管理线程的数据结构，包含了线程的状态、寄存器的值、堆栈信息等。当发生线程切换时，操作系统会通过切换TCB来保存和恢复线程的上下文信息。</p>
<h2 id="11-进程的状态（五种状态），如何切换？"><a href="#11-进程的状态（五种状态），如何切换？" class="headerlink" title="11# 进程的状态（五种状态），如何切换？"></a>11# 进程的状态（五种状态），如何切换？</h2><p>一个完整的进程状态的变迁如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1715669823633-dcd21d9d-1bc9-44b0-b708-7afda68c2257.webp" alt="img"></p>
<p>进程五种状态的变迁</p>
<p>再来详细说明一下进程的状态变迁：</p>
<ul>
<li><em>NULL -&gt; 创建状态</em>：一个新进程被创建时的第一个状态；</li>
<li><em>创建状态 -&gt; 就绪状态</em>：当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态，这个过程是很快的；</li>
<li><em>就绪态 -&gt; 运行状态</em>：处于就绪状态的进程被操作系统的进程调度器选中后，就分配给 CPU 正式运行该进程；</li>
<li><em>运行状态 -&gt; 结束状态</em>：当进程已经运行完成或出错时，会被操作系统作结束状态处理；</li>
<li><em>运行状态 -&gt; 就绪状态</em>：处于运行状态的进程在运行过程中，由于分配给它的运行时间片用完，操作系统会把该进程变为就绪态，接着从就绪态选中另外一个进程运行；</li>
<li><em>运行状态 -&gt; 阻塞状态</em>：当进程请求某个事件且必须等待时，例如请求 I&#x2F;O 事件；</li>
<li><em>阻塞状态 -&gt; 就绪状态</em>：当进程要等待的事件完成时，它从阻塞状态变到就绪状态；</li>
</ul>
<h2 id="12-进程上下文有哪些？"><a href="#12-进程上下文有哪些？" class="headerlink" title="12# 进程上下文有哪些？"></a>12# 进程上下文有哪些？</h2><p>各个进程之间是共享 CPU 资源的，在不同的时候进程之间需要切换，让不同的进程可以在 CPU 执行，那么这个<strong>一个进程切换到另一个进程运行，称为进程的上下文切换</strong>。</p>
<p>在详细说进程上下文切换前，我们先来看看 CPU 上下文切换</p>
<p>大多数操作系统都是多任务，通常支持大于 CPU 数量的任务同时运行。实际上，这些任务并不是同时运行的，只是因为系统在很短的时间内，让各个任务分别在 CPU 运行，于是就造成同时运行的错觉。</p>
<p>任务是交给 CPU 运行的，那么在每个任务运行前，CPU 需要知道任务从哪里加载，又从哪里开始运行。</p>
<p>所以，操作系统需要事先帮 CPU 设置好 <strong>CPU 寄存器和程序计数器</strong>。</p>
<p>CPU 寄存器是 CPU 内部一个容量小，但是速度极快的内存（缓存）。我举个例子，寄存器像是你的口袋，内存像你的书包，硬盘则是你家里的柜子，如果你的东西存放到口袋，那肯定是比你从书包或家里柜子取出来要快的多。</p>
<p>再来，程序计数器则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。</p>
<p>所以说，CPU 寄存器和程序计数是 CPU 在运行任何任务前，所必须依赖的环境，这些环境就叫做 <strong>CPU 上下文</strong>。</p>
<p>既然知道了什么是 CPU 上下文，那理解 CPU 上下文切换就不难了。</p>
<p>CPU 上下文切换就是先把前一个任务的 CPU 上下文（CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。</p>
<p>系统内核会存储保持下来的上下文信息，当此任务再次被分配给 CPU 运行时，CPU 会重新加载这些上下文，这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行.</p>
<p>上面说到所谓的「任务」，主要包含进程、线程和中断。所以，可以根据任务的不同，把 CPU 上下文切换分成：<strong>进程上下文切换、线程上下文切换和中断上下文切换</strong>。</p>
<blockquote>
<p>进程的上下文切换到底是切换什么呢？</p>
</blockquote>
<p>进程是由内核管理和调度的，所以进程的切换只能发生在内核态。</p>
<p>所以，<strong>进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。</strong></p>
<p>通常，会把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行，如下图所示：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1716198523841-10806f3d-3435-4a43-ac75-c8d046fb5c32.png" alt="img"></p>
<p>大家需要注意，进程的上下文开销是很关键的，我们希望它的开销越小越好，这样可以使得进程可以把更多时间花费在执行程序上，而不是耗费在上下文切换。</p>
<h2 id="13-进程间通讯有哪些方式？"><a href="#13-进程间通讯有哪些方式？" class="headerlink" title="13# 进程间通讯有哪些方式？"></a>13# 进程间通讯有哪些方式？</h2><p>Linux 内核提供了不少进程间通信的方式：</p>
<ul>
<li>管道</li>
<li>消息队列</li>
<li>共享内存</li>
<li>信号</li>
<li>信号量</li>
<li>socket</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/29791029/1719917324151-68127780-6ba6-4215-ba29-a13917011c64.png" alt="img"></p>
<p>Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。</p>
<p><strong>匿名管道</strong>顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「|」竖线就是匿名管道，通信的数据是<strong>无格式的流并且大小受限</strong>，通信的方式是<strong>单向</strong>的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来<strong>匿名管道是只能用于存在父子关系的进程间通信</strong>，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。</p>
<p><strong>命名管道</strong>突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是<strong>缓存在内核</strong>中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</p>
<p><strong>消息队列</strong>克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟<strong>每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。</strong></p>
<p><strong>共享内存</strong>可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，<strong>它直接分配一个共享空间，每个进程都可以直接访问</strong>，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有<strong>最快</strong>的进程间通信方式之名。但是便捷高效的共享内存通信，<strong>带来新的问题，多进程竞争同个共享资源会造成数据的错乱。</strong></p>
<p>那么，就需要<strong>信号量</strong>来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。<strong>信号量不仅可以实现访问的互斥性，还可以实现进程间的同步</strong>，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 <strong>P 操作和 V 操作</strong>。</p>
<p>与信号量名字很相似的叫<strong>信号</strong>，它俩名字虽然相似，但功能一点儿都不一样。信号是<strong>异步通信机制</strong>，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，<strong>进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号</strong>。有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SIGSTOP，这是为了方便我们能在任何时候结束或停止某个进程。</p>
<p>前面说到的通信机制，都是工作于同一台主机，如果<strong>要与不同主机的进程间通信，那么就需要 Socket 通信了</strong>。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。</p>
<h2 id="14-管道有几种方式？"><a href="#14-管道有几种方式？" class="headerlink" title="14# 管道有几种方式？"></a>14# 管道有几种方式？</h2><p>管道在Linux中有两种方式：匿名管道和命名管道。</p>
<ul>
<li>匿名管道：是一种在父子进程或者兄弟进程之间进行通信的机制，只能用于具有亲缘关系的进程间通信，通常通过pipe系统调用创建。</li>
<li>命名管道：是一种允许无关的进程间进行通信的机制，基于文件系统，可以在不相关的进程之间进行通信。</li>
</ul>
<h2 id="15-信号和信号量有什么区别？"><a href="#15-信号和信号量有什么区别？" class="headerlink" title="15# 信号和信号量有什么区别？"></a>15# 信号和信号量有什么区别？</h2><ul>
<li>信号：一种处理异步事件的方式。信号是比较复杂的通信方式，用于通知接收进程有某种事件发生，除了用于进程外，还可以发送信号给进程本身。</li>
<li>信号量：进程间通信处理同步互斥的机制。是在多线程环境下使用的一种设施，它负责协调各个线程，以保证它们能够正确，合理的使用公共资源。</li>
</ul>
<h2 id="16-共享内存怎么实现的？"><a href="#16-共享内存怎么实现的？" class="headerlink" title="16# 共享内存怎么实现的？"></a>16# 共享内存怎么实现的？</h2><p><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725233155798.png" alt="image-20240725233155798"></p>
<h2 id="17-线程间通讯有什么方式？"><a href="#17-线程间通讯有什么方式？" class="headerlink" title="17# 线程间通讯有什么方式？"></a>17# 线程间通讯有什么方式？</h2><p>Linux系统提供了五种用于线程通信的方式：<strong>互斥锁、读写锁、条件变量、自旋锁和信号量</strong>。</p>
<ul>
<li><strong>互斥锁（Mutex）</strong>：互斥量(mutex)从本质上说是一把锁，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量上的锁。对互斥量进行加锁以后，任何其他试图再次对互斥锁加锁的线程将会阻塞直到当前线程释放该互斥锁。如果释放互斥锁时有多个线程阻塞，所有在该互斥锁上的阻塞线程都会变成可运行状态，第一个变为运行状态的线程可以对互斥锁加锁，其他线程将会看到互斥锁依然被锁住，只能回去再次等待它重新变为可用。</li>
<li><strong>条件变量（Condition Variables）</strong>：条件变量(cond)是在多线程程序中用来实现”等待–》唤醒”逻辑常用的方法。条件变量利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待”条件变量的条件成立”而挂起；另一个线程使“条件成立”。为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。线程在改变条件状态前必须首先锁住互斥量，函数pthread_cond_wait把自己放到等待条件的线程列表上，然后对互斥锁解锁(这两个操作是原子操作)。在函数返回时，互斥量再次被锁住。</li>
<li><strong>自旋锁（Spinlock）</strong>：自旋锁通过 CPU 提供的 CAS 函数（<em>Compare And Swap</em>），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。一般加锁的过程，包含两个步骤：第一步，查看锁的状态，如果锁是空闲的，则执行第二步；第二步，将锁设置为当前线程持有；使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。CAS 函数就把这两个步骤合并成一条硬件级指令，形成<strong>原子指令</strong>，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。这里的「忙等待」可以用 while 循环等待实现，不过最好是使用 CPU 提供的 PAUSE 指令来实现「忙等待」，因为可以减少循环等待时的耗电量。</li>
<li><strong>信号量（Semaphores）</strong>：信号量可以是命名的（有名信号量）或无名的（仅限于当前进程内的线程），用于控制对资源的访问次数。通常<strong>信号量表示资源的数量</strong>，对应的变量是一个整型（sem）变量。另外，还有<strong>两个原子操作的系统调用函数来控制信号量的</strong>，分别是：<em>P 操作</em>：将 sem 减 1，相减后，如果 sem &lt; 0，则进程&#x2F;线程进入阻塞等待，否则继续，表明 P 操作可能会阻塞；<em>V 操作</em>：将 sem 加 1，相加后，如果 sem &lt;&#x3D; 0，唤醒一个等待中的进程&#x2F;线程，表明 V 操作不会阻塞；</li>
<li><strong>读写锁（Read-Write Locks）</strong>：读写锁从字面意思我们也可以知道，它由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。所以，<strong>读写锁适用于能明确区分读操作和写操作的场景</strong>。读写锁的工作原理是：当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。所以说，写锁是独占锁，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁，而读锁是共享锁，因为读锁可以被多个线程同时持有。知道了读写锁的工作原理后，我们可以发现，<strong>读写锁在读多写少的场景，能发挥出优势</strong>。</li>
</ul>
<h2 id="18-进程调度算法有哪些？"><a href="#18-进程调度算法有哪些？" class="headerlink" title="18# 进程调度算法有哪些？"></a>18# 进程调度算法有哪些？</h2><blockquote>
<p>先来先服务调度算法</p>
</blockquote>
<p>最简单的一个调度算法，就是非抢占式的<strong>先来先服务（*First Come First Severd, FCFS*）算法</strong>了。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1720958097438-d2dccfb8-bd9b-4556-86a3-2cb8d6c370f1.png" alt="img"> 顾名思义，先来后到，<strong>每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</strong></p>
<p>这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。 FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I&#x2F;O 繁忙型作业的系统。</p>
<blockquote>
<p>最短作业优先调度算法</p>
</blockquote>
<p><strong>最短作业优先（*Shortest Job First, SJF*）调度算法</strong>同样也是顾名思义，它会<strong>优先选择运行时间最短的进程来运行</strong>，这有助于提高系统的吞吐量。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1720958113844-46b5799d-6ebf-4f91-8924-d9744e9895d1.png" alt="img"></p>
<p>这显然对长作业不利，很容易造成一种极端现象。</p>
<p>比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。</p>
<blockquote>
<p>高响应比优先调度算法</p>
</blockquote>
<p>前面的「先来先服务调度算法」和「最短作业优先调度算法」都没有很好的权衡短作业和长作业。</p>
<p>那么，<strong>高响应比优先 （*Highest Response Ratio Next, HRRN*）调度算法</strong>主要是权衡了短作业和长作业。</p>
<p><strong>每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行</strong>，「响应比优先级」的计算公式：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1720958126833-a4591dd3-4c82-4c06-be20-cb8682cd5b5a.png" alt="img"></p>
<p>从上面的公式，可以发现：</p>
<ul>
<li>如果两个进程的「等待时间」相同时，「要求的服务时间」越短，「响应比」就越高，这样短作业的进程容易被选中运行；</li>
<li>如果两个进程「要求的服务时间」相同时，「等待时间」越长，「响应比」就越高，这就兼顾到了长作业进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会；</li>
</ul>
<blockquote>
<p>时间片轮转调度算法</p>
</blockquote>
<p>最古老、最简单、最公平且使用最广的算法就是<strong>时间片轮转（*Round Robin, RR*）调度算法</strong>。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1720958138354-bb990348-3374-4239-8aa6-bd3b3737b5ea.png" alt="image.png"> <strong>每个进程被分配一个时间段，称为时间片（*Quantum*)，即允许该进程在该时间段中运行。</strong></p>
<ul>
<li>如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程；</li>
<li>如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；</li>
</ul>
<p>另外，时间片的长度就是一个很关键的点：</p>
<ul>
<li>如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；</li>
<li>如果设得太长又可能引起对短作业进程的响应时间变长。将</li>
</ul>
<p>通常时间片设为 <code>20ms~50ms</code> 通常是一个比较合理的折中值。</p>
<blockquote>
<p>最高优先级调度算法</p>
</blockquote>
<p>前面的「时间片轮转算法」做了个假设，即让所有的进程同等重要，也不偏袒谁，大家的运行时间都一样。</p>
<p>但是，对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能<strong>从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（*Highest Priority First，HPF*）调度算法</strong>。 进程的优先级可以分为，静态优先级或动态优先级：</p>
<ul>
<li>静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；</li>
<li>动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是<strong>随着时间的推移增加等待进程的优先级</strong>。</li>
</ul>
<p>该算法也有两种处理优先级高的方法，非抢占式和抢占式：</p>
<ul>
<li>非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。</li>
<li>抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。</li>
</ul>
<p>但是依然有缺点，可能会导致低优先级的进程永远不会运行。</p>
<blockquote>
<p>多级反馈队列调度算法</p>
</blockquote>
<p><strong>多级反馈队列（*Multilevel Feedback Queue*）调度算法</strong>是「时间片轮转算法」和「最高优先级算法」的综合和发展。</p>
<p>顾名思义：</p>
<ul>
<li>「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。</li>
<li>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com//picgo/1720958157105-0947c14a-f422-464a-9294-7cf5ef8a23bd.png" alt="img"> 来看看，它是如何工作的：</p>
<ul>
<li>设置了多个队列，赋予每个队列不同的优先级，每个<strong>队列优先级从高到低</strong>，同时<strong>优先级越高时间片越短</strong>；</li>
<li>新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；</li>
<li>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；</li>
</ul>
<p>可以发现，对于短作业可能可以在第一级队列很快被处理完。</p>
<p>对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了，所以该算法很好的<strong>兼顾了长短作业，同时有较好的响应时间。</strong></p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="1-除了互斥锁你还知道什么锁？分别应用于什么场景？"><a href="#1-除了互斥锁你还知道什么锁？分别应用于什么场景？" class="headerlink" title="1# 除了互斥锁你还知道什么锁？分别应用于什么场景？"></a>1# 除了互斥锁你还知道什么锁？分别应用于什么场景？</h2><p>还有读写锁、自旋锁、条件变量、信号量。</p>
<ol>
<li>读写锁：读写锁允许多个线程同时读取共享资源，但只允许一个线程进行写操作。适用于读操作频繁、写操作较少的场景，可以提高并发性能。</li>
<li>自旋锁：自旋锁是一种忙等待锁，线程在获取锁时不会进入阻塞状态，而是循环忙等待直到获取到锁。适用于临界区很小且锁的持有时间很短的场景，避免线程频繁切换带来的开销。</li>
<li>条件变量：条件变量用于线程间的同步和通信。它通常与互斥锁一起使用，线程可以通过条件变量等待某个条件满足，当条件满足时，其他线程可以通过条件变量发送信号通知等待线程。</li>
<li>信号量：信号量是一种计数器，用于控制对共享资源的访问。它可以用来限制同时访问资源的线程数量，或者用于线程间的同步。</li>
</ol>
<h2 id="2-为什么并发执行线程要加锁？"><a href="#2-为什么并发执行线程要加锁？" class="headerlink" title="2# 为什么并发执行线程要加锁？"></a>2# 为什么并发执行线程要加锁？</h2><p>并发执行线程需要加锁主要是为了保护共享数据，防止出现”竞态条件”。</p>
<p>“竞态条件”是指当多个线程同时访问和操作同一块数据时，最终结果依赖于线程的执行顺序，这可能导致数据的不一致性。</p>
<p>通过加锁，我们可以确保在任何时刻只有一个线程能够访问共享数据，从而避免”竞态条件”，确保数据的一致性和完整性。</p>
<h2 id="3-自旋锁是什么？应用在哪些场景？"><a href="#3-自旋锁是什么？应用在哪些场景？" class="headerlink" title="3# 自旋锁是什么？应用在哪些场景？"></a>3# 自旋锁是什么？应用在哪些场景？</h2><p><strong>自旋锁</strong>加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁。</p>
<p>自旋锁是通过 CPU 提供的 <code>CAS</code> 函数（<em>Compare And Swap</em>），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。</p>
<p>一般加锁的过程，包含两个步骤：</p>
<ul>
<li>第一步，查看锁的状态，如果锁是空闲的，则执行第二步；</li>
<li>第二步，将锁设置为当前线程持有；</li>
</ul>
<p>CAS 函数就把这两个步骤合并成一条硬件级指令，形成<strong>原子指令</strong>，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。</p>
<p>比如，设锁为变量 lock，整数 0 表示锁是空闲状态，整数 pid 表示线程 ID，那么 CAS(lock, 0, pid) 就表示自旋锁的加锁操作，CAS(lock, pid, 0) 则表示解锁操作。</p>
<p>使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用 <code>while</code> 循环等待实现，不过最好是使用 CPU 提供的 <code>PAUSE</code> 指令来实现「忙等待」，因为可以减少循环等待时的耗电量。</p>
<p>自旋锁是最比较简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。<strong>需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。</strong></p>
<p>自旋锁开销少，在多核系统下一般不会主动产生线程切换，适合异步、协程等在用户态切换请求的编程方式，但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，所以自旋的时间和被锁住的代码执行的时间是成「正比」的关系，我们需要清楚的知道这一点。</p>
<p>自旋锁与互斥锁使用层面比较相似，但实现层面上完全不同：<strong>当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对</strong>。</p>
<p><strong>如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。</strong></p>
<h2 id="4-死锁发生条件是什么？"><a href="#4-死锁发生条件是什么？" class="headerlink" title="4# 死锁发生条件是什么？"></a>4# 死锁发生条件是什么？</h2><p>死锁只有<strong>同时满足</strong>以下四个条件才会发生：</p>
<ul>
<li>互斥条件：互斥条件是指<strong>多个线程不能同时使用同一个资源</strong>。</li>
<li>持有并等待条件：持有并等待条件是指，当线程 A 已经持有了资源 1，又想申请资源 2，而资源 2 已经被线程 C 持有了，所以线程 A 就会处于等待状态，但是<strong>线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1</strong>。</li>
<li>不可剥夺条件：不可剥夺条件是指，当线程已经持有了资源 ，<strong>在自己使用完之前不能被其他线程获取</strong>，线程 B 如果也想使用此资源，则只能在线程 A 使用完并释放后才能获取。</li>
<li>环路等待条件：环路等待条件指的是，在死锁发生的时候，<strong>两个线程获取资源的顺序构成了环形链</strong>。</li>
</ul>
<h2 id="5-如何避免死锁？"><a href="#5-如何避免死锁？" class="headerlink" title="5# 如何避免死锁？"></a>5# 如何避免死锁？</h2><p>避免死锁问题就只需要破环其中一个条件就可以，最常见的并且可行的就是<strong>使用资源有序分配法，来破环环路等待条件</strong>。</p>
<p>那什么是资源有序分配法呢？线程 A 和 线程 B 获取资源的顺序要一样，当线程 A 是先尝试获取资源 A，然后尝试获取资源 B 的时候，线程 B 同样也是先尝试获取资源 A，然后尝试获取资源 B。也就是说，线程 A 和 线程 B 总是以相同的顺序申请自己想要的资源。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1719563137049-4306fda2-ca9f-4183-b885-2499eb7570dc.webp" alt="img"></p>
<h2 id="6-讲一下银行家算法"><a href="#6-讲一下银行家算法" class="headerlink" title="6# 讲一下银行家算法"></a>6# 讲一下银行家算法</h2><p>系统发生死锁是很正常的，我们需要主动去预防死锁，即进行有序的资源分配，使用<strong>银行家算法</strong>。</p>
<p><strong>银行家算法是最有代表性的避免死锁的算法</strong>。</p>
<p>为什么叫银行家算法呢？就是这个算法的逻辑<strong>很像银行放贷的逻辑，也就是尽可能避免坏账的出现</strong>。</p>
<p>银行家算法的业务逻辑如下。</p>
<ul>
<li><strong>不负荷执行</strong>：一个进程的最大需求量不超过系统拥有的总资源数，才会被接纳执行。</li>
<li><strong>可分期</strong>：一个进程可以分期请求资源，但总请求书不可超过最大需求量。</li>
<li><strong>推迟分配</strong>：当系统现有资源数小于进程需求时，对进程的需求可以延迟分配，但总让进程在有限时间内获取资源。</li>
</ul>
<p>听起来有点绕，我们还是举个例子来说明。</p>
<p>假如系统中有三类互斥资源 R1、R2、R3，可用资源数分别是 9、8、5，在指定时刻有 P1、P2、P3、P4 和 P5 这五个进程，这些进程的对三类互斥资源的最大需求量和已分配资源数如下表所示，那么系统如何先后运行这五个进程，不会发生死锁问题？</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>最大需求量（分别为R1 R2 R3）</th>
<th>已分配资源数（分别为R1 R2 R3）</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>6 5 2</td>
<td>1 2 1</td>
</tr>
<tr>
<td>P2</td>
<td>2 2 1</td>
<td>2 1 1</td>
</tr>
<tr>
<td>P3</td>
<td>8 1 1</td>
<td>2 1 0</td>
</tr>
<tr>
<td>P4</td>
<td>1 2 1</td>
<td>1 2 0</td>
</tr>
<tr>
<td>P5</td>
<td>3 4 4</td>
<td>1 1 3</td>
</tr>
</tbody></table>
<hr>
<p>第一步：分析</p>
<p>首先分析首次需求的资源，<strong>系统剩余可用资源数分别是 2、1、0</strong>，各进程需要的资源数如下表所示。</p>
<p>资源 R1 的剩余可用资源数 &#x3D; 9 - 1 - 2 - 2 - 1 - 1 &#x3D; 2。</p>
<p>资源 R2 的剩余可用资源数 &#x3D; 8 - 2 - 1 - 1 - 2 - 1 &#x3D; 1。</p>
<p>资源 R3 的剩余可用资源数 &#x3D; 5 - 1 - 1 - 0 - 0 - 3 &#x3D; 0。</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>最大需求量</th>
<th>已分配资源数</th>
<th>首次分配需要的资源数</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>6 5 2</td>
<td>1 2 1</td>
<td>5 3 1</td>
</tr>
<tr>
<td>P2</td>
<td>2 2 1</td>
<td>2 1 1</td>
<td>0 1 0</td>
</tr>
<tr>
<td>P3</td>
<td>8 1 1</td>
<td>2 1 0</td>
<td>6 0 1</td>
</tr>
<tr>
<td>P4</td>
<td>1 2 1</td>
<td>1 2 0</td>
<td>0 0 1</td>
</tr>
<tr>
<td>P5</td>
<td>3 4 4</td>
<td>1 1 3</td>
<td>2 3 1</td>
</tr>
</tbody></table>
<p>根据银行家算法<strong>不负荷</strong>原则【一个进程的最大需求量不超过系统拥有的总资源数，才会被接纳执行】，优先给进程 P2 执行，因为剩余的 0 1 0 资源够让 P2 执行。</p>
<p>第二步：执行 P2</p>
<p>P2 执行之后，释放了刚刚放入的 2 1 0 资源，而且可以释放已分配的 2 1 1 资源，所以此时的资源剩余量。</p>
<p>资源 R1 的剩余可用资源数 &#x3D; 原资源数 - 执行 P2 消耗数 + P2 执行完释放的资源数 &#x3D; 2 - 0 +（2 + 0） &#x3D; 4。</p>
<p>资源 R2 的剩余可用资源数 &#x3D; 原资源数 - 执行 P2 消耗数 + P2 执行完释放的资源数 &#x3D; 1 - 1 + （1 + 1） &#x3D; 2。</p>
<p>资源 R3 的剩余可用资源数 &#x3D; 原资源数 - 执行 P2 消耗数 + P2 执行完释放的资源数 &#x3D; 0 - 0 +（0 + 1） &#x3D; 1。</p>
<p><strong>执行完成 P2 后，操作系统剩余可用资源数为 4 2 1</strong>。</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>最大需求量</th>
<th>已分配资源数</th>
<th>第二次分配需要的资源数</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>6 5 2</td>
<td>1 2 1</td>
<td>5 3 1</td>
</tr>
<tr>
<td>P2</td>
<td>完成</td>
<td>完成</td>
<td>完成</td>
</tr>
<tr>
<td>P3</td>
<td>8 1 1</td>
<td>2 1 0</td>
<td>6 0 1</td>
</tr>
<tr>
<td>P4</td>
<td>1 2 1</td>
<td>1 2 0</td>
<td>0 0 1</td>
</tr>
<tr>
<td>P5</td>
<td>3 4 4</td>
<td>1 1 3</td>
<td>2 3 1</td>
</tr>
</tbody></table>
<hr>
<p>第三步：执行 P4</p>
<p>此时操作系统剩余可用资源数为 4 2 1，只能执行进程 P4，因为其他进程资源不够。</p>
<p>P4 执行之后，释放了刚刚放入的 0 0 1 资源，而且可以释放已分配的 1 2 1 资源，所以此时的资源剩余量。</p>
<p>资源 R1 的剩余可用资源数 &#x3D; 原资源数 - 执行 P4 消耗数 + P4 执行完释放的资源数 &#x3D; 4 - 0 +（1 + 0） &#x3D; 5。</p>
<p>资源 R2 的剩余可用资源数 &#x3D; 原资源数 - 执行 P4 消耗数 + P4 执行完释放的资源数 &#x3D; 2 - 0 + （2 + 0） &#x3D; 4。</p>
<p>资源 R3 的剩余可用资源数 &#x3D; 原资源数 - 执行 P4 消耗数 + P4 执行完释放的资源数 &#x3D; 1 - 1 +（0 + 1） &#x3D; 1。</p>
<p><strong>执行完成 P4 后，操作系统剩余可用资源数为 5 4 1</strong>。</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>最大需求量</th>
<th>已分配资源数</th>
<th>第三次分配需要的资源数</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>6 5 2</td>
<td>1 2 1</td>
<td>5 3 1</td>
</tr>
<tr>
<td>P2</td>
<td>完成</td>
<td>完成</td>
<td>完成</td>
</tr>
<tr>
<td>P3</td>
<td>8 1 1</td>
<td>2 1 0</td>
<td>6 0 1</td>
</tr>
<tr>
<td>P4</td>
<td>完成</td>
<td>完成</td>
<td>完成</td>
</tr>
<tr>
<td>P5</td>
<td>3 4 4</td>
<td>1 1 3</td>
<td>2 3 1</td>
</tr>
</tbody></table>
<hr>
<p>第四步：执行 P5</p>
<p>此时操作系统剩余可用资源数为 5 4 1，只能执行进程 P5，因为其他进程资源不够。</p>
<p>P5 执行之后，释放了刚刚放入的 2 3 1 资源，而且可以释放已分配的 1 1 3 资源，所以此时的资源剩余量。</p>
<p>资源 R1 的剩余可用资源数 &#x3D; 原资源数 - 执行 P5 消耗数 + P5 执行完释放的资源数 &#x3D; 5 - 2 +（1 + 2） &#x3D; 6。</p>
<p>资源 R2 的剩余可用资源数 &#x3D; 原资源数 - 执行 P5 消耗数 + P5 执行完释放的资源数 &#x3D; 4 - 3 + （1 + 3） &#x3D; 5。</p>
<p>资源 R3 的剩余可用资源数 &#x3D; 原资源数 - 执行 P5 消耗数 + P5 执行完释放的资源数 &#x3D; 1 - 1 +（3 + 1） &#x3D; 4。</p>
<p><strong>执行完成 P5 后，操作系统剩余可用资源数为 6 5 4</strong>。</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>最大需求量</th>
<th>已分配资源数</th>
<th>第三次分配需要的资源数</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>6 5 2</td>
<td>1 2 1</td>
<td>5 3 1</td>
</tr>
<tr>
<td>P2</td>
<td>完成</td>
<td>完成</td>
<td>完成</td>
</tr>
<tr>
<td>P3</td>
<td>8 1 1</td>
<td>2 1 0</td>
<td>6 0 1</td>
</tr>
<tr>
<td>P4</td>
<td>完成</td>
<td>完成</td>
<td>完成</td>
</tr>
<tr>
<td>P5</td>
<td>完成</td>
<td>完成</td>
<td>完成</td>
</tr>
</tbody></table>
<hr>
<p>第五步：执行 P1 或者 P3</p>
<p>此时操作系统剩余可用资源数为 6 5 4，可以执行 P1 或 P3。</p>
<p>所以安全执行顺序为 <strong>p2 &#x3D;&gt; p4 &#x3D;&gt; p5 &#x3D;&gt; p1 &#x3D;&gt; p3</strong> 或 <strong>p2 &#x3D;&gt; p4 &#x3D;&gt; p5 &#x3D;&gt; p3 &#x3D;&gt; p1</strong>。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1720434387769-ee64c523-a971-46d4-8b59-00aac021b19f.png" alt="img"></p>
<p>或</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1720434387791-d1aa6916-6457-41e8-a356-1ebdec1538b0.png" alt="img"></p>
<p>银行家算法总结</p>
<p>银行家算法的核心思想，就是在<strong>分配给进程资源前，首先判断这个进程的安全性</strong>，也就是预执行，判断分配后是否产生死锁现象。如果系统当前资源能满足其执行，则尝试分配，如果不满足则让该进程等待。</p>
<p><strong>通过不断检查剩余可用资源是否满足某个进程的最大需求，如果可以则加入安全序列，并把该进程当前持有的资源回收；不断重复这个过程，看最后能否实现让所有进程都加入安全序列</strong>。安全序列一定不会发生死锁，但没有死锁不一定是安全序列。</p>
<h2 id="7-乐观锁和悲观锁有什么区别？"><a href="#7-乐观锁和悲观锁有什么区别？" class="headerlink" title="7# 乐观锁和悲观锁有什么区别？"></a>7# 乐观锁和悲观锁有什么区别？</h2><p>乐观锁：</p>
<ul>
<li>基本思想：乐观锁假设多个事务之间很少发生冲突，因此在读取数据时不会加锁，而是在更新数据时检查数据的版本（如使用版本号或时间戳），如果版本匹配则执行更新操作，否则认为发生了冲突。</li>
<li>使用场景：乐观锁适用于读多写少的场景，可以减少锁的竞争，提高并发性能。例如，数据库中的乐观锁机制可以用于处理并发更新同一行数据的情况。</li>
</ul>
<p>悲观锁：</p>
<ul>
<li>基本思想：悲观锁假设多个事务之间会频繁发生冲突，因此在读取数据时会加锁，防止其他事务对数据进行修改，直到当前事务完成操作后才释放锁。</li>
<li>使用场景：悲观锁适用于写多的场景，通过加锁保证数据的一致性。例如，数据库中的行级锁机制可以用于处理并发更新同一行数据的情况。</li>
</ul>
<p>乐观锁适用于读多写少的场景，通过版本控制来处理冲突；而悲观锁适用于写多的场景，通过加锁来避免冲突。</p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="1-介绍一下操作系统内存管理"><a href="#1-介绍一下操作系统内存管理" class="headerlink" title="1# 介绍一下操作系统内存管理"></a>1# 介绍一下操作系统内存管理</h2><p>操作系统设计了虚拟内存，每个进程都有自己的独立的虚拟内存，我们所写的程序不会直接与物理内打交道。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1719563032415-395220b4-ef7f-42b3-95c2-d7b6d7e0e6bc.png" alt="img"></p>
<p>有了虚拟内存之后，它带来了这些好处：</p>
<ul>
<li>第一，虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。</li>
<li>第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。</li>
<li>第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。</li>
</ul>
<p>Linux 是通过对内存分页的方式来管理内存，<strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</strong>。这样一个连续并且尺寸固定的内存空间，我们叫<strong>页</strong>（<em>Page</em>）。在 Linux 下，每一页的大小为 4KB。</p>
<p>虚拟地址与物理地址之间通过<strong>页表</strong>来映射，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1719563019798-1c61454f-5b12-4400-8a62-70d32f3f5ed4.png" alt="img"></p>
<p>页表是存储在内存里的，<strong>内存管理单元</strong> （<em>MMU</em>）就做将虚拟内存地址转换成物理地址的工作。</p>
<p>而当进程访问的虚拟地址在页表中查不到时，系统会产生一个<strong>缺页异常</strong>，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p>
<h2 id="2-什么是虚拟内存和物理内存？"><a href="#2-什么是虚拟内存和物理内存？" class="headerlink" title="2# 什么是虚拟内存和物理内存？"></a>2# 什么是虚拟内存和物理内存？</h2><ul>
<li>虚拟内存：是操作系统提供给每个运行中程序的一种地址空间，每个程序在运行时认为自己拥有的内存空间就是虚拟内存，其大小可以远远大于物理内存的大小。虚拟内存通过将程序的地址空间划分成若干个固定大小的页或段，并将这些页或者段映射到物理内存中的不同位置，从而使得程序在运行时可以更高效地利用物理内存。</li>
<li>物理内存：物理内存是计算机实际存在的内存，是计算机中的实际硬件部件。</li>
</ul>
<h2 id="3-讲一下页表？"><a href="#3-讲一下页表？" class="headerlink" title="3# 讲一下页表？"></a>3# 讲一下页表？</h2><p><strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</strong>。这样一个连续并且尺寸固定的内存空间，我们叫<strong>页</strong>（<em>Page</em>）。在 Linux 下，每一页的大小为 4KB。</p>
<p>虚拟地址与物理地址之间通过<strong>页表</strong>来映射，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1720434118047-14f427b4-9a01-4c53-abc9-0538e8a678ac.png" alt="img"></p>
<p>页表是存储在内存里的，<strong>内存管理单元</strong> （<em>MMU</em>）就做将虚拟内存地址转换成物理地址的工作。</p>
<p>而当进程访问的虚拟地址在页表中查不到时，系统会产生一个<strong>缺页异常</strong>，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p>
<p>内存分页由于内存空间都是预先划分好的，也就不会像内存分段一样，在段与段之间会产生间隙非常小的内存，这正是分段会产生外部内存碎片的原因。而<strong>采用了分页，页与页之间是紧密排列的，所以不会有外部碎片。</strong></p>
<p>但是，因为内存分页机制分配内存的最小单位是一页，即使程序不足一页大小，我们最少只能分配一个页，所以页内会出现内存浪费，所以针对<strong>内存分页机制会有内部内存碎片</strong>的现象。</p>
<p>在分页机制下，虚拟地址分为两部分，<strong>页号</strong>和<strong>页内偏移</strong>。页号作为页表的索引，<strong>页表</strong>包含物理页每页所在<strong>物理内存的基地址</strong>，这个基地址与页内偏移的组合就形成了物理内存地址，见下图。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1720434118095-d8674984-2006-4e28-8e41-bb487f8f559c.png" alt="img"></p>
<p>总结一下，对于一个内存地址转换，其实就是这样三个步骤：</p>
<ul>
<li>把虚拟内存地址，切分成页号和偏移量；</li>
<li>根据页号，从页表里面，查询对应的物理页号；</li>
<li>直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。</li>
</ul>
<p>下面举个例子，虚拟内存中的页通过页表映射为了物理内存中的页，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1720434118251-03e976f1-2c76-4af6-a590-23638ff73fc6.png" alt="img"></p>
<h2 id="4-讲一下段表？"><a href="#4-讲一下段表？" class="headerlink" title="4# 讲一下段表？"></a>4# 讲一下段表？</h2><p>虚拟地址也可以通过<strong>段表</strong>与物理地址进行映射的，分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1719382894658-93df8273-d3a8-4b79-af8e-77ec0a2ce51e.png" alt="img"></p>
<p>如果要访问段 3 中偏移量 500 的虚拟地址，我们可以计算出物理地址为，段 3 基地址 7000 + 偏移量 500 &#x3D; 7500。</p>
<h2 id="5-虚拟地址是怎么转化到物理地址的？"><a href="#5-虚拟地址是怎么转化到物理地址的？" class="headerlink" title="5# 虚拟地址是怎么转化到物理地址的？"></a>5# 虚拟地址是怎么转化到物理地址的？</h2><p>虚拟地址转化为物理地址是通过内存管理单元（Memory Management Unit，MMU）来完成的。MMU是计算机系统中的硬件组件，负责虚拟地址和物理地址之间的转换。</p>
<p>在虚拟地址转换的过程中，通常会使用页表（Page Table）来进行映射。页表是一种数据结构，它将虚拟地址空间划分为固定大小的页（Page），对应于物理内存中的页框（Page Frame）。每个页表项（Page Table Entry）记录了虚拟页和物理页的对应关系。</p>
<p>当程序访问一个虚拟地址时，MMU会将虚拟地址分解为页号和页内偏移量。然后，MMU会查找页表，根据页号找到对应的页表项。页表项中包含了物理页的地址或页框号。最后，MMU将物理页的地址与页内偏移量组合，得到对应的物理地址。</p>
<p>虚拟地址转化为物理地址的过程中，还可能涉及到多级页表、TLB（Translation Lookaside Buffer）缓存等机制，以提高地址转换的效率。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725233041537.png" alt="image-20240725233041537"></p>
<h2 id="6-程序的内存布局是怎么样的？"><a href="#6-程序的内存布局是怎么样的？" class="headerlink" title="6# 程序的内存布局是怎么样的？"></a>6# 程序的内存布局是怎么样的？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725233029022.png" alt="image-20240725233029022"></p>
<p>通过这张图你可以看到，用户空间内存，从<strong>低到高</strong>分别是 6 种不同的内存段：</p>
<ul>
<li>代码段，包括二进制可执行代码；</li>
<li>数据段，包括已初始化的静态常量和全局变量；</li>
<li>BSS 段，包括未初始化的静态变量和全局变量；</li>
<li>堆段，包括动态分配的内存，从低地址开始向上增长；</li>
<li>文件映射段，包括动态库、共享内存等；</li>
<li>栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 <code>8 MB</code>。当然系统也提供了参数，以便我们自定义大小；</li>
</ul>
<p>上图中的内存布局可以看到，代码段下面还有一段内存空间的（灰色部分），这一块区域是「保留区」，之所以要有保留区这是因为在大多数的系统里，我们认为比较小数值的地址不是一个合法地址，例如，我们通常在 C 的代码里会将无效的指针赋值为 NULL。因此，这里会出现一段不可访问的内存保留区，防止程序因为出现 bug，导致读或写了一些小内存地址的数据，而使得程序跑飞。</p>
<p>在这 7 个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的 <code>malloc()</code> 或者 <code>mmap()</code> ，就可以分别在堆和文件映射段动态分配内存。</p>
<h2 id="7-堆和栈的区别？"><a href="#7-堆和栈的区别？" class="headerlink" title="7# 堆和栈的区别？"></a>7# 堆和栈的区别？</h2><ul>
<li><strong>分配方式</strong>：堆是动态分配内存，由程序员手动申请和释放内存，通常用于存储动态数据结构和对象。栈是静态分配内存，由编译器自动分配和释放内存，用于存储函数的局部变量和函数调用信息。</li>
<li><strong>内存管理</strong>：堆需要程序员手动管理内存的分配和释放，如果管理不当可能会导致内存泄漏或内存溢出。栈由编译器自动管理内存，遵循后进先出的原则，变量的生命周期由其作用域决定，函数调用时分配内存，函数返回时释放内存。</li>
<li><strong>大小和速度</strong>：堆通常比栈大，内存空间较大，动态分配和释放内存需要时间开销。栈大小有限，通常比较小，内存分配和释放速度较快，因为是编译器自动管理。</li>
</ul>
<h2 id="8-fork-会复制哪些东西？"><a href="#8-fork-会复制哪些东西？" class="headerlink" title="8# fork()会复制哪些东西？"></a>8# fork()会复制哪些东西？</h2><ul>
<li>fork 阶段会复制父进程的页表（虚拟内存）</li>
<li>fork 之后，如果发生了写时复制，就会复制物理内存</li>
</ul>
<h2 id="9-介绍copy-on-write-写时复制"><a href="#9-介绍copy-on-write-写时复制" class="headerlink" title="9# 介绍copy on write(写时复制)"></a>9# 介绍copy on write(写时复制)</h2><p>主进程在执行 fork 的时候，操作系统会把主进程的「<strong>页表</strong>」复制一份给子进程，这个页表记录着虚拟地址和物理地址映射关系，而不会复制物理内存，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1711953642784-59f9d165-53fa-47db-8f88-dec5b084a96b.png" alt="img"></p>
<p>这样一来，子进程就共享了父进程的物理内存数据了，这样能够<strong>节约物理内存资源</strong>，页表对应的页表项的属性会标记该物理内存的权限为<strong>只读</strong>。</p>
<p>不过，当父进程或者子进程在向这个内存发起写操作时，CPU 就会触发<strong>写保护中断</strong>，这个写保护中断是由于违反权限导致的，然后操作系统会在「写保护中断处理函数」里进行<strong>物理内存的复制</strong>，并重新设置其内存映射关系，将父子进程的内存读写权限设置为<strong>可读写</strong>，最后才会对内存进行写操作，这个过程被称为「<strong>写时复制(Copy On Write)</strong>」。</p>
<p>写时复制顾名思义，<strong>在发生写操作的时候，操作系统才会去复制物理内存</strong>，这样是为了防止 fork 创建子进程时，由于物理内存数据的复制时间过长而导致父进程长时间阻塞的问题。</p>
<h2 id="10-copy-on-write节省了什么资源？"><a href="#10-copy-on-write节省了什么资源？" class="headerlink" title="10# copy on write节省了什么资源？"></a>10# copy on write节省了什么资源？</h2><p>节省了物理内存的资源，因为 fork 的时候，子进程不需要复制父进程的物理内存，避免了不必要的内存复制开销，子进程只需要复制父进程的页表，这时候父子进程的页表指向的都是共享的物理内存。</p>
<p>只有当父子进程任何有一方对这片共享的物理内存发生了修改操作，才会触发写时复制机制，这时候才会复制发生修改操作的物理内存。</p>
<h2 id="11-malloc-1KB和1MB-有什么区别？"><a href="#11-malloc-1KB和1MB-有什么区别？" class="headerlink" title="11# malloc 1KB和1MB 有什么区别？"></a>11# malloc 1KB和1MB 有什么区别？</h2><p>malloc() 源码里默认定义了一个阈值：</p>
<ul>
<li>如果用户分配的内存小于 128 KB，则通过 brk() 申请内存；</li>
<li>如果用户分配的内存大于 128 KB，则通过 mmap() 申请内存；</li>
</ul>
<p>注意，不同的 glibc 版本定义的阈值也是不同的。</p>
<h2 id="12-介绍一下brk，mmap"><a href="#12-介绍一下brk，mmap" class="headerlink" title="12# 介绍一下brk，mmap"></a>12# 介绍一下brk，mmap</h2><p>实际上，malloc() 并不是系统调用，而是 C 库里的函数，用于动态分配内存。</p>
<p>malloc 申请内存的时候，会有两种方式向操作系统申请堆内存。</p>
<ul>
<li>方式一：通过 brk() 系统调用从堆分配内存</li>
<li>方式二：通过 mmap() 系统调用在文件映射区域分配内存；</li>
</ul>
<p>方式一实现的方式很简单，就是通过 brk() 函数将「堆顶」指针向高地址移动，获得新的内存空间。如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1719035828276-082e542b-c319-4f78-ae32-c74a86dc3bdb.png" alt="img"></p>
<p>方式二通过 mmap() 系统调用中「私有匿名映射」的方式，在文件映射区分配一块内存，也就是从文件映射区“偷”了一块内存。如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1719035828217-77bcd391-5c82-44ac-b0f2-2ae74a6c188b.png" alt="img"></p>
<h2 id="13-操作系统内存不足的时候会发生什么？"><a href="#13-操作系统内存不足的时候会发生什么？" class="headerlink" title="13# 操作系统内存不足的时候会发生什么？"></a>13# 操作系统内存不足的时候会发生什么？</h2><p>应用程序通过 malloc 函数申请内存的时候，实际上申请的是虚拟内存，此时并不会分配物理内存。</p>
<p>当应用程序读写了这块虚拟内存，CPU 就会去访问这个虚拟内存， 这时会发现这个虚拟内存没有映射到物理内存， CPU 就会产生<strong>缺页中断</strong>，进程会从用户态切换到内核态，并将缺页中断交给内核的 Page Fault Handler （缺页中断函数）处理。</p>
<p>缺页中断处理函数会看是否有空闲的物理内存，如果有，就直接分配物理内存，并建立虚拟内存与物理内存之间的映射关系。</p>
<p>如果没有空闲的物理内存，那么内核就会开始进行<strong>回收内存</strong>的工作，回收的方式主要是两种：直接内存回收和后台内存回收。</p>
<ul>
<li><strong>后台内存回收</strong>（kswapd）：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程<strong>异步</strong>的，不会阻塞进程的执行。</li>
<li><strong>直接内存回收</strong>（direct reclaim）：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是<strong>同步</strong>的，会阻塞进程的执行。</li>
</ul>
<p>如果直接内存回收后，空闲的物理内存仍然无法满足此次物理内存的申请，那么内核就会放最后的大招了 ——<strong>触发 OOM （Out of Memory）机制</strong>。</p>
<p>OOM Killer 机制会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，OOM Killer 会继续杀死占用物理内存较高的进程，直到释放足够的内存位置。</p>
<p>申请物理内存的过程如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1716194642870-ef8ccbf7-1812-4ab9-a970-d0e51bb57bd2.png" alt="img"></p>
<p>系统内存紧张的时候，就会进行回收内存的工作，那具体哪些内存是可以被回收的呢？</p>
<p>主要有两类内存可以被回收，而且它们的回收方式也不同。</p>
<ul>
<li><strong>文件页</strong>（File-backed Page）：内核缓存的磁盘数据（Buffer）和内核缓存的文件数据（Cache）都叫作文件页。大部分文件页，都可以直接释放内存，以后有需要时，再从磁盘重新读取就可以了。而那些被应用程序修改过，并且暂时还没写入磁盘的数据（也就是脏页），就得先写入磁盘，然后才能进行内存释放。所以，<strong>回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存</strong>。</li>
<li><strong>匿名页</strong>（Anonymous Page）：这部分内存没有实际载体，不像文件缓存有硬盘文件这样一个载体，比如堆、栈数据等。这部分内存很可能还要再次被访问，所以不能直接释放内存，它们<strong>回收的方式是通过 Linux 的 Swap 机制</strong>，Swap 会把不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。</li>
</ul>
<p>文件页和匿名页的回收都是<strong>基于 LRU 算法</strong>，也就是优先回收不常访问的内存。LRU 回收算法，实际上维护着 active 和 inactive 两个双向链表，其中：</p>
<ul>
<li><strong>active_list</strong> 活跃内存页链表，这里存放的是最近被访问过（活跃）的内存页；</li>
<li><strong>inactive_list</strong> 不活跃内存页链表，这里存放的是很少被访问（非活跃）的内存页；</li>
</ul>
<p>越接近链表尾部，就表示内存页越不常访问。这样，在回收内存时，系统就可以根据活跃程度，优先回收不活跃的内存。</p>
<h2 id="14-页面置换有哪些算法？"><a href="#14-页面置换有哪些算法？" class="headerlink" title="14# 页面置换有哪些算法？"></a>14# 页面置换有哪些算法？</h2><p>页面置换算法的功能是，<strong>当出现缺页异常，需调入新页面而内存已满时，选择被置换的物理页面</strong>，也就是说选择一个物理页面换出到磁盘，然后把需要访问的页面换入到物理页。</p>
<p>那其算法目标则是，尽可能减少页面的换入换出的次数，常见的页面置换算法有如下几种：</p>
<ul>
<li>最佳页面置换算法（<em>OPT</em>）</li>
<li>先进先出置换算法（<em>FIFO</em>）</li>
<li>最近最久未使用的置换算法（<em>LRU</em>）</li>
<li>时钟页面置换算法（<em>Lock</em>）</li>
<li>最不常用置换算法（<em>LFU</em>）</li>
</ul>
<blockquote>
<p>最佳页面置换算法</p>
</blockquote>
<p>最佳页面置换算法基本思路是，<strong>置换在「未来」最长时间不访问的页面</strong>。</p>
<p>所以，该算法实现需要计算内存中每个逻辑页面的「下一次」访问时间，然后比较，选择未来最长时间不访问的页面。</p>
<p>我们举个例子，假设一开始有 3 个空闲的物理页，然后有请求的页面序列，那它的置换过程如下图：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E6%9C%80%E4%BC%98%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.png" alt="最佳页面置换算法"></p>
<p>在这个请求的页面序列中，缺页共发生了 <code>7</code> 次（空闲页换入 3 次 + 最优页面置换 4 次），页面置换共发生了 <code>4</code> 次。</p>
<p>这很理想，但是实际系统中无法实现，因为程序访问页面时是动态的，我们是无法预知每个页面在「下一次」访问前的等待时间。</p>
<p>所以，最佳页面置换算法作用是为了衡量你的算法的效率，你的算法效率越接近该算法的效率，那么说明你的算法是高效的。</p>
<blockquote>
<p>先进先出置换算法</p>
</blockquote>
<p>既然我们无法预知页面在下一次访问前所需的等待时间，那我们可以<strong>选择在内存驻留时间很长的页面进行中置换</strong>，这个就是「先进先出置换」算法的思想。</p>
<p>还是以前面的请求的页面序列作为例子，假设使用先进先出置换算法，则过程如下图：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/FIFO%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.png" alt="先进先出置换算法"></p>
<p>在这个请求的页面序列中，缺页共发生了 <code>10</code> 次，页面置换共发生了 <code>7</code> 次，跟最佳页面置换算法比较起来，性能明显差了很多。</p>
<blockquote>
<p>最近最久未使用的置换算法</p>
</blockquote>
<p>最近最久未使用（<em>LRU</em>）的置换算法的基本思路是，发生缺页时，<strong>选择最长时间没有被访问的页面进行置换</strong>，也就是说，该算法假设已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用。</p>
<p>这种算法近似最优置换算法，最优置换算法是通过「未来」的使用情况来推测要淘汰的页面，而 LRU 则是通过「历史」的使用情况来推测要淘汰的页面。</p>
<p>还是以前面的请求的页面序列作为例子，假设使用最近最久未使用的置换算法，则过程如下图：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/LRU%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.png" alt="最近最久未使用的置换算法"></p>
<p>在这个请求的页面序列中，缺页共发生了 <code>9</code> 次，页面置换共发生了 <code>6</code> 次，跟先进先出置换算法比较起来，性能提高了一些。</p>
<p>虽然 LRU 在理论上是可以实现的，但代价很高。为了完全实现 LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。</p>
<p>困难的是，在每次访问内存时都必须要更新「整个链表」。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常费时的操作。</p>
<p>所以，LRU 虽然看上去不错，但是由于开销比较大，实际应用中比较少使用。</p>
<blockquote>
<p>时钟页面置换算法</p>
</blockquote>
<p>那有没有一种即能优化置换的次数，也能方便实现的算法呢？</p>
<p>时钟页面置换算法就可以两者兼得，它跟 LRU 近似，又是对 FIFO 的一种改进。</p>
<p>该算法的思路是，把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。</p>
<p>当发生缺页中断时，算法首先检查表针指向的页面：</p>
<ul>
<li>如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；</li>
<li>如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；</li>
</ul>
<p>我画了一副时钟页面置换算法的工作流程图，你可以在下方看到：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.png" alt="时钟页面置换算法"></p>
<p>了解了这个算法的工作方式，就明白为什么它被称为时钟（<em>Clock</em>）算法了。</p>
<blockquote>
<p>最不常用算法</p>
</blockquote>
<p>最不常用（<em>LFU</em>）算法，这名字听起来很调皮，但是它的意思不是指这个算法不常用，而是<strong>当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰</strong>。</p>
<p>它的实现方式是，对每个页面设置一个「访问计数器」，每当一个页面被访问时，该页面的访问计数器就累加 1。在发生缺页中断时，淘汰计数器值最小的那个页面。</p>
<p>看起来很简单，每个页面加一个计数器就可以实现了，但是在操作系统中实现的时候，我们需要考虑效率和硬件成本的。</p>
<p>要增加一个计数器来实现，这个硬件成本是比较高的，另外如果要对这个计数器查找哪个页面访问次数最小，查找链表本身，如果链表长度很大，是非常耗时的，效率不高。</p>
<p>但还有个问题，LFU 算法只考虑了频率问题，没考虑时间的问题，比如有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。</p>
<p>那这个问题的解决的办法还是有的，可以定期减少访问的次数，比如当发生时间中断时，把过去时间访问的页面的访问次数除以 2，也就说，随着时间的流失，以前的高访问次数的页面会慢慢减少，相当于加大了被置换的概率。</p>
<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><h1 id="1-什么是中断？"><a href="#1-什么是中断？" class="headerlink" title="1# 什么是中断？"></a>1# 什么是中断？</h1><p><strong>CPU停下当前的工作任务，去处理其他事情，处理完后回来继续执行刚才的任务</strong>，这一过程便是中断。</p>
<p>中断分为外部中断和内部中断：</p>
<ul>
<li>外部中断分为可屏蔽中断和不可屏蔽中断：<ul>
<li><strong>可屏蔽中断</strong>：<strong>通过INTR线向CPU请求的中断</strong>，主要来自外部设备如硬盘，打印机，网卡等。此类中断并不会影响系统运行，可随时处理，甚至不处理，所以名为可屏蔽。</li>
<li><strong>不可屏蔽中断</strong>：<strong>通过NMI线向CPU请求的中断</strong>，如电源掉电，硬件线路故障等。这里不可屏蔽的意思不是不可以屏蔽，不建议屏蔽，而是问题太大，屏蔽不了，不能屏蔽的意思。注：INTR和NMI都是CPU的引脚</li>
</ul>
</li>
<li>内部中断分为陷阱、故障、终止：<ul>
<li><strong>陷阱：是一种有意的，预先安排的异常事件</strong>，一般是在编写程序时故意设下的陷阱指令，而后执行到陷阱指令后，CPU将会调用特定程序进行相应的处理，<strong>处理结束后返回到陷阱指令的下一条指令</strong>。如系统调用，程序调试功能等。如<strong>printf函数，最底层的实现中会有一条int 0x80指令</strong>，这就是一条陷阱指令，使用0x80号中断进行系统调用。</li>
<li>**故障：故障是在引起故障的指令被执行，但还没有执行结束时，CPU检测到的一类的意外事件。**出错时交由故障处理程序处理，<strong>如果能处理修正这个错误，就将控制返回到引起故障的指令即CPU重新执这条指令。如果不能处理就报错</strong>。常见的故障为缺页，当CPU引用的虚拟地址对应的物理页不存在时就会发生故障。缺页异常是能够修正的，有着专门的缺页处理程序，它会将缺失的物理页从磁盘中重新调进主存。而后再次执行引起故障的指令时便能够顺利执行了。</li>
<li>**终止：执行指令的过程中发生了致命错误，不可修复，程序无法继续运行，只能终止，通常会是一些硬件的错误。**终止处理程序不会将控制返回给原程序，而是直接终止原程序</li>
</ul>
</li>
</ul>
<h2 id="2-讲讲中断的流程"><a href="#2-讲讲中断的流程" class="headerlink" title="2# 讲讲中断的流程"></a>2# 讲讲中断的流程</h2><p>中断是计算机系统中一种机制，用于在处理器执行指令时暂停当前任务，并转而执行其他任务或处理特定事件。以下是中断的基本流程：</p>
<ul>
<li><strong>发生中断</strong>：当外部设备或者软件程序需要处理器的注意或者响应时，会发出中断信号。处理器在接收到中断信号后，会停止当前执行的指令，保存当前执行现场，并跳转到中断处理程序执行。</li>
<li><strong>中断响应</strong>：处理器接收到中断信号后，会根据中断向量表找到对应的中断处理程序的入口地址。 处理器会保存当前执行现场（如程序计数器、寄存器状态等），以便在中断处理完成后能够恢复执行。</li>
<li><strong>中断处理</strong>：处理器跳转到中断处理程序的入口地址开始执行中断处理程序。中断处理程序会根据中断类型进行相应的处理，可能涉及到保存现场、处理中断事件、执行特定任务等。</li>
</ul>
<h2 id="3-中断的类型有哪些？"><a href="#3-中断的类型有哪些？" class="headerlink" title="3# 中断的类型有哪些？"></a>3# 中断的类型有哪些？</h2><p>中断按事件来源分类，可以分为外部中断和内部中断。中断事件来自于CPU外部的被称为外部中断，来自于CPU内部的则为内部中断。</p>
<p>进一步细分，外部中断还可分为可屏蔽中断（maskable interrupt）和不可屏蔽中断（non-maskable interrupt）两种，而内部中断按事件是否正常来划分可分为软中断和异常两种。</p>
<ul>
<li><strong>外部中断</strong>的中断事件来源于CPU外部，必然是某个硬件产生的，所以外部中断又被称为硬件中断（hardware interrupt）。计算机的外部设备，如网卡、声卡、显卡等都能产生中断。外部设备的中断信号是通过两根信号线通知CPU的，一根是INTR，另一根是NMI。CPU从INTR收到的中断信号都是不影响系统运行的，CPU可以选择屏蔽（通过设置中断屏蔽寄存器中的IF位），而从NMI中收到的中断信号则是影响系统运行的严重错误，不可屏蔽，因为屏蔽的意义不大，系统已经无法运行。</li>
<li><strong>内部中断</strong>来自于处理器内部，其中软中断是由软件主动发起的中断，常被用于系统调用（system call）；而异常则是指令执行期间CPU内部产生的错误引起的。异常也和不可屏蔽中断一样不受eflags寄存器的IF位影响，区别在于不可屏蔽中断发生的事件会导致处理器无法运行（如断电、电源故障等），而异常则是影响系统正常运行的中断（如除0、越界访问等）。</li>
</ul>
<h2 id="4-中断的作用是什么？"><a href="#4-中断的作用是什么？" class="headerlink" title="4# 中断的作用是什么？"></a>4# 中断的作用是什么？</h2><p>中断使得计算机系统具备应对对处理突发事件的能力，提高了CPU的工作效率，如果没有中断系统，CPU就只能按照原来的程序编写的先后顺序，对各个外设进行查询和处理，即轮询工作方式，轮询方法貌似公平，但实际工作效率却很低，却不能及时响应紧急事件。</p>
<h1 id="网络-I-O"><a href="#网络-I-O" class="headerlink" title="网络 I&#x2F;O"></a>网络 I&#x2F;O</h1><h2 id="1-你了解过哪些-I-O-模型？"><a href="#1-你了解过哪些-I-O-模型？" class="headerlink" title="1# 你了解过哪些 I&#x2F;O 模型？"></a>1# 你了解过哪些 I&#x2F;O 模型？</h2><ul>
<li>阻塞I&#x2F;O模型：应用程序发起I&#x2F;O操作后会被阻塞，直到操作完成才返回结果。适用于对实时性要求不高的场景。</li>
<li>非阻塞I&#x2F;O模型：应用程序发起I&#x2F;O操作后立即返回，不会被阻塞，但需要不断轮询或者使用select&#x2F;poll&#x2F;epoll等系统调用来检查I&#x2F;O操作是否完成。适合于需要进行多路复用的场景，例如需要同时处理多个socket连接的服务器程序。</li>
<li>I&#x2F;O复用模型：通过select、poll、epoll等系统调用，应用程序可以同时等待多个I&#x2F;O操作，当其中任何一个I&#x2F;O操作准备就绪时，应用程序会被通知。适合于需要同时处理多个I&#x2F;O操作的场景，比如高并发的服务端程序。</li>
<li>信号驱动I&#x2F;O模型：应用程序发起I&#x2F;O操作后，可以继续做其他事情，当I&#x2F;O操作完成时，操作系统会向应用程序发送信号来通知其完成。适合于需要异步I&#x2F;O通知的场景，可以提高系统的并发能力。</li>
<li>异步I&#x2F;O模型：应用程序发起I&#x2F;O操作后可以立即做其他事情，当I&#x2F;O操作完成时，应用程序会得到通知。异步I&#x2F;O模型由操作系统内核完成I&#x2F;O操作，应用程序只需等待通知即可。适合于需要大量并发连接和高性能的场景，能够减少系统调用次数，提高系统效率。</li>
</ul>
<h2 id="2-服务器处理并发请求有哪几种方式？"><a href="#2-服务器处理并发请求有哪几种方式？" class="headerlink" title="2# 服务器处理并发请求有哪几种方式？"></a>2# 服务器处理并发请求有哪几种方式？</h2><ul>
<li>单线程web服务器方式：web服务器一次处理一个请求，结束后读取并处理下一个请求，性能比较低，一次只能处理一个请求。</li>
<li>多进程&#x2F;多线程web服务器：web服务器生成多个进程或线程并行处理多个用户请求，进程或线程可以按需或事先生成。有的web服务器应用程序为每个用户请求生成一个单独的进程或线程来进行响应，不过，一旦并发请求数量达到成千上万时，多个同时运行的进程或线程将会消耗大量的系统资源。（即每个进程只能响应一个请求，并且一个进程对应一个线程）</li>
<li>I&#x2F;O多路复用web服务器：web服务器可以I&#x2F;O多路复用，达到只用一个线程就能监听和处理多个客户端的 i&#x2F;o 事件。</li>
<li>多路复用多线程web服务器：将多进程和多路复用的功能结合起来形成的web服务器架构，其避免了让一个进程服务于过多的用户请求，并能充分利用多CPU主机所提供的计算能力。（这种架构可以理解为有多个进程，并且一个进程又生成多个线程，每个线程处理一个请求）</li>
</ul>
<h2 id="3-讲一下-I-O-多路复用"><a href="#3-讲一下-I-O-多路复用" class="headerlink" title="3# 讲一下 I&#x2F;O 多路复用"></a>3# 讲一下 I&#x2F;O 多路复用</h2><p>IO多路复用是一种IO得处理方式，指的是复用一个线程，处理多个socket中的事件。能够资源复用，防止创建过多线程导致的上下文切换的开销。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1713258801056-11017b4f-ca3a-4cdd-9cd3-c2e75fb6bad2.png" alt="img"></p>
<h2 id="4-select、poll、epoll-的区别是什么？"><a href="#4-select、poll、epoll-的区别是什么？" class="headerlink" title="4# select、poll、epoll 的区别是什么？"></a>4# select、poll、epoll 的区别是什么？</h2><p>我们熟悉的 select&#x2F;poll&#x2F;epoll 内核提供给用户态的多路复用系统调用，<strong>进程可以通过一个系统调用函数从内核中获取多个事件</strong>。</p>
<p>select&#x2F;poll&#x2F;epoll 是如何获取网络事件的呢？在获取事件时，先把所有连接（文件描述符）传给内核，再由内核返回产生了事件的连接，然后在用户态中再处理这些连接对应的请求即可。</p>
<p>select&#x2F;poll&#x2F;epoll 这是三个多路复用接口，都能实现 C10K 吗？接下来，我们分别说说它们。</p>
<blockquote>
<p>select&#x2F;poll</p>
</blockquote>
<p>select 实现多路复用的方式是，将已连接的 Socket 都放到一个<strong>文件描述符集合</strong>，然后调用 select 函数将文件描述符集合<strong>拷贝</strong>到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过<strong>遍历</strong>文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合<strong>拷贝</strong>回用户态里，然后用户态还需要再通过<strong>遍历</strong>的方法找到可读或可写的 Socket，然后再对其处理。</p>
<p>所以，对于 select 这种方式，需要进行 <strong>2 次「遍历」文件描述符集合</strong>，一次是在内核态里，一个次是在用户态里 ，而且还会发生 <strong>2 次「拷贝」文件描述符集合</strong>，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p>
<p>select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 1024，只能监听 0~1023 的文件描述符。</p>
<p>poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。</p>
<p>但是 poll 和 select 并没有太大的本质区别，<strong>都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合</strong>，这种方式随着并发数上来，性能的损耗会呈指数级增长。</p>
<blockquote>
<p>epoll</p>
</blockquote>
<p>先复习下 epoll 的用法。如下的代码中，先用epoll_create 创建一个 epol l对象 epfd，再通过 epoll_ctl 将需要监视的 socket 添加到epfd中，最后调用 epoll_wait 等待数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">bind(s, ...);</span><br><span class="line">listen(s, ...)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> epfd = epoll_create(...);</span><br><span class="line">epoll_ctl(epfd, ...); <span class="comment">//将所有需要监听的socket添加到epfd中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> n = epoll_wait(...);</span><br><span class="line">    <span class="keyword">for</span>(接收到数据的socket)&#123;</span><br><span class="line">        <span class="comment">//处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>epoll 通过两个方面，很好解决了 select&#x2F;poll 的问题。</p>
<ul>
<li><em>第一点</em>，epoll 在内核里使用<strong>红黑树来跟踪进程所有待检测的文件描述字</strong>，把需要监控的 socket 通过 epoll_ctl() 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 O(logn)。而 select&#x2F;poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket 的数据结构，所以 select&#x2F;poll 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。</li>
<li><em>第二点</em>， epoll 使用<strong>事件驱动</strong>的机制，内核里<strong>维护了一个链表来记录就绪事件</strong>，当某个 socket 有事件发生时，通过<strong>回调函数</strong>内核会将其加入到这个就绪事件列表中，当用户调用 epoll_wait() 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select&#x2F;poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</li>
</ul>
<p>从下图你可以看到 epoll 相关的接口作用：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1720432759667-f7bc5361-fe07-443b-b096-243f014d69a7.png" alt="img"></p>
<p>epoll 的方式即使监听的 Socket 数量越多的时候，效率不会大幅度降低，能够同时监听的 Socket 的数目也非常的多了，上限就为系统定义的进程打开的最大文件描述符个数。因而，<strong>epoll 被称为解决 C10K 问题的利器</strong>。</p>
<h2 id="5-epoll-的-边缘触发和水平触发有什么区别？"><a href="#5-epoll-的-边缘触发和水平触发有什么区别？" class="headerlink" title="5# epoll 的 边缘触发和水平触发有什么区别？"></a>5# epoll 的 边缘触发和水平触发有什么区别？</h2><p>epoll 支持两种事件触发模式，分别是<strong>边缘触发（edge-triggered，ET）和水平触发（level-triggered，LT</strong>）。</p>
<p>这两个术语还挺抽象的，其实它们的区别还是很好理解的。</p>
<ul>
<li>使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，<strong>服务器端只会从 epoll_wait 中苏醒一次</strong>，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；</li>
<li>使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，<strong>服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</strong>，目的是告诉我们有数据需要读取；</li>
</ul>
<p>举个例子，你的快递被放到了一个快递箱里，如果快递箱只会通过短信通知你一次，即使你一直没有去取，它也不会再发送第二条短信提醒你，这个方式就是边缘触发；如果快递箱发现你的快递没有被取出，它就会不停地发短信通知你，直到你取出了快递，它才消停，这个就是水平触发的方式。</p>
<p>这就是两者的区别，水平触发的意思是只要满足事件的条件，比如内核中有数据需要读，就一直不断地把这个事件传递给用户；而边缘触发的意思是只有第一次满足条件的时候才触发，之后就不会再传递同样的事件了。</p>
<p>如果使用水平触发模式，当内核通知文件描述符可读写时，接下来还可以继续去检测它的状态，看它是否依然可读或可写。所以在收到通知后，没必要一次执行尽可能多的读写操作。</p>
<p>如果使用边缘触发模式，I&#x2F;O 事件发生时只会通知一次，而且我们不知道到底能读写多少数据，所以在收到通知后应尽可能地读写数据，以免错失读写的机会。因此，我们会<strong>循环</strong>从文件描述符读写数据，那么如果文件描述符是阻塞的，没有数据可读写时，进程会阻塞在读写函数那里，程序就没办法继续往下执行。所以，<strong>边缘触发模式一般和非阻塞 I&#x2F;O 搭配使用</strong>，程序会一直执行 I&#x2F;O 操作，直到系统调用（如 read 和 write）返回错误，错误类型为 EAGAIN 或 EWOULDBLOCK。</p>
<p>一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。</p>
<h2 id="6-redis，nginx，netty-是依赖什么做的这么高性能？"><a href="#6-redis，nginx，netty-是依赖什么做的这么高性能？" class="headerlink" title="6# redis，nginx，netty 是依赖什么做的这么高性能？"></a>6# redis，nginx，netty 是依赖什么做的这么高性能？</h2><p>主要是依赖<strong>Reactor 模式</strong>实现了高性能网络模式，这个是在i&#x2F;o多路复用接口基础上实现的了网络模型。Reactor 翻译过来的意思是「反应堆」，这里的反应指的是「<strong>对事件反应</strong>」，也就是<strong>来了一个事件，Reactor 就有相对应的反应&#x2F;响应</strong>。</p>
<p>Reactor 模式主要由 Reactor 和处理资源池这两个核心部分组成，它俩负责的事情如下：</p>
<ul>
<li>Reactor 负责监听和分发事件，事件类型包含连接事件、读写事件；</li>
<li>处理资源池负责处理事件，如 read -&gt; 业务逻辑 -&gt; send；</li>
</ul>
<p>Reactor 模式是灵活多变的，可以应对不同的业务场景，灵活在于：</p>
<ul>
<li>Reactor 的数量可以只有一个，也可以有多个；</li>
<li>处理资源池可以是单个进程 &#x2F; 线程，也可以是多个进程 &#x2F;线程；</li>
</ul>
<blockquote>
<p>Redis</p>
</blockquote>
<p>Redis 6.0 之前使用的 Reactor 模型就是单 Reactor 单进程模式。单 Reactor 单进程的方案因为全部工作都在同一个进程内完成，所以实现起来比较简单，不需要考虑进程间通信，也不用担心多进程竞争。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1720420600761-3cf6a703-4650-4ed4-b900-f2ca71efa57e.webp" alt="img"></p>
<p>但是，这种方案存在 2 个缺点：</p>
<ul>
<li>第一个缺点，因为只有一个进程，<strong>无法充分利用 多核 CPU 的性能</strong>；</li>
<li>第二个缺点，Handler 对象在业务处理时，整个进程是无法处理其他连接的事件的，<strong>如果业务处理耗时比较长，那么就造成响应的延迟</strong>；</li>
</ul>
<p>所以，单 Reactor 单进程的方案<strong>不适用计算机密集型的场景，只适用于业务处理非常快速的场景</strong>。</p>
<p>Redis 是由 C 语言实现的，在 Redis 6.0 版本之前采用的正是「单 Reactor 单进程」的方案，因为 Redis 业务处理主要是在内存中完成，操作的速度是很快的，性能瓶颈不在 CPU 上，所以 Redis 对于命令的处理是单进程的方案。</p>
<blockquote>
<p>Netty</p>
</blockquote>
<p>Netty 是采用了多 Reactor 多线程方案，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1720420601537-460e47c6-27b5-4daa-a631-01e17b7d71f5.webp" alt="img"></p>
<p>多 Reactor 多线程的方案优势：</p>
<ul>
<li>主线程和子线程分工明确，主线程只负责接收新连接，子线程负责完成后续的业务处理。</li>
<li>主线程和子线程的交互很简单，主线程只需要把新连接传给子线程，子线程无须返回数据，直接就可以在子线程将处理结果发送给客户端。</li>
</ul>
<blockquote>
<p>nginx</p>
</blockquote>
<p>nginx 是多 Reactor 多进程方案，不过方案与标准的多 Reactor 多进程有些差异。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1720420601634-1d2e5786-5633-4406-b8e2-45ba4ab0a2da.webp" alt="img"></p>
<p>具体差异表现在主进程中仅仅用来初始化 socket，并没有创建 mainReactor 来 accept 连接，而是由子进程的 Reactor 来 accept 连接，通过锁来控制一次只有一个子进程进行 accept（防止出现惊群现象），子进程 accept 新连接后就放到自己的 Reactor 进行处理，不会再分配给其他子进程。</p>
<h2 id="7-零拷贝是什么？"><a href="#7-零拷贝是什么？" class="headerlink" title="7# 零拷贝是什么？"></a>7# 零拷贝是什么？</h2><p>传统 IO 的工作方式，从硬盘读取数据，然后再通过网卡向外发送，我们需要进行 4 上下文切换，和 4 次数据拷贝，其中 2 次数据拷贝发生在内存里的缓冲区和对应的硬件设备之间，这个是由 DMA 完成，另外 2 次则发生在内核态和用户态之间，这个数据搬移工作是由 CPU 完成的。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1713775119392-03ed8749-6f4b-43f1-b3ca-005c731fd41f.png" alt="img"></p>
<p>为了提高文件传输的性能，于是就出现了零拷贝技术，它通过一次系统调用（sendfile 方法）合并了磁盘读取与网络发送两个操作，降低了上下文切换次数。另外，拷贝数据都是发生在内核中的，天然就降低了数据拷贝的次数。</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1713775083722-bd89e407-dfca-487e-83ee-1563e46f1d85.png" alt="img"></p>
<p>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，<strong>只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</strong></p>
<p>总体来看，<strong>零拷贝技术可以把文件传输的性能提高至少一倍以上</strong>。</p>
]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 hot100 笔记</title>
    <url>/2025/09/08/leetcode-notes/</url>
    <content><![CDATA[<p> leetcode hot100</p>
<p><del>太菜了，就先不写困难了</del></p>
<span id="more"></span>

<h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 104</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
<li><strong>只会存在一个有效答案</strong></li>
</ul>
<p>**进阶：**你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p>
<p><strong>解题思路</strong></p>
<ol>
<li>遍历数组 <code>nums</code></li>
<li>对于当前数字 <code>x = nums[i]</code>，计算它的<strong>配对数</strong> <code>diff = target - x</code></li>
<li>如果 <code>diff</code> 已经在哈希表中出现过，说明找到了答案，返回下标</li>
<li>否则，将 <code>x</code> 和它的下标 <code>i</code> 存入哈希表，方便后续查找</li>
<li>时间复杂度 <strong>O(n)</strong>，空间复杂度 <strong>O(n)</strong></li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果配对数出现过，直接返回答案</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(diff)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;map.get(diff), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 否则存入当前值和下标</span></span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x。</p>
<p>空间复杂度：O(n)，其中 n 是数组中的元素数量。主要为哈希表的开销。</p>
<h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a>49. 字母异位词分组</h2><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p>
<p><strong>示例 1:</strong></p>
<p><strong>输入:</strong> strs &#x3D; [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]</p>
<p><strong>输出:</strong> [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]</p>
<p><strong>解释：</strong></p>
<ul>
<li>在 strs 中没有字符串可以通过重新排列来形成 <code>&quot;bat&quot;</code>。</li>
<li>字符串 <code>&quot;nat&quot;</code> 和 <code>&quot;tan&quot;</code> 是字母异位词，因为它们可以重新排列以形成彼此。</li>
<li>字符串 <code>&quot;ate&quot;</code> ，<code>&quot;eat&quot;</code> 和 <code>&quot;tea&quot;</code> 是字母异位词，因为它们可以重新排列以形成彼此。</li>
</ul>
<p><strong>示例 2:</strong></p>
<p><strong>输入:</strong> strs &#x3D; [“”]</p>
<p><strong>输出:</strong> [[“”]]</p>
<p><strong>示例 3:</strong></p>
<p><strong>输入:</strong> strs &#x3D; [“a”]</p>
<p><strong>输出:</strong> [[“a”]]</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= strs.length &lt;= 104</code></li>
<li><code>0 &lt;= strs[i].length &lt;= 100</code></li>
<li><code>strs[i]</code> 仅包含小写字母</li>
</ul>
<p><strong>解题思路</strong></p>
<ul>
<li>把字符串的字符排序后作为 key</li>
<li>用 <code>Map&lt;String, List&lt;String&gt;&gt;</code> 存储</li>
<li>时间复杂度：O(n * k log k)，k 为单词平均长度</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (String s : strs) &#123;</span><br><span class="line">            <span class="comment">// 将字符串排序</span></span><br><span class="line">            <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">            Arrays.sort(chars);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 放入对应的分组</span></span><br><span class="line">            map.computeIfAbsent(key, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(nk log k)，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度。需要遍历 n 个字符串，对于每个字符串，需要 O(k log k) 的时间进行排序以及 O(1) 的时间更新哈希表，因此总时间复杂度是 O(nk log k)。</p>
<p>空间复杂度：O(nk)，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度。需要用哈希表存储全部字符串。</p>
<h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a>128. 最长连续序列</h2><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,3,7,2,5,8,4,6,0,1]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,0,1,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 105</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li><p>把所有数字放进一个 <code>HashSet</code>，方便 O(1) 查询某个数字是否存在。</p>
</li>
<li><p>遍历每个数字 <code>num</code>：</p>
<ul>
<li><p>只从<strong>连续序列的起点</strong>开始往后数（即 <code>num - 1</code> 不在集合里时）</p>
</li>
<li><p>不然会重复计算，比如序列 [1,2,3,4]，从 2 开始也能找到长度 3，但没必要</p>
</li>
</ul>
</li>
<li><p>从起点 <code>num</code> 往后连续查找 <code>num+1, num+2, ...</code>，直到不连续为止，更新最大长度。</p>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">longest</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : set) &#123;</span><br><span class="line">            <span class="comment">// 只从序列起点开始查</span></span><br><span class="line">            <span class="keyword">if</span> (!set.contains(num - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">currentNum</span> <span class="operator">=</span> num;</span><br><span class="line">                <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (set.contains(currentNum + <span class="number">1</span>)) &#123;</span><br><span class="line">                    currentNum++;</span><br><span class="line">                    length++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                longest = Math.max(longest, length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 为数组的长度。具体分析已在上面正文中给出。</li>
<li>空间复杂度：O(n)。哈希表存储数组中所有的数需要 O(n) 的空间。</li>
</ul>
<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h2><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0]</span><br><span class="line">输出: [0]</span><br></pre></td></tr></table></figure>

<p><strong>提示</strong>:</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
</ul>
<p>**进阶：**你能尽量减少完成的操作次数吗？</p>
<p><strong>解题思路</strong></p>
<ol>
<li><p>双指针法：</p>
<ul>
<li><p><code>slow</code>：记录下一个非零元素应该放的位置</p>
</li>
<li><p><code>fast</code>：遍历数组</p>
</li>
</ul>
</li>
<li><p>遍历时：</p>
<ul>
<li>如果 <code>nums[fast] != 0</code>，就把 <code>nums[fast]</code> 放到 <code>nums[slow]</code>，<code>slow++</code></li>
</ul>
</li>
<li><p>遍历结束后，把从 <code>slow</code> 到末尾的元素全部置 0</p>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 指向下一个非零元素的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一轮：把非零元素往前放</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>; fast &lt; nums.length; fast++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != <span class="number">0</span>) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二轮：把剩下的位置填 0</span></span><br><span class="line">        <span class="keyword">while</span> (slow &lt; nums.length) &#123;</span><br><span class="line">            nums[slow] = <span class="number">0</span>;</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 为序列长度。每个位置至多被遍历两次。</li>
<li>空间复杂度：O(1)。只需要常数的空间存放若干变量。</li>
</ul>
<h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h2><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p>
<p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p>**说明：**你不能倾斜容器。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == height.length</code></li>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>0 &lt;= height[i] &lt;= 104</code></li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li><strong>左右指针</strong>分别从两端开始，计算当前容量</li>
<li>容量取决于较短的那条线，因为水不会溢出短板</li>
<li>移动<strong>短板指针</strong>，可能会找到更高的短板从而增大容量（移动长板无意义，因为高度受短板限制）</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxArea</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> Math.min(height[left], height[right]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> right - left;</span><br><span class="line">            maxArea = Math.max(h * width, maxArea);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移动短板</span></span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，双指针总计最多遍历整个数组一次。</li>
<li>空间复杂度：O(1)，只需要额外的常数级别的空间。</li>
</ul>
<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p>**注意：**答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 3000</code></li>
<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li><p><strong>排序</strong>数组（方便去重和使用双指针）。</p>
</li>
<li><p>遍历数组 <code>i</code> 作为第一个数 <code>nums[i]</code>。</p>
</li>
<li><p>对于每个 <code>i</code>，用<strong>双指针</strong> (<code>left</code>, <code>right</code>) 找出后面两数之和为 <code>-nums[i]</code> 的组合。</p>
</li>
<li><p>去重：</p>
<ul>
<li><p><code>i</code> 重复时跳过</p>
</li>
<li><p>找到一组解后，<code>left</code> 和 <code>right</code> 各自去掉重复的数，避免相同三元组重复加入结果。</p>
</li>
</ul>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);  <span class="comment">// 排序 O(n Log n)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 跳过重复的第一个元素</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 跳过重复的 left</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 跳过重复的 right</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;  <span class="comment">// 需要更大的和</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right--;  <span class="comment">// 需要更小的和</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n^2)，其中 n 是数组 nums 的长度。</p>
<p>空间复杂度：O(log n)。我们忽略存储答案的空间，额外的排序的空间复杂度为 O(log n)。然而我们修改了输入的数组 nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 nums 的副本并进行排序，空间复杂度为 O(n)。</p>
<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 104</code></li>
<li><code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li>用两个指针 <code>left</code> 和 <code>right</code> 表示窗口的左右边界。</li>
<li>用一个 <code>HashSet</code>（或 <code>Map</code>）存储当前窗口内的字符。</li>
<li>向右扩展窗口（<code>right++</code>），如果出现重复字符，就移动 <code>left</code> 缩小窗口，直到没有重复为止。</li>
<li>在过程中不断更新最大长度 <code>maxLen</code>。</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果重复，移动左指针</span></span><br><span class="line">            <span class="keyword">while</span> (set.contains(c)) &#123;</span><br><span class="line">                set.remove(s.charAt(left));</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加入新字符</span></span><br><span class="line">            set.add(c);</span><br><span class="line">            maxLen = Math.max(maxLen, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(N)，其中 N 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。</p>
<p>空间复杂度：O(∣Σ∣)，其中 Σ 表示字符集（即字符串中可以出现的字符），∣Σ∣ 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 [0,128) 内的字符，即 ∣Σ∣&#x3D;128。我们需要用到哈希集合来存储出现过的字符，而字符最多有 ∣Σ∣ 个，因此空间复杂度为 O(∣Σ∣)。</p>
<h2 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a>438. 找到字符串中所有字母异位词</h2><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span><br><span class="line">输出: [0,6]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</span><br></pre></td></tr></table></figure>

<p> <strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abab&quot;, p = &quot;ab&quot;</span><br><span class="line">输出: [0,1,2]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span><br><span class="line">起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。</span><br><span class="line">起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= s.length, p.length &lt;= 3 * 104</code></li>
<li><code>s</code> 和 <code>p</code> 仅包含小写字母</li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li><strong>异位词判断</strong>：两个字符串的字符出现频率相同即可。</li>
<li>用两个长度为 26 的整型数组：<ul>
<li><code>pCount</code> 记录 <code>p</code> 中每个字符的频率。</li>
<li><code>sCount</code> 记录当前窗口中每个字符的频率。</li>
</ul>
</li>
<li>滑动窗口大小固定为 <code>p.length()</code>，在滑动过程中更新 <code>sCount</code>，并比较 <code>sCount</code> 与 <code>pCount</code> 是否相等。</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt; p.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] sCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span>[] pCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">window</span> <span class="operator">=</span> p.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 p 的字符频率</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : p.toCharArray()) &#123;</span><br><span class="line">            pCount[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 右边进入窗口</span></span><br><span class="line">            sCount[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左边移出窗口</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= window) &#123;</span><br><span class="line">                sCount[s.charAt(i - window) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 比较两个频率数组</span></span><br><span class="line">            <span class="keyword">if</span> (Arrays.equals(sCount, pCount)) &#123;</span><br><span class="line">                res.add(i - window + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(m+(n−m)×Σ)，其中 n 为字符串 s 的长度，m 为字符串 p 的长度，Σ 为所有可能的字符数。我们需要 O(m) 来统计字符串 p 中每种字母的数量；需要 O(m) 来初始化滑动窗口；需要判断 n−m+1 个滑动窗口中每种字母的数量是否与字符串 p 中每种字母的数量相同，每次判断需要 O(Σ) 。因为 s 和 p 仅包含小写字母，所以 Σ&#x3D;26。</p>
<p>空间复杂度：O(Σ)。用于存储字符串 p 和滑动窗口中每种字母的数量。</p>
<h1 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h1><h2 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a>560. 和为 K 的子数组</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。</p>
<p>子数组是数组中元素的连续非空序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1], k = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3], k = 3</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li>
<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>-107 &lt;= k &lt;= 107</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>核心公式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prefixSum[j] - prefixSum[i] = k</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>prefixSum[j]</code> 表示从数组开头到 j 的元素和</li>
<li>如果 <code>prefixSum[j] - k</code> 在哈希表中出现过，说明存在以 j 结尾的子数组和为 k</li>
</ul>
<p>步骤：</p>
<ol>
<li>用 <code>sum</code> 记录当前前缀和</li>
<li>用 <code>map</code> 记录 <strong>某个前缀和出现的次数</strong></li>
<li>遍历数组：<ul>
<li><code>sum += nums[i]</code></li>
<li>查看 <code>map</code> 中是否存在 <code>sum - k</code></li>
<li>如果存在，把出现次数加到答案中</li>
<li>再把当前 <code>sum</code> 存入 <code>map</code></li>
</ul>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// 前缀和为 0 出现一次，表示从当前位置的和恰好为 k 的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查找是否有前缀和 = sum - k</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(sum - k)) &#123;</span><br><span class="line">                count += map.get(sum - k);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新当前前缀和出现的次数</span></span><br><span class="line">            map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 为数组的长度。我们遍历数组的时间复杂度为 O(n)，中间利用哈希表查询删除的复杂度均为 O(1)，因此总时间复杂度为 O(n)。</p>
<p>空间复杂度：O(n)，其中 n 为数组的长度。哈希表在最坏情况下可能有 n 个不同的键值，因此需要 O(n) 的空间复杂度。</p>
<h1 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h1><h2 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a>53. 最大子数组和</h2><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong>是数组中的一个连续部分。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,4,-1,7,8]</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
</ul>
<p>**进阶：**如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p>
<p><strong>解题思路</strong></p>
<p>我们要找的是一个 <strong>连续</strong> 子数组，和最大。<br> 每个位置 <code>i</code>，我们要么：</p>
<ul>
<li><strong>把当前元素 nums[i] 接在前面的子数组后面</strong>（如果前面和是正数，能帮它变大）</li>
<li><strong>从当前元素重新开始</strong>（如果前面的和是负数，还不如不要）</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentSum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 要么加上 nums[i]，要么从 nums[i] 重新开始</span></span><br><span class="line">            currentSum = Math.max(currentSum + nums[i], nums[i]);</span><br><span class="line">            maxSum = Math.max(maxSum, currentSum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 为 nums 数组的长度。我们只需要遍历一遍数组即可求得答案。</li>
<li>空间复杂度：O(1)。我们只需要常数空间存放若干变量。</li>
</ul>
<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h2><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[1,4],[4,5]]</span><br><span class="line">输出：[[1,5]]</span><br><span class="line">解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[4,7],[1,4]]</span><br><span class="line">输出：[[1,7]]</span><br><span class="line">解释：区间 [1,4] 和 [4,7] 可被视为重叠区间。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= intervals.length &lt;= 104</code></li>
<li><code>intervals[i].length == 2</code></li>
<li><code>0 &lt;= starti &lt;= endi &lt;= 104</code></li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li><p>按区间的起点 <code>start</code> 升序排序，这样所有可能重叠的区间都会相邻出现。</p>
</li>
<li><p>用一个临时变量 <code>current</code> 表示正在合并的区间：</p>
<ul>
<li><p>如果新区间的起点 ≤ <code>current</code> 的终点，说明重叠，更新 <code>current</code> 的终点为两者终点的最大值；</p>
</li>
<li><p>否则，没有重叠，把 <code>current</code> 加入结果，并开始合并下一个区间。</p>
</li>
</ul>
</li>
<li><p>记得最后一个 <code>current</code> 也要放进结果中。</p>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.length == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 按起点排序</span></span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; merged = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 初始化第一个区间</span></span><br><span class="line">        <span class="type">int</span>[] current = intervals[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果重叠</span></span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt;= current[<span class="number">1</span>]) &#123;</span><br><span class="line">                current[<span class="number">1</span>] = Math.max(current[<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有重叠，保存当前区间</span></span><br><span class="line">                merged.add(current);</span><br><span class="line">                current = intervals[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 加入最后一个区间</span></span><br><span class="line">        merged.add(current);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merged.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[merged.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n log n)，其中 n 为区间的数量。除去排序的开销，我们只需要一次线性扫描，所以主要的时间开销是排序的 O(n log n)。</p>
<p>空间复杂度：O(log n)，其中 n 为区间的数量。这里计算的是存储答案之外，使用的额外空间。O(log n) 即为排序所需要的空间复杂度。</p>
<h2 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a>189. 轮转数组</h2><p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右轮转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右轮转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右轮转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,-100,3,99], k = 2</span><br><span class="line">输出：[3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右轮转 1 步: [99,-1,-100,3]</span><br><span class="line">向右轮转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
<li><code>0 &lt;= k &lt;= 105</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>尽可能想出更多的解决方案，至少有 <strong>三种</strong> 不同的方法可以解决这个问题。</li>
<li>你可以使用空间复杂度为 <code>O(1)</code> 的 <strong>原地</strong> 算法解决这个问题吗？</li>
</ul>
<p><strong>解题思路</strong></p>
<p>右旋转 k 步相当于：</p>
<ol>
<li>先整体反转数组</li>
<li>再反转前 k 个元素</li>
<li>再反转剩余的 n - k 个元素</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        k = k % l;  <span class="comment">// 处理 k &gt; n 的情况</span></span><br><span class="line">        reverse(nums, <span class="number">0</span>, l - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[left];</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            nums[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<em>O</em>(<em>n</em>)，其中 <em>n</em> 为数组的长度。每个元素被翻转两次，一共 <em>n</em> 个元素，因此总时间复杂度为 <em>O</em>(2<em>n</em>)&#x3D;<em>O</em>(<em>n</em>)。</li>
<li>空间复杂度：<em>O</em>(1)。</li>
</ul>
<h2 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a>238. 除自身以外数组的乘积</h2><p>给你一个整数数组 <code>nums</code>，返回 数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积 。</p>
<p>题目数据 <strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内。</p>
<p>请 **不要使用除法，**且在 <code>O(n)</code> 时间复杂度内完成此题。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,1,0,-3,3]</span><br><span class="line">输出: [0,0,9,0,0]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 105</code></li>
<li><code>-30 &lt;= nums[i] &lt;= 30</code></li>
<li>输入 <strong>保证</strong> 数组 <code>answer[i]</code> 在 <strong>32 位</strong> 整数范围内</li>
</ul>
<p>**进阶：**你可以在 <code>O(1)</code> 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 <strong>不被视为</strong> 额外空间。）</p>
<p><strong>解题思路</strong></p>
<p>我们要求 <code>answer[i] = nums[0] * nums[1] * ... * nums[i-1] * nums[i+1] * ... * nums[n-1]</code><br> 也就是 <strong>当前位置的左边积 × 右边积</strong>。</p>
<ol>
<li>先计算左积：<ul>
<li><code>left[i]</code> 表示 <code>nums[0] ~ nums[i-1]</code> 的乘积</li>
<li>第 0 个位置没有左边元素，所以 <code>left[0] = 1</code></li>
</ul>
</li>
<li>再计算右积，并直接乘到结果数组上：<ul>
<li><code>right</code> 从末尾向前计算，不需要额外数组，用一个变量保存右积累乘值</li>
<li>每一步 <code>answer[i] = left[i] * right</code></li>
</ul>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span>[] answer = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 计算左积</span></span><br><span class="line">        answer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            answer[i] = answer[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 计算右积并乘在答案上</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 当前右边所有数的乘积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            answer[i] = answer[i] * right;</span><br><span class="line">            right *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 指的是数组 nums 的大小。分析与方法一相同。<br>空间复杂度：O(1)，输出数组不算进空间复杂度中，因此我们只需要常数的空间存放变量。</p>
<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a>73. 矩阵置零</h2><p>给定一个 <code>*m* x *n*</code> 的矩阵，如果一个元素为 <strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong>原地</strong> 算法**。**</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">输出：[[1,0,1],[0,0,0],[1,0,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]</span><br><span class="line">输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[0].length</code></li>
<li><code>1 &lt;= m, n &lt;= 200</code></li>
<li><code>-231 &lt;= matrix[i][j] &lt;= 231 - 1</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>一个直观的解决方案是使用  <code>O(*m**n*)</code> 的额外空间，但这并不是一个好的解决方案。</li>
<li>一个简单的改进方案是使用 <code>O(*m* + *n*)</code> 的额外空间，但这仍然不是最好的解决方案。</li>
<li>你能想出一个仅使用常量空间的解决方案吗？</li>
</ul>
<p><strong>解题思路</strong></p>
<p>如果不用额外数组，我们就需要 <strong>复用原矩阵的一部分来存储“这一行或这一列需要清零”的信息</strong>：</p>
<ol>
<li>先判断第一行和第一列是否本来就有 0<ul>
<li>因为第一行和第一列会被用来做标记，所以要提前单独记下来</li>
</ul>
</li>
<li>用第一行、第一列做标记<ul>
<li>遍历除第一行、第一列之外的元素，如果 <code>matrix[i][j] == 0</code><ul>
<li>标记 <code>matrix[i][0] = 0</code>（该行要清零）</li>
<li>标记 <code>matrix[0][j] = 0</code>（该列要清零）</li>
</ul>
</li>
</ul>
</li>
<li>根据标记清零<ul>
<li>再次遍历（不包括第一行第一列），如果当前行或列的标记是 0，就把它清零</li>
</ul>
</li>
<li>最后处理第一行、第一列<ul>
<li>如果第一行原来有 0，整行清零</li>
<li>如果第一列原来有 0，整列清零</li>
</ul>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZeroes</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">firstRowZero</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">firstColZero</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 判断第一行是否有 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                firstRowZero = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 判断第一列是否有 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                firstColZero = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 用第一行和第一列做标记</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4，根据标记清零（不动第一行和第一列）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 处理第一行</span></span><br><span class="line">        <span class="keyword">if</span> (firstRowZero) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6. 处理第一列</span></span><br><span class="line">        <span class="keyword">if</span> (firstColZero) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<em>O</em>(<em>mn</em>)，其中 <em>m</em> 是矩阵的行数，<em>n</em> 是矩阵的列数。我们至多只需要遍历该矩阵两次。</li>
<li>空间复杂度：<em>O</em>(1)。我们只需要常数空间存储若干变量。</li>
</ul>
<h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a>54. 螺旋矩阵</h2><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 10</code></li>
<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li>定义四个指针：<ul>
<li><code>top</code>：当前最上边界</li>
<li><code>bottom</code>：当前最下边界</li>
<li><code>left</code>：当前最左边界</li>
<li><code>right</code>：当前最右边界</li>
</ul>
</li>
<li>按照顺时针顺序循环：<ol>
<li>从左到右遍历上边界 <code>top</code>，然后 <code>top++</code></li>
<li>从上到下遍历右边界 <code>right</code>，然后 <code>right--</code></li>
<li>从右到左遍历下边界 <code>bottom</code>，然后 <code>bottom--</code></li>
<li>从下到上遍历左边界 <code>left</code>，然后 <code>left++</code></li>
</ol>
</li>
<li>每次遍历前都判断 <code>top &lt;= bottom &amp;&amp; left &lt;= right</code>，避免重复访问。</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>, right = matrix[<span class="number">0</span>].length - <span class="number">1</span>, bottom = matrix.length - <span class="number">1</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 1. 上边界从左到右</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left; j &lt;= right; j++) &#123;</span><br><span class="line">                res.add(matrix[top][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 右边界从上到下</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &lt;= bottom; i++) &#123;</span><br><span class="line">                res.add(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 下边界从右到左</span></span><br><span class="line">            <span class="keyword">if</span> (top &lt;= bottom) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right; j &gt;= left; j--) &#123;</span><br><span class="line">                    res.add(matrix[bottom][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                bottom--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 左边界从下到上</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bottom; i &gt;= top; i--) &#123;</span><br><span class="line">                    res.add(matrix[i][left]);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(mn)，其中 m 和 n 分别是输入矩阵的行数和列数。矩阵中的每个元素都要被访问一次。</p>
<p>空间复杂度：O(1)。除了输出数组以外，空间复杂度是常数。</p>
<h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a>48. 旋转图像</h2><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在<strong>原地</strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span><br><span class="line">输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == matrix.length == matrix[i].length</code></li>
<li><code>1 &lt;= n &lt;= 20</code></li>
<li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>顺时针旋转 90° &#x3D; <strong>先转置（transpose）</strong> + <strong>每行反转（reverse row）</strong></p>
<ol>
<li>转置矩阵：<ul>
<li>把 <code>matrix[i][j]</code> 和 <code>matrix[j][i]</code> 交换（只交换上三角部分，避免交换两次）</li>
<li>转置后行列互换</li>
</ul>
</li>
<li>每行反转：<ul>
<li>每一行首尾交换，得到最终顺时针 90° 的效果</li>
</ul>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> matrix.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 转置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; l; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 每行反转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; l / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[i][l - j - <span class="number">1</span>];</span><br><span class="line">                matrix[i][l - j - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n^2)，其中 n 是 matrix 的边长。对于每一次翻转操作，我们都需要枚举矩阵中一半的元素。</p>
<p>空间复杂度：O(1)。为原地翻转得到的原地旋转。</p>
<h2 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a>240. 搜索二维矩阵 II</h2><p>编写一个高效的算法来搜索 <code>*m* x *n*</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= n, m &lt;= 300</code></li>
<li><code>-109 &lt;= matrix[i][j] &lt;= 109</code></li>
<li>每行的所有元素从左到右升序排列</li>
<li>每列的所有元素从上到下升序排列</li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>当前位置元素 matrix[row][col] 与 target 比较</p>
<ul>
<li>如果 <code>matrix[row][col] == target</code> → 找到了，返回 <code>true</code></li>
<li>如果 <code>matrix[row][col] &gt; target</code> → 当前列都比 target 大，所以向 <strong>左</strong> 移动一列（<code>col--</code>）</li>
<li>如果 <code>matrix[row][col] &lt; target</code> → 当前行都比 target 小，所以向 <strong>下</strong> 移动一行（<code>row++</code>）</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从右上角开始</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (row &lt; m &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[row][col] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] &gt; target) &#123;</span><br><span class="line">                col--;  <span class="comment">// 向左移动</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                row++;  <span class="comment">// 向下移动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(m+n)。在搜索的过程中，如果我们没有找到 target，那么我们要么将 y 减少 1，要么将 x 增加 1。由于 (x,y) 的初始值分别为 (0,n−1)，因此 y 最多能被减少 n 次，x 最多能被增加 m 次，总搜索次数为 m+n。在这之后，x 和 y 就会超出矩阵的边界。</p>
<p>空间复杂度：O(1)。</p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h2><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p>
<p>图示两个链表在节点 <code>c1</code> 开始相交**：**</p>
<p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></a></p>
<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>
<p><strong>自定义评测：</strong></p>
<p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p>
<ul>
<li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li>
<li><code>listA</code> - 第一个链表</li>
<li><code>listB</code> - 第二个链表</li>
<li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li>
<li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li>
</ul>
<p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at &#x27;8&#x27;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br><span class="line">— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Intersected at &#x27;2&#x27;</span><br><span class="line">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：No intersection</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>listA</code> 中节点数目为 <code>m</code></li>
<li><code>listB</code> 中节点数目为 <code>n</code></li>
<li><code>1 &lt;= m, n &lt;= 3 * 104</code></li>
<li><code>1 &lt;= Node.val &lt;= 105</code></li>
<li><code>0 &lt;= skipA &lt;= m</code></li>
<li><code>0 &lt;= skipB &lt;= n</code></li>
<li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>
<li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li>
</ul>
<p>**进阶：**你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>
<p><strong>解题思路</strong></p>
<ul>
<li>两个指针 <code>pA</code> 和 <code>pB</code> 分别从 <code>headA</code> 和 <code>headB</code> 出发</li>
<li>当 <code>pA</code> 走到 A 链表的末尾，就跳到 B 链表的头继续走</li>
<li>当 <code>pB</code> 走到 B 链表的末尾，就跳到 A 链表的头继续走</li>
<li><strong>如果两条链表相交</strong>，那么它们会在某个节点相遇（就是交点）</li>
<li><strong>如果不相交</strong>，两个指针最终都会走到 <code>null</code>，同时结束</li>
</ul>
<p>这样做的原因：</p>
<ul>
<li>指针 pA 走过的路：<code>A 链表长度 + B 链表长度</code></li>
<li>指针 pB 走过的路：<code>B 链表长度 + A 链表长度</code></li>
<li>两者走的总长度相等，所以一定会在同一时刻到达交点或 null。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pA</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pB</span> <span class="operator">=</span> headB;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两指针走到同一个节点（可能是交点，也可能是 null）</span></span><br><span class="line">        <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">            pA = (pA == <span class="literal">null</span>) ? headB : pA.next;</span><br><span class="line">            pB = (pB == <span class="literal">null</span>) ? headA : pB.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pA;  <span class="comment">// 要么是交点，要么是 null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(m+n)，其中 m 和 n 是分别是链表 headA 和 headB 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次。</p>
<p>空间复杂度：O(1)。</p>
<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<p>**进阶：**链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
<p><strong>方法一：迭代</strong></p>
<p><strong>解题思路</strong></p>
<p>用三个指针：<code>prev</code>（前驱节点）、<code>curr</code>（当前节点）、<code>next</code>（暂存下一个节点）。</p>
<p>每次把 <code>curr.next</code> 指向 <code>prev</code>，然后整体往前推进。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;  <span class="comment">// 暂存下一个节点</span></span><br><span class="line">            curr.next = prev;           <span class="comment">// 反转指针</span></span><br><span class="line">            prev = curr;                <span class="comment">// 前驱前进</span></span><br><span class="line">            curr = next;                <span class="comment">// 当前前进</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev;  <span class="comment">// prev 指向新头</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<em>O</em>(<em>n</em>)，其中 <em>n</em> 是链表的长度。需要遍历链表一次。</li>
<li>空间复杂度：<em>O</em>(1)。</li>
</ul>
<p><strong>方法二：递归</strong></p>
<p><strong>解题思路</strong></p>
<p>从第二个节点开始递归反转后续链表，等反转完成后，将当前节点放到末尾。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归结束条件</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前节点放到后面</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是链表的长度。需要对链表的每个节点进行反转操作。</p>
<p>空间复杂度：O(n)，其中 n 是链表的长度。空间复杂度主要取决于递归调用的栈空间，最多为 n 层。</p>
<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a>234. 回文链表</h2><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点数目在范围<code>[1, 105]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
</ul>
<p>**进阶：**你能否用 <code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题？</p>
<p><strong>解题思路</strong></p>
<ol>
<li>找到链表中点（快慢指针）<ul>
<li>快指针一次走 2 步，慢指针一次走 1 步。</li>
<li>当快指针走到结尾，慢指针正好到中间。</li>
</ul>
</li>
<li>反转后半段链表<ul>
<li>从中点开始，把链表后半部分原地反转。</li>
</ul>
</li>
<li>比较前半段和后半段<ul>
<li>两个指针从链表头部和反转后的后半段同时往后走，逐个比较值是否相等。</li>
<li>比较完可选恢复链表（不要求可省略）。</li>
</ul>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 找中点（偶数时取左中点）</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 反转后半段</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">secondHalf</span> <span class="operator">=</span> reverse(slow.next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 比较两段</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> secondHalf;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (p2 != <span class="literal">null</span>) &#123;  <span class="comment">// 只需要遍历后半段</span></span><br><span class="line">            <span class="keyword">if</span> (p1.val != p2.val) &#123;</span><br><span class="line">                result = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 恢复链表</span></span><br><span class="line">        slow.next = reverse(secondHalf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转链表（迭代法）</span></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>, curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 指的是链表的大小。</li>
<li>空间复杂度：O(1)。我们只会修改原本链表中节点的指向，而在堆栈上的堆栈帧不超过 O(1)。</li>
</ul>
<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h2><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p>
<p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 104]</code></li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
<li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li>
</ul>
<p>**进阶：**你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p>
<p><strong>解题思路</strong></p>
<p>两个指针：</p>
<ul>
<li><code>slow</code> 每次走 1 步</li>
<li><code>fast</code> 每次走 2 步</li>
</ul>
<p>如果链表有环，那么 <code>fast</code> 最终会在环内追上 <code>slow</code>（就像跑道上跑步一样）。</p>
<p>如果链表无环，那么 <code>fast</code> 会先走到 <code>null</code>（链表尾）。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;       <span class="comment">// 慢指针走一步</span></span><br><span class="line">            fast = fast.next.next;  <span class="comment">// 快指针走两步</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;     <span class="comment">// 相遇 =&gt; 有环</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// fast 走到 null =&gt; 无环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(N)，其中 N 是链表中的节点数。</p>
<p>当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。</p>
<p>当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 N 轮。</p>
<p>空间复杂度：O(1)。我们只使用了两个指针的额外空间。</p>
<h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h2><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>
<p><strong>不允许修改</strong> 链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
<li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li>
</ul>
<p>**进阶：**你是否可以使用 <code>O(1)</code> 空间解决此题？</p>
<p><strong>解题思路</strong></p>
<ol>
<li>第一步：用快慢指针判断链表是否有环（跟 <code>hasCycle</code> 一样）。<ul>
<li><code>slow</code> 每次走一步</li>
<li><code>fast</code> 每次走两步</li>
<li>如果 <code>slow == fast</code>，说明有环</li>
<li>如果 <code>fast</code> 或 <code>fast.next</code> 为空，说明无环，直接返回 <code>null</code></li>
</ul>
</li>
<li>第二步：找到环的入口<ul>
<li>相遇后，让 一个指针从 <code>head</code> 出发，另一个指针从相遇点出发</li>
<li>两个指针都 每次走一步</li>
<li>它们再次相遇的点，就是 环的入口节点</li>
</ul>
</li>
</ol>
<p>为什么这样可行（数学推导）</p>
<p>设：</p>
<ul>
<li><code>a</code> &#x3D; 链表头到环入口的距离</li>
<li><code>b</code> &#x3D; 环入口到相遇点的距离</li>
<li><code>c</code> &#x3D; 相遇点到环入口的距离（即环剩余的长度）</li>
</ul>
<p>第一次相遇时：</p>
<ul>
<li><p><code>slow</code> 走了 <code>a + b</code></p>
</li>
<li><p><code>fast</code> 走了 <code>a + b + n(b + c)</code>（n 表示快指针多绕的圈数）</p>
</li>
<li><p>因为快指针速度是慢指针的 2 倍：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2(a + b) = a + b + n(b + c)</span><br><span class="line">a + b = n(b + c)</span><br><span class="line">a = n(b + c) - b</span><br><span class="line">a = (n - 1)(b + c) + c</span><br></pre></td></tr></table></figure>

<p>这说明：从头节点走 <code>a</code> 步，等价于从相遇点走 <code>c</code> 步（到达环入口）。</p>
</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 判断是否有环</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="comment">// 2. 寻找环入口</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">ptr</span> <span class="operator">=</span> head;</span><br><span class="line">                <span class="keyword">while</span> (ptr != slow) &#123;</span><br><span class="line">                    ptr = ptr.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 无环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(N)，其中 N 为链表中节点的数目。在最初判断快慢指针是否相遇时，slow 指针走过的距离不会超过链表的总长度；随后寻找入环点时，走过的距离也不会超过链表的总长度。因此，总的执行时间为 O(N)+O(N)&#x3D;O(N)。</p>
<p>空间复杂度：O(1)。我们只使用了 slow,fast,ptr 三个指针。</p>
<h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [], l2 = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>两个链表的节点数目范围是 <code>[0, 50]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li>创建一个 <strong>dummy 节点</strong>（值随便，比如 0），并用 <code>tail</code> 指向它。</li>
<li>遍历 <code>list1</code> 和 <code>list2</code>：<ul>
<li>比较 <code>list1.val</code> 和 <code>list2.val</code></li>
<li>取较小的节点挂到 <code>tail.next</code></li>
<li>移动对应的链表指针</li>
</ul>
</li>
<li>如果其中一个链表还没走完，把剩余部分直接接到 <code>tail.next</code></li>
<li>返回 <code>dummy.next</code>（因为 <code>dummy</code> 是占位用的）</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="comment">// 虚拟头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当两个链表都不为空时</span></span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="literal">null</span> &amp;&amp; list2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val &lt;= list2.val) &#123;</span><br><span class="line">                tail.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail.next;  <span class="comment">// 移动尾指针</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有一个链表没走完，直接接上</span></span><br><span class="line">        <span class="keyword">if</span> (list1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            tail.next = list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            tail.next = list2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， 因此 while 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 O(n+m)。</p>
<p>空间复杂度：O(1)。我们只需要常数的空间存放若干变量。</p>
<h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
<li>题目数据保证列表表示的数字不含前导零</li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li>创建虚拟头节点（dummy）简化链表操作，用 <code>curr</code> 指向当前处理位置。</li>
<li>初始化进位 <code>carry = 0</code>。</li>
<li>遍历 <code>l1</code> 和 <code>l2</code>：<ul>
<li>取当前节点的值（如果节点为 null，则值为 0）</li>
<li>计算和 <code>sum = x + y + carry</code></li>
<li>计算当前位的值 <code>sum % 10</code>，作为新节点的值</li>
<li>更新进位 <code>carry = sum / 10</code></li>
</ul>
</li>
<li>遍历结束后，如果 <code>carry &gt; 0</code>，要在链表末尾加一个节点。</li>
<li>返回 <code>dummy.next</code></li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (l1 == <span class="literal">null</span>) ? <span class="number">0</span> : l1.val;</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (l2 == <span class="literal">null</span>) ? <span class="number">0</span> : l2.val;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> x + y + carry;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            curr.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            curr = curr.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            curr.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(max(m,n))，其中 m 和 n 分别为两个链表的长度。我们要遍历两个链表的全部位置，而处理每个位置只需要 O(1) 的时间。</p>
<p>空间复杂度：O(1)。注意返回值不计入空间复杂度。</p>
<h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a>19. 删除链表的倒数第 N 个结点</h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中结点的数目为 <code>sz</code></li>
<li><code>1 &lt;= sz &lt;= 30</code></li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
<li><code>1 &lt;= n &lt;= sz</code></li>
</ul>
<p>**进阶：**你能尝试使用一趟扫描实现吗？</p>
<p><strong>解题思路</strong></p>
<p>虚拟头节点：加一个 <code>dummy</code>，指向 <code>head</code>，避免删除头节点时的特殊处理。</p>
<p>快慢指针：让 <code>fast</code> 先走 n+1 步，这样 <code>slow</code> 停在待删除节点的前一个位置。同时移动 <code>fast</code> 和 <code>slow</code>，直到 <code>fast</code> 到达链表末尾。</p>
<p>删除节点：<code>slow.next = slow.next.next</code></p>
<p>返回结果：返回 <code>dummy.next</code>（防止删除的是头节点）</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 快指针先走 n + 1 步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快慢指针同时移动</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除倒数第 n 个节点</span></span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<em>O</em>(<em>L</em>)，其中 <em>L</em> 是链表的长度。</li>
<li>空间复杂度：<em>O</em>(1)。</li>
</ul>
<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>dummy 节点</p>
<ul>
<li>避免处理 <code>head</code> 是空或需要交换第一个节点的特殊情况。</li>
<li>统一用 <code>prev.next</code> 来指向待交换的第一个节点。</li>
</ul>
<p>prev 节点</p>
<ul>
<li>指向当前待交换节点的前驱。</li>
<li>每次交换完成后，prev 移动到被交换后顺序靠后的节点（也就是 <code>first</code>）。</li>
</ul>
<p>while 条件</p>
<ul>
<li><code>prev.next != null &amp;&amp; prev.next.next != null</code> 保证有两个节点可以交换。</li>
</ul>
<p>交换过程</p>
<ul>
<li><code>first.next = second.next;</code> → 先把第一个节点指向第二个节点之后的节点。</li>
<li><code>second.next = first;</code> → 第二个节点指向第一个节点，实现反转。</li>
<li><code>prev.next = second;</code> → 前驱节点指向新的头节点。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个 dummy 节点，指向 head</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 用 prev 来跟踪待交换节点的前驱</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 当有两个节点可以交换时，循环</span></span><br><span class="line">        <span class="keyword">while</span> (prev.next != <span class="literal">null</span> &amp;&amp; prev.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 定位两个待交换节点</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> prev.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">second</span> <span class="operator">=</span> first.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 交换节点</span></span><br><span class="line">            first.next = second.next;</span><br><span class="line">            second.next = first;</span><br><span class="line">            prev.next = second;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移动 prev，准备下一轮交换</span></span><br><span class="line">            prev = first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 返回新的头节点</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h2 id="138-随机链表的复制"><a href="#138-随机链表的复制" class="headerlink" title="138. 随机链表的复制"></a>138. 随机链表的复制</h2><p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p>
<p>构造这个链表的 <strong>深拷贝</strong>。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。<strong>复制链表中的指针都不应指向原链表中的节点</strong> 。</p>
<p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p>
<p>返回复制链表的头节点。</p>
<p>用一个由 <code>n</code> 个节点组成的链表来表示输入&#x2F;输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p>
<ul>
<li><code>val</code>：一个表示 <code>Node.val</code> 的整数。</li>
<li><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为 <code>null</code> 。</li>
</ul>
<p>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [[1,1],[2,1]]</span><br><span class="line">输出：[[1,1],[2,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png" alt="img"></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [[3,null],[3,0],[3,null]]</span><br><span class="line">输出：[[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 1000</code></li>
<li><code>-104 &lt;= Node.val &lt;= 104</code></li>
<li><code>Node.random</code> 为 <code>null</code> 或指向链表中的节点。</li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li><p><strong>在每个原节点后面插入新节点</strong></p>
<ul>
<li>原链表：<code>A -&gt; B -&gt; C</code></li>
<li>插入新节点：<code>A -&gt; A&#39; -&gt; B -&gt; B&#39; -&gt; C -&gt; C&#39;</code></li>
<li>新节点 <code>A&#39;</code> 的 <code>val = A.val</code>，<code>next</code> 暂时指向原节点的 <code>next</code>。</li>
</ul>
</li>
<li><p><strong>复制 random 指针</strong></p>
<ul>
<li><p>对于原节点 <code>A</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (A.random != null)</span><br><span class="line">    A.next.random = A.random.next;</span><br></pre></td></tr></table></figure>
</li>
<li><p>因为 <code>A.next</code> 是新节点，<code>A.random.next</code> 正好是新节点对应的 random 指向。</p>
</li>
</ul>
</li>
<li><p><strong>拆分链表</strong></p>
<ul>
<li>将原链表和新链表拆开：<ul>
<li>原链表恢复：<code>A -&gt; B -&gt; C</code></li>
<li>新链表：<code>A&#39; -&gt; B&#39; -&gt; C&#39;</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 在每个节点后插入新节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(curr.val);</span><br><span class="line">            newNode.next = curr.next;</span><br><span class="line">            curr.next = newNode;</span><br><span class="line">            curr = newNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 复制 random 指针</span></span><br><span class="line">        curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr.random != <span class="literal">null</span>) &#123;</span><br><span class="line">                curr.next.random = curr.random.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 拆分链表</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">copyCurr</span> <span class="operator">=</span> dummy;</span><br><span class="line">        curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            copyCurr.next = curr.next;</span><br><span class="line">            copyCurr = copyCurr.next;</span><br><span class="line"></span><br><span class="line">            curr.next = curr.next.next;  <span class="comment">// 恢复原链表</span></span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是链表的长度。我们只需要遍历该链表三次。</p>
<p>读者们也可以自行尝试在计算拷贝节点的随机指针的同时计算其后继指针，这样只需要遍历两次。<br>空间复杂度：O(1)。注意返回值不计入空间复杂度。</p>
<h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a>148. 排序链表</h2><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [4,2,1,3]</span><br><span class="line">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [-1,5,3,4,0]</span><br><span class="line">输出：[-1,0,3,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 5 * 104]</code> 内</li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
</ul>
<p>**进阶：**你可以在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p>
<p><strong>解题思路</strong></p>
<ol>
<li><p>递归拆分链表</p>
<ul>
<li>用 快慢指针 找中点，将链表一分为二。</li>
<li>快指针一次走两步，慢指针一次走一步，快指针到尾时，慢指针就是中点。</li>
</ul>
</li>
<li><p>递归排序左右两部分</p>
</li>
<li><p>合并两个有序链表</p>
<ul>
<li>这个可以直接用 合并两个有序链表的题目 的方法。</li>
</ul>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归结束条件</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 快慢指针找中点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head, prev = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            prev = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev.next = <span class="literal">null</span>;  <span class="comment">// 断开链表</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 递归排序左右两部分</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> sortList(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l2</span> <span class="operator">=</span> sortList(slow);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 合并两个有序链表</span></span><br><span class="line">        <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                curr.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curr.next = (l1 == <span class="literal">null</span>) ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n log n)，其中 n 是链表的长度。</li>
<li>空间复杂度：O(log n)，其中 n 是链表的长度。空间复杂度主要取决于递归调用的栈空间。</li>
</ul>
<h2 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a>146. LRU 缓存</h2><p>请你设计并实现一个满足 LRU (最近最少使用) 缓存约束的数据结构。</p>
<p>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li>
<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li>
<li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li>
</ul>
<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache = new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;</span><br><span class="line">lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 1</span><br><span class="line">lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br><span class="line">lRUCache.get(2);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.get(3);    // 返回 3</span><br><span class="line">lRUCache.get(4);    // 返回 4</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= capacity &lt;= 3000</code></li>
<li><code>0 &lt;= key &lt;= 10000</code></li>
<li><code>0 &lt;= value &lt;= 105</code></li>
<li>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>这个 LRU 缓存题的核心是：</p>
<ul>
<li><strong>O(1)</strong> 查找 key → 哈希表（HashMap）</li>
<li><strong>O(1)</strong> 移动节点到最近使用位置 &amp; 删除最久未使用节点 → 双向链表（Doubly Linked List）</li>
</ul>
<p>哈希表负责 <strong>定位节点</strong>，双向链表负责 <strong>维护使用顺序</strong>。<br>新数据或最近访问的数据放在链表头，最久未使用的在链表尾。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> key, value;</span><br><span class="line">        Node prev, next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> k, <span class="type">int</span> val) &#123;</span><br><span class="line">            key = k;;</span><br><span class="line">            value = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> Node head, tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 伪头尾节点，方便处理边界</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);</span><br><span class="line">            map.put(key, node);</span><br><span class="line">            addToHead(node);</span><br><span class="line">            <span class="keyword">if</span> (map.size() &gt; capacity) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">removed</span> <span class="operator">=</span> removeTail();</span><br><span class="line">                map.remove(removed.key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助方法：把节点加到头部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助方法：移除节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助方法：把节点移动到头部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助方法：移除尾部节点</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">res</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：对于 <code>put</code> 和 <code>get</code> 都是 <em>O</em>(1)。</li>
<li>空间复杂度：<em>O</em>(capacity)，因为哈希表和双向链表最多存储 capacity+1 个元素。</li>
</ul>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h2><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,null,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
<p><strong>方法一：递归</strong></p>
<p><strong>解题思路</strong></p>
<p>略</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 方法一：递归法</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode node, List&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inorder(node.left, res);    <span class="comment">// 左</span></span><br><span class="line">        res.add(node.val);          <span class="comment">// 根</span></span><br><span class="line">        inorder(node.right, res);   <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</p>
<p>空间复杂度：O(n)。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</p>
<p><strong>方法二：迭代</strong></p>
<p><strong>解题思路</strong></p>
<p>略</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 不断往左子树走，并压栈</span></span><br><span class="line">            <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(curr);</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 弹出栈顶，访问节点</span></span><br><span class="line">            curr = stack.pop();</span><br><span class="line">            res.add(curr.val);</span><br><span class="line">            <span class="comment">// 转向右子树</span></span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</p>
<p>空间复杂度：O(n)。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</p>
<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h2><p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p>
<p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,null,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数量在 <code>[0, 104]</code> 区间内。</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>方法一：深度优先搜索</strong></p>
<p><strong>解题思路</strong></p>
<p>如果树为空，深度为 0；</p>
<p>否则最大深度 &#x3D; 1 + max(左子树深度, 右子树深度)。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 为二叉树节点的个数。每个节点在递归中只被遍历一次。</p>
<p>空间复杂度：O(h)，其中 h 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。</p>
<p><strong>方法二：广度优先搜索</strong></p>
<p><strong>解题思路</strong></p>
<p>用队列做层序遍历，每遍历一层，深度 +1。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 遍历当前层所有节点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            depth++;  <span class="comment">// 一层结束，深度 + 1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 为二叉树的节点个数。与方法一同样的分析，每个节点只会被访问一次。</p>
<p>空间复杂度：此方法空间的消耗取决于队列存储的元素数量，其在最坏情况下会达到 O(n)。</p>
<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h2><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围在 <code>[0, 100]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>方法一：递归</strong></p>
<p><strong>解题思路</strong></p>
<p>递归的思路是：对于每个节点，交换其左右子树，然后递归地交换其左右子树。基准条件是如果节点为空，直接返回。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode left;</span></span><br><span class="line"><span class="comment">*     TreeNode right;</span></span><br><span class="line"><span class="comment">*     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment">*     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment">*     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment">*         this.val = val;</span></span><br><span class="line"><span class="comment">*         this.left = left;</span></span><br><span class="line"><span class="comment">*         this.right = right;</span></span><br><span class="line"><span class="comment">*     &#125;</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果节点为空，则直接返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换左右子树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归翻转左右子树</span></span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 为二叉树节点的数目。我们会遍历二叉树中的每一个节点，对每个节点而言，我们在常数时间内交换其两棵子树。</p>
<p>空间复杂度：O(n)。使用的空间由递归栈的深度决定，它等于当前节点在二叉树中的高度。在平均情况下，二叉树的高度与节点个数为对数关系，即 O(log n)。而在最坏情况下，树形成链状，空间复杂度为 O(n)。</p>
<p><strong>方法二：迭代</strong></p>
<p><strong>解题思路</strong></p>
<p>迭代方法可以通过广度优先搜索（BFS）或深度优先搜索（DFS）来实现。这里我们使用队列来模拟广度优先搜索（BFS），逐层交换左右子树。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果节点为空，则直接返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用队列来进行广度优先遍历</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="comment">// 交换左右子树</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> curr.left;</span><br><span class="line">                curr.left = curr.right;</span><br><span class="line">                curr.right = temp;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将子节点加入队列</span></span><br><span class="line">                <span class="keyword">if</span> (curr.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(curr.left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (curr.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(curr.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，同「方法一」。<br>空间复杂度：这里需要用一个队列来维护节点，每个节点最多进队一次，出队一次，队列中最多不会超过 n 个点，故渐进空间复杂度为 O(n)。</p>
<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h2><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://pic.leetcode.cn/1698026966-JDYPDU-image.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://pic.leetcode.cn/1698027008-nPFLbM-image.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[1, 1000]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p>**进阶：**你可以运用递归和迭代两种方法解决这个问题吗？</p>
<p><strong>方法一：递归</strong></p>
<p><strong>解题思路</strong></p>
<p>我们可以定义一个辅助函数来比较两个子树是否对称。这个辅助函数接收两个节点作为参数，判断这两个节点是否镜像对称。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果根节点为空，是对称的</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归检查左右子树是否对称</span></span><br><span class="line">        <span class="keyword">return</span> isMirror(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查两个树是否镜像对称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isMirror</span><span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果两个节点都为空，是对称的</span></span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span> &amp;&amp; t2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果只有一个为空，或者值不同，不是对称的</span></span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span> || t2 == <span class="literal">null</span> || t1.val != t2.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归检查左右子树是否对称</span></span><br><span class="line">        <span class="keyword">return</span> isMirror(t1.left, t2.right) &amp;&amp; isMirror(t1.right, t2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：这里遍历了这棵树，渐进时间复杂度为 O(n)。<br>空间复杂度：这里的空间复杂度和递归使用的栈空间有关，这里递归层数不超过 n，故渐进空间复杂度为 O(n)。</p>
<p><strong>方法二：迭代</strong></p>
<p><strong>解题思路</strong></p>
<p>迭代方法可以通过使用队列来实现广度优先搜索（BFS）模拟递归过程。我们逐层遍历树，检查左右子树是否对称。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果根节点为空，是对称的</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用队列模拟广度优先搜索</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root.left);</span><br><span class="line">        queue.offer(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">t1</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">t2</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果两个节点都为空，继续检查下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (t1 == <span class="literal">null</span> &amp;&amp; t2 == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果只有一个节点为空，或者值不相等，不是对称的</span></span><br><span class="line">            <span class="keyword">if</span> (t1 == <span class="literal">null</span> || t2 == <span class="literal">null</span> || t1.val != t2.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将子节点按对称顺序加入队列</span></span><br><span class="line">            queue.offer(t1.left);</span><br><span class="line">            queue.offer(t2.right);</span><br><span class="line">            queue.offer(t1.right);</span><br><span class="line">            queue.offer(t2.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，同「方法一」。<br>空间复杂度：这里需要用一个队列来维护节点，每个节点最多进队一次，出队一次，队列中最多不会超过 n 个点，故渐进空间复杂度为 O(n)。</p>
<h2 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a>543. 二叉树的直径</h2><p>给你一棵二叉树的根节点，返回该树的 <strong>直径</strong> 。</p>
<p>二叉树的 <strong>直径</strong> 是指树中任意两个节点之间最长路径的 <strong>长度</strong> 。这条路径可能经过也可能不经过根节点 <code>root</code> 。</p>
<p>两节点之间路径的 <strong>长度</strong> 由它们之间边数表示。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5]</span><br><span class="line">输出：3</span><br><span class="line">解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[1, 104]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>为了计算二叉树的直径，我们可以通过深度优先搜索（DFS）来实现。对于每个节点，直径可能是通过该节点的路径，即左子树的深度加上右子树的深度。这个值可能是当前节点的直径。然后我们递归计算左右子树的直径，最终返回树的最大直径。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">diameter</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 记录树的最大直径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        depth(root);    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> diameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算树的深度并更新</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">depth</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果节点为空，深度为 0</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归左右子树的深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> depth(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> depth(node.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新直径</span></span><br><span class="line">        diameter = Math.max(diameter, leftDepth + rightDepth);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回该节点的深度</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 为二叉树的节点数，即遍历一棵二叉树的时间复杂度，每个结点只被访问一次。</p>
<p>空间复杂度：O(h)，其中 h 为二叉树的高度。由于递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，而递归的深度显然为二叉树的高度，并且每次递归调用的函数里又只用了常数个变量，所以所需空间复杂度为 O(h) 。</p>
<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a>102. 二叉树的层序遍历</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：[[3],[9,20],[15,7]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 2000]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<p><strong>解题思路</strong></p>
<ul>
<li>使用队列：队列是 BFS 的核心数据结构，它可以帮助我们按照层级访问节点。</li>
<li>遍历过程：<ol>
<li>初始时将根节点加入队列。</li>
<li>从队列中取出节点并访问。</li>
<li>如果当前节点有左子节点或右子节点，将它们加入队列。</li>
<li>继续这一过程，直到队列为空。</li>
</ol>
</li>
<li>每一层的节点：每次从队列中取出所有当前层的节点，访问它们并记录值，然后将其子节点加入队列。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个队列来进行 BFS</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();  <span class="comment">// 当前层的节点数</span></span><br><span class="line">            List&lt;Integer&gt; currentLevel = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                currentLevel.add(currentNode.val);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 把当前节点的左右子树加入到队列</span></span><br><span class="line">                <span class="keyword">if</span> (currentNode.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(currentNode.left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (currentNode.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(currentNode.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.add(currentLevel);  <span class="comment">// 将当前层的节点值加入到结果</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 O(n)。</p>
<p>空间复杂度：队列中元素的个数不超过 n 个，故渐进空间复杂度为 O(n)。</p>
<h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a>108. 将有序数组转换为二叉搜索树</h2><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 平衡 二叉搜索树。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-10,-3,0,5,9]</span><br><span class="line">输出：[0,-3,9,-10,null,5]</span><br><span class="line">解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3]</span><br><span class="line">输出：[3,1]</span><br><span class="line">解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li>选择中位数作为根节点：因为数组是升序排列的，选择中位数作为根节点可以确保树的左右两部分尽可能平衡。<ul>
<li>如果数组的长度是奇数，选择中间元素。</li>
<li>如果数组的长度是偶数，选择中间偏左的元素（例如，索引为 <code>(start + end) / 2</code>）。</li>
</ul>
</li>
<li>递归构建：通过递归地对数组的左半部分和右半部分重复上述操作，依次构建出整个树。</li>
<li>终止条件：当数组为空时，返回 <code>null</code>，表示树的子树为空。</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归的终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择中位数作为根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归构建左子树和右子树</span></span><br><span class="line">        node.left = buildTree(nums, start, mid - <span class="number">1</span>);</span><br><span class="line">        node.right = buildTree(nums, mid + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是数组的长度。每个节点都会被访问一次，并且每次都进行常数时间的操作（选择中位数和递归调用）。</p>
<p>空间复杂度：O(log n)，这是递归调用栈的最大深度。在最坏情况下（数组的长度为 n），递归的深度为 log(n)。</p>
<h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a>98. 验证二叉搜索树</h2><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>有效</strong> 二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含 <strong>严格小于</strong> 当前节点的数。</li>
<li>节点的右子树只包含 <strong>严格大于</strong> 当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [5,1,4,null,null,3,6]</span><br><span class="line">输出：false</span><br><span class="line">解释：根节点的值是 5 ，但是右子节点的值是 4 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围在<code>[1, 104]</code> 内</li>
<li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>我们可以通过递归来检查每个节点是否满足二叉搜索树的性质。为了避免重复检查，我们可以将每个节点的值限定在一个合法的区间内。递归过程中，我们可以利用以下规则：</p>
<ul>
<li>对于当前节点，左子树的所有节点值必须在 <code>(min, root.val)</code> 区间内，右子树的所有节点值必须在 <code>(root.val, max)</code> 区间内。</li>
<li>对于每一个节点，都需要检查其左子树和右子树是否满足这些条件。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始时，允许最小值为负无穷，最大值为正无穷</span></span><br><span class="line">        <span class="keyword">return</span> isValidBSTHelper(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助递归函数，检查根节点在 [min, max] 范围内</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValidBSTHelper</span><span class="params">(TreeNode node, <span class="type">long</span> min, <span class="type">long</span> max)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点为空，返回 true</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前值不在 [min, max] 范围内，返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (node.val &lt;= min || node.val &gt;= max) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归检查左右子树</span></span><br><span class="line">        <span class="keyword">return</span> isValidBSTHelper(node.left, min, node.val) &amp;&amp; isValidBSTHelper(node.right, node.val, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是二叉树的节点数。每个节点都被访问一次，且每次访问的操作是常数时间的。</p>
<p>空间复杂度：O(h)，其中 h 是二叉树的高度。最坏情况下（树是链表形式），空间复杂度为 O(n)；最好的情况下（树是平衡的），空间复杂度为 O(log n)，这与递归的栈深度有关。</p>
<h2 id="230-二叉搜索树中第-K-小的元素"><a href="#230-二叉搜索树中第-K-小的元素" class="headerlink" title="230. 二叉搜索树中第 K 小的元素"></a>230. 二叉搜索树中第 K 小的元素</h2><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 小的元素（从 1 开始计数）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,1,4,null,2], k = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中的节点数为 <code>n</code> 。</li>
<li><code>1 &lt;= k &lt;= n &lt;= 104</code></li>
<li><code>0 &lt;= Node.val &lt;= 104</code></li>
</ul>
<p>**进阶：**如果二叉搜索树经常被修改（插入&#x2F;删除操作）并且你需要频繁地查找第 <code>k</code> 小的值，你将如何优化算法？</p>
<p><strong>解题思路</strong></p>
<ol>
<li>中序遍历：中序遍历二叉搜索树会按升序访问节点。因此，我们可以通过中序遍历来依次访问节点，直到找到第 <code>k</code> 个节点。</li>
<li>递归或迭代实现：我们可以使用递归或迭代的方式来实现中序遍历。每遍历一个节点，就减小 <code>k</code>，当 <code>k</code> 减到 0 时，当前节点就是我们要找的第 <code>k</code> 小元素。</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 用于记录已经遍历的节点数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 用于存储第 k 小的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 开始中序遍历</span></span><br><span class="line">        inOrder(root, k);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode node, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归遍历子树</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问左子树</span></span><br><span class="line">        inOrder(node.left, k);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问当前节点</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">            result = node.val;  <span class="comment">// 记录第 k 小的值</span></span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// 提前返回，避免继续遍历</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问右子树</span></span><br><span class="line">        inOrder(node.right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是树的节点数。最坏情况下，我们需要遍历所有节点，直到找到第 k 小的元素。</p>
<p>空间复杂度：O(h)，其中 h 是二叉树的高度。由于递归栈的深度等于树的高度，在最坏情况下（树为链状），空间复杂度为 O(n)。</p>
<h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a>199. 二叉树的右视图</h2><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p><strong>示例 1：</strong></p>
<p>**输入：**root &#x3D; [1,2,3,null,5,null,4]</p>
<p><strong>输出：</strong>[1,3,4]</p>
<p><strong>解释：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2024/11/24/tmpd5jn43fs-1.png" alt="img"></p>
<p><strong>示例 2：</strong></p>
<p>**输入：**root &#x3D; [1,2,3,4,null,null,null,5]</p>
<p><strong>输出：</strong>[1,3,4,5]</p>
<p><strong>解释：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2024/11/24/tmpkpe40xeh-1.png" alt="img"></p>
<p><strong>示例 3：</strong></p>
<p>**输入：**root &#x3D; [1,null,3]</p>
<p><strong>输出：</strong>[1,3]</p>
<p><strong>示例 4：</strong></p>
<p>**输入：**root &#x3D; []</p>
<p><strong>输出：</strong>[]</p>
<p><strong>提示:</strong></p>
<ul>
<li>二叉树的节点个数的范围是 <code>[0,100]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li>层次遍历：从树的最上面一层开始，逐层遍历树。我们可以使用 BFS 来实现这一点。</li>
<li>每层的最后一个节点：对于每一层，我们将所有节点放入队列中，并逐个访问。每当我们遍历完当前层时，队列中的最后一个节点就是当前层从右侧看到的节点。</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列用于 BFS</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历当前层的所有节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果是当前层的最后一个节点，加入结果</span></span><br><span class="line">                <span class="keyword">if</span> (i == size - <span class="number">1</span>) &#123;</span><br><span class="line">                    result.add(node.val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将左右子树加入到队列</span></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度 : O(n)。 每个节点最多进队列一次，出队列一次，因此广度优先搜索的复杂度为线性。</p>
<p>空间复杂度 : O(n)。每个节点最多进队列一次，所以队列长度最大不不超过 n，所以这里的空间代价为 O(n)。</p>
<h2 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a>114. 二叉树展开为链表</h2><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li>
<li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,5,3,4,null,6]</span><br><span class="line">输出：[1,null,2,null,3,null,4,null,5,null,6]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中结点数在范围 <code>[0, 2000]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p>**进阶：**你可以使用原地算法（<code>O(1)</code> 额外空间）展开这棵树吗？</p>
<p><strong>解题思路</strong></p>
<ol>
<li>递归方法：可以采用递归的方式来进行展开。我们可以先遍历根节点，然后递归地展开左子树和右子树，最终将树的每个子树与其兄弟节点串联起来。</li>
<li>原地展开：我们可以在递归过程中直接修改 <code>root</code> 的 <code>left</code> 和 <code>right</code> 指针，而不使用额外的空间（如栈或队列）。</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归展开左右子树</span></span><br><span class="line">        flatten(root.left);</span><br><span class="line">        flatten(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存右子树，准备连接</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tempRight</span> <span class="operator">=</span> root.right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将左子树变为右子树</span></span><br><span class="line">        root.right = root.left;</span><br><span class="line">        root.left = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到新的右子树的最后一个节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (curr.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将原来的右子树连接到最后一个节点的右侧</span></span><br><span class="line">        curr.right = tempRight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是树的节点数。每个节点都被访问一次。</p>
<p>空间复杂度：O(h)，其中 h 是树的高度。递归栈的空间复杂度取决于树的深度，在最坏情况下为 O(n)（当树是线性的）。</p>
<h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h2><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p>
<p><strong>示例 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</span><br><span class="line">输出: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: preorder = [-1], inorder = [-1]</span><br><span class="line">输出: [-1]</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= preorder.length &lt;= 3000</code></li>
<li><code>inorder.length == preorder.length</code></li>
<li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li>
<li><code>preorder</code> 和 <code>inorder</code> 均 <strong>无重复</strong> 元素</li>
<li><code>inorder</code> 均出现在 <code>preorder</code></li>
<li><code>preorder</code> <strong>保证</strong> 为二叉树的前序遍历序列</li>
<li><code>inorder</code> <strong>保证</strong> 为二叉树的中序遍历序列</li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li><p>前序遍历的第一个元素就是树的根节点。</p>
</li>
<li><p>在中序遍历中找到根节点的位置，将中序遍历分为左右两部分：</p>
<ul>
<li><p>左边部分是左子树的节点。</p>
</li>
<li><p>右边部分是右子树的节点。</p>
</li>
</ul>
</li>
<li><p>递归地构建左子树和右子树。</p>
</li>
<li><p>使用递归的方式进行树的构建，并且通过索引来避免重复遍历。</p>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buildTreeHelper(preorder, inorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">buildTreeHelper</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder, <span class="type">int</span> preStart, <span class="type">int</span> preEnd, <span class="type">int</span> inStart, <span class="type">int</span> inEnd)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归出口</span></span><br><span class="line">        <span class="keyword">if</span> (preStart &gt; preEnd || inStart &gt; inEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根节点是 preorder 的第一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> preorder[preStart];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到根节点在 inorder 的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> inStart; i &lt;= inEnd; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == rootVal) &#123;</span><br><span class="line">                rootIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算左子树的大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> rootIndex - inStart;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归构建左右子树</span></span><br><span class="line">        root.left = buildTreeHelper(preorder, inorder, preStart + <span class="number">1</span>, preStart + leftSize, inStart, rootIndex - <span class="number">1</span>);</span><br><span class="line">        root.right = buildTreeHelper(preorder, inorder, preStart + leftSize + <span class="number">1</span>, preEnd, rootIndex + <span class="number">1</span>, inEnd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是树中的节点个数。</p>
<p>空间复杂度：O(n)，除去返回的答案需要的 O(n) 空间之外，我们还需要使用 O(n) 的空间存储哈希映射，以及 O(h)（其中 h 是树的高度）的空间表示递归时栈空间。这里 h&lt;n，所以总空间复杂度为 O(n)。</p>
<h2 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a>437. 路径总和 III</h2><p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p>
<p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8</span><br><span class="line">输出：3</span><br><span class="line">解释：和等于 8 的路径有 3 条，如图所示。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li>二叉树的节点个数的范围是 <code>[0,1000]</code></li>
<li><code>-109 &lt;= Node.val &lt;= 109</code> </li>
<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li>从根节点开始，递归遍历二叉树，遍历到每个节点时，检查以该节点为起点的路径和。</li>
<li>在递归过程中，如果当前路径和等于 <code>targetSum</code>，则记录该路径。</li>
<li>对每个节点，递归地计算从该节点向下的路径和，同时递归左右子树。</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归遍历二叉树</span></span><br><span class="line">        <span class="keyword">return</span> helper(root, (<span class="type">long</span>) targetSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每一个节点，从该节点出发，统计路径和为 targetSum 的路径数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">helper</span><span class="params">(TreeNode node, <span class="type">long</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算从当前节点出发的路径中，路径和为 targetSum 的个数</span></span><br><span class="line">        <span class="keyword">return</span> countPaths(node, targetSum) + helper(node.left, targetSum) + helper(node.right, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算从当前节点出发，路径和为 targetSum 的路径数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countPaths</span><span class="params">(TreeNode node, <span class="type">long</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点的路径和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">long</span>) node.val == targetSum) &#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归计算左右子树</span></span><br><span class="line">        count += countPaths(node.left, targetSum - node.val);</span><br><span class="line">        count += countPaths(node.right, targetSum - node.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n^2)，其中 n 为该二叉树节点的个数。对于每一个节点，求以该节点为起点的路径数目时，则需要遍历以该节点为根节点的子树的所有节点，因此求该路径所花费的最大时间为 O(n)，我们会对每个节点都求一次以该节点为起点的路径数目，因此时间复杂度为 O(n^2)。</p>
<p>空间复杂度：O(n)，考虑到递归需要在栈上开辟空间。</p>
<h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2], p = 1, q = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[2, 105]</code> 内。</li>
<li><code>-109 &lt;= Node.val &lt;= 109</code></li>
<li>所有 <code>Node.val</code> <code>互不相同</code> 。</li>
<li><code>p != q</code></li>
<li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li>
</ul>
<p><strong>解题思路</strong></p>
<p>这个题是经典的「最近公共祖先 LCA」问题，可以用递归轻松解决。核心思想是：</p>
<ul>
<li>如果当前节点是 <strong>null</strong>，说明没找到，返回 <code>null</code>。</li>
<li>如果当前节点是 <strong>p 或 q</strong>，那么这个节点本身就是答案的一部分，直接返回它。</li>
<li>否则就分别递归左右子树：<ul>
<li>如果左右子树都能找到（返回非空），说明 p 和 q 分别在左右两边，那么当前节点就是最近公共祖先；</li>
<li>如果只有一边找到，说明 p 和 q 都在这一边，直接返回这一边；</li>
<li>如果都没找到，返回 <code>null</code>。</li>
</ul>
</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前节点是 p 或 q，当前节点是公共祖先</span></span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// p 和 q 分别在左右子树，当前节点是公共祖先</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果只有一边非空，返回非空的那一边</span></span><br><span class="line">        <span class="keyword">return</span> left == <span class="literal">null</span> ? right : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是二叉树的节点数。二叉树的所有节点有且只会被访问一次，因此时间复杂度为 O(n)。</p>
<p>空间复杂度：O(n) ，其中 n 是二叉树的节点数。递归调用的栈深度取决于二叉树的高度，二叉树最坏情况下为一条链，此时高度为 n，因此空间复杂度为 O(n)。</p>
<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h2><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;],</span><br><span class="line">  [&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;0&#x27;],</span><br><span class="line">  [&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;],</span><br><span class="line">  [&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;],</span><br><span class="line">  [&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;],</span><br><span class="line">  [&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;],</span><br><span class="line">  [&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;1&#x27;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 300</code></li>
<li><code>grid[i][j]</code> 的值为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li>
</ul>
<p><strong>解题思路</strong></p>
<ul>
<li>遍历整个二维数组；</li>
<li>当遇到 <code>&#39;1&#39;</code>（陆地）时，就从这里开始 <strong>DFS 或 BFS</strong> 把整块岛屿淹没（把相邻的 <code>&#39;1&#39;</code> 都变成 <code>&#39;0&#39;</code>）；</li>
<li>每次淹没完成，说明找到了一座岛屿，计数器 <code>count++</code>；</li>
<li>遍历完成后，<code>count</code> 就是岛屿数量。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    dfs(grid, i, j);  <span class="comment">// 把这一整块岛屿淹没</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 越界 or 水，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || grid[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记为已访问（淹没）</span></span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归访问上下左右</span></span><br><span class="line">        dfs(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(m * n)，其中 m 和 n 分别为行数和列数。</p>
<p>空间复杂度：O(m * n)，在最坏情况下，整个网格均为陆地，深度优先搜索的深度达到 m * n。</p>
<h2 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994. 腐烂的橘子"></a>994. 腐烂的橘子</h2><p>在给定的 <code>m x n</code> 网格 <code>grid</code> 中，每个单元格可以有以下三个值之一：</p>
<ul>
<li>值 <code>0</code> 代表空单元格；</li>
<li>值 <code>1</code> 代表新鲜橘子；</li>
<li>值 <code>2</code> 代表腐烂的橘子。</li>
</ul>
<p>每分钟，腐烂的橘子 <strong>周围 4 个方向上相邻</strong> 的新鲜橘子都会腐烂。</p>
<p>返回 <em>直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 <code>-1</code></em> 。</p>
<p><strong>示例 1：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/oranges.png" alt="img"></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[2,1,1],[1,1,0],[0,1,1]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[2,1,1],[0,1,1],[1,0,1]]</span><br><span class="line">输出：-1</span><br><span class="line">解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个方向上。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[0,2]]</span><br><span class="line">输出：0</span><br><span class="line">解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 10</code></li>
<li><code>grid[i][j]</code> 仅为 <code>0</code>、<code>1</code> 或 <code>2</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>遍历整个 <code>grid</code>：</p>
<ul>
<li>把所有腐烂的橘子（值为 2）放进队列，作为 BFS 的起始点；</li>
<li>统计新鲜橘子的数量。</li>
</ul>
<p>从队列中一层一层地扩散（每一层扩散代表一分钟），将相邻的新鲜橘子变为腐烂，并入队。</p>
<p>BFS 结束后：</p>
<ul>
<li>如果没有剩下新鲜橘子，返回扩散的分钟数；</li>
<li>如果还有新鲜橘子没被腐烂，返回 <code>-1</code>。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">orangesRotting</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fresh</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 初始化，记录所有烂橘子的位置 &amp; 统计新鲜橘子数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;i, j&#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    fresh++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果一开始就没有新鲜橘子，直接返回 0</span></span><br><span class="line">        <span class="keyword">if</span> (fresh == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">minutes</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. BFS 扩散</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            minutes++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; size; k++) &#123;</span><br><span class="line">                <span class="type">int</span>[] curr = queue.poll();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span>[] d : dirs) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">ni</span> <span class="operator">=</span> curr[<span class="number">0</span>] + d[<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">nj</span> <span class="operator">=</span> curr[<span class="number">1</span>] + d[<span class="number">1</span>];</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (ni &gt;= <span class="number">0</span> &amp;&amp; ni &lt; m &amp;&amp; nj &gt;= <span class="number">0</span> &amp;&amp; nj &lt; n &amp;&amp; grid[ni][nj] == <span class="number">1</span>) &#123;</span><br><span class="line">                        grid[ni][nj] = <span class="number">2</span>;  <span class="comment">// 新鲜橘子腐烂</span></span><br><span class="line">                        fresh--;</span><br><span class="line">                        queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;ni, nj&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 检查是否还有新鲜橘子</span></span><br><span class="line">        <span class="keyword">return</span> fresh == <span class="number">0</span> ? minutes : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(m * n)。即进行一次广度优先搜索的时间，其中 m,n 分别为 grid 的行数与列数。</p>
<p>空间复杂度：O(m * n)。需要额外的 dis 数组记录每个新鲜橘子被腐烂的最短时间，大小为 O(nm)，且广度优先搜索中队列里存放的状态最多不会超过 m * n 个，最多需要 O(m * n) 的空间，所以最后的空间复杂度为 O(m * n)。</p>
<h2 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a>207. 课程表</h2><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p>
<p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code> 。</p>
<ul>
<li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li>
</ul>
<p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">输出：true</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0],[0,1]]</span><br><span class="line">输出：false</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= numCourses &lt;= 2000</code></li>
<li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li>
<li><code>prerequisites[i].length == 2</code></li>
<li><code>0 &lt;= ai, bi &lt; numCourses</code></li>
<li><code>prerequisites[i]</code> 中的所有课程对 <strong>互不相同</strong></li>
</ul>
<p><strong>解题思路</strong></p>
<p>BFS, Kahn 算法：</p>
<ul>
<li>用入度数组统计每门课程的依赖数；</li>
<li>将入度为 0 的课程加入队列；</li>
<li>每次出队一门课，就把它指向的课程的入度减一，如果某课程入度为 0，就入队；</li>
<li>如果最终出队的课程数等于总课程数，则说明能完成。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">        <span class="comment">// 建图</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] indegree = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="comment">// prerequisites[i] = [a, b]，表示 b -&gt; a</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] p : prerequisites) &#123;</span><br><span class="line">            graph.get(p[<span class="number">1</span>]).add(p[<span class="number">0</span>]);</span><br><span class="line">            indegree[p[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将入度为 0 的课程加入到队列</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 统计能学完的课程数</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">course</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            count++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i : graph.get(course)) &#123;</span><br><span class="line">                indegree[i]--;</span><br><span class="line">                <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.offer(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度: O(n+m)，其中 n 为课程数，m 为先修课程的要求数。这其实就是对图进行广度优先搜索的时间复杂度。</p>
<p>空间复杂度: O(n+m)。题目中是以列表形式给出的先修课程关系，为了对图进行广度优先搜索，我们需要存储成邻接表的形式，空间复杂度为 O(n+m)。在广度优先搜索的过程中，我们需要最多 O(n) 的队列空间（迭代）进行广度优先搜索。因此总空间复杂度为 O(n+m)。</p>
<h2 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a>208. 实现 Trie (前缀树)</h2><p><strong>Trie</strong>（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。</p>
<p>请你实现 Trie 类：</p>
<ul>
<li><code>Trie()</code> 初始化前缀树对象。</li>
<li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li>
<li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li>
<li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span><br><span class="line">[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span><br><span class="line">输出</span><br><span class="line">[null, null, true, false, true, null, true]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">Trie trie = new Trie();</span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   // 返回 True</span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 False</span><br><span class="line">trie.startsWith(&quot;app&quot;); // 返回 True</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 True</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li>
<li><code>word</code> 和 <code>prefix</code> 仅由小写英文字母组成</li>
<li><code>insert</code>、<code>search</code> 和 <code>startsWith</code> 调用次数 <strong>总计</strong> 不超过 <code>3 * 104</code> 次</li>
</ul>
<p><strong>解题思路</strong></p>
<p>每个节点要保存 <strong>26 个子节点指针</strong>（对应 <code>a-z</code>），也可以用 <code>Map&lt;Character, TrieNode&gt;</code>。</p>
<p>每个节点要有一个标志，表示“是否是某个完整单词的结尾”。</p>
<p>插入时逐字符往下建，搜索时逐字符往下走。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义节点</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">        TrieNode[] children;  <span class="comment">// 存 26 个节点</span></span><br><span class="line">        <span class="type">boolean</span> isEnd;        <span class="comment">// 标记是否为某个单词结尾</span></span><br><span class="line"></span><br><span class="line">        TrieNode() &#123;</span><br><span class="line">            children = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">            isEnd = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();  <span class="comment">// 初始化根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>;  <span class="comment">// 计算子节点索引</span></span><br><span class="line">            <span class="keyword">if</span> (node.children[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.children[i] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            node = node.children[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.isEnd = <span class="literal">true</span>;  <span class="comment">// 单词结束位置打标</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 没路了</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node = node.children[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node.isEnd;  <span class="comment">// 必须到结尾且 isEnd = true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : prefix.toCharArray()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node = node.children[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 只要路径存在即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：初始化为 O(1)，其余操作为 O(∣S∣)，其中 ∣S∣ 是每次插入或查询的字符串的长度。</p>
<p>空间复杂度：O(∣T∣⋅Σ)，其中 ∣T∣ 为所有插入字符串的长度之和，Σ 为字符集的大小，本题 Σ&#x3D;26。</p>
<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1]</span><br><span class="line">输出：[[0,1],[1,0]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 6</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
</ul>
<p><strong>解题思路</strong></p>
<p>使用一个 <code>List&lt;Integer&gt;</code> 保存当前路径（即正在构造的排列）。</p>
<p>用一个 <code>boolean[] used</code> 数组标记 <code>nums[i]</code> 是否已经被选择。</p>
<p>如果路径长度等于 <code>nums.length</code>，就把它加入答案。</p>
<p>否则枚举所有数字，把没用过的数字加入，递归下去，再回溯（撤销选择）。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        backtrack(nums, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), used, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, List&lt;Integer&gt; path, <span class="type">boolean</span>[] used, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));  <span class="comment">// 找到一个序列</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;  <span class="comment">// 已经用过，跳过</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 选择 nums[i]</span></span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line"></span><br><span class="line">            backtrack(nums, path, used, result);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n × n!)，其中 n 为序列的长度。</p>
<p>空间复杂度：O(n)，其中 n 为序列的长度。除答案数组以外，递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，这里可知递归调用深度为 O(n)。</p>
<h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a>78. 子集</h2><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li>
</ul>
<p><strong>解题思路</strong></p>
<p>每个元素都有 <strong>选</strong> 或 <strong>不选</strong> 两种可能。</p>
<p>用回溯（DFS）保证不会生成重复子集。</p>
<p>一开始就把当前 path 加入结果，所以会自然包含 <code>[]</code>（空集）。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtrack(nums, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            path.add(nums[i]);                     <span class="comment">// 选择</span></span><br><span class="line">            backtrack(nums, i + <span class="number">1</span>, path, result);  <span class="comment">// 进入下一层</span></span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);          <span class="comment">// 撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n · 2^n)，其中 n 为数组长度。每个元素都有选或不选两种情况，因此一共会生成 2^n 个子集；而在构造每个子集时需要 O(n) 的时间进行拷贝。</p>
<p>空间复杂度：O(n)，递归调用过程中使用的栈空间与当前路径存储所需的空间，最多为 O(n)。输出结果本身不计入额外空间复杂度。</p>
<h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h2><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="https://pic.leetcode.cn/1752723054-mfIHZs-image.png" alt="img"></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;2&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= digits.length &lt;= 4</code></li>
<li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li>
</ul>
<p><strong>解题思路</strong></p>
<p>先用一个数组或 <code>Map&lt;Character, String&gt;</code> 建立映射</p>
<p>回溯递归</p>
<ul>
<li>从字符串的第 <code>index</code> 个数字开始，取出它对应的所有字母；</li>
<li>把每个字母加入当前组合 <code>path</code>；</li>
<li>然后递归处理下一个数字；</li>
<li>当路径长度等于 <code>digits.length</code> 时，说明形成了一个完整的组合，加入结果。</li>
</ul>
<p>如果输入 <code>digits</code> 为空字符串，直接返回空列表。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] MAPPING = &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>,     <span class="comment">// 0</span></span><br><span class="line">        <span class="string">&quot;&quot;</span>,     <span class="comment">// 1</span></span><br><span class="line">        <span class="string">&quot;abc&quot;</span>,  <span class="comment">// 2</span></span><br><span class="line">        <span class="string">&quot;def&quot;</span>,  <span class="comment">// 3</span></span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>,  <span class="comment">// 4</span></span><br><span class="line">        <span class="string">&quot;jkl&quot;</span>,  <span class="comment">// 5</span></span><br><span class="line">        <span class="string">&quot;mno&quot;</span>,  <span class="comment">// 6</span></span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>, <span class="comment">// 7</span></span><br><span class="line">        <span class="string">&quot;tuv&quot;</span>,  <span class="comment">// 8</span></span><br><span class="line">        <span class="string">&quot;wxyz&quot;</span>  <span class="comment">// 9</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="literal">null</span> || digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        backtrack(digits, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(), result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(String digits, <span class="type">int</span> index, StringBuilder path, List&lt;String&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.length()) &#123;</span><br><span class="line">            result.add(path.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">letters</span> <span class="operator">=</span> MAPPING[digits.charAt(index) - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : letters.toCharArray()) &#123;</span><br><span class="line">            path.append(c);                             <span class="comment">// 选择一个字母</span></span><br><span class="line">            backtrack(digits, index + <span class="number">1</span>, path, result); <span class="comment">// 递归处理下一个数字</span></span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);       <span class="comment">// 撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(3^m * 4^n)，其中 m 是输入中对应 3 个字母的数字个数（包括数字 2、3、4、5、6、8），n 是输入中对应 4 个字母的数字个数（包括数字 7、9），m+n 是输入数字的总个数。当输入包含 m 个对应 3 个字母的数字和 n 个对应 4 个字母的数字时，不同的字母组合一共有 3^m * 4^n 种，需要遍历每一种字母组合。</p>
<p>空间复杂度：O(m+n)，其中 m 是输入中对应 3 个字母的数字个数，n 是输入中对应 4 个字母的数字个数，m+n 是输入数字的总个数。除了返回值以外，空间复杂度主要取决于哈希表以及回溯过程中的递归调用层数，哈希表的大小与输入无关，可以看成常数，递归调用层数最大为 m+n。</p>
<h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h2><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p>
<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: candidates = [2,3,5], target = 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: candidates = [2], target = 1</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= candidates.length &lt;= 30</code></li>
<li><code>2 &lt;= candidates[i] &lt;= 40</code></li>
<li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li>
<li><code>1 &lt;= target &lt;= 40</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>用 <strong>回溯</strong>，在搜索过程中不断累加当前和 <code>sum</code>，直到：</p>
<ul>
<li>如果 <code>sum == target</code> → 收集结果。</li>
<li>如果 <code>sum &gt; target</code> → 直接返回（剪枝）。</li>
</ul>
<p>用一个 <code>start</code> 参数控制搜索范围，保证组合里数字的顺序不会乱（避免重复解）。</p>
<ul>
<li>例如 <code>[2,3]</code> 和 <code>[3,2]</code> 其实是一样的，所以搜索的时候规定只能往后选。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtrack(candidates, target, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), result);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> start, <span class="type">int</span> sum, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));  <span class="comment">// 找到组合</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// 剪枝：超过目标值，直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            path.add(candidates[i]);  <span class="comment">// 选择当前数 </span></span><br><span class="line">            backtrack(candidates, target, i, sum + candidates[i], path, result);  <span class="comment">// 递归时 i 不变，因为可以重复选择同一个数</span></span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);  <span class="comment">// 撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(S)，其中 S 为所有可行解的长度之和。从分析给出的搜索树我们可以看出时间复杂度取决于搜索树所有叶子节点的深度之和，即所有可行解的长度之和。在这题中，我们很难给出一个比较紧的上界，我们知道 O(n * 2^n) 是一个比较松的上界，即在这份代码中，n 个位置每次考虑选或者不选，如果符合条件，就加入答案的时间代价。但是实际运行的时候，因为不可能所有的解都满足条件，递归的时候我们还会用 target−candidates[idx]≥0 进行剪枝，所以实际运行情况是远远小于这个上界的。</p>
<p>空间复杂度：O(target)。除答案数组外，空间复杂度取决于递归的栈深度，在最差情况下需要递归 O(target) 层。</p>
<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[&quot;()&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 8</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>有效括号的组合要求：</p>
<ul>
<li>左括号 <code>(</code> 必须在右括号 <code>)</code> 之前出现。</li>
<li>不能有不匹配的右括号（即右括号不能超过左括号）。</li>
</ul>
<p>递归过程：</p>
<ul>
<li>我们一开始有 <code>n</code> 对括号可以使用。</li>
<li>递归时，我们尝试添加左括号 <code>(</code> 和右括号 <code>)</code>，每次递归的时候需要确保：<ul>
<li>左括号数量不超过 <code>n</code>。</li>
<li>右括号数量不超过左括号数量。</li>
</ul>
</li>
</ul>
<p>回溯的终止条件：</p>
<ul>
<li>当左括号和右括号的数量都达到了 <code>n</code> 时，说明当前组合是一个有效的括号组合。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtrack(n, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> n, String current, <span class="type">int</span> open, <span class="type">int</span> close, List&lt;String&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (open == n &amp;&amp; close == n) &#123;</span><br><span class="line">            result.add(current);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左括号在右括号之前，左括号数不超过 n</span></span><br><span class="line">        <span class="keyword">if</span> (open &lt; n) &#123;</span><br><span class="line">            backtrack(n, current + <span class="string">&quot;(&quot;</span>, open + <span class="number">1</span>, close, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右括号数不超过左括号数</span></span><br><span class="line">        <span class="keyword">if</span> (close &lt; open) &#123;</span><br><span class="line">            backtrack(n, current + <span class="string">&quot;)&quot;</span>, open, close + <span class="number">1</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(4^n &#x2F; sqrt(n))，在回溯过程中，每个答案需要 O(n) 的时间复制到答案数组中。</p>
<p>空间复杂度：O(n)，除了答案数组之外，我们所需要的空间取决于递归栈的深度，每一层递归函数需要 O(1) 的空间，最多递归 2n 层，因此空间复杂度为 O(n)。</p>
<h2 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a>79. 单词搜索</h2><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = [[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;E&#x27;],[&#x27;S&#x27;,&#x27;F&#x27;,&#x27;C&#x27;,&#x27;S&#x27;],[&#x27;A&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;E&#x27;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = [[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;E&#x27;],[&#x27;S&#x27;,&#x27;F&#x27;,&#x27;C&#x27;,&#x27;S&#x27;],[&#x27;A&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;E&#x27;]], word = &quot;SEE&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/15/word3.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = [[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;E&#x27;],[&#x27;S&#x27;,&#x27;F&#x27;,&#x27;C&#x27;,&#x27;S&#x27;],[&#x27;A&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;E&#x27;]], word = &quot;ABCB&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == board.length</code></li>
<li><code>n = board[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 6</code></li>
<li><code>1 &lt;= word.length &lt;= 15</code></li>
<li><code>board</code> 和 <code>word</code> 仅由大小写英文字母组成</li>
</ul>
<p>**进阶：**你可以使用搜索剪枝的技术来优化解决方案，使其在 <code>board</code> 更大的情况下可以更快解决问题？</p>
<p><strong>解题思路</strong></p>
<p>从每个单元格开始：遍历整个 <code>board</code>，从每个位置开始进行搜索。</p>
<p>深度优先搜索：每次移动到相邻的单元格，检查该位置的字符是否匹配目标字符，并继续递归搜索下一个字符。</p>
<p>回溯：如果当前路径无法找到目标单词，则回溯并尝试其他路径。</p>
<p>剪枝：每个单元格只能被使用一次，因此每次进入递归时，需要将当前位置标记为已访问，退出时恢复状态。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (board == <span class="literal">null</span> || m == <span class="number">0</span> || n == <span class="number">0</span> || word == <span class="literal">null</span> || word.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个位置作为起点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(board, word, i, j, <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, String word, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> currLength)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前长度等于 word 长度，说明已经匹配成功</span></span><br><span class="line">        <span class="keyword">if</span> (currLength == word.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边界条件：越界 or 不等于目标字段</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] != word.charAt(currLength)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保留当前字符，标记为已访问</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> board[i][j];</span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试从四个方向 dfs</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isFound</span> <span class="operator">=</span> dfs(board, word, i + <span class="number">1</span>, j, currLength + <span class="number">1</span>) || dfs(board, word, i - <span class="number">1</span>, j, currLength + <span class="number">1</span>) || dfs(board, word, i, j + <span class="number">1</span>, currLength + <span class="number">1</span>) || dfs(board, word, i, j - <span class="number">1</span>, currLength + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        board[i][j] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isFound;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：最坏情况下，我们要遍历每个单元格，进行一次深度优先搜索。递归的深度为单词 word 的长度，假设为 L，每个位置可以有 4 个方向，最坏情况下时间复杂度是 O(m * n * 4^L)，其中 m 和 n 分别是 board 的行数和列数。</p>
<p>空间复杂度：空间复杂度主要来自递归栈的深度，最坏情况下递归深度为 L，因此空间复杂度是 O(L)。</p>
<h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a>131. 分割回文串</h2><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些 子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aab&quot;</span><br><span class="line">输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a&quot;</span><br><span class="line">输出：[[&quot;a&quot;]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 16</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<p><strong>解题思路</strong></p>
<p>回溯：我们从字符串的开头开始，每次选择一个可能的切割点，将字符串分割成多个部分，递归处理剩下的部分。</p>
<p>回文检查：在每次选择分割点时，我们需要判断当前子串是否是回文。如果是回文，就继续进行分割，否则跳过这个分割点。</p>
<p>终止条件：当字符串完全被分割成回文子串时，记录当前的分割方案。回溯回去继续尝试其他分割。</p>
<p>回溯算法步骤：</p>
<ol>
<li>从字符串的开头开始，尝试每一个可能的子串。</li>
<li>判断当前子串是否为回文。如果是回文，则继续递归地处理剩下的部分。</li>
<li>每当找到一种合法的分割方案，就将其加入结果集。</li>
<li>当递归到达字符串的末尾时，表示已经找到了一种合法的分割方案。</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; currentPartition = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtrack(s, <span class="number">0</span>, currentPartition, result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(String s, <span class="type">int</span> start, List&lt;String&gt; currentPartition, List&lt;List&lt;String&gt;&gt; result)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果已经遍历到字符串的末尾，记录当前分割方案</span></span><br><span class="line">        <span class="keyword">if</span> (start == s.length()) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(currentPartition));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从当前位置开始，尝试每个可能的子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> start + <span class="number">1</span>; end &lt;= s.length(); end++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">substring</span> <span class="operator">=</span> s.substring(start, end);</span><br><span class="line">            <span class="comment">// 如果当前子串是回文，则继续递归</span></span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(substring)) &#123;</span><br><span class="line">                currentPartition.add(substring);</span><br><span class="line">                <span class="comment">// 递归处理后续部分</span></span><br><span class="line">                backtrack(s, end, currentPartition, result);</span><br><span class="line">                <span class="comment">// 回溯，移出最后一个子串</span></span><br><span class="line">                currentPartition.remove(currentPartition.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断一个字符串是否是回文</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：对于每一个起始位置，我们可能会检查多个子串，因此总的时间复杂度是 O(2^n * n)，其中 2^n 是最坏情况下的回溯树的大小，n 是每次回文检查的时间。</p>
<p>空间复杂度：递归深度最多为 n，所以空间复杂度为 O(n)。</p>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 为 <strong>无重复元素</strong> 的 <strong>升序</strong> 排列数组</li>
<li><code>-104 &lt;= target &lt;= 104</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>初始化：我们需要设置两个指针：<code>left</code> 和 <code>right</code>，分别表示当前搜索范围的起始和结束位置。最开始时，<code>left = 0</code>，<code>right = nums.length - 1</code>。</p>
<p>查找目标：通过二分查找不断缩小搜索范围：</p>
<ul>
<li>计算中间位置 <code>mid = left + (right - left) / 2</code>。</li>
<li>比较 <code>nums[mid]</code> 与 <code>target</code>：<ul>
<li>如果 <code>nums[mid] == target</code>，说明找到了目标值，直接返回 <code>mid</code>。</li>
<li>如果 <code>nums[mid] &lt; target</code>，说明目标值在右半部分，更新 <code>left = mid + 1</code>。</li>
<li>如果 <code>nums[mid] &gt; target</code>，说明目标值在左半部分，更新 <code>right = mid - 1</code>。</li>
</ul>
</li>
</ul>
<p>插入位置：如果在搜索过程中没有找到目标值，最终 <code>left</code> 就是目标值应该插入的位置。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用二分查找</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;  <span class="comment">// 防止 overflow</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;  <span class="comment">// 找到目标值，返回索引</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;  <span class="comment">// 目标值在右半部分</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;  <span class="comment">// 目标值在左半部分</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有目标值，left 是目标值插入的位置</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(log n)，其中 n 为数组的长度。二分查找所需的时间复杂度为 O(log n)。</li>
<li>空间复杂度：O(1)。我们只需要常数空间存放若干变量。</li>
</ul>
<h2 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74. 搜索二维矩阵"></a>74. 搜索二维矩阵</h2><p>给你一个满足下述两条属性的 <code>m x n</code> 整数矩阵：</p>
<ul>
<li>每行中的整数从左到右按非严格递增顺序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。</li>
</ul>
<p>给你一个整数 <code>target</code> ，如果 <code>target</code> 在矩阵中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li><code>-104 &lt;= matrix[i][j], target &lt;= 104</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>由于矩阵满足特定的排列条件，我们可以使用一种 <strong>二分查找</strong> 的方法来优化搜索，达到 <code>O(log(m * n))</code> 的时间复杂度。</p>
<p>我们可以将这个问题看作是在一个 <strong>一维有序数组</strong> 中查找目标值。具体的做法如下：</p>
<ol>
<li>将二维矩阵看作一个一维的排序数组。例如，第 i 行第 j 列的元素可以通过 <code>matrix[i][j]</code> 来访问。在一维数组的角度上，可以用公式 <code>index = i * n + j</code> 来进行转换，其中 <code>n</code> 是每行的列数。</li>
<li>使用二分查找在矩阵中查找目标值。我们首先设定一个 <code>left</code> 指针指向数组的第一个元素，<code>right</code> 指针指向数组的最后一个元素。通过不断缩小搜索范围，直到找到目标值或者确定目标值不存在。</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> m * n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用二分查找</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;  <span class="comment">// 防止 overflow</span></span><br><span class="line">            <span class="comment">// mid = i * n + j</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">midValue</span> <span class="operator">=</span> matrix[mid / n][mid % n];</span><br><span class="line">            <span class="keyword">if</span> (midValue == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 找到目标值</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midValue &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;  <span class="comment">// 目标值在右半部分</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;  <span class="comment">// 目标值在左半部分</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(log m * n)，其中 m 和 n 分别是矩阵的行数和列数。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h2><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p>
<p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 105</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>nums</code> 是一个非递减数组</li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>二分查找：由于数组是有序的，我们可以使用二分查找来找到目标值的 开始位置 和 结束位置。首先，我们可以使用二分查找找到目标值的任意一个位置，然后从该位置向两边扩展，找到目标值的最左和最右位置。</p>
<p>步骤：</p>
<ul>
<li>首先，我们使用二分查找找到 <code>target</code> 的任意一个出现位置。</li>
<li>然后，在找到的位置基础上，分别进行二分查找：<ul>
<li>向左查找，直到找到最左边的 <code>target</code> 位置。</li>
<li>向右查找，直到找到最右边的 <code>target</code> 位置。</li>
</ul>
</li>
<li>如果数组中没有目标值 <code>target</code>，则返回 <code>[-1, -1]</code>。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        result[<span class="number">0</span>] = findLeft(nums, target);  <span class="comment">// 找到最左边的位置</span></span><br><span class="line">        result[<span class="number">1</span>] = findRight(nums, target);  <span class="comment">// 找到最右边的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找找到最左边的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findLeft</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftIndex</span> <span class="operator">=</span> -<span class="number">1</span>;  <span class="comment">// 默认找不到，返回 -1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                leftIndex = mid;</span><br><span class="line">                right = mid - <span class="number">1</span>;  <span class="comment">// 继续在左边寻找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找找到最右边的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findRight</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightIndex</span> <span class="operator">=</span> -<span class="number">1</span>;  <span class="comment">// 默认找不到，返回 -1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                rightIndex = mid;</span><br><span class="line">                left = mid + <span class="number">1</span>;  <span class="comment">// 继续在右边寻找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rightIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度： O(log n) ，其中 n 为数组的长度。二分查找的时间复杂度为 O(log n)，一共会执行两次，因此总时间复杂度为 O(log n)。</p>
<p>空间复杂度：O(1) 。只需要常数空间存放若干变量。</p>
<h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a>33. 搜索旋转排序数组</h2><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p>
<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>向左旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 下标 <code>3</code> 上向左旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p>
<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1], target = 0</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 5000</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 中的每个值都 <strong>独一无二</strong></li>
<li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li>
<li><code>-104 &lt;= target &lt;= 104</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p><strong>首先</strong>，我们知道数组的两部分是有序的：一部分是从旋转点开始的升序部分，另一部分是从旋转点之前的部分。</p>
<p>在每次二分查找的过程中，我们需要判断当前的中间值 <code>mid</code> 与目标值 <code>target</code> 的关系，以及确定旋转点位置，然后确定在哪一部分继续查找。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果找到目标，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;  <span class="comment">// 左半部分有序</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123;  <span class="comment">// 目标在左半部分</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 目标在右半部分</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 右半部分有序</span></span><br><span class="line">                <span class="keyword">if</span> (target &lt;= nums[right] &amp;&amp; target &gt; nums[mid]) &#123;  <span class="comment">// 目标在右半部分</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 目标在左半部分</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度： O(log n)，其中 n 为 nums 数组的大小。整个算法时间复杂度即为二分查找的时间复杂度 O(log n)。</p>
<p>空间复杂度： O(1) 。我们只需要常数级别的空间存放变量。</p>
<h2 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a>153. 寻找旋转排序数组中的最小值</h2><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p>
<ul>
<li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li>
<li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li>
</ul>
<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p>
<p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2]</span><br><span class="line">输出：0</span><br><span class="line">解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [11,13,15,17]</span><br><span class="line">输出：11</span><br><span class="line">解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 5000</code></li>
<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>
<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
<li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li>
</ul>
<p><strong>解题思路</strong></p>
<p>我们可以利用 二分查找 来缩小搜索范围。</p>
<p>每次比较中间元素 <code>mid</code> 和边界元素 <code>nums[left]</code> 以及 <code>nums[right]</code>，可以通过以下方式来决定移动哪一半：</p>
<ol>
<li>如果 <code>nums[mid] &gt;= nums[left]</code>，说明左半部分是升序的，最小值可能在右半部分。</li>
<li>如果 <code>nums[mid] &lt; nums[left]</code>，说明右半部分是升序的，最小值可能在左半部分。</li>
</ol>
<p>通过这种方式，我们可以在对数时间内找到最小元素。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;  <span class="comment">// 如果中间元素大于右边元素，说明最小值在右半部分</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 如果中间元素小于右边元素，说明最小值在左半部分</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当左指针和右指针重合时，left 即为最小元素的索引</span></span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：时间复杂度为 O(log n)，其中 n 是数组 nums 的长度。在二分查找的过程中，每一步会忽略一半的区间，因此时间复杂度为 O(log n)。</p>
<p>空间复杂度：O(1)。</p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ol>
<p><strong>示例 1：</strong></p>
<p>**输入：**s &#x3D; “()”</p>
<p>**输出：**true</p>
<p><strong>示例 2：</strong></p>
<p>**输入：**s &#x3D; “()[]{}”</p>
<p>**输出：**true</p>
<p><strong>示例 3：</strong></p>
<p>**输入：**s &#x3D; “(]”</p>
<p>**输出：**false</p>
<p><strong>示例 4：</strong></p>
<p>**输入：**s &#x3D; “([])”</p>
<p>**输出：**true</p>
<p><strong>示例 5：</strong></p>
<p>**输入：**s &#x3D; “([)]”</p>
<p>**输出：**false</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 仅由括号 <code>&#39;()[]{}&#39;</code> 组成</li>
</ul>
<p><strong>解题思路</strong></p>
<p>栈的使用：我们遍历字符串中的每个字符：</p>
<ul>
<li>如果是左括号（<code>(</code>, <code>{</code>, <code>[</code>），则将其压入栈中。</li>
<li>如果是右括号（<code>)</code>, <code>}</code>, <code>]</code>），则判断栈顶是否有对应的左括号。如果有，弹出栈顶的左括号；如果没有，则说明括号不匹配，返回 <code>false</code>。</li>
</ul>
<p>最后检查：遍历结束后，如果栈为空，说明所有的括号都成功匹配并闭合，返回 <code>true</code>；否则，返回 <code>false</code>。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span>) &#123;  <span class="comment">// 如果是左括号，压入栈</span></span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 如果是右括号，弹出栈顶并匹配左括号</span></span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> <span class="variable">top</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (top == <span class="string">&#x27;(&#x27;</span> &amp;&amp; c != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (top == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; c != <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (top == <span class="string">&#x27;[&#x27;</span> &amp;&amp; c != <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是字符串 s 的长度。</p>
<p>空间复杂度：O(n+∣Σ∣)，其中 Σ 表示字符集，本题中字符串只包含 6 种括号，∣Σ∣&#x3D;6。栈中的字符数量为 O(n)，而哈希表使用的空间为 O(∣Σ∣)，相加即可得到总空间复杂度。</p>
<h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a>155. 最小栈</h2><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>实现 <code>MinStack</code> 类:</p>
<ul>
<li><code>MinStack()</code> 初始化堆栈对象。</li>
<li><code>void push(int val)</code> 将元素val推入堆栈。</li>
<li><code>void pop()</code> 删除堆栈顶部的元素。</li>
<li><code>int top()</code> 获取堆栈顶部的元素。</li>
<li><code>int getMin()</code> 获取堆栈中的最小元素。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>-231 &lt;= val &lt;= 231 - 1</code></li>
<li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用</li>
<li><code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>最多被调用 <code>3 * 104</code> 次</li>
</ul>
<p><strong>解题思路</strong></p>
<p>主栈：存储栈中的所有元素。</p>
<p>辅助栈：每次 <code>push</code> 一个元素时，如果该元素小于当前最小值（或栈为空），就将它压入辅助栈。否则，将辅助栈当前的最小值再次压入辅助栈。这样，辅助栈的栈顶始终保存当前栈的最小值。</p>
<p><code>getMin</code> 操作：只需要返回辅助栈的栈顶元素，因为它始终保存当前最小值。</p>
<p><code>pop</code> 操作：在弹出主栈的元素时，辅助栈也要弹出对应的元素，保证辅助栈中的最小值与主栈同步。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;  <span class="comment">// 主栈：用于存储所有元素</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack;  <span class="comment">// 辅助栈：用于存储当前最小值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        stack.push(val);</span><br><span class="line">        <span class="keyword">if</span> (minStack.isEmpty() || val &lt; minStack.peek()) &#123;</span><br><span class="line">            minStack.push(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minStack.push(minStack.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(val);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：对于题目中的所有操作，时间复杂度均为 O(1)。因为栈的插入、删除与读取操作都是 O(1)，我们定义的每个操作最多调用栈操作两次。</p>
<p>空间复杂度：O(n)，其中 n 为总操作数。最坏情况下，我们会连续插入 n 个元素，此时两个栈占用的空间为 O(n)。</p>
<h2 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a>394. 字符串解码</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p>
<p>测试用例保证输出的长度不会超过 <code>105</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;3[a]2[bc]&quot;</span><br><span class="line">输出：&quot;aaabcbc&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;3[a2[c]]&quot;</span><br><span class="line">输出：&quot;accaccacc&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;2[abc]3[cd]ef&quot;</span><br><span class="line">输出：&quot;abcabccdcdcdef&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abc3[cd]xyz&quot;</span><br><span class="line">输出：&quot;abccdcdcdxyz&quot;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 30</code></li>
<li><code>s</code> 由小写英文字母、数字和方括号 <code>&#39;[]&#39;</code> 组成</li>
<li><code>s</code> 保证是一个 <strong>有效</strong> 的输入。</li>
<li><code>s</code> 中所有整数的取值范围为 <code>[1, 300]</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>遍历字符串：</p>
<ul>
<li>如果遇到数字（<code>k</code>），那么我们就要记录下来，因为它表示要重复的次数。</li>
<li>如果遇到左括号（<code>[</code>），说明后面开始是需要重复的子字符串，我们将当前已构建的部分（包括数字 <code>k</code>）压入栈。</li>
<li>如果遇到右括号（<code>]</code>），说明一个完整的子字符串已经结束，我们从栈中弹出最近的重复次数和之前的字符串部分，然后将当前字符串按照重复次数进行扩展。</li>
</ul>
<p>关键步骤：</p>
<ul>
<li>使用栈保存数字 <code>k</code> 和已构建的字符串部分。</li>
<li>每次遇到 <code>[</code> 就把当前数字和字符串部分压栈，遇到 <code>]</code> 就弹栈并进行字符串拼接。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decodeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  <span class="comment">// 存储字符串和数字</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">currentString</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;  <span class="comment">// 存储当前处理的字符串</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">currentNum</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 存储重复的次数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(c)) &#123;  <span class="comment">// 如果是数字，积累数字</span></span><br><span class="line">                currentNum = currentNum * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;[&#x27;</span>) &#123;  <span class="comment">// 如果是左括号，将重复次数和字符串入栈</span></span><br><span class="line">                stack.push(Integer.toString(currentNum));</span><br><span class="line">                stack.push(currentString);</span><br><span class="line">                currentNum = <span class="number">0</span>;</span><br><span class="line">                currentString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;]&#x27;</span>) &#123;  <span class="comment">// 如果是右括号，弹出栈中的信息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">preString</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">repeatTimes</span> <span class="operator">=</span> Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(preString);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; repeatTimes; i++) &#123;</span><br><span class="line">                    sb.append(currentString);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                currentString = sb.toString();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 如果是字母，直接添加到当前处理的字符串</span></span><br><span class="line">                currentString += c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> currentString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：记解码后得出的字符串长度为 S，除了遍历一次原字符串 s，我们还需要将解码后的字符串中的每个字符都入栈，并最终拼接进答案中，故渐进时间复杂度为 O(S+∣s∣)，即 O(S)。<br>空间复杂度：记解码后得出的字符串长度为 S，这里用栈维护 TOKEN，栈的总大小最终与 S 相同，故渐进空间复杂度为 O(S)。</p>
<h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h2><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class="line">输出: [1,1,4,2,1,1,0,0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: temperatures = [30,40,50,60]</span><br><span class="line">输出: [1,1,1,0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: temperatures = [30,60,90]</span><br><span class="line">输出: [1,1,0]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= temperatures.length &lt;= 105</code></li>
<li><code>30 &lt;= temperatures[i] &lt;= 100</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>我们遍历温度数组，对于每一天的温度：</p>
<ul>
<li>如果当前温度大于栈顶存储的温度（栈顶的温度对应的是较早的天数），则说明当前天的温度是一个更高的温度，栈顶的天数就找到了一个更高温度的天数。</li>
<li>这时我们可以更新答案数组，并将栈顶元素弹出。</li>
</ul>
<p>将当前温度的索引压入栈中，等待后续的更高温度来更新答案。</p>
<p>最终，当栈为空时，意味着没有更多更高温度，因此答案数组中相应位置的值是 <code>0</code>。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[temperatures.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; temperatures.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                result[preIndex] = i - preIndex;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是温度列表的长度。正向遍历温度列表一遍，对于温度列表中的每个下标，最多有一次进栈和出栈的操作。</p>
<p>空间复杂度：O(n)，其中 n 是温度列表的长度。需要维护一个单调栈存储温度列表中的下标。</p>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a>215. 数组中的第K个最大元素</h2><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>
<p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4], k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6], k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= nums.length &lt;= 105</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
</ul>
<p><strong>方法一：基于堆排序的选择方法</strong></p>
<p><strong>解题思路</strong></p>
<p>遍历数组，把元素依次放入一个最小堆（PriorityQueue）。</p>
<p>如果堆的大小超过 k，就把堆顶（最小值）弹出。</p>
<p>遍历完成后，堆顶就是第 k 大的元素。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">heapSize</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 从最后一个非叶子节点开始往前调整堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> heapSize / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxHeapify(nums, heapSize, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依次将堆顶元素（最大值）交换到数组末尾</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= nums.length - k + <span class="number">1</span>; i--) &#123;</span><br><span class="line">            swap(nums, i, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 缩小堆的范围，重新调整堆</span></span><br><span class="line">            heapSize--;</span><br><span class="line">            maxHeapify(nums, heapSize, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">maxHeapify</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> heapSize, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; nums[left] &gt; nums[largest]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; nums[right] &gt; nums[largest]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(nums, largest, i);</span><br><span class="line">            maxHeapify(nums, heapSize, largest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n log n)，建堆的时间代价是 O(n)，删除的总代价是 O(k log n)，因为 k&lt;n，故渐进时间复杂为 O(n+k log n)&#x3D;O(n log n)。<br>空间复杂度：O(log n)，即递归使用栈空间的空间代价。</p>
<p><strong>方法二：基于快速排序的选择方法</strong></p>
<p><strong>解题思路</strong></p>
<p>快速选择算法是快速排序（Quicksort）的变种：</p>
<ul>
<li>快速排序是递归地对左右子数组排序；</li>
<li>快速选择只需要递归到包含第 k 大元素的那一半数组即可。</li>
</ul>
<p>我们先选一个 <code>pivot</code>（基准值），把数组划分成两部分：</p>
<ul>
<li>左边：比 <code>pivot</code> 小的数；</li>
<li>右边：比 <code>pivot</code> 大的数。</li>
</ul>
<p>根据 <strong>pivot 的位置</strong> 与目标位置 <code>n - k</code>（第 k 大对应的索引）进行比较：</p>
<ul>
<li>如果 <code>pivotIndex == n - k</code>，直接返回结果；</li>
<li>如果 <code>pivotIndex &lt; n - k</code>，递归右边；</li>
<li>如果 <code>pivotIndex &gt; n - k</code>，递归左边。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, nums.length - k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">quickSelect</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> targetIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[targetIndex];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">while</span> (nums[i] &lt;   pivot);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">while</span> (nums[j] &gt; pivot);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (targetIndex &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">return</span> quickSelect(nums, left, j, targetIndex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> quickSelect(nums, j + <span class="number">1</span>, right, targetIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>平均时间复杂度：O(n)</p>
<p>最坏时间复杂度：O(n^2)（当每次划分极端不平衡时）</p>
<p>空间复杂度：O(log n)（递归栈）</p>
<h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a>347. 前 K 个高频元素</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<p>**输入：**nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</p>
<p><strong>输出：</strong>[1,2]</p>
<p><strong>示例 2：</strong></p>
<p>**输入：**nums &#x3D; [1], k &#x3D; 1</p>
<p><strong>输出：</strong>[1]</p>
<p><strong>示例 3：</strong></p>
<p>**输入：**nums &#x3D; [1,2,1,2,1,2,3,1,3,2], k &#x3D; 2</p>
<p><strong>输出：</strong>[1,2]</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li>
<li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li>
</ul>
<p>**进阶：**你所设计算法的时间复杂度 <strong>必须</strong> 优于 <code>O(n log n)</code> ，其中 <code>n</code> 是数组大小。</p>
<p><strong>解题思路</strong></p>
<p>统计频率<br> 用 <code>HashMap&lt;Integer, Integer&gt;</code> 统计每个元素出现的次数。</p>
<p>小顶堆存 K 个最高频率元素</p>
<ul>
<li>使用 <strong>优先队列 PriorityQueue</strong>（小顶堆），按频率从小到大排序。</li>
<li>遍历 <code>map</code>，把元素放入堆中：<ul>
<li>如果堆大小超过 <code>k</code>，就弹出堆顶（频率最小的）。</li>
</ul>
</li>
<li>最终堆里保留的就是前 <code>k</code> 高频元素。</li>
</ul>
<p>取结果<br> 堆中存的就是答案，转换成数组返回即可。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 统计频率</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; occurrences = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            occurrences.put(num, occurrences.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用小顶堆，按频率升序</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">            (a, b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : occurrences.entrySet()) &#123;</span><br><span class="line">            heap.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(), entry.getValue()&#125;);</span><br><span class="line">            <span class="comment">// 保证堆里最多只有 k 个元素</span></span><br><span class="line">            <span class="keyword">if</span> (heap.size() &gt; k) &#123;</span><br><span class="line">                heap.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取结果</span></span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            result[i] = heap.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n log k)，其中 n 为数组的长度。我们首先遍历原数组，并使用哈希表记录出现次数，每个元素需要 O(1) 的时间，共需 O(n) 的时间。随后，我们遍历「出现次数数组」，由于堆的大小至多为 k，因此每次堆操作需要 O(log k) 的时间，共需 O(n log k) 的时间。二者之和为 O(n log k)。<br>空间复杂度：O(n)。哈希表的大小为 O(n)，而堆的大小为 O(k)，共计为 O(n)。</p>
<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h2><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 105</code></li>
<li><code>0 &lt;= prices[i] &lt;= 104</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>我们只需要找到：</p>
<ul>
<li><strong>最便宜的一天买入</strong>（<code>minPrice</code>）</li>
<li><strong>之后某天卖出价格与它的差值最大</strong></li>
</ul>
<p>遍历 <code>prices</code> 数组时：</p>
<ol>
<li>更新最小买入价 <code>minPrice</code></li>
<li>计算当前天卖出的利润 <code>prices[i] - minPrice</code></li>
<li>更新最大利润 <code>maxProfit</code></li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minPrice</span> <span class="operator">=</span> Integer.MAX_VALUE;   <span class="comment">// 初始化最小买入价</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxProfit</span> <span class="operator">=</span> <span class="number">0</span>;                  <span class="comment">// 初始化最大利润</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price : prices) &#123;</span><br><span class="line">            <span class="keyword">if</span> (price &lt; minPrice) &#123;  <span class="comment">// 更新最小买入价</span></span><br><span class="line">                minPrice = price;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (price - minPrice &gt; maxProfit) &#123;  <span class="comment">// 更新最大利润</span></span><br><span class="line">                maxProfit = price - minPrice;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，只需要遍历一次。</li>
<li>空间复杂度：O(1)，只使用了常数个变量。</li>
</ul>
<h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h2><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>0 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>我们维护一个变量 <code>maxReach</code> 表示 <strong>能到达的最远下标</strong>：</p>
<ol>
<li>从头开始遍历数组。</li>
<li>如果当前位置 <code>i</code> 在 <code>maxReach</code> 之外，说明走不到这里 → 返回 <code>false</code>。</li>
<li>否则，更新 <code>maxReach = max(maxReach, i + nums[i])</code>。</li>
<li>遍历过程中如果 <code>maxReach &gt;= nums.length - 1</code>，说明能到达最后一个位置 → 返回 <code>true</code>。</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxRearch</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前位置不可到达，提前返回</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; maxRearch) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新能到达的最远位置</span></span><br><span class="line">            maxRearch = Math.max(maxRearch, i + nums[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果可以到达最后，提前返回</span></span><br><span class="line">            <span class="keyword">if</span> (maxRearch &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 为数组的大小。只需要访问 <code>nums</code> 数组一遍，共 n 个位置。</li>
<li>空间复杂度：O(1)，不需要额外的空间开销。</li>
</ul>
<h2 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a>45. 跳跃游戏 II</h2><p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置在下标 0。</p>
<p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向后跳转的最大长度。换句话说，如果你在索引 <code>i</code> 处，你可以跳转到任意 <code>(i + j)</code> 处：</p>
<ul>
<li><code>0 &lt;= j &lt;= nums[i]</code> 且</li>
<li><code>i + j &lt; n</code></li>
</ul>
<p>返回到达 <code>n - 1</code> 的最小跳跃次数。测试用例保证可以到达 <code>n - 1</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [2,3,0,1,4]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
<li>题目保证可以到达 <code>n - 1</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>我们要找的是<strong>最少跳跃次数</strong>。</p>
<ul>
<li>走到某个位置时，我们关心的是<strong>从当前位置最远能到哪里</strong>。</li>
<li>当我们走完一个“跳跃范围”后，必须进行一次跳跃。</li>
<li>所以我们用两个变量：<ul>
<li><code>end</code>：当前这一步能到的最远范围的边界。</li>
<li><code>farthest</code>：在当前范围内能到的最远位置。</li>
</ul>
</li>
<li>每次遍历到 <code>end</code> 时，说明这一步的范围走完了，就需要进行一次跳跃，然后把 <code>end</code> 更新为 <code>farthest</code>。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">steps</span> <span class="operator">=</span> <span class="number">0</span>;      <span class="comment">// 跳跃次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="comment">// 当前范围的最远位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">farthest</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">// 在当前范围内能到达的最远位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            farthest = Math.max(farthest, i + nums[i]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;  <span class="comment">// 到达当前范围的最远位置，必须跳跃一次</span></span><br><span class="line">                steps++;</span><br><span class="line">                end = farthest;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> steps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 是数组长度。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a>763. 划分字母区间</h2><p>给你一个字符串 <code>s</code> 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 <code>&quot;ababcc&quot;</code> 能够被分为 <code>[&quot;abab&quot;, &quot;cc&quot;]</code>，但类似 <code>[&quot;aba&quot;, &quot;bcc&quot;]</code> 或 <code>[&quot;ab&quot;, &quot;ab&quot;, &quot;cc&quot;]</code> 的划分是非法的。</p>
<p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 <code>s</code> 。</p>
<p>返回一个表示每个字符串片段的长度的列表。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">输出：[9,7,8]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 &quot;ababcbaca&quot;、&quot;defegde&quot;、&quot;hijhklij&quot; 。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 这样的划分是错误的，因为划分的片段数较少。 </span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;eccbbbbdec&quot;</span><br><span class="line">输出：[10]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 500</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<p><strong>解题思路</strong></p>
<p>我们要把字符串划分成尽可能多的片段，并保证每个字母只出现在一个片段中。</p>
<p><strong>关键点</strong>：</p>
<ul>
<li>对于某个片段来说，如果片段中包含某个字母，就必须把这个字母最后一次出现的位置也包括进来。</li>
<li>因此我们可以先扫描一遍字符串，记录每个字母的<strong>最后出现位置</strong>。</li>
<li>然后从头遍历字符串，用一个变量 <code>end</code> 表示当前片段能到的最远位置。<ul>
<li>遍历时不断更新 <code>end = max(end, last[s[i]])</code>。</li>
<li>当 <code>i == end</code> 时，说明一个片段结束，可以记录下来。</li>
</ul>
</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[] last = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录每个字母最后出现的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            last[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分割区间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            end = Math.max(end, last[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                result.add(end - start + <span class="number">1</span>);</span><br><span class="line">                start = end + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是字符串的长度。需要遍历字符串两次，第一次遍历时记录每个字母最后一次出现的下标位置，第二次遍历时进行字符串的划分。</p>
<p>空间复杂度：O(∣Σ∣)，其中 Σ 是字符串中的字符集。这道题中，字符串只包含小写字母，因此 ∣Σ∣&#x3D;26。</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶</span><br><span class="line">2. 2 阶</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶 + 1 阶</span><br><span class="line">2. 1 阶 + 2 阶</span><br><span class="line">3. 2 阶 + 1 阶</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 45</code></li>
</ul>
<p><strong>解题思路</strong></p>
<ul>
<li><p>如果要爬到第 <code>n</code> 阶，可以从：</p>
<ol>
<li><code>n-1</code> 阶走 <strong>1 步</strong>；</li>
<li><code>n-2</code> 阶走 <strong>2 步</strong>。</li>
</ol>
</li>
<li><p>因此有递推关系式：</p>
<p>f(n) &#x3D; f(n − 1) + f(n − 2)</p>
</li>
<li><p>初始条件：</p>
<ul>
<li><code>f(1) = 1</code> （只有一种方式，1 阶）</li>
<li><code>f(2) = 2</code> （两种方式：1+1 或 2）</li>
</ul>
</li>
</ul>
<p>这其实就是 <strong>斐波那契数列</strong>，第 <code>n</code> 项即为答案。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> b + a;  <span class="comment">// f(i) = f(i - 1) + f(i - 2)</span></span><br><span class="line">            a = b;          <span class="comment">// f(i - 2 + 1) -&gt; f(i - 1)</span></span><br><span class="line">            b = c;          <span class="comment">// f(i - 1 + 1) -&gt; f(i - 1) + f(i - 2)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> b;           <span class="comment">// f(n - 1) + f(n - 2)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：循环执行 n 次，每次花费常数的时间代价，故渐进时间复杂度为 O(n)。<br>空间复杂度：这里只用了常数个变量作为辅助空间，故渐进空间复杂度为 O(1)。</p>
<h2 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a>118. 杨辉三角</h2><p>给定一个非负整数 *<code>numRows</code>，*生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p>
<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<p><img src="https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="img"></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: numRows = 5</span><br><span class="line">输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: numRows = 1</span><br><span class="line">输出: [[1]]</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= numRows &lt;= 30</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>杨辉三角的性质：</p>
<ol>
<li><p>每一行的首尾元素都是 <code>1</code>。</p>
</li>
<li><p>其他元素满足：row[j] &#x3D; prev[j − 1] + prev[j]</p>
<p>其中 <code>prev</code> 是上一行。</p>
</li>
</ol>
<p>因此我们可以逐行生成。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">generate</span><span class="params">(<span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 第 i 行有 i + 1 个元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span> || j == i) &#123;</span><br><span class="line">                    row.add(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// row[j] = prev[j - 1] + prev[j]</span></span><br><span class="line">                    row.add(result.get(i - <span class="number">1</span>).get(j - <span class="number">1</span>) + result.get(i - <span class="number">1</span>).get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(numRows^2)，因为总共有 1 + 2 + … + numRows ≈ O(numRows^2) 个元素。</p>
<p>空间复杂度：O(numRows^2)，存储整个三角。</p>
<h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. 打家劫舍</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 400</code></li>
</ul>
<p><strong>解题思路</strong></p>
<ul>
<li>如果我们在第 <code>i</code> 个房子：<ul>
<li>偷它：就不能偷 <code>i-1</code>，所以收益是 <code>dp[i-2] + nums[i]</code></li>
<li>不偷它：那收益是 <code>dp[i-1]</code></li>
</ul>
</li>
<li>状态转移公式：dp[i] &#x3D; max(dp[i], dp[i - 2] + nums[i])</li>
<li><strong>初始条件</strong>：<ul>
<li><code>dp[0] = nums[0]</code></li>
<li><code>dp[1] = max(nums[0], nums[1])</code></li>
</ul>
</li>
<li>最终答案：<code>dp[n-1]</code></li>
</ul>
<p>优化：由于 <code>dp[i]</code> 只依赖 <code>dp[i-1]</code> 和 <code>dp[i-2]</code>，我们可以用两个变量滚动更新，空间降到 <code>O(1)</code>。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 转移方程：dp[i] = max(dp[i], dp[i - 2] + nums[i])</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">prev2</span> <span class="operator">=</span> nums[<span class="number">0</span>];  <span class="comment">// dp[i - 2]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">prev1</span> <span class="operator">=</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);  <span class="comment">// dp[i - 1]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> Math.max(prev1, prev2 + nums[i]);</span><br><span class="line">            prev2 = prev1;</span><br><span class="line">            prev1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是数组长度。只需要对数组遍历一次。</p>
<p>空间复杂度：O(1)。使用滚动数组，可以只存储前两间房屋的最高总金额，而不需要存储整个数组的结果，因此空间复杂度是 O(1)。</p>
<h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a>279. 完全平方数</h2><p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p>
<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 = 4 + 4 + 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 13</span><br><span class="line">输出：2</span><br><span class="line">解释：13 = 4 + 9</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 104</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>我们把 <code>n</code> 看作一个「背包容量」，完全平方数看作「物品」，每个物品可以无限使用，求最少物品数量。</p>
<ul>
<li>定义 <code>dp[i]</code>：表示和为 <code>i</code> 的最少完全平方数数量。</li>
<li>转移方程：dp[i] &#x3D; dp[i - j * j] + 1 (j * j &lt;&#x3D; i)</li>
<li>初始化：<ul>
<li><code>dp[0] = 0</code>（和为 0 不需要数字）</li>
<li>其他初始化为一个较大值</li>
</ul>
</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 转移方程：dp[i] = dp[i - j * j] + 1 (j * j &lt;= i)</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - j * j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n * sqrt(n))，其中 n 为给定的正整数。状态转移方程的时间复杂度为 O(sqrt(n))，共需要计算 n 个状态，因此总时间复杂度为 O(n * sqrt(n))。</p>
<p>空间复杂度：O(n)。我们需要 O(n) 的空间保存状态。</p>
<h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a>322. 零钱兑换</h2><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：coins = [2], amount = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：coins = [1], amount = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= coins.length &lt;= 12</code></li>
<li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li>
<li><code>0 &lt;= amount &lt;= 104</code></li>
</ul>
<p><strong>解题思路</strong></p>
<ul>
<li><p>定义 <code>dp[i]</code> 表示字符串 <code>s[0..i-1]</code> 是否可以由字典中的单词拼接而成。</p>
</li>
<li><p>初始条件：<code>dp[0] = true</code>（空字符串可被拆分）。</p>
</li>
<li><p>状态转移：<br> 对于每个位置 <code>i</code>，遍历所有 <code>j &lt; i</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果 dp[j] == true 且 s[j..i-1] 在字典中出现，则 dp[i] = true</span><br></pre></td></tr></table></figure>
</li>
<li><p>最终答案：<code>dp[n]</code>，其中 <code>n = s.length()</code>。</p>
</li>
</ul>
<p>为了加速判断子串是否在字典中，我们可以用 <strong>HashSet</strong> 存储 <code>wordDict</code>。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="comment">// 转移方程：dp[i] = min(dp[i], dp[i - coin] + 1)</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, amount + <span class="number">1</span>);  <span class="comment">// 最大不会超过 amount 个（全部使用 1 元）</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= coin) &#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount] != amount + <span class="number">1</span> ? dp[amount] : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(Sn)，其中 S 是金额，n 是面额数。我们一共需要计算 O(S) 个状态，S 为题目所给的总金额。对于每个状态，每次需要枚举 n 个面额来转移状态，所以一共需要 O(Sn) 的时间复杂度。<br>空间复杂度：O(S)。数组 dp 需要开长度为总金额 S 的空间。</p>
<h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a>139. 单词拆分</h2><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code> 则返回 <code>true</code>。</p>
<p>**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以由 &quot;apple&quot; &quot;pen&quot; &quot;apple&quot; 拼接成。</span><br><span class="line">     注意，你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 300</code></li>
<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>
<li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li>
<li><code>s</code> 和 <code>wordDict[i]</code> 仅由小写英文字母组成</li>
<li><code>wordDict</code> 中的所有字符串 <strong>互不相同</strong></li>
</ul>
<p><strong>解题思路</strong></p>
<ul>
<li><p>定义 <code>dp[i]</code> 表示字符串 <code>s[0..i-1]</code> 是否可以由字典中的单词拼接而成。</p>
</li>
<li><p>初始条件：<code>dp[0] = true</code>（空字符串可被拆分）。</p>
</li>
<li><p>状态转移：<br> 对于每个位置 <code>i</code>，遍历所有 <code>j &lt; i</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果 dp[j] == true 且 s[j..i-1] 在字典中出现，则 dp[i] = true</span><br></pre></td></tr></table></figure>
</li>
<li><p>最终答案：<code>dp[n]</code>，其中 <code>n = s.length()</code>。</p>
</li>
</ul>
<p>为了加速判断子串是否在字典中，我们可以用 <strong>HashSet</strong> 存储 <code>wordDict</code>。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        <span class="comment">// 转移方程：dp[i] = dp[j] &amp;&amp; s[j...i-1]，dp[i] 表示 s[0...i-1] 是否能由字典拼接</span></span><br><span class="line">        <span class="comment">// 把 wordDict 存在 HashSet中，加速查找</span></span><br><span class="line">        Set&lt;String&gt; wordSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordDict);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;  <span class="comment">// 初始条件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; wordSet.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;  <span class="comment">// 找到一个即可终止</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n^2) ，其中 n 为字符串 s 的长度。我们一共有 O(n) 个状态需要计算，每次计算需要枚举 O(n) 个分割点，哈希表判断一个字符串是否出现在给定的字符串列表需要 O(1) 的时间，因此总时间复杂度为 O(n^2)。</p>
<p>空间复杂度：O(n) ，其中 n 为字符串 s 的长度。我们需要 O(n) 的空间存放 dp 值以及哈希表亦需要 O(n) 的空间复杂度，因此总空间复杂度为 O(n)。</p>
<h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a>300. 最长递增子序列</h2><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2500</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</li>
</ul>
<p><strong>方法一：动态规划</strong></p>
<p><strong>解题思路</strong></p>
<p>定义 <code>dp[i]</code>：表示 <strong>以 <code>nums[i]</code> 结尾的最长递增子序列长度</strong>。</p>
<p>转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i] = max(dp[j] + 1)  for all j &lt; i and nums[j] &lt; nums[i]</span><br></pre></td></tr></table></figure>

<p>初始化：<code>dp[i] = 1</code>（每个数都能单独成为长度为 1 的子序列）。</p>
<p>答案就是 <code>max(dp[i])</code>。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 方法一：动态规划，时间复杂度 O(n^2)，空间复杂度 O(n)</span></span><br><span class="line">        <span class="comment">// 转移方程：dp[i] = max(dp[i], dp[j] + 1) for all j &lt; i and nums[j] &lt; nums[i]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[ny];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLength = Math.max(maxLength, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n^2)，其中 n 为数组 nums 的长度。动态规划的状态数为 n，计算状态 dp[i] 时，需要 O(n) 的时间遍历 dp[0…i−1] 的所有状态，所以总时间复杂度为 O(n^2)。</p>
<p>空间复杂度：O(n)，需要额外使用长度为 n 的 dp 数组。</p>
<p><strong>方法二：贪心 + 二分查找</strong></p>
<p><strong>解题思路</strong></p>
<p>考虑一个简单的贪心，如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。</p>
<p>基于上面的贪心思路，我们维护一个数组 d[i] ，表示长度为 i 的最长上升子序列的末尾元素的最小值，用 len 记录目前最长上升子序列的长度，起始时 len 为 1，d[1]&#x3D;nums[0]。</p>
<p>我们依次遍历数组 nums 中的每个元素，并更新数组 d 和 len 的值。如果 nums[i]&gt;d[len] 则更新 len&#x3D;len+1，否则在 d[1…len]中找满足 d[i−1]&lt;nums[j]&lt;d[i] 的下标 i，并更新 d[i]&#x3D;nums[j]。</p>
<p>根据 d 数组的单调性，我们可以使用二分查找寻找下标 i，优化时间复杂度。</p>
<p>最后整个算法流程为：</p>
<p>设当前已求出的最长上升子序列的长度为 len（初始时为 1），从前往后遍历数组 nums，在遍历到 nums[i] 时：</p>
<p>如果 nums[i]&gt;d[len] ，则直接加入到 d 数组末尾，并更新 len&#x3D;len+1；</p>
<p>否则，在 d 数组中二分查找，找到第一个比 nums[i] 小的数 d[k] ，并更新 d[k+1]&#x3D;nums[i]。</p>
<p>以输入序列 [0,8,4,12,2] 为例：</p>
<p>第一步插入 0，d&#x3D;[0]；</p>
<p>第二步插入 8，d&#x3D;[0,8]；</p>
<p>第三步插入 4，d&#x3D;[0,4]；</p>
<p>第四步插入 12，d&#x3D;[0,4,12]；</p>
<p>第五步插入 2，d&#x3D;[0,2,12]。</p>
<p>最终得到最大递增子序列长度为 3。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 方法二：贪心 + 二分，时间复杂度 O(n log n)，空间复杂度 O(n)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 初始时为 1</span></span><br><span class="line">        <span class="type">int</span>[] d = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        d[len] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; d[len]) &#123;  <span class="comment">// 如果 nums[i] &gt; d[len] ，则直接加入到 d 数组末尾，并更新 len = len+1</span></span><br><span class="line">                d[++len] = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 否则，在 d 数组中二分查找，找到第一个比 nums[i] 小的数 d[k] ，并更新 d[k + 1] = nums[i]</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> len;</span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 k 设为 0</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (d[mid] &lt; nums[i]) &#123;</span><br><span class="line">                        k = mid;</span><br><span class="line">                        left = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        right = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                d[k + <span class="number">1</span>] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n log n)。数组 nums 的长度为 n，我们依次用数组中的元素去更新 d 数组，而更新 d 数组时需要进行 O(log n) 的二分搜索，所以总时间复杂度为 O(n log n)。</p>
<p>空间复杂度：O(n)，需要额外使用长度为 n 的 d 数组。</p>
<h2 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a>152. 乘积最大子数组</h2><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续 子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>测试用例的答案是一个 <strong>32-位</strong> 整数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-2,0,-1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li><code>nums</code> 的任何子数组的乘积都 <strong>保证</strong> 是一个 <strong>32-位</strong> 整数</li>
</ul>
<p><strong>解题思路</strong></p>
<p>定义两个数组（或变量即可优化空间）：</p>
<ul>
<li><code>maxF[i]</code>：以 <code>i</code> 结尾的子数组的最大乘积</li>
<li><code>minF[i]</code>：以 <code>i</code> 结尾的子数组的最小乘积</li>
</ul>
<p>状态转移：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maxF[i] = max(nums[i], maxF[i-1] * nums[i], minF[i-1] * nums[i]);</span><br><span class="line">minF[i] = min(nums[i], maxF[i-1] * nums[i], minF[i-1] * nums[i]);</span><br></pre></td></tr></table></figure>

<p>因为 <code>nums[i]</code> 可能为负数，乘上 <code>minF[i-1]</code> 有可能变大。</p>
<p>答案就是所有 <code>maxF[i]</code> 中的最大值。</p>
<p>空间优化：我们只需要前一状态，所以用两个变量 <code>maxVal</code> 和 <code>minVal</code> 即可。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// maxF[i] = max(nums[i], maxF[i-1] * nums[i], minF[i-1] * nums[i]);</span></span><br><span class="line">        <span class="comment">// minF[i] = min(nums[i], maxF[i-1] * nums[i], minF[i-1] * nums[i]);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span>) &#123;  <span class="comment">// 如果当前数是负数，交换 maxValue 和 minValue</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> maxValue;</span><br><span class="line">                maxValue = minValue;</span><br><span class="line">                minValue = temp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            maxValue = Math.max(nums[i], maxValue * nums[i]);</span><br><span class="line">            minValue = Math.min(nums[i], minValue * nums[i]);</span><br><span class="line">            result = Math.max(result, maxValue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：程序一次循环遍历了 nums，故渐进时间复杂度为 O(n)。</p>
<p>空间复杂度：优化后只使用常数个临时变量作为辅助空间，与 n 无关，故渐进空间复杂度为 O(1)。</p>
<h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a>416. 分割等和子集</h2><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,5,11,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：数组可以分割成 [1, 5, 5] 和 [11] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,5]</span><br><span class="line">输出：false</span><br><span class="line">解释：数组不能分割成两个元素和相等的子集。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 200</code></li>
<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>总和判断</p>
<ul>
<li>先算数组总和 <code>sum</code>。</li>
<li>如果 <code>sum</code> 是奇数，直接返回 <code>false</code>（不可能拆成相等的两份）。</li>
<li>目标就是找到一个子集，和为 <code>target = sum / 2</code>。</li>
</ul>
<p>转化为 0-1 背包问题</p>
<ul>
<li>问题就变成：是否可以从 <code>nums</code> 中选一些数，使得和恰好等于 <code>target</code>。</li>
<li>定义 <code>dp[j]</code>：表示是否可以恰好装满容量为 <code>j</code> 的背包。</li>
</ul>
<p>状态转移<br> 遍历每个 <code>num</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[j] = dp[j] || dp[j - num]   (前提 j &gt;= num)</span><br></pre></td></tr></table></figure>

<p>注意要 <strong>逆序遍历 j</strong>，防止同一个 <code>num</code> 被重复使用。</p>
<p><strong>初始化</strong></p>
<ul>
<li><code>dp[0] = true</code>（不选任何数时，和为 0 是可行的）。</li>
</ul>
<p>答案</p>
<ul>
<li>返回 <code>dp[target]</code>。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 转移方程：dp[i] = dp[i] || dp[i - num] (i &gt;= num)</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum /= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[sum + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sum; i &gt;= num; i--) &#123;</span><br><span class="line">                dp[i] = dp[i] || dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n×target)，其中 n 是数组的长度，target 是整个数组的元素和的一半。需要计算出所有的状态，每个状态在进行转移时的时间复杂度为 O(1)。</p>
<p>空间复杂度：O(target)，其中 target 是整个数组的元素和的一半。空间复杂度取决于 dp 数组，在不进行空间优化的情况下，空间复杂度是 O(n×target)，在进行空间优化的情况下，空间复杂度可以降到 O(target)。</p>
<h1 id="多维动态规划"><a href="#多维动态规划" class="headerlink" title="多维动态规划"></a>多维动态规划</h1><h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a>62. 不同路径</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://pic.leetcode.cn/1697422740-adxmsI-image.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 7</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向下</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 7, n = 3</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li>题目数据保证答案小于等于 <code>2 * 109</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>状态定义</p>
<ul>
<li><code>dp[i][j]</code> 表示从起点 <code>(0,0)</code> 到达 <code>(i,j)</code> 的路径数。</li>
</ul>
<p>状态转移方程</p>
<ul>
<li><p>机器人只能从 <strong>上方</strong> <code>(i-1,j)</code> 或 <strong>左边</strong> <code>(i,j-1)</code> 过来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j] + dp[i][j-1]</span><br></pre></td></tr></table></figure></li>
</ul>
<p>初始化</p>
<ul>
<li>第一行只能一直往右走，所以 <code>dp[0][j] = 1</code>。</li>
<li>第一列只能一直往下走，所以 <code>dp[i][0] = 1</code>。</li>
</ul>
<p>答案</p>
<ul>
<li>最终答案是 <code>dp[m-1][n-1]</code>。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 转移方程：dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(mn)。</p>
<p>空间复杂度：O(min(m,n))，即为存储所有状态需要的空间。注意到 f(i,j) 仅与第 i 行和第 i−1 行的状态有关，因此我们可以使用滚动数组代替代码中的二维数组，使空间复杂度降低为 O(n)。此外，由于我们交换行列的值并不会对答案产生影响，因此我们总可以通过交换 m 和 n 使得 m≤n，这样空间复杂度降低至 O(min(m,n))。</p>
<h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a>64. 最小路径和</h2><p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>**说明：**每次只能向下或者向右移动一步。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">输出：7</span><br><span class="line">解释：因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,2,3],[4,5,6]]</span><br><span class="line">输出：12</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 200</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 200</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>当 i&gt;0 且 j&#x3D;0 时，dp[i][0]&#x3D;dp[i−1][0]+grid[i][0]。</p>
<p>当 i&#x3D;0 且 j&gt;0 时，dp[0][j]&#x3D;dp[0][j−1]+grid[0][j]。</p>
<p>当 i&gt;0 且 j&gt;0 时，dp[i][j]&#x3D;min(dp[i−1][j],dp[i][j−1])+grid[i][j]</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="comment">// 转移方程：dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(mn)，其中 m 和 n 分别是网格的行数和列数。需要对整个网格遍历一次，计算 dp 的每个元素的值。</p>
<p>空间复杂度：O(mn)，其中 m 和 n 分别是网格的行数和列数。创建一个二维数组 dp，和网格大小相同。<br>空间复杂度可以优化，例如每次只存储上一行的 dp 值，则可以将空间复杂度优化到 O(n)。</p>
<h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的 回文 子串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 仅由数字和英文字母组成</li>
</ul>
<p><strong>解题思路</strong></p>
<p>回文串有两种情况：</p>
<ol>
<li>奇数长度回文：中心是一个字符</li>
<li>偶数长度回文：中心是两个字符</li>
</ol>
<p>从每个位置向两边扩展，找到以该点（或该点和下一个点）为中心的最长回文子串。</p>
<p>记录最长的区间。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 转移方程：dp[i][j] = dp[i + 1][j - 1] if (s.charAt(i) == s.charAt(j))</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];  <span class="comment">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class="line">        <span class="comment">// 每个单字符都是回文串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 最长子串头部位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 最长子串的长度</span></span><br><span class="line">        <span class="comment">// 枚举每个子串长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + len - <span class="number">1</span>;  <span class="comment">// 子串右端点</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (j &gt;= n) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (len &lt;= <span class="number">3</span>) &#123;  <span class="comment">// 2 个或 3 个字符，直接就是回文子串</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新最大长度</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; len &gt; maxLen) &#123;</span><br><span class="line">                    maxLen = len;</span><br><span class="line">                    start = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n^2)，其中 n 是字符串的长度。动态规划的状态总数为 O(n^2)，对于每个状态，我们需要转移的时间为 O(1)。</p>
<p>空间复杂度：O(n^2)，即存储动态规划状态需要的空间。</p>
<h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a>1143. 最长公共子序列</h2><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p>
<p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li>
</ul>
<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li>
<li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li>
</ul>
<p><strong>解题思路</strong></p>
<p>定义状态：<br> <code>dp[i][j]</code> 表示 <code>text1[0..i-1]</code> 与 <code>text2[0..j-1]</code> 的最长公共子序列的长度。</p>
<p>状态转移：</p>
<ul>
<li>如果 <code>text1[i-1] == text2[j-1]</code>，则：<code>dp[i][j] = dp[i-1][j-1] + 1</code></li>
<li>否则：<code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code></li>
</ul>
<p>初始化：<br> <code>dp[0][*] = 0</code>, <code>dp[*][0] = 0</code>，即空字符串和任何字符串的 LCS 长度是 0。</p>
<p>答案：<br> <code>dp[m][n]</code>，其中 <code>m = text1.length</code>, <code>n = text2.length</code>。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="comment">// 转移方程：dp[i][j] = dp[i - 1][j - 1] + 1</span></span><br><span class="line">        <span class="comment">// dp[i][j] 表示 text1[0..i-1] 与 text2[0..j-1] 的最长公共子序列的长度</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> text1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> text2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(mn)，其中 m 和 n 分别是字符串 text1 和 text2 的长度。二维数组 dp 有 m+1 行和 n+1 列，需要对 dp 中的每个元素进行计算。</p>
<p>空间复杂度：O(mn)，其中 m 和 n 分别是字符串 text1 和 text2 的长度。创建了 m+1 行 n+1 列的二维数组 dp。</p>
<h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a>72. 编辑距离</h2><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)</span><br><span class="line">rorse -&gt; rose (删除 &#x27;r&#x27;)</span><br><span class="line">rose -&gt; ros (删除 &#x27;e&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 &#x27;t&#x27;)</span><br><span class="line">inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)</span><br><span class="line">enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)</span><br><span class="line">exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)</span><br><span class="line">exection -&gt; execution (插入 &#x27;u&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li>
<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>
</ul>
<p><strong>解题思路</strong></p>
<ul>
<li>定义 <code>dp[i][j]</code> 表示 <strong>将 <code>word1[0..i-1]</code> 转换为 <code>word2[0..j-1]</code> 的最少操作数</strong>。</li>
<li>递推公式：<ol>
<li><strong>如果最后一个字符相同</strong>：<br> <code>dp[i][j] = dp[i-1][j-1]</code></li>
<li><strong>如果最后一个字符不同</strong>，有三种选择，取三者最小值：<ul>
<li>插入：<code>dp[i][j-1] + 1</code></li>
<li>删除：<code>dp[i-1][j] + 1</code></li>
<li>替换：<code>dp[i-1][j-1] + 1</code></li>
</ul>
</li>
</ol>
</li>
<li>边界条件：<ul>
<li><code>dp[0][j] = j</code> （空字符串变成 word2[0..j-1] 需要插入 j 次）</li>
<li><code>dp[i][0] = i</code> （word1[0..i-1] 变成空字符串需要删除 i 次）</li>
</ul>
</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="comment">// 最后一个字符相同：dp[i][j] = dp[i - 1][j - 1]</span></span><br><span class="line">        <span class="comment">// 最后一个字符不同：</span></span><br><span class="line">        <span class="comment">// 插入：dp[i][j - 1] + 1</span></span><br><span class="line">        <span class="comment">// 删除：dp[i - 1][j] + 1</span></span><br><span class="line">        <span class="comment">// 替换: dp[i - 1][j - 1]</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> word1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> word2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i -<span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度 ：O(mn)，其中 m 为 word1 的长度，n 为 word2 的长度。</p>
<p>空间复杂度 ：O(mn)，我们需要大小为 O(mn) 的 D 数组来记录状态值。</p>
<h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a>136. 只出现一次的数字</h2><p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p>
<p><strong>示例 1 ：</strong></p>
<p>**输入：**nums &#x3D; [2,2,1]</p>
<p>**输出：**1</p>
<p><strong>示例 2 ：</strong></p>
<p>**输入：**nums &#x3D; [4,1,2,1,2]</p>
<p>**输出：**4</p>
<p><strong>示例 3 ：</strong></p>
<p>**输入：**nums &#x3D; [1]</p>
<p>**输出：**1</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>
<li><code>-3 * 104 &lt;= nums[i] &lt;= 3 * 104</code></li>
<li>除了某个元素只出现一次以外，其余每个元素均出现两次。</li>
</ul>
<p><strong>解题思路</strong></p>
<p>最巧妙的方法就是 <strong>位运算 - 异或 XOR</strong>。</p>
<p><strong>异或运算的性质</strong>：</p>
<ul>
<li><code>a ^ a = 0</code> （一个数和自己异或等于 0）</li>
<li><code>a ^ 0 = a</code> （一个数和 0 异或等于它本身）</li>
<li><strong>异或满足交换律和结合律</strong>。</li>
</ul>
<p>所以：把所有数字依次异或，<strong>成对出现的数字都会变成 0，被抵消掉</strong>，只剩下那个唯一的数字。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 异或运算 a ^ a = 0, a ^ 0 = a</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            result ^= num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 是数组长度。只需要对数组遍历一次。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a>169. 多数元素</h2><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,2,1,1,1,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 5 * 104</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<p>**进阶：**尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。</p>
<p><strong>解题思路</strong></p>
<p>最优解法是 <strong>Boyer-Moore 投票算法</strong>。</p>
<p>多数元素的出现次数 &gt; ⌊n&#x2F;2⌋。</p>
<p><strong>投票法</strong>：</p>
<ul>
<li>维护一个候选人 candidate 和一个计数器 count。</li>
<li>遍历数组：<ul>
<li>如果 count &#x3D;&#x3D; 0，设置当前数为候选人 candidate。</li>
<li>如果当前数 &#x3D;&#x3D; candidate，count++；否则 count–。</li>
</ul>
</li>
<li>遍历结束，candidate 就是多数元素</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 计数器</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 候选人</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// count 为 0 时，将当前数设置为 candidate</span></span><br><span class="line">        <span class="comment">// 遍历数组，如果当前数为 candidate，count++；否则 count--</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            count += (candidate == num) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)。Boyer-Moore 算法只对数组进行了一次遍历。</p>
<p>空间复杂度：O(1)。Boyer-Moore 算法只需要常数级别的额外空间。</p>
<h2 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a>75. 颜色分类</h2><p>给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组 <code>nums</code> ，<strong>原地</strong> 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p>
<p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p>
<p>**示例 1：**f</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,0,2,1,1,0]</span><br><span class="line">输出：[0,0,1,1,2,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,0,1]</span><br><span class="line">输出：[0,1,2]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 300</code></li>
<li><code>nums[i]</code> 为 <code>0</code>、<code>1</code> 或 <code>2</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li>
</ul>
<p><strong>解题思路</strong></p>
<p>我们用三个指针来维护区间：</p>
<ul>
<li><code>p0</code>：下一个 <code>0</code> 应该放置的位置；</li>
<li><code>p2</code>：下一个 <code>2</code> 应该放置的位置；</li>
<li><code>i</code>：当前扫描的位置。</li>
</ul>
<p>遍历 <code>nums</code>：</p>
<ul>
<li>如果 <code>nums[i] == 0</code>，说明它应该放到最前面：<ul>
<li>与 <code>nums[p0]</code> 交换，并移动 <code>p0++</code> 和 <code>i++</code>。</li>
</ul>
</li>
<li>如果 <code>nums[i] == 2</code>，说明它应该放到最后面：<ul>
<li>与 <code>nums[p2]</code> 交换，并移动 <code>p2--</code>（注意此时不能 <code>i++</code>，因为交换过来的数还没处理）。</li>
</ul>
</li>
<li>如果 <code>nums[i] == 1</code>，就继续 <code>i++</code>。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p0</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 下一个 0 的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;  <span class="comment">// 下一个 2 的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 当前位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= p2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums, i, p0);</span><br><span class="line">                p0++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 还不能移动 i，需要先处理交换过来的数</span></span><br><span class="line">                swap(nums, i, p2);</span><br><span class="line">                p2--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是数组 nums 的长度。</p>
<p>空间复杂度：O(1)。</p>
<h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a>31. 下一个排列</h2><p>整数数组的一个 <strong>排列</strong> 就是将其所有成员以序列或线性顺序排列。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li>
</ul>
<p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li>
<li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li>
<li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li>
</ul>
<p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p>
<p>必须<strong>原地</strong>修改，只允许使用额外常数空间。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,1]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,5]</span><br><span class="line">输出：[1,5,1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>注意到下一个排列总是比当前排列要大，除非该排列已经是最大的排列。我们希望找到一种方法，能够找到一个大于当前序列的新序列，且变大的幅度尽可能小。</p>
<p>阶段 1：从后往前找到第一个下降点 <code>i</code></p>
<ul>
<li>即满足 <code>nums[i] &lt; nums[i+1]</code> 的最大下标 <code>i</code>。</li>
<li>说明从 <code>i+1</code> 到末尾是一个非升序序列（最大排列）。</li>
<li>如果找不到这样的 <code>i</code>，说明整个数组是非升序（最大排列），直接反转整个数组即可。</li>
</ul>
<p>阶段 2：再从后往前找到第一个比 <code>nums[i]</code> 大的数 <code>j</code></p>
<ul>
<li>因为 <code>i+1..end</code> 是非升序，找到的第一个比 <code>nums[i]</code> 大的数，一定是“刚刚比它大”的数。</li>
</ul>
<p>阶段 3：交换 <code>nums[i]</code> 和 <code>nums[j]</code></p>
<ul>
<li>这样确保 <code>nums[0..i]</code> 变大，并且尽可能小。</li>
</ul>
<p>阶段 4：反转 <code>nums[i+1..end]</code></p>
<ul>
<li>让尾部恢复成最小字典序。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length; </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 1. 找到第一个下降点</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 2. 从后往前找第一个比 nums[i] 大的数 </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3. 交换</span></span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 反转 i+1...end</span></span><br><span class="line">        reverse(nums, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            swap(nums, left, right);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 N 为给定序列的长度。我们至多只需要扫描两次序列，以及进行一次反转操作。</p>
<p>空间复杂度：O(1)，只需要常数的空间存放若干变量。</p>
<h2 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a>287. 寻找重复数</h2><p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code> ，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。</p>
<p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回 <strong>这个重复的数</strong> 。</p>
<p>你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code> 且只用常量级 <code>O(1)</code> 的额外空间</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3,4,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,1,3,4,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 3 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,3,3,3,3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>nums.length == n + 1</code></li>
<li><code>1 &lt;= nums[i] &lt;= n</code></li>
<li><code>nums</code> 中 <strong>只有一个整数</strong> 出现 <strong>两次或多次</strong> ，其余整数均只出现 <strong>一次</strong></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>如何证明 <code>nums</code> 中至少存在一个重复的数字?</li>
<li>你可以设计一个线性级时间复杂度 <code>O(n)</code> 的解决方案吗？</li>
</ul>
<p><strong>解题思路</strong></p>
<p>这其实是 <strong>Floyd 判圈算法（龟兔赛跑算法）</strong> 的应用。</p>
<p>把数组看成一个<strong>链表</strong>：</p>
<ul>
<li>索引是节点，<code>nums[i]</code> 是指针。</li>
<li>由于有重复数，链表中一定会出现“环”。</li>
<li>问题转化为：找出环的入口，就是重复的数字。</li>
</ul>
<p>阶段 1：找环内的相遇点</p>
<ul>
<li>用快慢指针：<ul>
<li>慢指针 <code>slow = nums[slow]</code></li>
<li>快指针 <code>fast = nums[nums[fast]]</code></li>
</ul>
</li>
<li>它们一定会在环中相遇。</li>
</ul>
<p>阶段 2：找到环的入口（即重复数）</p>
<ul>
<li>一个指针从头开始 <code>p1 = 0</code></li>
<li>一个指针从相遇点开始 <code>p2 = slow</code></li>
<li>两个指针一起走，每次 <code>p1 = nums[p1], p2 = nums[p2]</code></li>
<li>相遇点就是重复数。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到相遇点</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到环入口</span></span><br><span class="line">        slow = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)。其中 n 为数组长度。算法分为两步：第一步利用快慢指针寻找相遇点，最坏情况下需要 O(n) 步；第二步从头开始再次移动指针寻找环的入口，同样最多 O(n) 步，因此整体复杂度为 O(n)。</p>
<p>空间复杂度：O(1)。只使用了若干指针变量（slow 和 fast），不依赖额外数据结构。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
