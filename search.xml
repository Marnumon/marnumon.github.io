<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AimAssist</title>
    <url>/2024/11/13/AimAssist/</url>
    <content><![CDATA[<h1 id="基于carpet-1-20的提前辅助瞄准"><a href="#基于carpet-1-20的提前辅助瞄准" class="headerlink" title="基于carpet 1.20的提前辅助瞄准"></a>基于carpet 1.20的提前辅助瞄准</h1><p><del>咕了</del></p>
<p>适用版本：1.20.x</p>
<span id="more"></span>

<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── helpers</span><br><span class="line">│   ├── BallisticCalculator // 弹道计算</span><br><span class="line">│   └── generateEmissionAngle(Player)</span><br><span class="line">└── mixins</span><br><span class="line">    ├── BowItem_aimAssistMixin  // 捕获目标</span><br><span class="line">    ├── getTarget(Level, Player, InteractionHand, CallbackInfoReturnable&lt;InteractionResultHolder&lt;ItemStack&gt;&gt;)</span><br><span class="line">    ├── LivingEntity_aimAssistMixin  // 准心控制</span><br><span class="line">    └── directionControl(CallbackInfo) // tick级物品栏检测</span><br></pre></td></tr></table></figure>

<h2 id="基本处理逻辑"><a href="#基本处理逻辑" class="headerlink" title="基本处理逻辑"></a>基本处理逻辑</h2><ol>
<li><p>输入指令，标记为true</p>
</li>
<li><p>鼠标右键（mouseDown）发出射线追踪获取实体信息，如果为Mob类，添加到目标队列，并且高亮目标，再次右键同一目标，移出队列，取消高亮</p>
</li>
<li><p>鼠标右键（mouseOn），根据目标的坐标和速度，计算弹道，并将准心设置在预设点，<del>蓄力完毕后会持续跟踪</del>，直到生物被移除目标队列</p>
</li>
</ol>
<h2 id="代码参考"><a href="#代码参考" class="headerlink" title="代码参考"></a>代码参考</h2><ul>
<li><p>carpet命令<br><code>carpet.commands.PlayerCommand</code><br><code>carpet.CarpetSettings</code><br><code>carpet.commands</code></p>
</li>
<li><p>使用mixin注入代码，检测玩家对于物品弓的使用事件<br><a href="https://github.com/gnembon/fabric-carpet/wiki/Checking-if-a-player-is-holding-the-right-tool">carpet检测玩家手持物品</a></p>
</li>
<li><p>射线检测获取目标<br><code>carpet.script.utils.Tracer.rayTrace</code><br><code>net.minecraft.world.phys.EntityHitResult</code><br><code>net.minecraft.world.entity.Entity.getViewVector</code>  </p>
</li>
<li><p>添加到目标队列<br>&#x2F;&#x2F; TODO</p>
</li>
<li><p>获取目标坐标，速度等信息<br><code>net.minecraft.world.entity.getDeltaMovement</code><br><code>net.minecraft.world.entity.spawnSprintParticle</code><br><code>net.minecraft.world.entity.getYRotf</code></p>
</li>
<li><p>获取轨迹所经过的方块，添加到队列<br><code>package net.minecraft.world.entity.projectile.shoot</code></p>
</li>
<li><p>箭的运动<br><code>net.minecraft.world.entity.projectile.AbstractArrow.tick</code></p>
</li>
<li><p>tick级计算并获取计算后的角度和力度<br>&#x2F;&#x2F; TODO</p>
</li>
<li><p>方向控制<br><code>carpet.helpers.EntityPlayerActionPack.look</code><br><code>net.minecraft.world.entity.ai.control.LookControl.tick</code><br><code>net.minecraft.world.entity.Entity.setRot</code></p>
</li>
<li><p>火力控制<br><code>carpet.helpers.EntityPlayerActionPack.ActionType.USE</code><br><code>net.minecraft.world.item.SnowballItem.use</code><br><code>net.minecraft.world.entity.projectile.Projectile.shoot</code><br><code>net.minecraft.world.entity.projectile.Projectile.shootFromRotation</code><br><code>net.minecraft.world.item.BowItem.releaseUsing</code></p>
</li>
<li><p>检查弓物品的使用状态<br><code>net.minecraft.world.entity.ai.goal.RangedBowAttackGoal.isHoldingBow</code></p>
</li>
<li><p>图腾检测<br><code>net.minecraft.world.entity.LivingEntity.checkTotemDeathProtection</code></p>
</li>
</ul>
<h2 id="待研究"><a href="#待研究" class="headerlink" title="待研究"></a>待研究</h2><ul>
<li><p>检测弓的使用*<br><code>net.minecraft.world.entity.LivingEntity.releaseUsingItem</code>  结束阶段<br><code>net.minecraft.world.entity.LivingEntity.updateUsingItem</code>  可能是中期阶段，待验证</p>
</li>
<li><p>实体<br><code>net.minecraft.world.entity.Entity.getOnPos</code>  脚底方块<br><code>net.minecraft.world.entity.Entity.getXRot</code>  角度</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Minecraft</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
        <tag>Carpet</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>八股文笔记 #1 Java 基础</title>
    <url>/2025/06/30/boilerplate-answers-1-java-basics/</url>
    <content><![CDATA[<p><del>再好的项目，也敌不过 HashMap 的 resize 过程没讲清楚</del></p>
<span id="more"></span>

<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="说一下-Java-的特点"><a href="#说一下-Java-的特点" class="headerlink" title="说一下 Java 的特点"></a>说一下 Java 的特点</h2><ul>
<li><strong>平台无关性</strong>：Java 的 “编写一次，运行无处不在” 哲学是其最大的特点之一。Java 编译器将源代码编译成字节码，该字节码可以在任何安装了 JVM 的系统上运行</li>
<li><strong>面向对象</strong>：Java 是一门严格的面向对象的编程语言，几乎一切都是对象。OOP 特性使得代码更易于维护和复用，包括类、对象、继承、多态、抽象和封装</li>
<li><strong>内存管理</strong>：Java 有自己的垃圾回收机制，自动管理内存和回收不再使用的对象</li>
</ul>
<h2 id="Java-的优势和劣势是什么？"><a href="#Java-的优势和劣势是什么？" class="headerlink" title="Java 的优势和劣势是什么？"></a>Java 的优势和劣势是什么？</h2><p><strong>优势</strong>：</p>
<ul>
<li><strong>跨平台</strong>：因为 JVM 的存在，一次编写到处运行</li>
<li><strong>面向对象</strong>：虽然现在很多语言都支持面向对象，但是 Java 的设计从一开始就是 OPP 的</li>
<li><strong>强大的生态</strong>：比如 Spring 框架，各种库和工具，社区支持大，企业应用广泛</li>
<li><strong>内存管理</strong>：自动垃圾回收机制，减少了内存泄漏的问题，对开发者友好</li>
<li><strong>多线程支持</strong>：内置的线程机制，方便并发编程</li>
<li><strong>安全性</strong>：Java 有安全模型，比如沙箱机制，适合网络环境</li>
<li><strong>稳定性</strong>：企业级应用长期使用，版本更新也比较注重向后兼容</li>
</ul>
<p><strong>劣势</strong>：</p>
<ul>
<li><strong>性能</strong>：虽然 JVM 优化了很多，但相比 CPP 和 Rust 这种原生编译语言，还是有一定开销</li>
<li><strong>启动时间</strong>：比如微服务场景下，可能不如 Go 之类的快</li>
<li><strong>语法繁琐</strong>：样板代码多，之前没有 lambda 的时候更麻烦，现在有了但是相比 Python 还是不够简介</li>
<li><strong>内存消耗</strong>：JVM 本身占内存，对于资源有限的环境可能不太友好</li>
<li><strong>面向对象过于严格</strong>：有时候写简单程序反而麻烦，虽然 Java 8 引入了函数式编程，但是不如其他语言自然</li>
<li><strong>开发效率</strong>：相比动态语言如 Python，Java需要更多代码，编译过程也可鞥拖慢开发节奏</li>
</ul>
<h2 id="Java-为什么是跨平台的？"><a href="#Java-为什么是跨平台的？" class="headerlink" title="Java 为什么是跨平台的？"></a>Java 为什么是跨平台的？</h2><p>主要依赖于 JVM。JVM也是一个软件，不同平台有不同的版本。编写的 Java 源码在编译后生成一种 <code>.class</code> 文件，称为字节码文件。JVM 就是负责将机器码文件翻译成特定平台下的机器码然后运行</p>
<p>也就是说，只要在不同平台上安装对应的 JVM，就可以运行字节码文件，运行我们编写的 Java 程序</p>
<p>PS：不同平台下编译生成的字节码是一样的，但是由 JVM 翻译成的机器码是不一样的；即使将 Java 程序打包成可执行文件（如 <code>.exe</code>），仍然需要 JVM 的支持；跨平台的是 Java 程序，不是 JVM，JVM 是用 C&#x2F;CPP 开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的 JVM</p>
<h2 id="JVM、JDK、JRE-三者关系？"><a href="#JVM、JDK、JRE-三者关系？" class="headerlink" title="JVM、JDK、JRE 三者关系？"></a>JVM、JDK、JRE 三者关系？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/image-20240725230247664.png" alt="JVM、JDK、JRE 关系图"></p>
<ul>
<li>JDK 是 Java 开发工具包，是开发 Java 程序所需的工具集合。它包含了 JVM、编译器（javac）、调试器（jdb）等开发工具，以及一系列的类库（如 Java 标准库和开发工具库）。JDK 提供了开发、编译、调试和运行 Java 程序所需的全部工具和环境</li>
<li>JRE 是 Java 运行时环境，是 Java 程序运行所需的最小环境。它包含了 JVM 和 一组 Java 类库，用于支持 Java 程序的执行。JRE 不包含开发工具，只提供 Java 程序运行所需的运行环境</li>
<li>JVM 是 Java 虚拟机，是 Java 程序运行的环境。它负责将 Java 字节码（由 Java 编译器生成）解释或编译成机器码，并执行程序。JVM 提供了内存管理、垃圾回收、安全性等功能，使得 Java 程序具备跨平台性</li>
</ul>
<h2 id="为什么-Java-解释和编译都有？"><a href="#为什么-Java-解释和编译都有？" class="headerlink" title="为什么 Java 解释和编译都有？"></a>为什么 Java 解释和编译都有？</h2><p>在 Java 经过编译之后生成字节码文件，接下来进入 JVM 中，就有两个步骤编译和解释，如图：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1715928000183-44fc6130-8abc-4f0b-8f6d-79de0ab09509.webp" alt="Java 源码执行过程"></p>
<ul>
<li><p><strong>编译性</strong>：Java 源码（<code>.java</code> 文件）通过 <code>javac</code> 编译，生成字节码文件（<code>.class</code>）</p>
</li>
<li><p><strong>解释性</strong>：早期 JVM 使用<strong>解释器</strong>，逐行解释执行字节码。现代 JVM 引入 <strong>JIT（Just-In-Time）编译器</strong>，热点代码会被编译为本地机器码提高执行效率</p>
</li>
</ul>
<p>所以 Java 既是编译型语言，也是解释型语言，默认采用的是解释器和编译器混合的模式</p>
<h2 id="JVM-是什么？"><a href="#JVM-是什么？" class="headerlink" title="JVM 是什么？"></a>JVM 是什么？</h2><p>JVM 是 Java 虚拟机，主要工作是解释自己的指令集（即字节码）并映射到本地的 CPU 指令集和 OS 的系统调用</p>
<p>JVM 屏蔽了与操作系统平台相关的信息，使得 Java 程序只需要生成在 Java 虚拟机上运行的目标代码（字节码），就可在多种平台上不加修改地运行，这也是 Java 能够 “一次编译，到处运行” 的原因</p>
<h2 id="编译型语言和解释型语言的区别？"><a href="#编译型语言和解释型语言的区别？" class="headerlink" title="编译型语言和解释型语言的区别？"></a>编译型语言和解释型语言的区别？</h2><ul>
<li><p><strong>编译型语言</strong>：在程序执行之前，整个源码会被编译成字节码或机器码，生成可执行文件。执行时直接运行编译后的代码，速度快，但跨平台性较差</p>
</li>
<li><p><strong>解释型语言</strong>：在程序执行时，逐行解释执行源码，不生成独立的可执行文件。通常由解释器动态解释并执行代码，跨平台性好，但执行速度相对较慢</p>
</li>
</ul>
<p>典型的编译型语言如 C、CPP，典型的解释型语言如 Python、JavaScript</p>
<h2 id="Java-和-Python-的区别是什么？"><a href="#Java-和-Python-的区别是什么？" class="headerlink" title="Java 和 Python 的区别是什么？"></a>Java 和 Python 的区别是什么？</h2><ul>
<li>Java 是一种先编译后解释的混合型语言，Java 编译器将源码编译为字节码，而字节码则由 Java 虚拟机执行</li>
<li>Python 是一种解释型语言，会在执行程序的同时进行解释</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="8-种基本的数据类型"><a href="#8-种基本的数据类型" class="headerlink" title="8 种基本的数据类型"></a>8 种基本的数据类型</h2><ul>
<li><strong>数值型</strong>：整数类型（<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>）和浮点类型（<code>float</code>、<code>double</code>）</li>
<li><strong>字符型</strong>：<code>char</code></li>
<li><strong>布尔型</strong>：<code>boolean</code></li>
</ul>
<p>8 种基本数据类型的占用大小、取值范围、默认值，如下表所示：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>占用大小（字节）</th>
<th>取值范围</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>byte</code></td>
<td>1</td>
<td><code>-2^7</code> 到 <code>2^7 - 1</code></td>
<td>0</td>
<td>最小的整数类型，适合用于节省内存，例如在处理文件或网络流时存储小范围整数数据</td>
</tr>
<tr>
<td><code>short</code></td>
<td>2</td>
<td><code>-2^15</code> 到 <code>2^15 - 1</code></td>
<td>0</td>
<td>较少使用，通常用于在需要节省内存且数据范围在该区间的场景</td>
</tr>
<tr>
<td><code>int</code></td>
<td>4</td>
<td><code>-2^31</code>到 <code>2^31 - 1</code></td>
<td>0</td>
<td>最常用的整数类型，可满足大多数日常编程种整数计算的需求</td>
</tr>
<tr>
<td><code>long</code></td>
<td>8</td>
<td><code>-2^63</code>到 <code>2^63 - 1</code></td>
<td>0L</td>
<td>用于表示非常大的整数，当 <code>int</code> 类型无法满足需求时使用，定义时数值后需加 <code>L</code> 或 <code>l</code></td>
</tr>
<tr>
<td><code>float</code></td>
<td>4</td>
<td><code>-2^31</code>到 <code>2^31 - 1</code></td>
<td>0.0f</td>
<td>单精度浮点数，用于表示小数，定义时数值后需加 <code>F</code> 或 <code>f</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td>8</td>
<td><code>-2^63</code>到 <code>2^63 - 1</code></td>
<td>0.0d</td>
<td>双精度浮点数，精度比 <code>float</code> 高，是 Java 种表示小数的默认类型</td>
</tr>
<tr>
<td><code>char</code></td>
<td>2</td>
<td><code>-2^15</code> 到 <code>2^15 - 1</code></td>
<td>‘\u0000’</td>
<td>用于表示单个字符，采用 Unicode编码，可表示各种语言的字符</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>不确定（理论上1位）</td>
<td><code>true</code> 或 <code>false</code></td>
<td><code>false</code></td>
<td>用于逻辑判断，只有两个取值，常用于条件判断和循环控制等逻辑场景</td>
</tr>
</tbody></table>
<p><code>float</code> 和 <code>double</code> 的最小值和最大值是以科学计数法的形式输出的，比如 3.14E3 表示 3.14 * 10^3，3.14E-3 表示 3.14 &#x2F; 10^3</p>
<p>注意：</p>
<ul>
<li>浮点数的默认类型是 <code>double</code>，声明 <code>float</code> 时必须在末尾加上 <code>F</code> 或 <code>f</code></li>
<li>整数的默认类型为 <code>int</code>，声明 <code>long</code> 时必须在末尾加上 <code>L</code> 或 <code>l</code></li>
<li><code>char</code> 的包装类是 <code>Character</code>，<code>int</code> 的是 <code>Integer</code>，其他都是首字母大写</li>
<li><code>char</code> 是无符号的，不能为负，所以是 0 开始的</li>
</ul>
<h2 id="long-和-int-可以互转吗？"><a href="#long-和-int-可以互转吗？" class="headerlink" title="long 和 int 可以互转吗？"></a>long 和 int 可以互转吗？</h2><p><strong>可以</strong>。由于 <code>long</code> 的范围比 <code>int</code> 大，因此将 <code>int</code> 转换为 <code>long</code> 是安全的，而将 <code>long</code> 转换为 <code>int</code> 可能会导致数据丢失或溢出</p>
<p>将 <code>int</code> 转换为 <code>long</code> 可以通过直接赋值或强制类型转换来实现。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">longValue</span> <span class="operator">=</span> intValue; <span class="comment">// 自动转换，安全的</span></span><br></pre></td></tr></table></figure>

<p>将 <code>long</code> 转换为 <code>int</code> 需要使用强制类型转换，但需要注意潜在的数据丢失或溢出问题。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">longValue</span> <span class="operator">=</span> <span class="number">100L</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> (<span class="type">int</span>) longValue; <span class="comment">// 强制类转换，可能会有数据丢失或溢出</span></span><br></pre></td></tr></table></figure>

<p>如果 <code>longValue</code> 的值超出了 <code>int</code> 的范围，转换结果是截断后的低位部分。因此，在转换之前，建议先检查 <code>longValue</code> 的值是否在 <code>int</code> 范围内，以避免数据丢失或溢出的问题</p>
<h2 id="数据类型转换的方式有哪些？"><a href="#数据类型转换的方式有哪些？" class="headerlink" title="数据类型转换的方式有哪些？"></a>数据类型转换的方式有哪些？</h2><ul>
<li><strong>自动类型转换（隐式转换）</strong>：当目标类型的范围大于源类型时，Java 会自动将源类型转换为目标类型，不需要显示的类型转换。例如：将 <code>int</code> 转换为 <code>long</code>、将 <code>float</code> 转换为 <code>double</code> 等</li>
<li><strong>强制类型转换（显示转换）</strong>：当目标类型的范围小于源类型时，需要使用强制类型转换将源类型转换为目标类型。这可能导致数据丢失或溢出。例如：将 <code>long</code> 转换为 <code>int</code> 、将 <code>double</code> 转换为 <code>float</code> 等。语法为：目标类型 变量名 &#x3D; (目标类型) 源类型</li>
<li><strong>字符串转换</strong>：Java 提供了将字符串表示的数据转换为其他类型数据的方法。例如，将字符串转换为整型 <code>int</code>，可以使用 <code>Integer.parseInt()</code> 方法；将字符串转换为浮点型 <code>double</code>，可以使用 <code>Double.parseDouble()</code> 方法等</li>
<li><strong>数值之间的转换</strong>：Java 提供了一些数据类型之间的转换方法，如将整型转换为字符型、将字符型转换为整型等。这些转换方式可以通过类型的包装类来实现，例如：将 <code>int</code> 转换为 <code>char</code>，可以使用 <code>Character.forDigit()</code> 方法；将 <code>char</code> 转换为 <code>int</code>，可以使用 <code>Character.getNumericValue()</code> 方法</li>
</ul>
<h2 id="类型互转可能会出现什么问题？"><a href="#类型互转可能会出现什么问题？" class="headerlink" title="类型互转可能会出现什么问题？"></a>类型互转可能会出现什么问题？</h2><ul>
<li><strong>数据丢失</strong>：当将一个范围较大的数据类型转换为一个范围较小的数据类型时，可能会发生数据丢失。例如：将一个 <code>long</code> 转换为 <code>int</code> 时，如果 <code>long</code> 值超出了 <code>int</code> 类型的范围，转换结果将是截断后的低位部分，高位部分的数据丢失</li>
<li><strong>数据溢出</strong>：与数据丢失相反，当讲一个范围较小的数据类型转换为一个范围较大的数据类型时，可能会发生数据溢出。例如：将一个 <code>int</code> 转换为 <code>long</code> 时，转换结果会填充额外的高位空间，但原始数据仍然保持不变</li>
<li><strong>精度损失</strong>：在进行浮点数类型的转换时，可能会发生精度损失。由于浮点数的表示方法不同，将一个单精度浮点数 <code>double</code> 转换为双精度浮点数 <code>float</code> 时，精度可能会损失</li>
<li><strong>类型不匹配导致的错误</strong>：在进行类型转换时，需要确保源类型和目标类型是兼容的。如果两者不兼容，会导致编译错误或运行时错误</li>
</ul>
<h2 id="为什么用-BigDecimal-不用-double？"><a href="#为什么用-BigDecimal-不用-double？" class="headerlink" title="为什么用 BigDecimal 不用 double？"></a>为什么用 BigDecimal 不用 double？</h2><p><code>double</code> 会出现精度丢失的问题，<code>dobule</code> 执行的是二进制浮点运算，二进制表示小数只能使用 1&#x2F;(2^n) 的和的组合，有些情况下不能准确地表示一个小数。</p>
<p>而 <code>BigDecimal</code> 是精确计算，一般牵扯到金钱的计算，都使用 <code>BigDecimal</code>。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.1&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">sum</span> <span class="operator">=</span> num1.add(num2); <span class="comment">// 0.3</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">product</span> <span class="operator">=</span> num1.multiply(num2); <span class="comment">// 0.02</span></span><br></pre></td></tr></table></figure>

<p>这样，<code>BigDecimal</code> 可以确保精确的十进制数值计算，避免了使用 <code>double</code> 可能出现的舍入误差。需要注意的是，在创建 <code>BigDecimal</code> 对象时，应该使用字符串作为参数，而不是直接使用浮点数值，以避免浮点数精度丢失</p>
<h2 id="装箱和拆箱是什么？"><a href="#装箱和拆箱是什么？" class="headerlink" title="装箱和拆箱是什么？"></a>装箱和拆箱是什么？</h2><p>装箱（Boxing）和拆箱（Unboxing）是将基本数据类型和对应的包装类之间进行转换的过程，自动装箱主要发送在赋值时和方法调用时，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 赋值时</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i; <span class="comment">// 拆箱</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法调用时</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">show</span><span class="params">(Integer iParam)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;自动装箱&quot;</span> + iParam);</span><br><span class="line">    <span class="keyword">return</span> iParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">show(<span class="number">3</span>); <span class="comment">// 装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> show(<span class="number">3</span>); <span class="comment">// 返回类型是 Integer，拆箱</span></span><br></pre></td></tr></table></figure>

<p>在一个循环中进行自动装箱操作的情况下可能出现问题，会创建多余的对象，影响程序的性能，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123; sum += <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure>

<p><code>+</code> 这个操作符不适用于 <code>Integer</code> 对象，首先 <code>sum</code> 进行自动拆箱操作，进行数值相加操作，最后发生自动装箱操作转换成 <code>Integer</code> 对象。其内部变化如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> sum.intValue() + i;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(result);</span><br></pre></td></tr></table></figure>

<p>因为 <code>sum</code> 声明为 <code>Integer</code> 类型，上面的循环中会创建 1000 个无用的 <code>Integer</code> 对象，会降低程序的性能，加重垃圾回收的工作量。因此在编程的时候，需要正确地声明变量类型，避免因为自动装箱引起的性能问题</p>
<h2 id="Java-为什么要有包装类？"><a href="#Java-为什么要有包装类？" class="headerlink" title="Java 为什么要有包装类？"></a>Java 为什么要有包装类？</h2><p>包装类就是将基本数据类型包装成 <code>Object</code> 对象，对象封装有诸多好处：</p>
<ul>
<li>可以把属性和方法结合在一起，比如 <code>Integer</code> 有 <code>parseInte()</code> 方法来专门处理 <code>int</code> 相关的数据</li>
<li>Java 中大部分类和方法都是用来处理<strong>引用类型</strong>的。像 <code>ArrayList</code> 这样的集合类，不能直接存储基本类型（如 <code>int</code>、<code>double</code>），而是必须使用其对应的包装类（如 <code>Integer</code>、<code>Double</code>）</li>
<li>在 Java 中，泛型只能使用<strong>引用类型</strong>，而不能使用<strong>基本数据类型</strong>。例如：对一个列表的元素进行排序，如果使用基本类型 <code>int</code>（实际上基本类型无法作为泛型参数，所以连 <code>List&lt;int&gt;</code> 都不合法），无法直接使用 <code>Collections.sort()</code> 方法，如果使用 <code>Integer</code> 包装类，则可以</li>
<li>在 Java 中，集合中只能存储引用类型，而不能存储基本类型。比如 <code>List&lt;int&gt;</code> 是不合法的，需要使用 <code>List&lt;Integer&gt;</code></li>
</ul>
<p>需要注意空指针异常。例如：<code>int</code> 可以赋值为 0，而 <code>Integer</code> 必须通过实例化对象来赋值，如果对一个未经初始化的 <code>Integer</code> 变量进行操作，就会出现 <code>NullPointerException</code>，这是因为它被赋值为 <code>null</code>，而 <code>null</code> 是无法进行自动拆箱的</p>
<h2 id="为什么还要保留基本数据类型？"><a href="#为什么还要保留基本数据类型？" class="headerlink" title="为什么还要保留基本数据类型？"></a>为什么还要保留基本数据类型？</h2><p>包装类是引用类型，对象的引用和对象本身是分开存储的，而对于基本数据类型，变量对应的内存块直接存储数据本身。因此，基本数据类型在读写效率方面，要比包装类高效</p>
<p>此外，在 64 位 JVM 上，在开启引用压缩的情况下，一个 <code>Integer</code> 对象占用 16 个字节的内存空间，而一个 <code>int</code> 类型数据只占用 4 字节的内存空间</p>
<p>不管在读写效率，还是存储效率，基本类型都比包装类高效</p>
<h2 id="说一下-Integer-的基本缓存"><a href="#说一下-Integer-的基本缓存" class="headerlink" title="说一下 Integer 的基本缓存"></a>说一下 Integer 的基本缓存</h2><p>Java 的 <code>Integer</code> 类内部实现了一个静态缓存池，用于存储特定范围内的整数值对应的 <code>Integer</code> 对象</p>
<p>默认情况下，这个范围是 -128 到 127。当通过 <code>Integer.valueOf(int)</code> 方法创建一个在这个范围内的整数对象时，并不会每次都生成新的对象实例，而是复用缓存中的对象，直接从内存中取出，不需要新建一个对象</p>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="怎么理解面向对象？简单说说封装、继承、多态"><a href="#怎么理解面向对象？简单说说封装、继承、多态" class="headerlink" title="怎么理解面向对象？简单说说封装、继承、多态"></a>怎么理解面向对象？简单说说封装、继承、多态</h2><p>面向对象是一种编程范式，它将现实世界中的事物抽象为对象，对象具有属性和方法。面向对象编程的设计思想是以对象为中心，通过对象之间的交互来完成程序的功能，具有灵活性和可扩展性</p>
<p>Java 面向对象的三大特性包括**：封装、继承、多态**</p>
<ul>
<li><strong>封装</strong>：封装是指将对象的属性（成员变量）和行为（方法）封装在一个类中，并通过访问控制符（如 <code>private</code>、<code>public</code> 等）隐藏内部实现细节，只暴露必要的接口供外部使用。封装的作用是<strong>增强安全性、提高模块独立性</strong>，防止外部对对象状态的非法访问或修改</li>
<li><strong>继承</strong>：继承是面向对象编程中实现代码复用的机制，它允许一个类（子类）继承另一个类（父类）的属性和方法。继承使得子类可以在父类基础上扩展功能，从而构建更清晰、更有层次的类结构</li>
<li><strong>多态</strong>：多态是指<strong>同一个方法调用，在不同对象上可以表现出不同的行为</strong>。它分为两种形式：<ul>
<li><strong>编译时多态（方法重载）</strong>：同一类中方法名相同、参数不同</li>
<li><strong>运行时多态（方法重写）</strong>：子类重写父类方法，并通过父类引用调用子类对象。<br> 多态使程序具备更好的<strong>扩展性和可维护性</strong>，是实现面向接口编程的关键</li>
</ul>
</li>
</ul>
<h2 id="多态体现在哪几个方面？"><a href="#多态体现在哪几个方面？" class="headerlink" title="多态体现在哪几个方面？"></a>多态体现在哪几个方面？</h2><ul>
<li><strong>方法重载</strong>：方法重载是指同一类中可以有多个同名方法，它们具有不同的参数列表。虽然方法名相同，但根据传入的不同参数，编译器会在编译时确定调用哪个方法。注意：方法返回值不同但参数相同，<strong>不构成重载</strong></li>
<li><strong>方法重写</strong>：方法重写是指子类能够提供对父类中同名方法的具体实现。在运行时，JVM 会根据对象的实际类型确定调用哪个版本的方法，这是实现多态的主要方式。注意：重写的方法必须具有<strong>相同的方法签名</strong>，且<strong>访问权限不能比父类更严格</strong></li>
<li><strong>接口与实现</strong>：Java 中的接口是一种行为规范，类通过 <code>implements</code> 关键字实现接口。多个类可以实现同一个接口，通过<strong>接口引用来调用方法</strong>，可以实现<strong>调用方与实现方的解耦</strong>，体现了多态特性</li>
<li><strong>向上转型和向下转型</strong>：<ul>
<li><strong>向上转型</strong>：子类对象可以被赋值给父类类型的引用（即：<code>Parent p = new Child()</code>），这在 Java 中是<strong>自动进行</strong>的，也是多态的前提。可以只调用父类中定义的方法，实际运行的是子类的重写实现（如果有）</li>
<li><strong>向下转型</strong>：将父类引用转换为子类类型（即：<code>Child c = (Child) p</code>），这通常需要<strong>强制类型转换</strong>，并应使用 <code>instanceof</code> 检查其实际类型，避免出现 <code>ClassCastException</code>。向下转型常用于访问子类特有的方法</li>
</ul>
</li>
</ul>
<h2 id="多态解决了什么问题？"><a href="#多态解决了什么问题？" class="headerlink" title="多态解决了什么问题？"></a>多态解决了什么问题？</h2><p>多态是指<strong>同一个方法调用，在不同对象上可以表现出不同的行为</strong>。多态的这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类</p>
<p>多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等</p>
<h2 id="面向对象的设计原则有哪些？"><a href="#面向对象的设计原则有哪些？" class="headerlink" title="面向对象的设计原则有哪些？"></a>面向对象的设计原则有哪些？</h2><ul>
<li><strong>单一职责原则（SRP）</strong>：一个类应该只有一个引起它变化的原因，即一个类应该只负责一项职责。例如：考虑一个员工类，它应该只负责管理员工信息，而不负责其他无关的工作</li>
<li><strong>开放封闭原则（OCP）</strong>：软件实体应该对扩展开放，对修改封闭。例如：定义一个图形类，然后让不同类型的图形继承这个类，而不需要修改图形类本身</li>
<li><strong>里式替换原则（LSP）</strong>：父类出现的地方，子类必须能够替代父类，并且保证原有功能不被破坏。例如：如果一个公司类包含部门类，应该考虑使用合成&#x2F;聚合关系，而不是将公司类继承自部门类</li>
<li><strong>接口隔离原则（ISP）</strong>：客户端不应该依赖那些它不需要的接口，即接口应该小而专。例如：你设计了一个 “多功能设备接口”，里面包含<strong>打印</strong>、<strong>扫描</strong>、<strong>传真</strong>、<strong>装订</strong>四个方法，结果，公司后来要做一款<strong>廉价入门级打印机</strong>，它只能打印，其余功能都没有。为了实现接口，这台打印机被迫提供空实现或抛异常</li>
<li><strong>依赖倒置原则（DIP）</strong>：高层模块不应该依赖低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。例如：假设有一个通知服务类 ，需要发送消息。错误的做法是它直接创建并依赖一个 <code>EmailSender</code> 类，这样如果以后要改用短信或微信，就必须修改通知服务的代码。正确的做法是先定义一个接口并实现它。通知服务类只依赖接口，而不是具体实现</li>
<li><strong>最少知识原则（Law of Demeter）</strong>：一个对象应当对其他对象有最少的了解，只与其直接的朋友交互。例如：你要点一杯咖啡，应该说：“服务员，请给我一杯拿铁。”，由服务员自己决定找谁、怎么做</li>
</ul>
<h2 id="抽象类和普通类的区别？"><a href="#抽象类和普通类的区别？" class="headerlink" title="抽象类和普通类的区别？"></a>抽象类和普通类的区别？</h2><ul>
<li><strong>实例化</strong>：普通类可以直接实例化对象，而抽象类不能被实例化，只能被继承</li>
<li><strong>方法实现</strong>：普通类中的方法可以有具体的实现，而抽象类中的方法可以有实现也可以没有实现</li>
<li><strong>实现限制</strong>：普通类可以被其他类继承和使用，而抽象类一般用于作为基类，被其他类继承和扩展使用</li>
</ul>
<h2 id="抽象类和接口的区别是什么？"><a href="#抽象类和接口的区别是什么？" class="headerlink" title="抽象类和接口的区别是什么？"></a>抽象类和接口的区别是什么？</h2><p><strong>两者的特点</strong>：</p>
<ul>
<li>抽象类用于描述类的共同特性和行为，可以有成员变量、构造方法和具体方法。适用于有明显继承关系的场景</li>
<li>接口用于定义行为规范，可以多实现，只能有常量和抽象方法(Java 8 以后可以有默认方法和静态方法)。适用于定义类的能力或功能</li>
</ul>
<p><strong>两者的区别:</strong></p>
<ul>
<li><strong>实现方式</strong>：实现接口的关键字为 <code>implements</code>，继承抽象类的关键字为 <code>extends</code>。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承</li>
<li><strong>方法方式</strong>：接口只有定义，不能有方法的实现，Java 8 中可以定义 <code>default</code> 方法体，而抽象类可以有定义与实现，方法可在抽象类中实现</li>
<li><strong>访问修饰符</strong>：接口成员变量默认为 <code>public static final</code>，必须赋初值，不能被修改；其所有的成员方法都是 <code>public abstract</code> 的。抽象类中成员变量默认 <code>default</code>，可在子类中被重新定义，也可被重新赋值；抽象方法被 <code>abstract</code> 修饰，不能被 <code>private</code>、<code>static</code>、<code>synchronized</code> 和 <code>native</code> 等修饰，必须以分号结尾，不带花括号</li>
<li><strong>变量</strong>：抽象类可以包含实例变量和静态变量，而接口只能包含常量（静态常量）</li>
</ul>
<h2 id="抽象类能加-final-修饰吗？"><a href="#抽象类能加-final-修饰吗？" class="headerlink" title="抽象类能加 final 修饰吗？"></a>抽象类能加 final 修饰吗？</h2><p><strong>不能</strong>。Java 中的抽象类是用来被继承的，而 <code>final</code> 修饰符用于禁止类被继承或方法被重写，因此，抽象类和 <code>final</code> 修饰符是互斥的，不能同时使用</p>
<h2 id="接口里面可以定义哪些方法"><a href="#接口里面可以定义哪些方法" class="headerlink" title="接口里面可以定义哪些方法"></a>接口里面可以定义哪些方法</h2><ul>
<li><strong>抽象方法</strong>：抽象方法是接口的核心部分，所有实现接口的类必须实现这些方法。抽象方法默认是 <code>public</code> 和 <code>abstract</code>，这些修饰符可以省略</li>
<li><strong>默认方法</strong>：默认方法是在 Java 8 引入的，允许接口提供具体实现，实现类可以选择重写默认方法</li>
<li><strong>静态方法</strong>：静态方法也是在 Java 8 引入的，它们属于接口本身，可以通过接口名直接调用，而不需要实现类的对象</li>
<li><strong>私有方法</strong>：私有方法是在 Java 9 引入的，用于在接口中为默认方法和其他私有方法提供辅助功能，这些方法不能被实现类访问，只能在接口内部使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sleeping...&quot;</span>);</span><br><span class="line">        logSleep();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method in interface&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logSleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logging sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="抽象类可以被实例化吗？"><a href="#抽象类可以被实例化吗？" class="headerlink" title="抽象类可以被实例化吗？"></a>抽象类可以被实例化吗？</h2><p><strong>不能</strong>。这意味着不能使用 <code>new</code> 关键字直接创建一个抽象类的对象。抽象类的存在主要是为了被继承，它通常包含一个或多个抽象方法（由 <code>abstract</code> 关键字修饰且无方法体），这些方法在子类中被实现</p>
<p>抽象类可以有构造器，这些构造器在子类实例化时会被调用，以便进行必要的初始化工作。然而，这个过程并不是直接实例化抽象类，而是创建了子类的实例，间接地使用了抽象类的构造器。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 构造器代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ConcreteClass &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 调用抽象类的构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实现抽象方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ConcreteClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass</span>();</span><br></pre></td></tr></table></figure>



<h2 id="接口可以包含构造函数吗？"><a href="#接口可以包含构造函数吗？" class="headerlink" title="接口可以包含构造函数吗？"></a>接口可以包含构造函数吗？</h2><p><strong>不能</strong>。接口不会有自己的示例，所以不需要有构造函数。</p>
<p>这是因为，构造函数就是初始化类的属性或方法，在 new 的一瞬间自动调用，然而接口是不能 new 的</p>
<h2 id="解释-Java-中的静态变量和静态方法"><a href="#解释-Java-中的静态变量和静态方法" class="headerlink" title="解释 Java 中的静态变量和静态方法"></a>解释 Java 中的静态变量和静态方法</h2><p>在 Java 中，静态变量和静态方法是与类本身关联的，而不是与类的实例（对象）关联，它们在内存中只存在一份，可以被类的所有实例共享</p>
<ul>
<li><strong>静态变量</strong>：静态变量（类变量）是在类中使用 <code>static</code> 关键字声明的变量，他们属于类而不是任何具体的对象。常用于需要在所有对象间共享的数据，如计数器、常量等。主要的特点：<ul>
<li><strong>共享性</strong>：所有该类的实例共享同一个静态变量。如果一个实例修改了静态变量的值，其他实例也会看到这个更改</li>
<li><strong>初始化</strong>：静态变量在类被加载时初始化，只会对其进行一次内存分配</li>
<li><strong>访问方式</strong>：静态变量可以直接通过类名访问，也可以通过实例访问，但推荐使用类名</li>
</ul>
</li>
<li><strong>静态方法</strong>：静态方法是在类中使用 <code>static</code> 关键字声明的方法，类似于静态变量，静态方法也属于类而不是任何具体的对象。常用于助手方法、获取类级别的信息或者是没有依赖于实例的数据处理。主要的特点：<ul>
<li><strong>访问静态成员</strong>：静态方法可以直接调用其他静态变量和静态方法，但不能之际访问非静态成员</li>
<li><strong>无实例依赖</strong>：静态方法可以在没有创建类实例的情况下调用。对于静态方法来说，不能直接访问非静态的成员变量或方法，因为静态方法没有上下文的实例</li>
<li><strong>多态性</strong>：静态方法不支持重写（Override），但可以被隐藏（Hide）</li>
</ul>
</li>
</ul>
<h2 id="非静态内部类和静态内部类的区别？"><a href="#非静态内部类和静态内部类的区别？" class="headerlink" title="非静态内部类和静态内部类的区别？"></a>非静态内部类和静态内部类的区别？</h2><ul>
<li>非静态内部类依赖于外部类的实例，而静态内部类不依赖于外部类的实例</li>
<li>非静态内部类可以访问外部类的实例变量和方法，而静态内部类只能访问外部类的静态成员</li>
<li>非静态内部类不能定义静态成员，而静态内部类可以定义静态成员</li>
<li>非静态内部类在外部类实例化后才能实例化，而静态内部类可以独立实例化</li>
<li>非静态内部类可以访问外部类的私有成员，而静态内部类不能直接访问外部类的私有成员，需要通过实例化外部类来访问</li>
</ul>
<h2 id="非静态内部类可以直接访问外部类的实例变量和方法，编译器是怎么做到的？"><a href="#非静态内部类可以直接访问外部类的实例变量和方法，编译器是怎么做到的？" class="headerlink" title="非静态内部类可以直接访问外部类的实例变量和方法，编译器是怎么做到的？"></a>非静态内部类可以直接访问外部类的实例变量和方法，编译器是怎么做到的？</h2><p>这是因为编译器在生成字节码时，会为非静态内部类维护一个指向外部类实例的引用，将外部类实例作为参数传入，并在内部类的实例化过程中建立外部类实例与内部类实例之间的联系，从而实现直接访问外部方法的功能</p>
<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="Java-中-final-的作用是什么？"><a href="#Java-中-final-的作用是什么？" class="headerlink" title="Java 中 final 的作用是什么？"></a>Java 中 final 的作用是什么？</h2><ul>
<li><strong>装饰类</strong>：当 <code>final</code> 修饰一个类时，表示这个类不能被继承，是类继承体系中的最终形态。例如：Java 中的 <code>String</code> 类就是用 <code>final</code> 修饰的，着保证了 <code>String</code> 类的不可变性和安全性，防止其他类通过继承来改变 <code>String</code> 类的行为和特性</li>
<li><strong>修饰方法</strong>：用 <code>final</code> 修饰的方法不能在子类中被重写。例如：<code>java.lang.Object</code> 类中的 <code>getClass</code> 方法就是 <code>final</code> 的，因为这个方法的行为是由 JVM 底层实现来保证的，不应该被子类修改</li>
<li><strong>修饰变量</strong>：当 <code>final</code> 修饰基本数据类型的变量时，改变量一旦被赋值就不能再改变。例如：<code>final int num = 10</code>，这里的 <code>num</code> 就是一个常量，不能再对齐进行重新赋值操作，否则会导致编译错误。对于引用类型，<code>final</code> 修饰意味着这个引用变量不能再指向其他对象，但对象本身的内容是可以改变的。例如：<code>final StringBuilder sb = new StringBuilder(&quot;Hello&quot;);</code>，不能让 <code>sb</code> 再指向其他 <code>StringBuilder</code> 对象，但可以通过 <code>sb.append(&quot; World!&quot;);</code> 来修改字符串的内容</li>
</ul>
<h1 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h1><h2 id="浅拷贝和深拷贝的区别？"><a href="#浅拷贝和深拷贝的区别？" class="headerlink" title="浅拷贝和深拷贝的区别？"></a>浅拷贝和深拷贝的区别？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1720683675376-c5af6668-4538-479f-84e8-42d4143ab101.webp" alt="深拷贝和浅拷贝的区别"></p>
<ul>
<li><strong>浅拷贝</strong>：只复制对象本身以及其字段中的基本类型值和引用类型的引用地址，不会递归复制引用对象本身。也就是说，浅拷贝会创建一个新的对象，但其中引用类型的字段仍指向原对象中引用的<strong>同一内存地址</strong>，所以原对象和拷贝对象会<strong>共享</strong>这些引用</li>
<li><strong>深拷贝</strong>：不仅复制对象本身，还会递归复制对象中所有的引用类型字段，确保所有嵌套的对象也被复制一份。这样，深拷贝生成的是一个完全独立的对象及其所有内部对象，原对象和拷贝对象之间互不影响</li>
</ul>
<h2 id="实现深拷贝的三种方法是什么"><a href="#实现深拷贝的三种方法是什么" class="headerlink" title="实现深拷贝的三种方法是什么?"></a>实现深拷贝的三种方法是什么?</h2><ul>
<li><strong>实现 <code>Cloneable</code> 接口并重写 <code>clone()</code> 方法</strong>：在 <code>clone()</code> 方法中，通过递归克隆引用类型字段来实现深拷贝</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String field1;</span><br><span class="line">    <span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">cloned</span> <span class="operator">=</span> (MyClass) <span class="built_in">super</span>.clone();</span><br><span class="line">        cloned.nestedObject = (NestedClass) nestedObject.clone(); <span class="comment">// 深拷贝内部的引用对象</span></span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>使用序列化和反序列化</strong>：通过将对象序列化为字节流，再从字节流反序列化为对象来实现深拷贝。要求对象及其所有引用类型字段都实现 <code>Serializable</code> 接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String field1;</span><br><span class="line">    <span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Myclass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">			<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">			oos.writeObject(<span class="built_in">this</span>);</span><br><span class="line">			oos.flush();</span><br><span class="line">			oos.close();</span><br><span class="line">			<span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray());</span><br><span class="line">			<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">			<span class="keyword">return</span> (MyClass) ois.readObject();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>手动递归复制</strong>：针对特定对象结构，手动递归复制对象及其引用类型字段。适用于对象结构复杂度不高的情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String field1;</span><br><span class="line">	<span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> MyClass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">MyClass</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">		copy.setField1(<span class="built_in">this</span>.field1);</span><br><span class="line">		copy.setNestedObject(<span class="built_in">this</span>.nestedObject.deepCopy());</span><br><span class="line">		<span class="keyword">return</span> copy;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line">	<span class="keyword">public</span> NestedClass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">NestedClass</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NestedClass</span>();</span><br><span class="line">		copy.setNestedField(<span class="built_in">this</span>.nestedField);</span><br><span class="line">		<span class="keyword">return</span> copy;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="什么是泛型？"><a href="#什么是泛型？" class="headerlink" title="什么是泛型？"></a>什么是泛型？</h2><p>泛型是 Java 编程语言中的一个重要特性，它允许类、接口和方法在定义时使用一个或多个类型参数，这些类型参数在使用时可以被指定为具体的类型</p>
<p>泛型的主要目的是在编译时提供更强的类型检查，并且在编译后能够保留类型信息，避免了在运行时出现类型转换异常</p>
<h2 id="为什么需要泛型？"><a href="#为什么需要泛型？" class="headerlink" title="为什么需要泛型？"></a>为什么需要泛型？</h2><ul>
<li><strong>适用于多种数据类型执行相同的代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">	System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">add</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> &#123;</span><br><span class="line">	System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">	System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个 <code>add()</code> 方法；通过泛型，我们可以复用为一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="type">double</span> <span class="title function_">add</span> <span class="params">(T a, T b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a.doubleValue() + b.doubleValue()));</span><br><span class="line">    <span class="keyword">return</span> a.doubleValue() + b.doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）</strong></li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.add(<span class="number">123</span>); <span class="comment">// 添加的是 Integer</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) list.get(<span class="number">1</span>); <span class="comment">// 编译通过，但运行时抛出 CCE</span></span><br></pre></td></tr></table></figure>

<p><code>list</code> 中的元素都是 <code>Object</code> 类型（无法约束其中的类型），所以在取出集合元素时需要人为地强制类型转换到具体的目标类型，且很容易出现 <code>ClassCastException</code> 异常</p>
<p>引入泛型，它将提供类型的约束，提供编译前的检查：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">// list.add(123); // 编译错误，不允许添加非 String 类型</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> list.get(<span class="number">0</span>); <span class="comment">// 不需要强制类型转换</span></span><br></pre></td></tr></table></figure>



<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="Java-创建对象有哪些方式？"><a href="#Java-创建对象有哪些方式？" class="headerlink" title="Java 创建对象有哪些方式？"></a>Java 创建对象有哪些方式？</h2><ul>
<li><strong>使用 <code>new</code> 关键字</strong>：通过 <code>new</code> 关键字直接调用类的构造方法来创建对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>通过反射创建对象</strong>：通过 Java 的反射机制可以再运行时动态地创建对象。可以使用 <code>Class</code> 类的 <code>newInstance()</code> 或者 <code>Constructor</code> 类的 <code>newInstance()</code> 方法创建对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Class 类</span></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>).newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Construcotr 类</span></span><br><span class="line">Constructor&lt;MyClass&gt; constructor = MyClass.class.getConstructor();</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用 <code>clone()</code> 方法</strong>：如果类实现了 <code>Cloneable</code> 接口，可以使用 <code>clone()</code> 方法复制对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj2</span> <span class="operator">=</span> (MyClass) obj1.clone();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用反序列化</strong>：通过将对象序列化到文件流中，然后再进行反序列化来创建对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">	<span class="comment">// Class definition</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// Serialize object</span></span><br><span class="line">		<span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">		<span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> 					<span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.ser&quot;</span>))</span><br><span class="line">		out.writeObject(obj);</span><br><span class="line">		out.close();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// Deserialize object</span></span><br><span class="line">		<span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> 						<span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line">		<span class="type">MyClass</span> <span class="variable">newObj</span> <span class="operator">=</span> (MyClass) in.readObject();</span><br><span class="line">		in.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="new-出的对象什么时候回收？"><a href="#new-出的对象什么时候回收？" class="headerlink" title="new 出的对象什么时候回收？"></a>new 出的对象什么时候回收？</h2><p>通过关键字 <code>new</code> 创建的对象，由 Java 的**垃圾回收器（Garbage Collector）**负责回收。垃圾回收器的工作是在程序运行过程中自动进行的，它会周期性地检测不再被引用的对象，并将其回收释放内存</p>
<p>具体来说，Java 对象的回收时机是由垃圾回收器根据一些算法来决定的，主要有以下几种情况：</p>
<ol>
<li><strong>引用计数法</strong>：某个对象的引用计数为 0 时，表示该对象不再被引用，可以被回收</li>
<li><strong>可达性分析算法</strong>：从根对象（如方法区中的类静态属性、方法中的局部变量等）出发，通过对象之间的引用链进行遍历，如果存在一条引用链到达某个对象，则说明该对象是可达的，反之则不可达，不可达的对象将被回收</li>
<li><strong>终结器（Finalizer）</strong>：如果对象重写了 <code>finalize()</code> 方法，垃圾回收器会在回收该对象之前调用 <code>finalize()</code> 方法，对象可以在 <code>finalize()</code> 方法中进行一些清理操作。然而，终结器机制的使用不被推荐，因为它的执行时间是不确定的，可能会导致不可预测的性能问题</li>
</ol>
<h2 id="如何获取私有对象？"><a href="#如何获取私有对象？" class="headerlink" title="如何获取私有对象？"></a>如何获取私有对象？</h2><p>在 Java 中，私有对象通常指的是类中被声明为 <code>private</code>  的成员变量或方法。由于 <code>private</code> 访问修饰符的限制，这些成员只能在其所在的类内部被访问</p>
<p>不过，可以通过下面两种方式来间接获取私有对象</p>
<ul>
<li><strong>使用公共访问器方法（<code>getter</code> 方法）</strong>：如果类的设计者遵循良好的编程规范，通常会为私有成员变量提供公共的访问器方法（<code>getter</code> 方法），通过调用这些方法可以安全地获取私有对象</li>
<li><strong>反射机制</strong>：反射机制允许在运行时检查和修改类、方法、字段等信息，通过反射可以绕过 <code>private</code> 访问修饰符的限制来获取私有对象。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">privateField</span> <span class="operator">=</span> <span class="string">&quot;私有字段的值&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessExcept</span><br><span class="line">		<span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">		Class&lt;?&gt; clazz = obj.getClass(); <span class="comment">// 获取 Class 对象</span></span><br><span class="line">		<span class="type">Field</span> <span class="variable">privateField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;privateField&quot;</span>); <span class="comment">// 获取私有字段</span></span><br><span class="line">		privateField.setAccessible(<span class="literal">true</span>); <span class="comment">// 设置可访问性</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) privateField.get(obj); <span class="comment">// 获取私有字段的值</span></span><br><span class="line">		System.out.println(value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h2><p><strong>Java 反射机制</strong>是指在程序运行期间，能够动态地获取一个类的结构信息（如类名、属性、方法、构造函数等），并且可以在运行时操作这些信息，例如创建对象、访问属性、调用方法等。这使得 Java 拥有强大的动态性和灵活性，是实现诸如框架设计、依赖注入、动态代理等高级功能的重要基础</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1718957173277-863d2ec6-a754-423b-9066-9f28610d1a31.png" alt="反射机制"></p>
<p><strong>反射具有以下特性</strong>：</p>
<ul>
<li><strong>运行时类信息访问</strong>：反射允许程序在运行时获取一个类的完整结构信息，包括类名、字段、方法、构造器等，即使在编译时并不知道具体的类</li>
<li><strong>动态创建对象</strong>：通过反射，可以在运行时动态地创建对象实例。即便类名是在运行时才确定，也可以使用 <code>Class.newInstance()</code> 或 <code>Constructor.newInstance()</code> 方法完成对象的创建</li>
<li><strong>动态方法调用</strong>：反射支持在运行时调用对象的方法，包括私有方法。这通常通过 <code>Method.invoke()</code> 实现，允许传入对象实例和参数，从而执行对应的方法</li>
<li><strong>字段访问与修改</strong>：反射还可以访问和修改对象的字段值，包括私有字段。可以使用 <code>Field.set()</code> 方法设置字段的值，必要时可通过 <code>setAccessible(true)</code> 打破访问限制</li>
</ul>
<h2 id="反射在你平时写代码或者框架中的应用场景有哪些？"><a href="#反射在你平时写代码或者框架中的应用场景有哪些？" class="headerlink" title="反射在你平时写代码或者框架中的应用场景有哪些？"></a>反射在你平时写代码或者框架中的应用场景有哪些？</h2><ul>
<li><p><strong>加载数据库驱动</strong>：在使用 JDBC 连接数据库时，常常需要根据实际使用的数据库类型（如 MySQL、Oracle）动态加载对应的驱动类。此时可以使用 <code>Class.forName()</code> 方法通过反射机制加载指定的驱动类，而无需在代码中硬编码具体的驱动实现，从而提升系统的灵活性和可配置性。例如：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;db.properties&quot;</span>));</span><br><span class="line"><span class="type">String</span> <span class="variable">driverClass</span> <span class="operator">=</span> props.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">Class.forName(driverClass); <span class="comment">// 反射方式动态加载驱动</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置文件加载</strong>：在 Spring 框架中，IoC（控制反转）容器能够根据配置文件（如 XML 或 properties）动态加载和管理 Bean。你只需在配置文件中声明需要的类及其属性，Spring 就会自动通过反射机制实例化相应的对象并注入依赖，极大地提高了程序的可扩展性与解耦性</p>
<p>下面以简单示例说明 Spring 通过配置文件和反射加载 Bean 的过程：</p>
<ul>
<li>将所有 XML 或 properties 配置文件加载到内存中</li>
<li>通过 Java 代码解析配置文件，提取类的全限定名（即类的完整包名路径）及其属性等配置信息</li>
<li>利用反射机制，根据提取的类名动态获取对应的 <code>Class</code> 实例，并创建对象或调用方法</li>
</ul>
<p>配置文件（如 <code>config.properties</code>）</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">className</span>=<span class="string">com.example.reflectdemo.testInvoke</span></span><br><span class="line"><span class="attr">methodName</span>=<span class="string">printlnState</span></span><br></pre></td></tr></table></figure>

<p>实体类（<code>TestInvoke.java</code>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInvoke</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printlnState</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;I am fine&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置读取工具方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getName</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\config.properties&quot;</span>);</span><br><span class="line">    properties.load(in);</span><br><span class="line">    in.close();</span><br><span class="line">    <span class="keyword">return</span> properties.getProperty(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主方法：使用反射加载类并调用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1. 通过配置文件读取类名和方法名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> getName(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> getName(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 加载类</span></span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取并访问方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(methodName);</span><br><span class="line">    method.setAccessible(<span class="literal">true</span>); <span class="comment">// 允许访问私有方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 实例化对象并调用方法</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">    method.invoke(instance); <span class="comment">// 输出：I am fine</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="能讲一讲注解的原理吗？"><a href="#能讲一讲注解的原理吗？" class="headerlink" title="能讲一讲注解的原理吗？"></a>能讲一讲注解的原理吗？</h2><p>在 Java 中，注解（Annotation）本质上是继承了 <code>java.lang.annotation.Annotation</code> 接口的特殊接口。每个注解类型在编译后都会生成一个 <code>.class</code> 文件，JVM 会根据字节码中的信息，在运行时动态创建该注解的<strong>代理对象</strong></p>
<p>当我们通过反射调用 <code>clazz.getAnnotation(MyAnnotation.class)</code> 获取注解时，返回的并不是一个普通对象，而是一个由 JVM 动态生成的代理实例。该代理实现了注解接口，并会将方法调用转发给 <code>AnnotationInvocationHandler</code> 的 <code>invoke()</code> 方法</p>
<p>在 <code>AnnotationInvocationHandler</code> 中维护了一个 <code>memberValues</code> 的 <code>Map</code>，它存储了注解的属性名与属性值。这个 Map 的内容来源于 <code>.class</code> 文件中的常量池，类加载时被 JVM 解析并缓存</p>
<p><strong>总结整个流程</strong>：</p>
<ol>
<li>注解被编写并编译后，相关信息存入 <code>.class</code> 文件的字节码结构中；</li>
<li>如果注解的保留策略为 <code>RUNTIME</code>，JVM 在加载类时会解析注解信息；</li>
<li>调用反射 API 获取注解对象时，JVM 返回的是一个动态代理实例；</li>
<li>调用注解方法（如 <code>value()</code>）时，方法会被代理对象拦截；</li>
<li>代理将调用转发至 <code>AnnotationInvocationHandler</code>，从 <code>memberValues</code> 中取出实际值并返回。</li>
</ol>
<h2 id="对注解解析的底层实现了解吗？"><a href="#对注解解析的底层实现了解吗？" class="headerlink" title="对注解解析的底层实现了解吗？"></a>对注解解析的底层实现了解吗？</h2><p>注解本质上是一个接口，继承自 <code>java.lang.annotation.Annotation</code>。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后，注解类型会被转换成一个普通接口的形式，并保留相关元数据到 <code>.class</code> 文件中</p>
<p>Java 中通过 <code>@Retention</code> 注解指定注解的保留策略，常见的三种为：</p>
<ul>
<li><code>SOURCE</code>：仅保留在源码中，编译后丢弃</li>
<li><code>CLASS</code>：编译时保留在 <code>.class</code> 文件中，运行时不可访问</li>
<li><code>RUNTIME</code>：编译后保留，并可通过反射访问（<strong>实际参与运行时行为</strong>）</li>
</ul>
<p>只有 <code>RUNTIME</code> 注解会被 JVM 加载并参与反射处理，JVM 会将注解元数据存储在 <code>.class</code> 文件的**属性表（Attribute Table）**中，包括：</p>
<ul>
<li><strong><code>RuntimeVisibleAnnotations</code></strong>：存储运行时可见的注解信息</li>
<li><strong><code>RuntimeInvisibleAnnotations</code></strong>：存储运行时不可见的注解信息</li>
<li><strong><code>RuntimeVisibleParameterAnnotations</code></strong>：存储方法参数上的注解信息</li>
</ul>
<p>通过反射 API 可以获取类、方法、字段等元素上的注解。反射的核心类 <code>AnnotatedElement</code>（如 <code>Class</code>、<code>Method</code>、<code>Field</code> 都实现了它）提供了访问注解的接口，如：</p>
<ul>
<li><strong><code>getAnnotation(Class&lt;T&gt; annotationClass)</code></strong>：获取指定类型的注解</li>
<li><strong><code>getAnnotations()</code></strong>：获取所有注解</li>
<li><strong><code>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</code></strong>：判断是否包含指定注解</li>
</ul>
<p>这些方法最终调用的是 JVM 的 native 方法，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">native</span> Annotation[] getDeclaredAnnotations0(<span class="type">boolean</span> publicOnly);</span><br></pre></td></tr></table></figure>

<p>这些 native 方法在类加载时解析 <code>.class</code> 文件中保存的注解字节码信息，并生成<strong>动态代理对象</strong>，用于运行时访问</p>
<p>因此，注解解析的底层实现主要依赖于 Java 的反射机制和字节码文件的存储。通过 <code>@Retention</code> 元注解可以控制注解的保留策略，当使用 <code>RetentionPolicy.RUNTIME</code> 时，可以在运行时通过反射 API 来解析注解信息。在 JVM 层面，会从字节码文件中读取注解信息，并创建注解的代理对象来获取注解的属性值</p>
<h2 id="注解的适用范围（Target）是什么？"><a href="#注解的适用范围（Target）是什么？" class="headerlink" title="注解的适用范围（Target）是什么？"></a>注解的适用范围（Target）是什么？</h2><p>Java 中注解的“适用范围”由 <code>@Target</code> 元注解指定，用于定义注解可以作用于哪些程序元素。常见的范围包括：</p>
<ul>
<li><code>ElementType.TYPE</code>：类、接口（包括注解类型）或枚举</li>
<li><code>ElementType.METHOD</code>：方法</li>
<li><code>ElementType.FIELD</code>：字段（包括枚举常量）</li>
<li><code>ElementType.CONSTRUCTOR</code>：构造方法</li>
<li><code>ElementType.PARAMETER</code>：参数</li>
<li><code>ElementType.LOCAL_VARIABLE</code>：局部变量</li>
<li><code>ElementType.ANNOTATION_TYPE</code>：注解类型本身</li>
<li><code>ElementType.PACKAGE</code>：包</li>
<li><code>ElementType.TYPE_USE</code>：任何使用类型的地方（如泛型、强转、注解类型参数等）</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个注解就只能用于类或方法</p>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="介绍一下-Java-的异常"><a href="#介绍一下-Java-的异常" class="headerlink" title="介绍一下 Java 的异常"></a>介绍一下 Java 的异常</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1720683900898-1d0ce69d-4b5d-41a6-a5df-022e42f8f4c5.webp" alt="Java 异常类层次结构图"></p>
<p>Java 的异常体系是围绕 <code>Throwable</code> 类及其子类构建的。<code>Throwable</code> 有两个直接子类：<code>Error</code> 和 <code>Exception</code>，它们代表了两类不同性质的问题：</p>
<ul>
<li><p><strong>Error（错误）</strong>：表示 JVM 运行时出现的严重错误，通常是系统级的问题，程序无法控制和恢复。常见的错误包括 <code>OutOfMemoryError</code>、<code>StackOverflowError</code> 等，这类错误 <strong>不建议</strong> 程序捕获或处理，因为处理后也难以恢复</p>
</li>
<li><p><strong>Exception（异常）</strong>：表示程序本身可以<strong>感知并处理</strong>的问题，又细分为：</p>
<ul>
<li><p><strong>非运行时异常</strong>：编译器会强制检查，必须显式处理（try-catch）或声明抛出（throws）。例如 <code>IOException</code>、<code>SQLException</code>、<code>ClassNotFoundException</code> 等，这些异常多与外部资源或环境因素有关（如文件、数据库、网络），处理它们可以提升程序的健壮性</p>
</li>
<li><p><strong>运行时异常</strong>：<code>RuntimeException</code> 及其子类，编译器<strong>不会强制检查</strong>，通常由程序逻辑错误引起。例如 <code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code>、<code>ArithmeticException</code> 等。虽然不是强制处理，但良好的程序设计应尽量避免这类异常</p>
</li>
</ul>
</li>
</ul>
<h2 id="Java-的异常处理方式有哪些？"><a href="#Java-的异常处理方式有哪些？" class="headerlink" title="Java 的异常处理方式有哪些？"></a>Java 的异常处理方式有哪些？</h2><p>Java 提供了一套完整的异常处理机制，用于捕获和处理运行时可能出现的异常，以增强程序的健壮性和可维护性。主要包括以下几种方式：</p>
<ul>
<li><p><strong><code>try-catch-finally</code> 语句块</strong>：用于捕获并处理代码执行过程中可能抛出的异常</p>
<ul>
<li><code>try</code> 块包含可能抛出异常的代码</li>
<li><code>catch</code> 块用于捕获并处理特定类型的异常</li>
<li><code>finally</code> 块（可选）用于释放资源或执行善后操作，无论是否发生异常都会执行，常用于资源释放（如关闭文件流、数据库连接等）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType1 e1) &#123;</span><br><span class="line">    <span class="comment">// 处理异常类型1</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType2 e2) &#123;</span><br><span class="line">    <span class="comment">// 处理异常类型2</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论是否发生异常，都会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>throw</code> 语句</strong>：用于<strong>手动抛出</strong>一个异常实例，抛出的对象必须是 <code>Throwable</code> 类型或其子类，通常用于业务逻辑判断，如参数校验失败时主动抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>throws</code> 关键字</strong>：用于在<strong>方法签名</strong>中声明该方法可能抛出的异常类型，通知调用者需要处理这些异常，如果是受检异常，必须显式处理或继续声明抛出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 可能抛出 IOException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="抛出异常为什么不用-throws？"><a href="#抛出异常为什么不用-throws？" class="headerlink" title="抛出异常为什么不用 throws？"></a>抛出异常为什么不用 throws？</h2><p>在 Java 中，如果异常属于<strong>非受检异常</strong>，或者在方法内部已经<strong>被捕获并处理</strong>，那么就不需要在方法签名中使用 <code>throws</code> 关键字</p>
<ul>
<li><strong>非受检异常</strong>：未检查异常是指继承自 <code>RuntimeException</code> 或 <code>Error</code> 的异常类型。编译器<strong>不会强制要求</strong>开发者显式地处理这些异常，也不要求在方法签名中声明它们。包括 <code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code>、<code>IllegalArgumentException</code>、<code>ArithmeticException</code> 等，由于这类异常往往是由程序逻辑错误引起的，Java 更倾向于通过代码修复，而不是强制捕获或声明</li>
<li><strong>异常已被捕获并处理</strong>：如果在方法内部使用了 <code>try-catch</code> 块对异常进行了处理，那么该异常就<strong>不会继续向外抛出</strong>，因此也不需要在方法签名中使用 <code>throws</code></li>
</ul>
<h2 id="try-catch-中的语句运行情况"><a href="#try-catch-中的语句运行情况" class="headerlink" title="try-catch 中的语句运行情况"></a>try-catch 中的语句运行情况</h2><p>在 Java 中，<code>try</code> 块中的代码会按顺序执行：</p>
<ul>
<li>如果 <code>try</code> 块中<strong>未发生异常</strong>，则跳过所有 <code>catch</code> 块，<strong>直接执行 <code>finally</code>（如果有）</strong>，然后继续执行后续代码</li>
<li>如果 <code>try</code> 块中<strong>发生了异常</strong>，Java 会依次检查每个 <code>catch</code> 块，看是否有匹配的异常类型：<ul>
<li>如果匹配成功，对应的 <code>catch</code> 块会执行，然后进入 <code>finally</code>（如果有）</li>
<li>如果没有匹配的 <code>catch</code>，异常将<strong>向上抛出</strong>，由调用者处理，<code>finally</code> 块仍会执行</li>
</ul>
</li>
<li><strong><code>finally</code> 块始终会执行</strong>，无论是否发生异常，除非 JVM 退出或程序崩溃</li>
</ul>
<h2 id="try-return-“a”-finally-return-“b”-返回什么？"><a href="#try-return-“a”-finally-return-“b”-返回什么？" class="headerlink" title="try { return “a” } finally { return “b” } 返回什么？"></a>try { return “a” } finally { return “b” } 返回什么？</h2><p>该语句的返回值是 <code>&quot;b&quot;</code></p>
<p>在 Java 中，如果 <code>try</code> 和 <code>finally</code> 中都包含 <code>return</code> 语句，<strong><code>finally</code> 中的 <code>return</code> 会覆盖 <code>try</code> 中的返回值</strong>。即使 <code>try</code> 中已经准备好返回 <code>&quot;a&quot;</code>，在执行 <code>finally</code> 时仍会被 <code>&quot;b&quot;</code> 替代</p>
<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><h2 id="与-equals-有什么区别？"><a href="#与-equals-有什么区别？" class="headerlink" title="&#x3D;&#x3D; 与 equals() 有什么区别？"></a>&#x3D;&#x3D; 与 equals() 有什么区别？</h2><p>在 Java 中，<code>==</code> 和 <code>equals()</code> 都可用于比较两个对象，但它们的行为有本质上的不同：</p>
<ul>
<li><p><strong><code>==</code></strong>：比较的是引用是否相等</p>
<ul>
<li><p><code>==</code> 判断两个对象<strong>是否指向同一块内存地址</strong>，即它们是否是<strong>同一个对象的引用</strong></p>
</li>
<li><p>对于基本数据类型，<code>==</code> 比较的是<strong>数值本身是否相等</strong></p>
</li>
<li><p>对于引用类型（如字符串、对象等），<code>==</code> 比较的是两个引用是否指向<strong>同一对象</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(a == b); <span class="comment">// false：不同对象，地址不同</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>equals()</code></strong>：比较的是内容是否相等</p>
<ul>
<li><p><code>equals()</code> 是 <code>Object</code> 类中的方法，默认行为与 <code>==</code> 相同，即<strong>比较引用地址</strong></p>
</li>
<li><p>但很多类（如 <code>String</code>、<code>Integer</code>、<code>List</code> 等）都<strong>重写了 <code>equals()</code> 方法</strong>，改为比较对象的<strong>内容</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(a.equals(b)); <span class="comment">// true：内容相同</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>需要注意</strong>：字符串是 Java 中的特殊对象，字面量字符串会被放入<strong>字符串常量池</strong>，如果你写 <code>String s1 = &quot;abc&quot;; String s2 = &quot;abc&quot;;</code>，则 <code>s1 == s2</code> 会返回 <code>true</code>，因为它们引用的是常量池中的同一个对象</p>
<h2 id="hashCode-和-equals-方法有什么关系？"><a href="#hashCode-和-equals-方法有什么关系？" class="headerlink" title="hashCode() 和 equals() 方法有什么关系？"></a>hashCode() 和 equals() 方法有什么关系？</h2><p>在 Java 中，对于重写 <code>equals()</code> 方法的类，通常也需要重写 <code>hashCode()</code> 方法，并且需要遵循以下规定：</p>
<ul>
<li><strong>一致性</strong>：如果两个对象使用 <code>equals()</code> 方法比较结果为 <code>true</code>，那么它们的 <code>hashCode()</code> 的值必须相同。也就是说，如果 <code>obj1.equals(obj2)</code> 返回 <code>true</code>，那么 <code>obj1.hashCode()</code> 必须等于 <code>obj2.hashCode()</code>。</li>
<li><strong>非一致性</strong>：如果两个对象的 <code>hashCode()</code> 的值相同，它们使用 <code>equals()</code> 方法比较的结果不一定为 <code>true</code>。即 <code>obj1.hashCode() == obj2.hashCode()</code> 时，<code>obj1.equals(obj2)</code> 可能为 <code>false</code>，这种情况称为哈希冲突。</li>
</ul>
<p><code>hashCode()</code> 和 <code>equals()</code> 方法是紧密相关的，重写 <code>equals()</code> 方法时必须重写 <code>hashCode()</code> 方法，以保证在使用哈希表等数据结构时，对象的相等性判断和存储查找操作能够正常工作。而重写 <code>hashCode()</code> 方法时，需要确保相等的对象具有相同的哈希码，但相同哈希码的对象不一定相等</p>
<h2 id="String、StringBuilder、StringBuffer-的区别和联系"><a href="#String、StringBuilder、StringBuffer-的区别和联系" class="headerlink" title="String、StringBuilder、StringBuffer 的区别和联系"></a>String、StringBuilder、StringBuffer 的区别和联系</h2><ul>
<li><p><strong>可变性</strong>： <code>String</code> 是不可变的（Immutable），一旦创建，内容无法修改，每次修改都会生成一个新的对象。<code>StringBuilder</code> 和 <code>StringBuffer</code> 是可变的（Mutable），可以直接对字符串内容进行修改而不会创建新对象</p>
</li>
<li><p>**线程安全性 **：<code>String</code> 因为不可变，天然线程安全。<code>StringBuilder</code> 不是线程安全的，适用于单线程环境。<code>StringBuffer</code> 是线程安全的，其方法通过 <code>synchronized</code> 关键字实现同步，适用于多线程环境</p>
</li>
<li><p>**性能 **：<code>String</code> 性能最低，尤其是在频繁修改字符串时会生成大量临时对象，增加内存开销和垃圾回收压力。<code>StringBuilder</code> 性能最高，因为它没有线程安全的开销，适合单线程下的字符串操作。<code>StringBuffer</code> 性能略低于 <code>StringBuilder</code>，因为它的线程安全机制引入了同步开销</p>
</li>
<li><p>**使用场景 **：如果字符串内容固定或不常变化，优先使用 <code>String</code>。如果需要频繁修改字符串且在单线程环境下，使用 <code>StringBuilder</code>。如果需要频繁修改字符串且在多线程环境下，使用 <code>StringBuffer</code></p>
</li>
</ul>
<p>对比总结如下：</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>String</strong></th>
<th><strong>StringBuilder</strong></th>
<th><strong>StringBuffer</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>不可变性</strong></td>
<td>不可变</td>
<td>可变</td>
<td>可变</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>是（因不可变）</td>
<td>否</td>
<td>是（同步方法）</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>低（频繁修改时）</td>
<td>高（单线程）</td>
<td>中（多线程安全）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>静态字符串</td>
<td>单线程动态字符串</td>
<td>多线程动态字符串</td>
</tr>
</tbody></table>
<h1 id="Java-新特性"><a href="#Java-新特性" class="headerlink" title="Java 新特性"></a>Java 新特性</h1><h2 id="Java-8-有什么新特性？"><a href="#Java-8-有什么新特性？" class="headerlink" title="Java 8 有什么新特性？"></a>Java 8 有什么新特性？</h2><p>下面是 Java 8 主要新特性的整理表格，包含关键改进和示例说明：</p>
<table>
<thead>
<tr>
<th><strong>特性名称</strong></th>
<th><strong>描述</strong></th>
<th><strong>示例或说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Lambda 表达式</strong></td>
<td>简化匿名内部类，支持函数式编程</td>
<td><code>(a, b) -&gt; a + b</code> 代替匿名类实现接口</td>
</tr>
<tr>
<td><strong>函数式接口</strong></td>
<td>仅含一个抽象方法的接口，可用 <code>@FunctionalInterface</code> 注解标记</td>
<td><code>Runnable</code>, <code>Comparator</code> 或自定义接口 <code>@FunctionalInterface interface MyFunc &#123; void run(); &#125;</code></td>
</tr>
<tr>
<td><strong>Stream API</strong></td>
<td>提供链式操作处理集合数据，支持并行处理</td>
<td><code>list.stream().filter(x -&gt; x &gt; 0).collect(Collectors.toList())</code></td>
</tr>
<tr>
<td><strong>Optional 类</strong></td>
<td>封装可能为 <code>null</code> 的对象，减少空指针异常</td>
<td><code>Optional.ofNullable(value).orElse(&quot;default&quot;)</code></td>
</tr>
<tr>
<td><strong>方法引用</strong></td>
<td>简化 Lambda 表达式，直接引用现有方法</td>
<td><code>System.out::println</code> 等价于 <code>x -&gt; System.out.println(x)</code></td>
</tr>
<tr>
<td><strong>接口的默认方法与静态方法</strong></td>
<td>接口可定义默认实现和静态方法，增强扩展性</td>
<td><code>interface A &#123; default void print() &#123; System.out.println(&quot;默认方法&quot;); &#125; &#125;</code></td>
</tr>
<tr>
<td><strong>并行数组排序</strong></td>
<td>使用多线程加速数组排序</td>
<td><code>Arrays.parallelSort(array)</code></td>
</tr>
<tr>
<td><strong>重复注解</strong></td>
<td>允许同一位置多次使用相同注解</td>
<td><code>@Repeatable</code> 注解配合容器注解使用</td>
</tr>
<tr>
<td><strong>类型注解</strong></td>
<td>注解可应用于更多位置（如泛型、异常等）</td>
<td><code>List&lt;@NonNull String&gt; list</code></td>
</tr>
<tr>
<td><strong>CompletableFuture</strong></td>
<td>增强异步编程能力，支持链式调用和组合操作</td>
<td><code>CompletableFuture.supplyAsync(() -&gt; &quot;result&quot;).thenAccept(System.out::println)</code></td>
</tr>
</tbody></table>
<h2 id="Lambda-表达式了解吗？"><a href="#Lambda-表达式了解吗？" class="headerlink" title="Lambda 表达式了解吗？"></a>Lambda 表达式了解吗？</h2><p>Lambda 表达式是一种简洁的语法，用于创建匿名函数，主要用于简化函数式接口（只有一个抽象方法的接口）的使用。其基本语法有以下两种形式：</p>
<ul>
<li><strong><code>(parameters) -&gt; expression</code></strong>：当 Lambda 体只有一个表达式时使用，表达式的结果会作为返回值</li>
<li><strong><code>(parameters) -&gt; &#123; statements; &#125;</code></strong>：当 Lambda 体包含多条语句时，需要使用大括号将语句括起来，若有返回值则需要使用 <code>return</code> 语句</li>
</ul>
<p>传统的匿名内部类实现方式代码较为冗长，<strong>而 Lambda 表达式可以用更简洁的语法实现相同的功能</strong>。例如，使用匿名内部类实现 <code>Runnable</code> 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousClassExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Running using anonymous class&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Lambda 表达式实现相同功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;Running using lambda expression&quot;</span>));</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Lambda 表达式能够更清晰地表达代码的意图</strong>，尤其是在处理集合操作时，如过滤、映射等。例如，过滤出列表中所有偶数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadabilityExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式结合 Stream API 过滤偶数</span></span><br><span class="line">        List&lt;Integer&gt; evenNumbers = numbers.stream()</span><br><span class="line">                                           .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                                           .collect(Collectors.toList());</span><br><span class="line">        System.out.println(evenNumbers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Lambda 表达式使得 Java 支持函数式编程范式</strong>，允许将函数作为参数传递，从而可以编写更灵活、可复用的代码。例如，定义一个通用的计算函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionalProgrammingExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">operate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, Calculator calculator)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> calculator.calculate(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式传递加法函数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> operate(<span class="number">3</span>, <span class="number">5</span>, (x, y) -&gt; x + y);</span><br><span class="line">        System.out.println(<span class="string">&quot;Sum: &quot;</span> + sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式传递乘法函数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> operate(<span class="number">3</span>, <span class="number">5</span>, (x, y) -&gt; x * y);</span><br><span class="line">        System.out.println(<span class="string">&quot;Product: &quot;</span> + product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然 Lambda 表达式优点蛮多的，不过也有一些缺点，比如会增加调试困难，因为 Lambda 表达式是匿名的，在调试时很难定位具体是哪个 Lambda 表达式出现了问题。尤其是当 Lambda 表达式嵌套使用或者比较复杂时，调试难度会进一步增加</p>
<h2 id="介绍一下-stream-的-API"><a href="#介绍一下-stream-的-API" class="headerlink" title="介绍一下 stream 的 API"></a>介绍一下 stream 的 API</h2><p>Java 8 引入了 Stream API，它提供了一种高效且易于使用的数据处理方式，特别适合集合对象的操作，如过滤、映射、排序等。Stream API 不仅可以提高代码的可读性和简洁性，还能利用多核处理器的优势进行并行处理</p>
<p><strong>案例1：过滤并收集满足条件的元素</strong></p>
<p><strong>问题场景</strong>：从一个列表中筛选出所有长度大于 3 的字符串，并收集到一个新的列表中</p>
<p><strong>没有Stream API的做法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; originalList = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;fig&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;kiwi&quot;</span>);</span><br><span class="line">List&lt;String&gt; filteredList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String item : originalList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.length() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        filteredList.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码需要显式地创建一个新的 <code>ArrayList</code>，并通过循环遍历原列表，手动检查每个元素是否满足条件，然后添加到新列表中</p>
<p><strong>使用Stream API的做法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; originalList = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;fig&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;kiwi&quot;</span>);</span><br><span class="line">List&lt;String&gt; filteredList = originalList.stream()</span><br><span class="line">                                        .filter(s -&gt; s.length() &gt; <span class="number">3</span>)</span><br><span class="line">                                        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>这里，我们直接在原始列表上调用 <code>stream()</code> 方法创建了一个流，使用 <code>filter()</code> 中间操作筛选出长度大于 3 的字符串，最后使用 <code>collect(Collectors.toList())</code> 终端操作将结果收集到一个新的列表中。代码更加简洁明了，逻辑一目了然</p>
<p><strong>案例2：计算列表中所有数字的总和</strong></p>
<p><strong>问题场景</strong>：计算一个数字列表中所有元素的总和</p>
<p><strong>没有Stream API的做法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Integer number : numbers) &#123;</span><br><span class="line">    sum += number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个传统的 for-each 循环遍历列表中的每一个元素，累加它们的值来计算总和</p>
<p><strong>使用Stream API的做法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers.stream()</span><br><span class="line">                 .mapToInt(Integer::intValue)</span><br><span class="line">                 .sum();</span><br></pre></td></tr></table></figure>

<p>通过 Stream API，我们可以先使用 <code>mapToInt()</code> 将 Integer 流转换为 IntStream（这是为了高效处理基本类型），然后直接调用 <code>sum()</code> 方法来计算总和，极大地简化了代码</p>
<h2 id="Stream流的并行-API-是什么？"><a href="#Stream流的并行-API-是什么？" class="headerlink" title="Stream流的并行 API 是什么？"></a>Stream流的并行 API 是什么？</h2><p><strong>是 ParallelStream</strong></p>
<p>并行流（ParallelStream）就是将源数据分为多个子流对象进行多线程操作，然后将处理的结果再汇总为一个流对象，底层是使用通用的 fork&#x2F;join 池来实现，即将一个任务拆分成多个 “小任务” 并行计算，再把多个 “小任务” 的结果合并成总的计算结果</p>
<p>Stream 串行流与并行流的主要区别：</p>
<p> <img src="https://cdn.xiaolincoding.com//picgo/1716365522454-4b56a07e-9b54-4cbb-9832-26b099fc35cd.png" alt="Stream 串行流与并行流的主要区别"></p>
<p>对 CPU 密集型的任务来说，并行流使用 ForkJoinPool 线程池，为每个 CPU 分配一个任务，这是非常有效率的，但是如果任务不是 CPU 密集的，而是 IO 密集的，并且任务数相对线程数比较大，那么直接用 ParallelStream 并不是很好的选择</p>
<h2 id="CompletableFuture-怎么用的？"><a href="#CompletableFuture-怎么用的？" class="headerlink" title="CompletableFuture 怎么用的？"></a>CompletableFuture 怎么用的？</h2><p><code>CompletableFuture</code> 是由 Java 8 引入的，在 Java 8 之前我们一般通过 Future 实现异步</p>
<ul>
<li><code>Future</code> 用于表示异步计算的结果，只能通过阻塞或者轮询的方式获取结果，而且不支持设置回调方法，Java 8 之前若要设置回调一般会使用 guava 的 <code>ListenableFuture</code> ，回调的引入又会导致臭名昭著的回调地狱</li>
<li><code>CompletableFuture</code> 对 <code>Future</code> 进行了扩展，可以通过设置回调的方式处理计算结果，同时也支持组合操作，支持进一步的编排，同时一定程度解决了回调地狱的问题</li>
</ul>
<p><code>Future</code>（<code>ListenableFuture</code>）的实现（回调地狱）如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="type">ListeningExecutorService</span> <span class="variable">guavaExecutor</span> <span class="operator">=</span> MoreExecutors.listeningDecorator(executor);</span><br><span class="line">ListenableFuture&lt;String&gt; future1 = guavaExecutor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//step 1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step1 result&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">ListenableFuture&lt;String&gt; future2 = guavaExecutor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//step 2</span></span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step2 result&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">ListenableFuture&lt;List&lt;String&gt;&gt; future1And2 = Futures.allAsList(future1, future2);</span><br><span class="line">Futures.addCallback(future1And2, <span class="keyword">new</span> <span class="title class_">FutureCallback</span>&lt;List&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(List&lt;String&gt; result)</span> &#123;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        ListenableFuture&lt;String&gt; future3 = guavaExecutor.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行step 3&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;step3 result&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        Futures.addCallback(future3, <span class="keyword">new</span> <span class="title class_">FutureCallback</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String result)</span> &#123;</span><br><span class="line">                System.out.println(result);</span><br><span class="line">            &#125;        </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, guavaExecutor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">    &#125;&#125;, guavaExecutor);</span><br></pre></td></tr></table></figure>

<p><code>CompletableFuture</code> 的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step1 result&quot;</span>;</span><br><span class="line">&#125;, executor);</span><br><span class="line">CompletableFuture&lt;String&gt; cf2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step2 result&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">cf1.thenCombine(cf2, (result1, result2) -&gt; &#123;</span><br><span class="line">    System.out.println(result1 + <span class="string">&quot; , &quot;</span> + result2);</span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 3&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step3 result&quot;</span>;</span><br><span class="line">&#125;).thenAccept(result3 -&gt; System.out.println(result3));</span><br></pre></td></tr></table></figure>

<p>显然，<code>CompletableFuture</code> 的实现更为简洁，可读性更好</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1713777049912-2268a5fc-c7f1-477d-8c9c-310aae18f51a.png" alt="CompletableFuture"></p>
<p><code>CompletableFuture</code> 实现了两个接口：<code>Future</code>、<code>CompletionStage</code></p>
<ul>
<li><code>Future</code> 表示异步计算的结果，<code>CompletionStage</code> 用于表示异步执行过程中的一个步骤（Stage），这个步骤可能是由另外一个 <code>CompletionStage</code> 触发的，随着当前步骤的完成，也可能会触发其他一系列 <code>CompletionStage</code> 的执行</li>
<li>从而我们可以根据实际业务对这些步骤进行多样化的编排组合，<code>CompletionStage</code> 接口正是定义了这样的能力，我们可以通过其提供的 <code>thenAppy</code>、<code>thenCompose</code> 等函数式编程方法来组合编排这些步骤</li>
</ul>
<h2 id="Java-21-新特性知道哪些？"><a href="#Java-21-新特性知道哪些？" class="headerlink" title="Java 21 新特性知道哪些？"></a>Java 21 新特性知道哪些？</h2><p><strong>新语言特性</strong>：</p>
<ul>
<li><strong>Switch 语句的模式匹配</strong>：该功能在 Java 21 中也得到了增强。它允许在 <code>switch</code> 的 <code>case</code> 标签中使用模式匹配，使操作更加灵活和类型安全，减少了样板代码和潜在错误。例如：对于不同类型的账户类，可以在 <code>switch</code> 语句中直接根据账户类型的模式来获取相应的余额，如 <code>case savingsAccount sa -&gt; result = sa.getSavings();</code></li>
<li><strong>数组模式</strong>：将模式匹配扩展到数组中，使开发者能够在条件语句中更高效地解构和检查数组内容。例如：<code>if (arr instanceof int[] &#123;1, 2, 3&#125;)</code>，可以直接判断数组 <code>arr</code> 是否匹配指定的模式</li>
<li><strong>字符串模板（预览版）</strong>：提供了一种更可读、更易维护的方式来构建复杂字符串，支持在字符串字面量中直接嵌入表达式。例如，以前可能需要使用 <code>&quot;hello &quot; + name + &quot;, welcome to the geeksforgeeks!&quot;</code> 这样的方式来拼接字符串，在 Java 21 中可以使用  <code>hello &#123;name&#125;, welcome to the geeksforgeeks!</code> 这种更简洁的写法</li>
</ul>
<p><strong>新并发特性方面</strong>：</p>
<ul>
<li><strong>虚拟线程</strong>：这是 Java 21 引入的一种轻量级并发的新选择。它通过共享堆栈的方式，大大降低了内存消耗，同时提高了应用程序的吞吐量和响应速度。可以使用静态构建方法、构建器或 <code>ExecutorService</code> 来创建和使用虚拟线程</li>
<li><strong>Scoped Values（范围值）</strong>：提供了一种在线程间共享不可变数据的新方式，避免使用传统的线程局部存储，促进了更好的封装性和线程安全，可用于在不通过方法参数传递的情况下，传递上下文信息，如用户会话或配置设置</li>
</ul>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><h2 id="怎么把一个对象从一个-JVM-转移到另一个-JVM"><a href="#怎么把一个对象从一个-JVM-转移到另一个-JVM" class="headerlink" title="怎么把一个对象从一个 JVM 转移到另一个 JVM"></a>怎么把一个对象从一个 JVM 转移到另一个 JVM</h2><ul>
<li><strong>使用序列化和反序列化</strong>：将对象序列化为字节流，并将其发送到另一个 JVM，然后在另一个 JVM 中反序列化字节流恢复对象。这可以通过 Java 的 <code>ObjectOutputStream</code> 和 <code>ObjectInputStream</code> 来实现。</li>
<li><strong>使用消息传递机制</strong>：利用消息传递机制，比如使用消息队列（如 RabbitMQ、Kafka）或者通过网络套接字进行通信，将对象从一个 JVM 发送到另一个。这需要自定义协议来序列化对象并在另一个 JVM 中反序列化</li>
<li><strong>使用远程方法调用（RPC）</strong>：可以使用远程方法调用框架，如 gRPC，来实现对象在不同 JVM 之间的传输。远程方法调用可以让你在分布式系统中调用远程 JVM 上的对象的方法</li>
<li><strong>使用共享数据库或缓存</strong>：将对象存储在共享数据库（如 MySQL、PostgreSQL）或共享缓存（如 Redis）中，让不同的 JVM 可以访问这些共享数据。这种方法适用于需要共享数据但不需要直接传输对象的场景</li>
</ul>
<h2 id="让你自己实现序列化和反序列化，你会怎么做"><a href="#让你自己实现序列化和反序列化，你会怎么做" class="headerlink" title="让你自己实现序列化和反序列化，你会怎么做?"></a>让你自己实现序列化和反序列化，你会怎么做?</h2><p>Java 默认的序列化虽然实现方便，但却存在安全漏洞、不跨语言以及性能差等缺陷：</p>
<ul>
<li><strong>无法跨语言</strong>： Java 序列化目前只适用基于 Java 语言实现的框架，其它语言大部分都没有使用 Java 的序列化框架，也没有实现 Java 序列化这套协议。因此，如果是两个基于不同语言编写的应用程序相互通信，则无法实现两个应用服务之间传输对象的序列化与反序列化</li>
<li><strong>容易被攻击</strong>：Java 序列化是不安全的，我们知道对象是通过在 <code>ObjectInputStream</code> 上调用 <code>readObject()</code> 方法进行反序列化的，这个方法其实是一个神奇的构造器，它可以将类路径上几乎所有实现了 <code>Serializable</code> 接口的对象都实例化。这也就意味着，在反序列化字节流的过程中，该方法可以执行任意类型的代码，这是非常危险的</li>
<li><strong>序列化后的流太大</strong>：序列化后的二进制流大小能体现序列化的性能。序列化后的二进制数组越大，占用的存储空间就越多，存储硬件的成本就越高。如果我们是进行网络传输，则占用的带宽就更多，这时就会影响到系统的吞吐量</li>
</ul>
<p>我会考虑用主流序列化框架，比如 FastJson、Protobuf 来替代 Java 序列化</p>
<p>如果追求性能的话，Protobuf 序列化框架会比较合适，Protobuf 的这种数据存储格式，不仅压缩存储数据的效果好， 在编码和解码的性能方面也很高效。Protobuf 的编码和解码过程结合 <code>.proto</code> 文件格式，加上 Protocol Buffer 独特的编码格式，只需要简单的数据运算以及位移等操作就可以完成编码与解码。可以说 Protobuf 的整体性能非常优秀</p>
<h2 id="将对象转为二进制字节流具体怎么实现"><a href="#将对象转为二进制字节流具体怎么实现" class="headerlink" title="将对象转为二进制字节流具体怎么实现?"></a>将对象转为二进制字节流具体怎么实现?</h2><p>其实，像序列化和反序列化，无论这些可逆操作是什么机制，都会有对应的<strong>处理和解析协议</strong>，例如加密和解密，TCP的粘包和拆包，序列化机制是通过序列化协议来进行处理的，和 <code>.class</code> 文件类似，它其实是定义了序列化后的字节流格式，然后对此格式进行操作，生成符合格式的字节流或者将字节流解析成对象。</p>
<p>在 Java 中通过序列化对象流来完成序列化和反序列化：</p>
<ul>
<li><code>ObjectOutputStream</code>：通过 <code>writeObject()</code> 方法做序列化操作</li>
<li><code>ObjectInputStrean</code>：通过 <code>readObject()</code> 方法做反序列化操作</li>
</ul>
<p>只有实现了 <code>Serializable</code> 或 <code>Externalizable</code> 接口的类的对象才能被序列化，否则抛出异常</p>
<p>实现对象序列化：</p>
<ul>
<li>让类实现 <code>Serializable</code> 接口：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// class code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建输出流并写入对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.ser&quot;</span>);</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOut);</span><br><span class="line">    out.writeObject(obj);</span><br><span class="line">    out.close();</span><br><span class="line">    fileOut.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现对象反序列化：</p>
<ul>
<li>创建输入流并读取对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">newObj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>);</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileIn);</span><br><span class="line">    newObj = (MyClass) in.readObject();</span><br><span class="line">    in.close();</span><br><span class="line">    fileIn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上步骤，对象 <code>obj</code> 会被序列化并写入到文件 <code>object.ser</code> 中，然后通过反序列化操作，从文件中读取字节流并恢复为对象 <code>newObj</code>。这种方式可以方便地将对象转换为字节流用于持久化存储、网络传输等操作。需要注意的是，要确保类实现了 <code>Serializable</code> 接口，并且所有成员变量都是 <code>Serializable</code> 的才能被正确序列化</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="volatile-和-sychronized-如何实现单例模式"><a href="#volatile-和-sychronized-如何实现单例模式" class="headerlink" title="volatile 和 sychronized 如何实现单例模式"></a>volatile 和 sychronized 如何实现单例模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleTon</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止指令重排，保证可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">SingleTon</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleTon</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleTon <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingleTon.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">SingleTon</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>volatile</code> 的作用：</p>
<ol>
<li><strong>保证可见性</strong>：多个线程访问 <code>instance</code> 时，能看到最新的值</li>
<li><strong>禁止指令重排序</strong>：确保对象在完全构造前，其他线程不会看到它的引用，避免出现“半初始化”对象</li>
</ol>
<p>双重检查锁定（DCL）原理：</p>
<ul>
<li><strong>第一次检查</strong>：避免进入同步块（提升性能）</li>
<li><strong>同步块内部再次检查</strong>：保证线程安全，仅在首次创建对象时同步</li>
</ul>
<h2 id="代理模式和适配器模式有什么区别？"><a href="#代理模式和适配器模式有什么区别？" class="headerlink" title="代理模式和适配器模式有什么区别？"></a>代理模式和适配器模式有什么区别？</h2><ul>
<li><strong>目的不同</strong>：代理模式主要关注控制对对象的访问，而适配器模式则用于接口转换，使不兼容的类能够一起工作</li>
<li><strong>结构不同</strong>：代理模式一般包含抽象主题、真实主题和代理三个角色，适配器模式包含目标接口、适配器和被适配者三个角色</li>
<li><strong>应用场景不同</strong>：代理模式常用于添加额外功能或控制对对象的访问，适配器模式常用于让不兼容的接口协同工作</li>
</ul>
<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="Java-怎么实现网络-IO-高并发编程？"><a href="#Java-怎么实现网络-IO-高并发编程？" class="headerlink" title="Java 怎么实现网络 IO 高并发编程？"></a>Java 怎么实现网络 IO 高并发编程？</h2><p><strong>可以用 Java NIO</strong>，是一种同步非阻塞的 IO 模型，也是 IO 多路复用的基础</p>
<p>传统的 BIO 里面 <code>socket.read()</code>，如果 TCP RecvBuffer 里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据， 如果使用 BIO 要想要并发处理多个客户端的 IO，那么会使用多线程模式，一个线程专门处理一个客户端 IO，这种模式随着客户端越来越多，所需要创建的线程也越来越多，会急剧消耗系统的性能</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/image-20240820112641716.png" alt="BIO"></p>
<p>NIO 是基于 IO 多路复用实现的，它可以只用一个线程处理多个客户端 IO，如果你需要同时管理成千上万的连接，但是每个连接只发送少量数据，例如一个聊天服务器，用NIO实现会更好一些</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/image-20240820112656259.png" alt="NIO"></p>
<h2 id="BIO、NIO、AIO区别是什么？"><a href="#BIO、NIO、AIO区别是什么？" class="headerlink" title="BIO、NIO、AIO区别是什么？"></a>BIO、NIO、AIO区别是什么？</h2><table>
<thead>
<tr>
<th>模型</th>
<th>特点</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>BIO</strong></td>
<td>同步阻塞，每个连接一个线程，简单但性能差</td>
<td>适用于连接数少、对实时性要求不高的系统</td>
</tr>
<tr>
<td><strong>NIO</strong></td>
<td>同步非阻塞，使用 <code>Selector</code> 管理多个通道，一个线程可处理多个连接</td>
<td>适用于高并发、大量连接的服务端程序</td>
</tr>
<tr>
<td><strong>AIO</strong></td>
<td>异步非阻塞，基于回调通知，IO 操作完全由系统异步完成</td>
<td>适用于连接数非常多、IO 操作频繁的高性能场景</td>
</tr>
</tbody></table>
<ul>
<li><strong>BIO（Blocking IO）</strong>：传统 <code>java.io</code>，线程阻塞直至完成读写操作，编程简单但不适合高并发</li>
<li><strong>NIO（Non-blocking IO）</strong>：Java 1.4 引入，引入 <code>Channel</code>、<code>Selector</code>、<code>Buffer</code>，可以实现单线程处理多连接</li>
<li><strong>AIO（Asynchronous IO）</strong>：Java 1.7 引入，真正的异步非阻塞，系统完成 IO 后自动回调通知业务线程处理</li>
</ul>
<h2 id="NIO-是怎么实现的？"><a href="#NIO-是怎么实现的？" class="headerlink" title="NIO 是怎么实现的？"></a>NIO 是怎么实现的？</h2><p>NIO 是一种<strong>同步非阻塞</strong>的 IO 模型 </p>
<p>同步是指线程不断轮询 IO 事件是否就绪，同步的核心是 Selector（IO多路复用），Selector 代替了线程本身轮询 IO 事件，避免了阻塞同时减少了不必要的线程消耗；非阻塞是指线程在等待 IO 的时候，可以同时做其他任务，非阻塞的核心就是通道和缓冲区，当IO事件就绪时，可以通过写到缓冲区，保证 IO 的成功，而无需线程阻塞式地等待</p>
<p>NIO 通常由一个专门的线程负责监听所有 IO 事件，并进行分发处理。它基于事件驱动机制：当感兴趣的事件（如连接就绪、数据可读）发生时，线程被唤醒进行处理，而不是长时间阻塞等待</p>
<p><strong>NIO 的核心组件</strong>：</p>
<ul>
<li><p><strong>Channel（通道）</strong><br> 类似传统 IO 的流，但既可读也可写，支持非阻塞模式</p>
</li>
<li><p><strong>Buffer（缓冲区）</strong><br> 所有数据读写都要通过 Buffer，Channel 与 Buffer 相互配合实现数据交换</p>
</li>
<li><p><strong>Selector（选择器）</strong><br> 允许单线程监听多个 Channel 的 IO 事件（如连接建立、数据可读），实现 <strong>IO 多路复用</strong></p>
</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com//picgo/1716018476312-e5525ca7-acf8-46b1-8fff-8a7d22db5304.webp" alt="NIO 原理"></p>
<h2 id="你知道有哪个框架用到-NIO-了吗？"><a href="#你知道有哪个框架用到-NIO-了吗？" class="headerlink" title="你知道有哪个框架用到 NIO 了吗？"></a>你知道有哪个框架用到 NIO 了吗？</h2><p><strong>Netty</strong></p>
<p>Netty 的 IO 模型是基于非阻塞 IO 实现的，底层依赖的是 NIO 框架的多路复用器 Selector。采用 epoll 模式后，只需要一个线程负责 Selector 的轮询。当有数据处于就绪状态后，需要一个事件分发器（Event Dispather），它负责将读写事件分发给对应的读写事件处理器（Event Handler）。事件分发器有两种设计模式：Reactor 和 Proactor，Reactor 采用同步 IO， Proactor 采用异步 IO</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1715424254674-7a7159b1-d1ed-4236-ae18-09421c9837ed.png" alt="Netty 的 IO 模型"></p>
<p>Reactor 实现相对简单，适合处理耗时短的场景，对于耗时长的 IO 操作容易造成阻塞。Proactor 性能更高，但是实现逻辑非常复杂，适合图片或视频流分析服务器，目前主流的事件驱动模型还是依赖 select 或 epoll 来实现</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="有一个学生类，想按照分数排序，再按学号排序，应该怎么做？"><a href="#有一个学生类，想按照分数排序，再按学号排序，应该怎么做？" class="headerlink" title="有一个学生类，想按照分数排序，再按学号排序，应该怎么做？"></a>有一个学生类，想按照分数排序，再按学号排序，应该怎么做？</h2><p>在学生类中实现 <code>Comparable</code> 接口，并重写 <code>compareTo</code> 方法，然后在 <code>compareTo</code> 方法中实现按照分数排序和按照学号排序的逻辑:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法和其他属性、方法省略</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student other)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.score != other.score) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(other.score, <span class="built_in">this</span>.score); <span class="comment">// 按照分数降序排序</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.id, other.id); <span class="comment">// 如果分数相同，则按照学号升序排序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在需要对学生列表进行排序的地方，使用 <code>Collections.sort()</code> 方法对学生列表进行排序即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 添加学生对象到列表中</span></span><br><span class="line">Collections.sort(students);</span><br></pre></td></tr></table></figure>



<h2 id="解释一下-native-方法"><a href="#解释一下-native-方法" class="headerlink" title="解释一下 native 方法"></a>解释一下 native 方法</h2><p>在 Java 中，native 方法是一种特殊类型的方法，它允许 Java 代码调用外部的本地代码，即用 C、CPP 或其他语言编写的代码</p>
<p>native 方法看起来与其他方法相似，只是其方法体由 <code>native</code> 关键字代替，标记一个方法的实现将在外部定义，没有实际的实现代码。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeMethod</span><span class="params">()</span>; <span class="comment">// 声明为 native，无方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用 native 方法的一般流程</strong>：</p>
<ol>
<li><strong>声明 native 方法</strong>：在 Java 类中使用 <code>native</code> 关键字声明方法，无需提供方法体</li>
<li><strong>生成 JNI 头文件</strong>：使用 <code>javac</code> 编译 Java 类，然后用 <code>javah</code>（或 <code>javac -h</code>，较新版本）生成对应的 C&#x2F;CPP 头文件（<code>.h</code>），该文件包含 native 方法的函数签名</li>
<li><strong>实现本地代码</strong>：编写本地代码，实现 <code>.h</code> 文件中声明的方法逻辑。函数名需严格匹配 JNI 的命名规范</li>
<li><strong>编译为本地库</strong>：将本地代码编译成动态链接库（<code>.dll</code>，在 Windows 上），共享库（<code>.so</code>，在 Linux 上）</li>
<li><strong>加载本地库</strong>：使用 <code>System.loadLibrary(&quot;库名&quot;)</code> 加载编译好的本地库，使 JVM 能调用 native 方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeExample</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;nativeLib&quot;</span>); <span class="comment">// 加载名为 nativeLib 的本地库</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeMethod</span><span class="params">()</span>; <span class="comment">// 声明 native 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NativeExample</span>().nativeMethod(); <span class="comment">// 调用本地方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>八股文笔记 #2 Java 集合</title>
    <url>/2025/07/01/boilerplate-answers-2-java-collection/</url>
    <content><![CDATA[<p><del>再好的项目，也敌不过 HashMap 的 resize 过程没讲清楚</del></p>
<span id="more"></span>

<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="数组与集合的区别是？用过哪些？"><a href="#数组与集合的区别是？用过哪些？" class="headerlink" title="数组与集合的区别是？用过哪些？"></a>数组与集合的区别是？用过哪些？</h2><p>数组和集合的区别：</p>
<ul>
<li>数组是固定长度的数据结构，一旦创建长度就无法改变，而集合是动态长度的数据结构，可以根据需要动态增加或减少元素</li>
<li>数组可以包含基本数据类型和对象，而集合只能包含对象</li>
<li>数组可以直接访问元素，而集合需要通过迭代器或其他方法访问元素</li>
</ul>
<p>我用过的一些 Java 集合类：</p>
<ul>
<li><strong><code>List</code> 系列（有序、可重复）</strong>：<ul>
<li><strong><code>ArrayList</code>：</strong> 动态数组，随机访问快，适合读多写少场景</li>
<li><strong><code>LinkedList</code>：</strong> 双向链表，插入&#x2F;删除快，适合频繁操作头尾</li>
</ul>
</li>
<li><strong><code>Set</code> 系列（无序&#x2F;有序、不可重复）</strong>：<ul>
<li><strong><code>HashSet</code>：</strong> 基于 <code>HashMap</code> 实现的 <code>Set</code> 集合，用于存储唯一元素</li>
<li><strong><code>LinkedHashSet</code></strong>：有插入顺序的 <code>HashSet</code></li>
<li><strong><code>TreeSet</code></strong>：基于红黑树，元素自动排序（按自然顺序或比较器）</li>
</ul>
</li>
<li><strong><code>Map</code> 系列（键值对）</strong>：<ul>
<li><strong><code>HashMap</code>：</strong> 基于哈希表的 <code>Map</code> 实现，存储键值对，通过键快速查找值</li>
<li><strong><code>ConcurrentHashMap</code></strong>：线程安全的高性能并发 <code>Map</code></li>
<li><strong><code>TreeMap</code>：</strong> 基于红黑树实现的有序 <code>Map</code> 集合，可以按照键的顺序进行排序</li>
<li><strong><code>LinkedHashMap</code>：</strong> 基于哈希表和双向链表实现的 <code>Map</code> 集合，保持插入顺序或访问顺序</li>
</ul>
</li>
<li><strong><code>Queue</code> 系列（队列&#x2F;优先队列）</strong>：<ul>
<li><strong><code>PriorityQueue</code>：</strong> 优先队列，可以按照比较器或元素的自然顺序进行排序</li>
<li><strong><code>ArrayDeque</code></strong>：双端队列，可用于栈或队列结构</li>
</ul>
</li>
</ul>
<h2 id="说说-Java-中的集合？"><a href="#说说-Java-中的集合？" class="headerlink" title="说说 Java 中的集合？"></a>说说 Java 中的集合？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1717481094793-b8ffe6ae-2ee6-4de5-b61b-8468e32bf269.webp" alt="Java 集合"></p>
<p><code>List</code> 是一个<strong>有序、可重复</strong>的集合，它允许根据索引精确控制元素的插入位置，也支持根据索引访问、搜索和修改元素</p>
<ul>
<li><code>ArrayList</code> 基于<strong>动态数组</strong>实现，元素按插入顺序排序。因为底层是数组，支持<strong>快速随机访问</strong>（时间复杂度 O(1)），插入和删除操作（特别是在中间位置）较慢，需移动大量元素（时间复杂度 O(n)）。当几何扩容时，会创建更大的数组，并把原数组复制到新数组。<strong>线程不安全</strong>，适用于单线程环境</li>
<li><code>LinkedList</code> 基于<strong>双向链表</strong>实现，每个节点都保存前后指针。插入和删除操作性能较好，尤其是在首尾位置添加&#x2F;删除元素时（O(1)），不支持高效的随机访问（访问第 n 个元素需从头或尾遍历，时间复杂度 O(n)）。同样是<strong>线程不安全</strong>的</li>
<li><code>Vector</code>：与 <code>ArrayList</code> 类似，也是基于<strong>动态数组</strong>实现的。<code>Vector</code> 是<strong>线程安全的</strong>，其大多数方法都使用了 <code>synchronized</code> 关键字修饰，保证线程同步。属于<strong>过时类</strong>，在 JDK 的后续发展中不再推荐使用</li>
<li><code>Stack</code>：是 <code>Vector</code> 的子类，继承了 <code>Vector</code> 的所有特性，线程安全。它实现的是**后进先出（LIFO）**的数据结构，提供了栈操作方法。同样存在设计上的历史局限，不推荐在新的项目中使用</li>
</ul>
<p><code>Set</code> 是一个<strong>不包含重复元素</strong>的集合，元素通常是<strong>无序</strong>的，但具体顺序取决于其实现类</p>
<ul>
<li><code>HashSet</code> ：基于 <code>HashMap</code> 实现，底层以 <code>HashMap</code> 的 key 存储元素，所有 key 对应的 value 都是一个统一的常量 <code>PRESENT</code>。它不保证元素顺序，插入顺序和取出顺序可能不同。由于依赖 <code>HashMap</code>，因此是<strong>线程不安全的</strong></li>
<li><code>LinkedHashSet</code>：继承自 <code>HashSet</code>，通过 <code>LinkedHashMap</code> 实现，内部使用<strong>双向链表</strong>维护元素的插入顺序，因此是<strong>有序的（按插入顺序）</strong></li>
<li><code>TreeSet</code>：基于 <code>TreeMap</code> 实现，底层结构为<strong>红黑树</strong>。元素将根据其<strong>自然顺序</strong>或提供的<strong>比较器（Comparator）进行排序，因此是有序集合</strong></li>
</ul>
<p><code>Map</code> 是一种键值对集合，<strong>key 不可重复</strong>，<strong>value 可重复</strong>。它不是 <code>Collection</code> 的子接口，但同样是 Java 集合框架的核心部分</p>
<ul>
<li><code>HashMap</code>：最常用的 <code>Map</code> 实现，key 无序、唯一，value 可重复。JDK 1.8 之前底层是<strong>数组 + 链表</strong>结构，使用<strong>拉链法</strong>解决哈希冲突；JDK 1.8 之后，当单个桶中的链表长度超过阈值（默认 8），链表将转为<strong>红黑树</strong>以提高性能。线程不安全，适用于单线程环境</li>
<li><code>LinkedHashMap</code>：是 <code>HashMap</code> 的子类，底层在 <code>HashMap</code> 基础上添加了<strong>双向链表</strong>，以维护插入顺序或访问顺序。可以通过构造函数设置为按<strong>访问顺序排序</strong>，常用于实现 LRU 缓存</li>
<li><code>HashTable</code>：较早的实现，底层为<strong>数组 + 链表</strong>，链表主要是为了解决哈希冲突。所有方法都使用 <code>synchronized</code> 修饰，线程安全但性能较差，已基本被 <code>ConcurrentHashMap</code> 替代</li>
<li><code>TreeMap</code>：是基于红黑树实现的<code>Map</code>，它可以对键进行排序，默认按照自然顺序排序，也可以通过指定的比较器进行排序。<code>TreeMap</code> 是非线程安全的，在多线程环境下，如果多个线程同时对 <code>TreeMap</code> 进行插入、删除等操作，可能会破坏红黑树的结构，导致数据不一致或程序出现异常</li>
<li><code>ConcurrentHashMap</code>：支持高并发访问的线程安全 <code>Map</code> 实现。JDK 1.8 以前使用<strong>Segment 分段锁机制</strong>；JDK 1.8 后采用<strong>数组 + 链表 + 红黑树</strong>结构，并通过 <strong>CAS + synchronized</strong> 等机制实现更细粒度的并发控制，性能显著提升</li>
</ul>
<h2 id="Java-中线程安全的集合有什么？"><a href="#Java-中线程安全的集合有什么？" class="headerlink" title="Java 中线程安全的集合有什么？"></a>Java 中线程安全的集合有什么？</h2><p>在 <code>java.util</code> 包中的线程安全的类主要 2 个，其他都是非线程安全的：</p>
<ul>
<li><code>Vector</code>：和 <code>ArrayList</code> 类似，也是基于数组实现。其大多数方法通过 <code>synchronized</code> 保证线程安全，但在单线程场景中同步开销大，性能略低于 <code>ArrayList</code>。<code>Vector</code> 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据</li>
<li><code>Hashtable</code>：线程安全的哈希表，<code>HashTable</code> 的加锁方法是给每个方法加上 <code>synchronized</code> 关键字，这样锁住的是整个 <code>Table</code> 对象，不支持 <code>null</code> 键和值，由于同步导致的性能开销，所以已经很少被推荐使用，如果要保证线程安全的哈希表，可以用 <code>ConcurrentHashMap</code></li>
</ul>
<p><code>java.util.concurrent</code> 包提供的都是线程安全的集合：</p>
<p><strong>并发 Map</strong>：</p>
<ul>
<li><code>ConcurrentHashMap</code>：它与 <code>HashTable</code> 的主要区别是二者加锁粒度的不同，在 JDK 1.8 前，<code>ConcurrentHashMap</code> 加的是分段锁，也就是 Segment 锁，每个 Segment 含有整个 table 的一部分，这样不同分段之间的并发操作就互不影响。在 JDK 1.8 后，它取消了 Segment 字段，直接在 table 元素上加锁，实现对每一行进行加锁，进一步减小了并发冲突的概率。对于 put 操作，如果 key 对应的数组元素为 <code>null</code>，则通过 CAS 操作（Compare and Swap）将其设置为当前值。如果 key 对应的数组元素（也即链表表头或者树的根元素）不为 <code>null</code>，则对该元素使用 <code>synchronized</code> 关键字申请锁，然后进行操作。如果该 put 操作使得当前链表长度超过一定阈值，则将该链表转换为红黑树，从而提高寻址效率</li>
<li><code>ConcurrentSkipListMap</code>：实现了一个基于 <code>SkipList</code>（跳表）算法的可排序的并发集合，<code>SkipList</code> 是一种可以在对数预期时间内完成搜索、插入、删除等操作的数据结构，通过维护多个指向其他元素的 “跳跃” 链接来实现高效查找</li>
</ul>
<p><strong>并发 Set</strong>：</p>
<ul>
<li><code>ConcurrentSkipListSet</code>：是线程安全的有序的集合。底层是使用 <code>ConcurrentSkipListMap</code> 实现</li>
<li><code>CopyOnWriteArraySet</code>：是线程安全的 <code>Set</code> 实现，它是线程安全的无序的集合，可以将它理解成线程安全的 <code>HashSet</code>。有意思的是，<code>CopyOnWriteArraySet</code> 和 <code>HashSet</code> 虽然都继承于共同的父类 <code>AbstractSet</code>；但是，<code>HashSet</code> 是通过散列表实现的，而 <code>CopyOnWriteArraySet</code> 则是通过动态数组 <code>CopyOnWriteArrayList</code> 实现的，并不是散列表</li>
</ul>
<p><strong>并发 List</strong>：</p>
<ul>
<li><code>CopyOnWriteArrayList</code>：它是 <code>ArrayList</code> 的线程安全的变体，其中所有写操作（add，set 等）都通过对底层数组进行全新复制来实现，允许存储 <code>null</code> 元素。即当对象进行写操作时，使用了 Lock 锁做同步处理，内部拷贝了原数组，并在新数组上进行添加操作，最后将新数组替换掉旧数组；若进行的读操作，则直接返回结果，操作过程中不需要进行同步</li>
</ul>
<p><strong>并发 Queue</strong>：</p>
<ul>
<li><code>ConcurrentLinkedQueue</code>：是一个适用于高并发场景下的队列，它通过无锁的方式（CAS），实现了高并发状态下的高性能。通常，<code>ConcurrentLinkedQueue</code> 的性能要好于 <code>BlockingQueue</code></li>
<li><code>BlockingQueue</code>：与 <code>ConcurrentLinkedQueue</code> 的使用场景不同，<code>BlockingQueue</code> 的主要功能并不是在于提升高并发时的队列性能，而在于简化多线程间的数据共享。<code>BlockingQueue</code> 提供一种读写阻塞等待的机制，即如果消费者速度较快，则 <code>BlockingQueue</code> 则可能被清空，此时消费线程再试图从 <code>BlockingQueue</code> 读取数据时就会被阻塞。反之，如果生产线程较快，则 <code>BlockingQueue</code> 可能会被装满，此时，生产线程再试图向 <code>BlockingQueue</code> 队列装入数据时，便会被阻塞等待</li>
</ul>
<p><strong>并发 Deque</strong>：</p>
<ul>
<li><code>LinkedBlockingDeque</code>：是一个线程安全的双端队列实现。它的内部使用链表结构，每一个节点都维护了一个前驱节点和一个后驱节点。<code>LinkedBlockingDeque</code> 没有进行读写锁的分离，因此同一时间只能有一个线程对其进行操作</li>
<li><code>ConcurrentLinkedDeque</code>：<code>ConcurrentLinkedDeque</code> 是一种基于链接节点的无限并发链表。可以安全地并发执行插入、删除和访问操作。当许多线程同时访问一个公共集合时，<code>ConcurrentLinkedDeque</code> 是一个合适的选择</li>
</ul>
<p><del><strong>太长不看版</strong>：</del></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>主要实现</th>
<th>线程安全机制 &amp; 典型特性</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>早期同步类（<code>java.util</code>）</strong></td>
<td><code>Vector</code>、<code>Hashtable</code></td>
<td>整体 <code>synchronized</code>，简单但锁粒度大，已基本淘汰</td>
<td>兼容遗留代码</td>
</tr>
<tr>
<td><strong>并发 Map</strong></td>
<td><code>ConcurrentHashMap``ConcurrentSkipListMap</code></td>
<td>JDK 8：数组 + 链表&#x2F;红黑树 + <strong>CAS &#x2F; synchronized</strong>（行锁）SkipList：基于跳表，<strong>有序</strong>、读写并发</td>
<td>高并发 KV 存储；有序场景用 SkipList</td>
</tr>
<tr>
<td><strong>并发 Set</strong></td>
<td><code>ConcurrentSkipListSet``CopyOnWriteArraySet</code></td>
<td>前者基于 SkipList（有序）后者基于 Copy‑On‑Write，读多写少</td>
<td>排序去重 &#x2F; 读多写少</td>
</tr>
<tr>
<td><strong>并发 List</strong></td>
<td><code>CopyOnWriteArrayList</code></td>
<td>写时复制：写操作复制数组，读无需加锁</td>
<td>读多写少、迭代不要求实时一致</td>
</tr>
<tr>
<td><strong>并发 Queue &#x2F; Deque</strong></td>
<td><code>ConcurrentLinkedQueue</code>（无锁链表）<code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>、<code>LinkedBlockingDeque</code>（阻塞队列）<code>ConcurrentLinkedDeque</code>（无锁双端）</td>
<td>CAS 或 <code>ReentrantLock</code> + 条件队列，实现非阻塞或阻塞语义</td>
<td>生产者&#x2F;消费者模型、任务队列、并发栈&#x2F;队列</td>
</tr>
</tbody></table>
<h2 id="Collection-和-Collections-的区别"><a href="#Collection-和-Collections-的区别" class="headerlink" title="Collection 和 Collections 的区别"></a>Collection 和 Collections 的区别</h2><ul>
<li><code>Collection</code> 是 Java 集合框架的顶层接口，位于 <code>java.util</code> 包中，定义了集合的基本操作，如增删改查、遍历等。它是 <code>List</code>、<code>Set</code>、<code>Queue</code> 等集合接口的父接口，用于表示一组元素的抽象结构</li>
<li><code>Collections</code> 是 Java 提供的一个 <strong>工具类</strong>，同样位于 <code>java.util</code> 包中，专门用于对集合进行操作。它包含大量的<strong>静态方法</strong>，如排序 <code>sort()</code>、查找 <code>binarySearch()</code>、替换、反转 <code>reverse()</code>、线程安全包装 <code>synchronizedList()</code>等，可用于处理实现了 <code>Collection</code> 接口的集合对象（如 <code>List</code>、<code>Set</code> 等）</li>
</ul>
<h2 id="遍历集合的方式有哪些？"><a href="#遍历集合的方式有哪些？" class="headerlink" title="遍历集合的方式有哪些？"></a>遍历集合的方式有哪些？</h2><ul>
<li><p><strong>普通 for 循环</strong>：可以使用带有索引的普通 for 循环来遍历 <code>List</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>增强 for 循环（for-each 循环）：</strong> 用于循环访问数组或集合中的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String element : list) &#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Iterator 迭代器：</strong> 可以使用迭代器来遍历集合，特别适用于需要删除元素的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ListIterator 列表迭代器：</strong> <code>ListIterator</code> 是迭代器的子类，可以双向访问列表并在迭代过程中修改元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListIterator&lt;String&gt; listIterator = list.listIterator();</span><br><span class="line"><span class="keyword">while</span> (listIterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> listIterator.next();</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>forEach()</code> 方法：</strong> Java 8 引入了 <code>forEach()</code> 方法，可以对集合进行快速遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.forEach(element -&gt; System.out.println(element));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Stream API：</strong> Java 8 的 Stream API 提供了丰富的功能，可以对集合进行函数式操作，如过滤、映射等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.stream().forEach(element -&gt; System.out.println(element));</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="说说常见的-list-集合？"><a href="#说说常见的-list-集合？" class="headerlink" title="说说常见的 list 集合？"></a>说说常见的 list 集合？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1737438845596-760eb59b-c34c-441c-bea7-5b4eb1da4db4.png" alt="List 集合"></p>
<p><strong>非线程安全</strong>：</p>
<ul>
<li><code>ArrayList</code> ：基于<strong>动态数组</strong>实现，元素按插入顺序排序。因为底层是数组，支持<strong>快速随机访问</strong>（时间复杂度 O(1)），插入和删除操作（特别是在中间位置）较慢，需移动大量元素（时间复杂度 O(n)）。当几何扩容时，会创建更大的数组，并把原数组复制到新数组。<strong>线程不安全</strong>，适用于单线程环境</li>
<li><code>LinkedList</code> ：基于<strong>双向链表</strong>实现，每个节点都保存前后指针。插入和删除操作性能较好，尤其是在首尾位置添加&#x2F;删除元素时（O(1)），不支持高效的随机访问（访问第 n 个元素需从头或尾遍历，时间复杂度 O(n)）。同样是<strong>线程不安全</strong>的</li>
</ul>
<p><strong>线程安全</strong>：</p>
<ul>
<li><p><code>Vector</code>：和 <code>ArrayList</code> 类似，也是基于数组实现。其大多数方法通过 <code>synchronized</code> 保证线程安全，但在单线程场景中同步开销大，性能略低于 <code>ArrayList</code>。<code>Vector</code> 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据</p>
</li>
<li><p><code>CopyOnWriteArrayList</code>：一种<strong>并发容器类</strong>，写操作（如添加、删除）时会复制一份底层数组，并在新数组上修改，写完后再替换旧数组；读操作无需加锁，始终在旧数组上执行，实现了<strong>读写分离</strong>，大幅提升读性能。适用于<strong>读多写少</strong>的并发场景，如事件监听器列表、缓存快照等。缺点是写操作开销较大，且不适合大数据量频繁写入的场景</p>
</li>
</ul>
<h2 id="讲一下-List-的几种实现，几种实现有什么不同？"><a href="#讲一下-List-的几种实现，几种实现有什么不同？" class="headerlink" title="讲一下 List 的几种实现，几种实现有什么不同？"></a>讲一下 List 的几种实现，几种实现有什么不同？</h2><p><code>ArrayList</code>、<code>Vector</code>、<code>LinkedList</code>，概念如上。</p>
<p><code>ArrayList</code> 和 <code>Vector</code> 作为动态数组，因为底层是数组，支持<strong>快速随机访问</strong>（时间复杂度 O(1)），插入和删除操作（特别是在中间位置）较慢，需移动大量元素（时间复杂度 O(n)）</p>
<p>而 <code>LinkedList</code> 插入和删除操作性能较好，尤其是在首尾位置添加&#x2F;删除元素时（O(1)），不支持高效的随机访问（访问第 n 个元素需从头或尾遍历，时间复杂度 O(n)）</p>
<h2 id="List-可以一边遍历一边修改元素吗？"><a href="#List-可以一边遍历一边修改元素吗？" class="headerlink" title="List 可以一边遍历一边修改元素吗？"></a>List 可以一边遍历一边修改元素吗？</h2><ul>
<li><p><strong>使用普通 for 循环遍历</strong>：可以在遍历过程中修改元素，只要修改的索引不超出<code>List</code>的范围即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">	list.set(i, list.get(i) * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 for-earch 循环遍历</strong>：一般不建议在 <code>for-earch</code> 循环中直接修改正在遍历的 <code>List</code> 元素，可能会导致意外的结果或 <code>ConcurrentModificationException</code> 异常。因为 <code>for-earch</code> 循环底层是基于迭代器实现的，在遍历过程中修改集合结构，会导致迭代器的预期结构和实际结构不一致</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Integer num : list) &#123;</span><br><span class="line">	list.set(list.indexOf(num), num * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用迭代器遍历</strong>：可以使用迭代器的 <code>remove()</code> 方法来删除元素，但如果要修改元素的值，需要通过迭代器的 <code>set()</code> 方法来进行，而不是直接通过 <code>List</code> 的 <code>set()</code> 方法，否则也可能会抛出<code>ConcurrentModificationException</code>异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">	<span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">	iterator.set(num * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="List-如何快速删除指定下标的元素？"><a href="#List-如何快速删除指定下标的元素？" class="headerlink" title="List 如何快速删除指定下标的元素？"></a>List 如何快速删除指定下标的元素？</h2><ul>
<li><p><strong><code>ArrayList</code> 的 <code>remove(int index)</code> 方法</strong>：该方法在删除元素后，会将后续元素向前移动，以填补被删除元素的位置。如果删除的是列表中间的元素，时间复杂度为 O (n)；如果删除的是列表末尾的元素，时间复杂度为 O (1)</p>
</li>
<li><p><strong><code>LinkedList</code> 的 <code>remove(int index)</code> 方法</strong>：它需要先遍历到指定下标位置，然后修改链表的指针来删除元素，时间复杂度为 O (n)；如果删除的是链表的头节点或尾节点的元素，可以直接通过修改头指针或尾指针来实现删除，时间复杂度为 O (1)</p>
</li>
<li><p><strong><code>CopyOnWriteArrayList</code> 的 <code>remove(int index)</code> 方法</strong>：由于 <code>CopyOnWriteArrayList</code> 在写操作时会创建一个新的数组，所以删除操作的时间复杂度取决于数组的复制速度，通常为 O (n)。但在并发环境下，它的删除操作不会影响读操作，具有较好的并发性能</p>
</li>
</ul>
<h2 id="ArrayList-线程安全吗？把-Arraylist-变成线程安全的方式有哪些？"><a href="#ArrayList-线程安全吗？把-Arraylist-变成线程安全的方式有哪些？" class="headerlink" title="ArrayList 线程安全吗？把 Arraylist 变成线程安全的方式有哪些？"></a>ArrayList 线程安全吗？把 Arraylist 变成线程安全的方式有哪些？</h2><p><strong>不是线程安全的</strong>。变成线程安全的方式：</p>
<ul>
<li><p>使用 <code>Collections</code> 类的 <code>synchronizedList</code> 方法将 <code>ArrayList</code> 包装成线程安全的 <code>List</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; synchronizedList = Collections.synchronizedList(arrayList);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>CopyOnWriteArrayList</code> 类代替 <code>ArrayList</code>，它是一个线程安全的 <code>List</code> 实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CopyOnWriteArrayList&lt;String&gt; copyOnWriteArrayList = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;(arrayList);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>Vector</code> 类代替 <code>ArrayList</code>，<code>Vector</code> 是线程安全的 <code>List</code> 实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Vector&lt;String&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;(arrayList);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="为什么-ArrayList-不是线程安全的"><a href="#为什么-ArrayList-不是线程安全的" class="headerlink" title="为什么 ArrayList 不是线程安全的?"></a>为什么 ArrayList 不是线程安全的?</h2><p>在高并发添加数据时，<code>ArrayList</code> 会暴露三个问题：</p>
<ul>
<li>部分值为 <code>null</code></li>
<li>索引越界异常（<code>IndexOutOfBoundsException</code>）</li>
<li>size 与 add 的数量不符</li>
</ul>
<p><code>ArrayList</code> 添加元素的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">	ensureCapacityInternal(size + <span class="number">1</span>); <span class="comment">// 可能扩容</span></span><br><span class="line">	elementData[size++] = e;          <span class="comment">// 赋值后再自增 size</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ensureCapacityInternal()</code> 方法判断将当前的新元素加到列表后面，列表的 <code>elementData</code> 数组的大小是否满足，如果 size + 1 的这个需求长度大于了 <code>elementData</code> 这个数组的长度，那么就要对这个数组进行扩容</p>
<p>大体可以分为三步：</p>
<ol>
<li><p>判断数组需不需要扩容，如果需要的话，调用 <code>grow()</code> 方法进行扩容</p>
</li>
<li><p>将数组的 size 位置设置值（因为数组的下标是从 0 开始的）</p>
</li>
<li><p>将当前集合的大小加 1</p>
</li>
</ol>
<p>那么三个问题都是如何产生的？</p>
<ul>
<li>部分值为 <code>null</code>：根因是同一索引被<strong>重复写</strong>，导致后继位置空洞。线程 T1 与 T2 都判断无需扩容（容量 &#x3D;10，size &#x3D;9） → T1 把元素写入 <code>elementData[9]</code>，尚未 <code>size++</code> 就被抢占 → T2 也把元素写入同一槽位并随后 <code>size++</code> → 槽位 10 从未被写入，被视为 <code>null</code></li>
<li>索引越界异常：根因是第二线程基于<strong>过期的容量判断</strong>，写到实际不存在的索引。线程 T1 与 T2 都判断无需扩容（容量 &#x3D;10，size &#x3D;9）→ T1 写索引  9  并 <code>size++</code> → size&#x3D;10 → T2 继续写 <strong>索引 10</strong> → 数组下标越界（数组的下标索引从 0 开始）</li>
<li>size 与 add 的数量不符：根因是<code>size++</code> 是<strong>非原子</strong>递增，发生 “写覆盖”。两线程几乎同时执行 <code>size++</code>：都读取到 size&#x3D;5 → 都各自加1 → 都写回 6 → 少加了一次</li>
</ul>
<h2 id="ArrayList-和-LinkedList-的应用场景分别是什么？"><a href="#ArrayList-和-LinkedList-的应用场景分别是什么？" class="headerlink" title="ArrayList 和 LinkedList 的应用场景分别是什么？"></a>ArrayList 和 LinkedList 的应用场景分别是什么？</h2><ul>
<li><code>ArrayList</code>：适用于需要频繁访问集合元素的场景。它基于<strong>动态数组</strong>实现，可以通过索引快速访问元素，因此在按索引查找、遍历和随机访问元素的操作上具有较高的性能</li>
<li><code>LinkedList</code>：适用于频繁进行插入和删除操作的场景。它基于<strong>双向链表</strong>实现，插入和删除元素的操作只需要调整节点的指针，因此在插入和删除操作上具有较高的性能</li>
</ul>
<h2 id="说一下-ArrayList-的扩容机制"><a href="#说一下-ArrayList-的扩容机制" class="headerlink" title="说一下 ArrayList 的扩容机制"></a>说一下 ArrayList 的扩容机制</h2><p><code>ArrayList</code> 在添加元素时，如果当前元素数量已达到内部数组的容量上限，就会触发扩容操作。<code>ArrayList</code> 的扩容操作主要包括以下几个步骤：</p>
<ul>
<li><p><strong>计算新的容量</strong>：一般情况下，<code>ArrayList</code> 会将容量扩大为原来的 <strong>1.5 倍</strong>（在 JDK 10 之后，扩容策略做了调整），这是通过移位运算来避免浮点运算，效率较高，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建新的数组</strong>：根据新的容量创建一个更大的数组</p>
</li>
<li><p><strong>将元素复制</strong>：将旧数组中的元素逐个复制到新数组中</p>
</li>
<li><p><strong>更新引用</strong>：将内部数组引用指向新的数组</p>
</li>
<li><p><strong>完成扩容</strong>：之后即可继续向列表中添加新元素</p>
</li>
</ul>
<p>扩容过程中涉及到<strong>数组复制和内存重新分配</strong>，是一个相对开销较大的操作。因此，在预计会添加大量元素的场景下，建议在构造 <code>ArrayList</code> 时指定初始容量，以减少扩容次数，提高性能</p>
<h2 id="CopyonWriteArraylist-是如何实现线程安全的？"><a href="#CopyonWriteArraylist-是如何实现线程安全的？" class="headerlink" title="CopyonWriteArraylist 是如何实现线程安全的？"></a>CopyonWriteArraylist 是如何实现线程安全的？</h2><p><code>CopyOnWriteArrayList</code> 是一种<strong>线程安全</strong>的列表实现，其核心思想是：<strong>写时复制</strong>（Copy-On-Write）。它的底层通过一个被 <code>volatile</code> 修饰的数组来保存数据，并结合 <code>ReentrantLock</code> 实现写操作的互斥，确保线程安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// 加锁，保证写操作互斥</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();               <span class="comment">// 获取当前数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;                    <span class="comment">// 原数组长度</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>); <span class="comment">// 创建新数组</span></span><br><span class="line">        newElements[len] = e;                         <span class="comment">// 添加新元素</span></span><br><span class="line">        setArray(newElements);                        <span class="comment">// 替换原数组引用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行写入操作时，首先获取当前的底层数组，然后创建一个长度为原数组长度加一的新数组，并将旧数组中的所有元素复制到新数组中。接着，将待添加的新元素放置到新数组的末尾位置。最后，将内部数组的引用更新为这个新数组。整个写入过程在加锁的保护下进行，确保在并发环境中写操作的互斥性和数据的一致性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于新数组是在写操作期间独立构建的，读操作始终访问旧数组，因此不会受到影响，实现了读写分离的线程安全策略。因为数组引用是 <code>volatile</code> 的，所以读取总是能看到最新或一致的有效数据</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="说说常见的-Map-集合？"><a href="#说说常见的-Map-集合？" class="headerlink" title="说说常见的 Map 集合？"></a>说说常见的 Map 集合？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1737437072655-fd232d5c-f89c-4d28-b2f2-a29f908ecaba.png" alt="Map 集合"></p>
<p><strong>非线程安全</strong>：</p>
<ul>
<li><p><code>HashMap</code>：最常用的 <code>Map</code> 实现，key 无序、唯一，value 可重复。JDK 1.8 之前底层是<strong>数组 + 链表</strong>结构，使用<strong>拉链法</strong>解决哈希冲突；JDK 1.8 之后，当单个桶中的链表长度超过阈值（默认 8），链表将转为<strong>红黑树</strong>以提高性能。<code>HashMap</code> 是非线程安全的，在多线程环境下，当多个线程同时对 <code>HashMap</code> 进行操作时，可能会导致数据不一致或出现死循环等问题</p>
</li>
<li><p><code>LinkedHashMap</code>：是 <code>HashMap</code> 的子类，底层在 <code>HashMap</code> 基础上添加了<strong>双向链表</strong>，以维护插入顺序或访问顺序。可以通过构造函数设置为按<strong>访问顺序排序</strong>，常用于实现 LRU 缓存。由于它继承自<code>HashMap</code>，在多线程并发访问时，同样会出现与<code>HashMap</code>类似的线程安全问题</p>
</li>
<li><p><code>TreeMap</code>：是基于红黑树实现的<code>Map</code>，它可以对键进行排序，默认按照自然顺序排序，也可以通过指定的比较器进行排序。<code>TreeMap</code> 是非线程安全的，在多线程环境下，如果多个线程同时对 <code>TreeMap</code> 进行插入、删除等操作，可能会破坏红黑树的结构，导致数据不一致或程序出现异常</p>
</li>
</ul>
<p><strong>线程安全</strong>：</p>
<ul>
<li><code>HashTable</code>：较早的实现，底层为<strong>数组 + 链表</strong>，链表主要是为了解决哈希冲突。所有方法都使用 <code>synchronized</code> 修饰，线程安全但性能较差，已基本被 <code>ConcurrentHashMap</code> 替代</li>
<li><code>ConcurrentHashMap</code>：支持高并发访问的线程安全 <code>Map</code> 实现。JDK 1.8 以前使用<strong>Segment 分段锁机制</strong>，将数据分成多个段（Segment），每个段都有自己的锁。在进行插入、删除等操作时，只需要获取相应段的锁，而不是整个 <code>Map</code> 的锁，这样可以允许多个线程同时访问不同的段，提高了并发访问的效率；JDK 1.8 后采用<strong>数组 + 链表 + 红黑树</strong>结构，并通过 <strong>CAS + synchronized</strong> 等机制实现更细粒度的并发控制，性能显著提升</li>
</ul>
<h2 id="如何对-Map-进行快速遍历？"><a href="#如何对-Map-进行快速遍历？" class="headerlink" title="如何对 Map 进行快速遍历？"></a>如何对 Map 进行快速遍历？</h2><ul>
<li><p><strong>使用 for-each 循环和 <code>entrySet()</code> 方法</strong>：这是一种较为常见和简洁的遍历方式，它可以同时获取 <code>Map</code> 中的键和值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;Key: &quot;</span> + entry.getKey() + <span class="string">&quot;, Value: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 for-each 循环和 <code>keySet()</code> 方法</strong>：只需要遍历 <code>Map</code> 中的键，这种方式相对简单，性能也较好</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;Key: &quot;</span> + key + <span class="string">&quot;, Value: &quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用迭代器</strong>：通过获取 <code>Map</code> 的 <code>entrySet()</code> 或 <code>keySet()</code> 的迭代器，也可以实现对 <code>Map</code> 的遍历，这种方式在需要删除元素等操作时比较有用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">	Entry&lt;String, Integer&gt; entry = iterator.next();</span><br><span class="line">	System.out.println(<span class="string">&quot;Key: &quot;</span> + entry.getKey() + <span class="string">&quot;, Value: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 Lambda 表达式和 <code>forEach()</code> 方法</strong>：这种方式更加简洁和函数式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; System.out.println(<span class="string">&quot;Key: &quot;</span> + key + <span class="string">&quot;, Value: &quot;</span> + value));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 Stream API</strong>：可以将 <code>Map</code> 转换为流，然后进行各种操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.entrySet().stream().forEach(entry -&gt; System.out.println(<span class="string">&quot;Key: &quot;</span> + entry.getKey() + <span class="string">&quot;, Value: &quot;</span> + entry.getValue()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以进行其他操作，如过滤、映射等</span></span><br><span class="line">Map&lt;String, Integer&gt; filteredMap = map.entrySet().stream()</span><br><span class="line">    .filter(entry -&gt; entry.getValue() &gt; <span class="number">1</span>)</span><br><span class="line">    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));</span><br><span class="line">System.out.println(filteredMap);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="介绍一下-HashMap实现原理？"><a href="#介绍一下-HashMap实现原理？" class="headerlink" title="介绍一下 HashMap实现原理？"></a>介绍一下 HashMap实现原理？</h2><p>在 JDK 1.8 之前，<code>HashMap</code> 数据结构是<strong>数组和链表</strong>，<code>HashMap</code> 通过哈希算法将元素的键映射到数组中的槽位（Bucket）。如果多个键映射到同一个槽位，它们会以链表的形式存储在同一个槽位上，因为链表的查询时间是O(n)，所以冲突很严重，一个索引上的链表非常长，效率就很低了</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1719565480532-57a14329-c36b-4514-8e7d-2f2f1df88a82.webp" alt="Java7 HashMap 结构"></p>
<p>所以在 <strong>JDK 1.8</strong> 做了优化，当一个链表的长度超过 8 的时候就转换数据结构，不再使用链表存储，而是使用<strong>红黑树</strong>，查找时使用红黑树，时间复杂度O（log n），可以提高查询性能，但是在数量较少时，即数量小于 6 时，会将红黑树转换回链表</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1719565481289-0c2164f4-f755-46e3-bb39-b5f28621bb6b.webp" alt="Java8 HashMap 结构"></p>
<h2 id="哈希冲突的解决方式有哪些？"><a href="#哈希冲突的解决方式有哪些？" class="headerlink" title="哈希冲突的解决方式有哪些？"></a>哈希冲突的解决方式有哪些？</h2><ul>
<li><strong>链接法</strong>：使用链表或其他数据结构来存储冲突的键值对，将它们链接在同一个哈希桶中</li>
<li><strong>开放寻址法</strong>：在哈希表中找到另一个可用的位置来存储冲突的键值对，而不是存储在链表中。常见的开放寻址方法包括线性探测、二次探测和双重散列</li>
<li><strong>再哈希法（Rehashing）</strong>：当发生冲突时，使用另一个哈希函数再次计算键的哈希值，直到找到一个空槽来存储键值对</li>
<li><strong>哈希桶扩容</strong>：当哈希冲突过多时，可以动态地扩大哈希桶的数量，重新分配键值对，以减少冲突的概率</li>
</ul>
<h2 id="HashMap-是线程安全的吗？"><a href="#HashMap-是线程安全的吗？" class="headerlink" title="HashMap 是线程安全的吗？"></a>HashMap 是线程安全的吗？</h2><p>hashmap不是线程安全的，hashmap在多线程会存在下面的问题：</p>
<ul>
<li>JDK 1.7 的 <code>HashMap</code> 采用<strong>数组 + 链表</strong>的数据结构，多线程背景下，在数组扩容的时候，有可能导致环形链表的出现，形成死循环</li>
<li>JDK 1.8 的 <code>HashMap</code> 采用<strong>数组 + 链表 + 红黑树</strong>的数据结构，优化了 1.7 中数组扩容的方案，使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。但是多线程同时执行 <code>put()</code> 方法，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失</li>
</ul>
<p>如果要保证线程安全，可以通过这些方法来保证：</p>
<ul>
<li>多线程环境可以使用 <code>Collections.synchronizedMap</code> 同步加锁的方式，还可以使用 <code>HashTable</code>，但是同步的方式显然性能不达标，而 <code>ConcurrentHashMap </code> 更适合高并发场景使用</li>
<li><code>ConcurrentHashMap</code> 在 JDK 1.7 和 1.8 的版本改动比较大，1.7 使用 <strong>Segment + HashEntry</strong> 分段锁的方式实现，1.8 则抛弃了 Segment，改为使用 <strong>CAS + synchronized + Node</strong> 实现，同样也加入了红黑树，避免链表过长导致性能的问题</li>
</ul>
<h2 id="讲一下-HashMap-的-put-过程"><a href="#讲一下-HashMap-的-put-过程" class="headerlink" title="讲一下 HashMap 的 put 过程"></a>讲一下 HashMap 的 put 过程</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1720684054342-1e3cb2a9-532e-40b8-b5cf-0043811391dc.png" alt="HashMap 的 put 过程"></p>
<p>当调用 <code>put(key, value)</code> 向 <code>HashMap</code> 添加键值对时，会按以下步骤执行：</p>
<ol>
<li><p><strong>计算索引</strong></p>
<p>根据键的哈希码，通过扰动函数（hash 方法）计算出其在数组中的位置（桶索引）</p>
</li>
<li><p><strong>检查该位置是否为空</strong></p>
<ul>
<li>如果该位置为空（无碰撞），直接创建一个新节点存入该桶</li>
<li>修改计数器 <code>modCount</code>，以支持快速失败机制（fail-fast）</li>
</ul>
</li>
<li><p><strong>该位置已有节点（发生哈希冲突）</strong></p>
<ul>
<li><p>比较头节点的哈希值和键，若相同则直接替换其值</p>
</li>
<li><p>否则遍历链表或红黑树：</p>
<ul>
<li><p><strong>链表结构</strong>：遍历节点，比较键的 <code>equals()</code> 方法，若找到则替换；否则将新节点追加到链尾</p>
</li>
<li><p><strong>红黑树结构</strong>：使用哈希和键比较规则在树中查找，若找到则替换；否则插入为新节点</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>检查是否需要树化</strong><br> 如果该桶中链表长度 ≥ 8 且数组容量 ≥ 64，则将链表转换为红黑树，以提升查询效率。</p>
</li>
<li><p><strong>检查是否需要扩容</strong><br> 若当前键值对总数超过阈值（容量 × 负载因子，默认 0.75），则触发扩容。</p>
</li>
<li><p><strong>扩容操作</strong></p>
<ul>
<li><p>创建新数组，容量为原数组的 2 倍。</p>
</li>
<li><p>重新计算所有节点的索引位置，并迁移到新数组。</p>
</li>
<li><p>更新阈值与数组引用。</p>
</li>
</ul>
</li>
<li><p><strong>插入完成</strong><br> 最终完成键值对的添加，否则返回 <code>null</code></p>
</li>
</ol>
<h2 id="HashMap-的-put-key-val-和-get-key-过程"><a href="#HashMap-的-put-key-val-和-get-key-过程" class="headerlink" title="HashMap 的 put(key, val) 和 get(key) 过程"></a>HashMap 的 put(key, val) 和 get(key) 过程</h2><p><strong>插入数据（<code>put(key, value)</code>）时</strong>，<code>HashMap</code> 首先通过 <code>hashCode()</code> 方法计算哈希值，再根据哈希值定位到对应的桶位置。如果该位置为空，直接插入；如果已存在元素（哈希冲突），则通过链表或红黑树的方式将新节点插入其中。若元素数量超过负载因子（默认 0.75）与容量的乘积，<code>HashMap</code> 会触发扩容，通常为原容量的 2 倍</p>
<p><strong>查询数据（<code>get(key)</code>）时</strong>，同样根据 <code>hashCode()</code> 方法定位到桶，再遍历桶中节点（通过 <code>equals()</code> 判断键是否相等）以查找目标键值对。若该桶中的节点数超过阈值（默认 8），且总容量大于等于 64，链表将转化为红黑树，以提高查找效率</p>
<h2 id="HashMap-调用-get-方法一定安全吗？"><a href="#HashMap-调用-get-方法一定安全吗？" class="headerlink" title="HashMap 调用 get() 方法一定安全吗？"></a>HashMap 调用 get() 方法一定安全吗？</h2><p>并不，调用 <code>get()</code> 方法有几点需要注意的地方：</p>
<ul>
<li><strong>空指针异常</strong>：如果你尝试用 <code>null</code> 作为键调用 <code>get()</code> 方法，而 <code>HashMap</code> 没有被初始化（即为 <code>null</code>），那么会抛出空指针异常。不过，如果 <code>HashMap</code> 已经初始化，使用 <code>null</code> 作为键是允许的，因为 <code>HashMap</code> 支持 <code>null</code> 键</li>
<li><strong>线程安全</strong>：<code>HashMap</code> 本身不是线程安全的。如果在多线程环境中，没有适当的同步措施，同时对 <code>HashMap</code> 进行读写操作可能会导致不可预测的行为。例如，在一个线程中调用 <code>get()</code> 方法读取数据，而另一个线程同时修改了结构（如增加或删除元素），可能会导致读取操作得到错误的结果或抛出 <code>ConcurrentModificationException</code>。如果需要在多线程环境中使用类似 <code>HashMap</code> 的数据结构，可以考虑使用 <code>ConcurrentHashMap</code></li>
</ul>
<h2 id="为什么-String-适合作为HashMap-的-key？"><a href="#为什么-String-适合作为HashMap-的-key？" class="headerlink" title="为什么 String 适合作为HashMap 的 key？"></a>为什么 String 适合作为HashMap 的 key？</h2><p>因为 <code>String</code> 对象是不可变的，一旦创建就不能被修改，这确保了 key 的稳定性。如果 key 是可变的，可能会导致 <code>hashCode</code> 和 <code>equals()</code> 方法的不一致，进而影响 <code>HashMap</code> 的正确性</p>
<h2 id="为什么HashMap要用红黑树而不是平衡二叉树？"><a href="#为什么HashMap要用红黑树而不是平衡二叉树？" class="headerlink" title="为什么HashMap要用红黑树而不是平衡二叉树？"></a>为什么HashMap要用红黑树而不是平衡二叉树？</h2><p>平衡二叉树追求的是一种 <strong>“完全平衡”</strong> 状态：任何结点的左右子树的高度差不会超过 1，优势是树的结点是很平均分配的。这个要求实在是太严了，导致每次进行插入&#x2F;删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过<strong>左旋</strong>和<strong>右旋</strong>来进行调整，使之再次成为一颗符合要求的平衡树</p>
<p>红黑树不追求这种完全平衡状态，而是追求一种 <strong>“弱平衡”</strong> 状态：整个树最长路径不会超过最短路径的 2 倍。优势是虽然牺牲了一部分查找的性能效率，但是能够换取一部分维持树平衡状态的成本。与平衡树不同的是，红黑树在插入、删除等操作，<strong>不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整</strong>，这也是我们为什么大多数情况下使用红黑树的原因</p>
<h2 id="HashMap-的-key-可以为-null-吗？"><a href="#HashMap-的-key-可以为-null-吗？" class="headerlink" title="HashMap 的 key 可以为 null 吗？"></a>HashMap 的 key 可以为 null 吗？</h2><p><strong>可以</strong></p>
<p><code>HashMap</code> 中使用 <code>hash()</code> 方法来计算 key 的哈希值，当 key 为空时，哈希值为 0，不走 <code>key.hashCode()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>HashMap</code> 虽然支持 key 和 value 为 <code>null</code>，但是 <code>null</code> 作为 key 只能有一个， <code>null</code> 作为 value 可以有多个</p>
<h2 id="重写-HashMap-的-equals-和-hashCode-方法需要注意什么？"><a href="#重写-HashMap-的-equals-和-hashCode-方法需要注意什么？" class="headerlink" title="重写 HashMap 的 equals() 和 hashCode() 方法需要注意什么？"></a>重写 HashMap 的 equals() 和 hashCode() 方法需要注意什么？</h2><p>在使用 <code>HashMap</code> 时，键对象的 <code>hashCode()</code> 和 <code>equals()</code> 方法起着决定性作用：</p>
<ul>
<li><code>hashCode()</code> 用于确定键值对在哈希表中的存储位置（即桶的位置）</li>
<li><code>equals()</code> 用于在哈希冲突时，判断两个键是否 “真正相等”</li>
</ul>
<p>当我们向 <code>HashMap</code> 中存入或读取数据时，会先调用键的 <code>hashCode()</code> 方法定位桶，再通过 <code>equals()</code> 判断桶中是否已存在相同的键。如果这两个方法没有被正确重写：</p>
<ul>
<li>可能导致不同的键被误认为相同，从而覆盖原有的数据（没有正确重写 <code>equals()</code> 方法）</li>
<li>或者导致相同的键被误认为不同，存储在不同位置，无法正确获取（没有正确重写 <code>hashCode()</code> 方法）</li>
</ul>
<p>此外，所有基于哈希结构、不允许键重复的集合类（如 <code>HashSet</code>）也依赖这两个方法判断元素的唯一性</p>
<p>重写时必须遵循 Java 规范中规定的以下契约：</p>
<ul>
<li>如果 <code>o1.equals(o2)</code> 为 <code>true</code>，那么 <code>o1.hashCode() == o2.hashCode()</code> 必须也为 <code>true</code></li>
<li>如果 <code>o1.hashCode() == o2.hashCode()</code>，并不要求 <code>o1.equals(o2)</code> 一定为 <code>true</code></li>
</ul>
<h2 id="介绍一下-HashMap-的扩容机制"><a href="#介绍一下-HashMap-的扩容机制" class="headerlink" title="介绍一下 HashMap 的扩容机制"></a>介绍一下 HashMap 的扩容机制</h2><p>HashMap 的默认负载因子是 <strong>0.75</strong>，也就是说，当哈希表中元素数量超过总容量的 75% 时，就会触发扩容操作。扩容主要包括两个步骤：</p>
<ol>
<li><strong>扩展数组容量为原来的 2 倍</strong></li>
<li><strong>将旧数组中的元素重新映射到新数组中（即重新分配位置）</strong></li>
</ol>
<p>因为 <code>HashMap</code> 使用的是 <strong>2 次幂</strong>的扩展，所以，元素在新数组中的位置，要么与原位置相同，要么是在原位置再移动 2 次幂</p>
<p>例如，从 16 扩展为 32 时，具体的变化如下所示：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1713514753772-9467a399-6b18-4a47-89d4-957adcc53cc0.webp" alt="img"></p>
<p>在计算桶索引时，HashMap 使用 <code>(n - 1) &amp; hash</code> 来定位元素。扩容时，数组长度 <code>n</code> 变为原来的两倍，n - 1 的二进制表示会在高位多出一个 1，因此新的索引就会发生这样的变化：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1713514753786-cdca10bf-6eda-47f9-9bbe-0cc3beb67d76.webp" alt="img"></p>
<p>因此我们只需观察原哈希值中的这个新 bit：如果该 bit 是 0，元素在新数组中的位置不变；如果该 bit 是 1，元素的新位置 &#x3D; 原位置 + oldCap</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1713514753885-d1529537-322c-49b1-beec-5d9953da5150.webp" alt="img"></p>
<p>这意味着<strong>不需要重新计算 hash 值</strong>，只需简单地判断一个 bit 位即可完成重新分配，极大提升了扩容效率。同时，由于新增的 bit 是 0 还是 1 可以认为是随机的，<strong>原先冲突的元素更均匀地分布到了新的桶中</strong>，从而提升了查找性能</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
