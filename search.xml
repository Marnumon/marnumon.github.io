<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AimAssist</title>
    <url>/2024/11/13/AimAssist/</url>
    <content><![CDATA[<h1 id="基于carpet-1-20的提前辅助瞄准"><a href="#基于carpet-1-20的提前辅助瞄准" class="headerlink" title="基于carpet 1.20的提前辅助瞄准"></a>基于carpet 1.20的提前辅助瞄准</h1><p><del>咕了</del></p>
<p>适用版本：1.20.x</p>
<span id="more"></span>

<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── helpers</span><br><span class="line">│   ├── BallisticCalculator // 弹道计算</span><br><span class="line">│   └── generateEmissionAngle(Player)</span><br><span class="line">└── mixins</span><br><span class="line">    ├── BowItem_aimAssistMixin  // 捕获目标</span><br><span class="line">    ├── getTarget(Level, Player, InteractionHand, CallbackInfoReturnable&lt;InteractionResultHolder&lt;ItemStack&gt;&gt;)</span><br><span class="line">    ├── LivingEntity_aimAssistMixin  // 准心控制</span><br><span class="line">    └── directionControl(CallbackInfo) // tick级物品栏检测</span><br></pre></td></tr></table></figure>

<h2 id="基本处理逻辑"><a href="#基本处理逻辑" class="headerlink" title="基本处理逻辑"></a>基本处理逻辑</h2><ol>
<li><p>输入指令，标记为true</p>
</li>
<li><p>鼠标右键（mouseDown）发出射线追踪获取实体信息，如果为Mob类，添加到目标队列，并且高亮目标，再次右键同一目标，移出队列，取消高亮</p>
</li>
<li><p>鼠标右键（mouseOn），根据目标的坐标和速度，计算弹道，并将准心设置在预设点，<del>蓄力完毕后会持续跟踪</del>，直到生物被移除目标队列</p>
</li>
</ol>
<h2 id="代码参考"><a href="#代码参考" class="headerlink" title="代码参考"></a>代码参考</h2><ul>
<li><p>carpet命令<br><code>carpet.commands.PlayerCommand</code><br><code>carpet.CarpetSettings</code><br><code>carpet.commands</code></p>
</li>
<li><p>使用mixin注入代码，检测玩家对于物品弓的使用事件<br><a href="https://github.com/gnembon/fabric-carpet/wiki/Checking-if-a-player-is-holding-the-right-tool">carpet检测玩家手持物品</a></p>
</li>
<li><p>射线检测获取目标<br><code>carpet.script.utils.Tracer.rayTrace</code><br><code>net.minecraft.world.phys.EntityHitResult</code><br><code>net.minecraft.world.entity.Entity.getViewVector</code>  </p>
</li>
<li><p>添加到目标队列<br>&#x2F;&#x2F; TODO</p>
</li>
<li><p>获取目标坐标，速度等信息<br><code>net.minecraft.world.entity.getDeltaMovement</code><br><code>net.minecraft.world.entity.spawnSprintParticle</code><br><code>net.minecraft.world.entity.getYRotf</code></p>
</li>
<li><p>获取轨迹所经过的方块，添加到队列<br><code>package net.minecraft.world.entity.projectile.shoot</code></p>
</li>
<li><p>箭的运动<br><code>net.minecraft.world.entity.projectile.AbstractArrow.tick</code></p>
</li>
<li><p>tick级计算并获取计算后的角度和力度<br>&#x2F;&#x2F; TODO</p>
</li>
<li><p>方向控制<br><code>carpet.helpers.EntityPlayerActionPack.look</code><br><code>net.minecraft.world.entity.ai.control.LookControl.tick</code><br><code>net.minecraft.world.entity.Entity.setRot</code></p>
</li>
<li><p>火力控制<br><code>carpet.helpers.EntityPlayerActionPack.ActionType.USE</code><br><code>net.minecraft.world.item.SnowballItem.use</code><br><code>net.minecraft.world.entity.projectile.Projectile.shoot</code><br><code>net.minecraft.world.entity.projectile.Projectile.shootFromRotation</code><br><code>net.minecraft.world.item.BowItem.releaseUsing</code></p>
</li>
<li><p>检查弓物品的使用状态<br><code>net.minecraft.world.entity.ai.goal.RangedBowAttackGoal.isHoldingBow</code></p>
</li>
<li><p>图腾检测<br><code>net.minecraft.world.entity.LivingEntity.checkTotemDeathProtection</code></p>
</li>
</ul>
<h2 id="待研究"><a href="#待研究" class="headerlink" title="待研究"></a>待研究</h2><ul>
<li><p>检测弓的使用*<br><code>net.minecraft.world.entity.LivingEntity.releaseUsingItem</code>  结束阶段<br><code>net.minecraft.world.entity.LivingEntity.updateUsingItem</code>  可能是中期阶段，待验证</p>
</li>
<li><p>实体<br><code>net.minecraft.world.entity.Entity.getOnPos</code>  脚底方块<br><code>net.minecraft.world.entity.Entity.getXRot</code>  角度</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Minecraft</category>
      </categories>
      <tags>
        <tag>Minecraft</tag>
        <tag>Carpet</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>八股文笔记 #1 Java 基础</title>
    <url>/2025/06/30/boilerplate-answers-1-java-basics/</url>
    <content><![CDATA[<p><del>再好的项目，也敌不过 HashMap 的 resize 过程没讲清楚</del></p>
<span id="more"></span>

<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="1-说一下-Java-的特点"><a href="#1-说一下-Java-的特点" class="headerlink" title="1# 说一下 Java 的特点"></a>1# 说一下 Java 的特点</h2><ol>
<li><strong>平台无关性</strong>：Java 的 “编写一次，运行无处不在” 哲学是其最大的特点之一。Java 编译器将源代码编译成字节码，该字节码可以在任何安装了 JVM 的系统上运行</li>
<li><strong>面向对象</strong>：Java 是一门严格的面向对象的编程语言，几乎一切都是对象。OOP 特性使得代码更易于维护和复用，包括类、对象、继承、多态、抽象和封装</li>
<li><strong>内存管理</strong>：Java 有自己的垃圾回收机制，自动管理内存和回收不再使用的对象</li>
</ol>
<h2 id="2-Java-的优势和劣势是什么？"><a href="#2-Java-的优势和劣势是什么？" class="headerlink" title="2# Java 的优势和劣势是什么？"></a>2# Java 的优势和劣势是什么？</h2><p><strong>优势</strong>：</p>
<ol>
<li><strong>跨平台</strong>：因为 JVM 的存在，一次编写到处运行</li>
<li><strong>面向对象</strong>：虽然现在很多语言都支持面向对象，但是 Java 的设计从一开始就是 OPP 的</li>
<li><strong>强大的生态</strong>：比如 Spring 框架，各种库和工具，社区支持大，企业应用广泛</li>
<li><strong>内存管理</strong>：自动垃圾回收机制，减少了内存泄漏的问题，对开发者友好</li>
<li><strong>多线程支持</strong>：内置的线程机制，方便并发编程</li>
<li><strong>安全性</strong>：Java 有安全模型，比如沙箱机制，适合网络环境</li>
<li><strong>稳定性</strong>：企业级应用长期使用，版本更新也比较注重向后兼容</li>
</ol>
<p><strong>劣势</strong>：</p>
<ol>
<li><strong>性能</strong>：虽然 JVM 优化了很多，但相比 CPP 和 Rust 这种原生编译语言，还是有一定开销</li>
<li><strong>启动时间</strong>：比如微服务场景下，可能不如 Go 之类的快</li>
<li><strong>语法繁琐</strong>：样板代码多，之前没有 lambda 的时候更麻烦，现在有了但是相比 Python 还是不够简洁</li>
<li><strong>内存消耗</strong>：JVM 本身占内存，对于资源有限的环境可能不太友好</li>
<li><strong>面向对象过于严格</strong>：有时候写简单程序反而麻烦，虽然 Java 8 引入了函数式编程，但是不如其他语言自然</li>
<li><strong>开发效率</strong>：相比动态语言如 Python，Java需要更多代码，编译过程也可能拖慢开发节奏</li>
</ol>
<h2 id="3-Java-为什么是跨平台的？"><a href="#3-Java-为什么是跨平台的？" class="headerlink" title="3# Java 为什么是跨平台的？"></a>3# Java 为什么是跨平台的？</h2><p>主要依赖于 JVM。JVM也是一个软件，不同平台有不同的版本。编写的 Java 源码在编译后生成一种 <code>.class</code> 文件，称为字节码文件。JVM 就是负责将机器码文件翻译成特定平台下的机器码然后运行</p>
<p>也就是说，只要在不同平台上安装对应的 JVM，就可以运行字节码文件，运行我们编写的 Java 程序</p>
<p>PS：不同平台下编译生成的字节码是一样的，但是由 JVM 翻译成的机器码是不一样的；即使将 Java 程序打包成可执行文件（如 <code>.exe</code>），仍然需要 JVM 的支持；跨平台的是 Java 程序，不是 JVM，JVM 是用 C&#x2F;CPP 开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的 JVM</p>
<h2 id="4-JVM、JDK、JRE-三者关系？"><a href="#4-JVM、JDK、JRE-三者关系？" class="headerlink" title="4# JVM、JDK、JRE 三者关系？"></a>4# JVM、JDK、JRE 三者关系？</h2><img src="https://cdn.xiaolincoding.com//picgo/image-20240725230247664.png" alt="JVM、JDK、JRE 关系图" style="zoom: 33%;" />

<ul>
<li>JDK 是 Java 开发工具包，是开发 Java 程序所需的工具集合。它包含了 JVM、编译器（javac）、调试器（jdb）等开发工具，以及一系列的类库（如 Java 标准库和开发工具库）。JDK 提供了开发、编译、调试和运行 Java 程序所需的全部工具和环境</li>
<li>JRE 是 Java 运行时环境，是 Java 程序运行所需的最小环境。它包含了 JVM 和 一组 Java 类库，用于支持 Java 程序的执行。JRE 不包含开发工具，只提供 Java 程序运行所需的运行环境</li>
<li>JVM 是 Java 虚拟机，是 Java 程序运行的环境。它负责将 Java 字节码（由 Java 编译器生成）解释或编译成机器码，并执行程序。JVM 提供了内存管理、垃圾回收、安全性等功能，使得 Java 程序具备跨平台性</li>
</ul>
<h2 id="5-为什么-Java-解释和编译都有？"><a href="#5-为什么-Java-解释和编译都有？" class="headerlink" title="5# 为什么 Java 解释和编译都有？"></a>5# 为什么 Java 解释和编译都有？</h2><p>在 Java 经过编译之后生成字节码文件，接下来进入 JVM 中，就有两个步骤编译和解释，如图：</p>
<img src="https://cdn.xiaolincoding.com//picgo/1715928000183-44fc6130-8abc-4f0b-8f6d-79de0ab09509.webp" alt="Java 源码执行过程" style="zoom: 67%;" />

<ul>
<li><p><strong>编译性</strong>：Java 源码（<code>.java</code> 文件）通过 <code>javac</code> 编译，生成字节码文件（<code>.class</code>）</p>
</li>
<li><p><strong>解释性</strong>：早期 JVM 使用<strong>解释器</strong>，逐行解释执行字节码。现代 JVM 引入 <strong>JIT（Just-In-Time）编译器</strong>，热点代码会被编译为本地机器码提高执行效率</p>
</li>
</ul>
<p>所以 Java 既是编译型语言，也是解释型语言，默认采用的是解释器和编译器混合的模式</p>
<h2 id="6-JVM-是什么？"><a href="#6-JVM-是什么？" class="headerlink" title="6# JVM 是什么？"></a>6# JVM 是什么？</h2><p>JVM 是 Java 虚拟机，主要工作是解释自己的指令集（即字节码）并映射到本地的 CPU 指令集和 OS 的系统调用</p>
<p>JVM 屏蔽了与操作系统平台相关的信息，使得 Java 程序只需要生成在 Java 虚拟机上运行的目标代码（字节码），就可在多种平台上不加修改地运行，这也是 Java 能够 “一次编译，到处运行” 的原因</p>
<h2 id="7-编译型语言和解释型语言的区别？"><a href="#7-编译型语言和解释型语言的区别？" class="headerlink" title="7# 编译型语言和解释型语言的区别？"></a>7# 编译型语言和解释型语言的区别？</h2><ul>
<li><p><strong>编译型语言</strong>：在程序执行之前，整个源码会被编译成字节码或机器码，生成可执行文件。执行时直接运行编译后的代码，速度快，但跨平台性较差</p>
</li>
<li><p><strong>解释型语言</strong>：在程序执行时，逐行解释执行源码，不生成独立的可执行文件。通常由解释器动态解释并执行代码，跨平台性好，但执行速度相对较慢</p>
</li>
</ul>
<p>典型的编译型语言如 C、CPP，典型的解释型语言如 Python、JavaScript</p>
<h2 id="8-Java-和-Python-的区别是什么？"><a href="#8-Java-和-Python-的区别是什么？" class="headerlink" title="8# Java 和 Python 的区别是什么？"></a>8# Java 和 Python 的区别是什么？</h2><ul>
<li>Java 是一种先编译后解释的混合型语言，Java 编译器将源码编译为字节码，而字节码则由 Java 虚拟机执行</li>
<li>Python 是一种解释型语言，会在执行程序的同时进行解释</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="1-8-种基本的数据类型"><a href="#1-8-种基本的数据类型" class="headerlink" title="1# 8 种基本的数据类型"></a>1# 8 种基本的数据类型</h2><ul>
<li><strong>数值型</strong>：整数类型（<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>）和浮点类型（<code>float</code>、<code>double</code>）</li>
<li><strong>字符型</strong>：<code>char</code></li>
<li><strong>布尔型</strong>：<code>boolean</code></li>
</ul>
<p>8 种基本数据类型的占用大小、取值范围、默认值，如下表所示：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>占用大小（字节）</th>
<th>取值范围</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>byte</code></td>
<td>1</td>
<td><code>-2^7</code> 到 <code>2^7 - 1</code></td>
<td>0</td>
<td>最小的整数类型，适合用于节省内存，例如在处理文件或网络流时存储小范围整数数据</td>
</tr>
<tr>
<td><code>short</code></td>
<td>2</td>
<td><code>-2^15</code> 到 <code>2^15 - 1</code></td>
<td>0</td>
<td>较少使用，通常用于在需要节省内存且数据范围在该区间的场景</td>
</tr>
<tr>
<td><code>int</code></td>
<td>4</td>
<td><code>-2^31</code>到 <code>2^31 - 1</code></td>
<td>0</td>
<td>最常用的整数类型，可满足大多数日常编程种整数计算的需求</td>
</tr>
<tr>
<td><code>long</code></td>
<td>8</td>
<td><code>-2^63</code>到 <code>2^63 - 1</code></td>
<td>0L</td>
<td>用于表示非常大的整数，当 <code>int</code> 类型无法满足需求时使用，定义时数值后需加 <code>L</code> 或 <code>l</code></td>
</tr>
<tr>
<td><code>float</code></td>
<td>4</td>
<td><code>-2^31</code>到 <code>2^31 - 1</code></td>
<td>0.0f</td>
<td>单精度浮点数，用于表示小数，定义时数值后需加 <code>F</code> 或 <code>f</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td>8</td>
<td><code>-2^63</code>到 <code>2^63 - 1</code></td>
<td>0.0d</td>
<td>双精度浮点数，精度比 <code>float</code> 高，是 Java 种表示小数的默认类型</td>
</tr>
<tr>
<td><code>char</code></td>
<td>2</td>
<td><code>-2^15</code> 到 <code>2^15 - 1</code></td>
<td>‘\u0000’</td>
<td>用于表示单个字符，采用 Unicode编码，可表示各种语言的字符</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>不确定（理论上1位）</td>
<td><code>true</code> 或 <code>false</code></td>
<td><code>false</code></td>
<td>用于逻辑判断，只有两个取值，常用于条件判断和循环控制等逻辑场景</td>
</tr>
</tbody></table>
<p><code>float</code> 和 <code>double</code> 的最小值和最大值是以科学计数法的形式输出的，比如 3.14E3 表示 3.14 * 10^3，3.14E-3 表示 3.14 &#x2F; 10^3</p>
<p>注意：</p>
<ul>
<li>浮点数的默认类型是 <code>double</code>，声明 <code>float</code> 时必须在末尾加上 <code>F</code> 或 <code>f</code></li>
<li>整数的默认类型为 <code>int</code>，声明 <code>long</code> 时必须在末尾加上 <code>L</code> 或 <code>l</code></li>
<li><code>char</code> 的包装类是 <code>Character</code>，<code>int</code> 的是 <code>Integer</code>，其他都是首字母大写</li>
<li><code>char</code> 是无符号的，不能为负，所以是 0 开始的</li>
</ul>
<h2 id="2-long-和-int-可以互转吗？"><a href="#2-long-和-int-可以互转吗？" class="headerlink" title="2# long 和 int 可以互转吗？"></a>2# long 和 int 可以互转吗？</h2><p><strong>可以</strong>。由于 <code>long</code> 的范围比 <code>int</code> 大，因此将 <code>int</code> 转换为 <code>long</code> 是安全的，而将 <code>long</code> 转换为 <code>int</code> 可能会导致数据丢失或溢出</p>
<p>将 <code>int</code> 转换为 <code>long</code> 可以通过直接赋值或强制类型转换来实现。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">longValue</span> <span class="operator">=</span> intValue; <span class="comment">// 自动转换，安全的</span></span><br></pre></td></tr></table></figure>

<p>将 <code>long</code> 转换为 <code>int</code> 需要使用强制类型转换，但需要注意潜在的数据丢失或溢出问题。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">longValue</span> <span class="operator">=</span> <span class="number">100L</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> (<span class="type">int</span>) longValue; <span class="comment">// 强制类转换，可能会有数据丢失或溢出</span></span><br></pre></td></tr></table></figure>

<p>如果 <code>longValue</code> 的值超出了 <code>int</code> 的范围，转换结果是截断后的低位部分。因此，在转换之前，建议先检查 <code>longValue</code> 的值是否在 <code>int</code> 范围内，以避免数据丢失或溢出的问题</p>
<h2 id="3-数据类型转换的方式有哪些？"><a href="#3-数据类型转换的方式有哪些？" class="headerlink" title="3# 数据类型转换的方式有哪些？"></a>3# 数据类型转换的方式有哪些？</h2><ol>
<li><strong>自动类型转换（隐式转换）</strong>：当目标类型的范围大于源类型时，Java 会自动将源类型转换为目标类型，不需要显示的类型转换。例如：将 <code>int</code> 转换为 <code>long</code>、将 <code>float</code> 转换为 <code>double</code> 等</li>
<li><strong>强制类型转换（显示转换）</strong>：当目标类型的范围小于源类型时，需要使用强制类型转换将源类型转换为目标类型。这可能导致数据丢失或溢出。例如：将 <code>long</code> 转换为 <code>int</code> 、将 <code>double</code> 转换为 <code>float</code> 等。语法为：目标类型 变量名 &#x3D; (目标类型) 源类型</li>
<li><strong>字符串转换</strong>：Java 提供了将字符串表示的数据转换为其他类型数据的方法。例如，将字符串转换为整型 <code>int</code>，可以使用 <code>Integer.parseInt()</code> 方法；将字符串转换为浮点型 <code>double</code>，可以使用 <code>Double.parseDouble()</code> 方法等</li>
<li><strong>数值之间的转换</strong>：Java 提供了一些数据类型之间的转换方法，如将整型转换为字符型、将字符型转换为整型等。这些转换方式可以通过类型的包装类来实现，例如：将 <code>int</code> 转换为 <code>char</code>，可以使用 <code>Character.forDigit()</code> 方法；将 <code>char</code> 转换为 <code>int</code>，可以使用 <code>Character.getNumericValue()</code> 方法</li>
</ol>
<h2 id="4-类型互转可能会出现什么问题？"><a href="#4-类型互转可能会出现什么问题？" class="headerlink" title="4# 类型互转可能会出现什么问题？"></a>4# 类型互转可能会出现什么问题？</h2><ol>
<li><strong>数据丢失</strong>：当将一个范围较大的数据类型转换为一个范围较小的数据类型时，可能会发生数据丢失。例如：将一个 <code>long</code> 转换为 <code>int</code> 时，如果 <code>long</code> 值超出了 <code>int</code> 类型的范围，转换结果将是截断后的低位部分，高位部分的数据丢失</li>
<li><strong>数据溢出</strong>：与数据丢失相反，当将一个范围较小的数据类型转换为一个范围较大的数据类型时，可能会发生数据溢出。例如：将一个 <code>int</code> 转换为 <code>long</code> 时，转换结果会填充额外的高位空间，但原始数据仍然保持不变</li>
<li><strong>精度损失</strong>：在进行浮点数类型的转换时，可能会发生精度损失。由于浮点数的表示方法不同，将一个双精度浮点数 <code>double</code> 转换为单精度浮点数 <code>float</code> 时，精度可能会损失</li>
<li><strong>类型不匹配导致的错误</strong>：在进行类型转换时，需要确保源类型和目标类型是兼容的。如果两者不兼容，会导致编译错误或运行时错误</li>
</ol>
<h2 id="5-为什么用-BigDecimal-不用-double？"><a href="#5-为什么用-BigDecimal-不用-double？" class="headerlink" title="5# 为什么用 BigDecimal 不用 double？"></a>5# 为什么用 BigDecimal 不用 double？</h2><p><code>double</code> 会出现精度丢失的问题，<code>dobule</code> 执行的是二进制浮点运算，二进制表示小数只能使用 1&#x2F;(2^n) 的和的组合，有些情况下不能准确地表示一个小数。</p>
<p>而 <code>BigDecimal</code> 是精确计算，一般牵扯到金钱的计算，都使用 <code>BigDecimal</code>。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.1&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">sum</span> <span class="operator">=</span> num1.add(num2); <span class="comment">// 0.3</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">product</span> <span class="operator">=</span> num1.multiply(num2); <span class="comment">// 0.02</span></span><br></pre></td></tr></table></figure>

<p>这样，<code>BigDecimal</code> 可以确保精确的十进制数值计算，避免了使用 <code>double</code> 可能出现的舍入误差。需要注意的是，在创建 <code>BigDecimal</code> 对象时，应该使用字符串作为参数，而不是直接使用浮点数值，以避免浮点数精度丢失</p>
<h2 id="6-装箱和拆箱是什么？"><a href="#6-装箱和拆箱是什么？" class="headerlink" title="6# 装箱和拆箱是什么？"></a>6# 装箱和拆箱是什么？</h2><p>装箱（Boxing）和拆箱（Unboxing）是将基本数据类型和对应的包装类之间进行转换的过程，自动装箱主要发送在赋值时和方法调用时，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 赋值时</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i; <span class="comment">// 拆箱</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法调用时</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">show</span><span class="params">(Integer iParam)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;自动装箱&quot;</span> + iParam);</span><br><span class="line">    <span class="keyword">return</span> iParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">show(<span class="number">3</span>); <span class="comment">// 装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> show(<span class="number">3</span>); <span class="comment">// 返回类型是 Integer，拆箱</span></span><br></pre></td></tr></table></figure>

<p>在一个循环中进行自动装箱操作的情况下可能出现问题，会创建多余的对象，影响程序的性能，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123; sum += <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure>

<p><code>+</code> 这个操作符不适用于 <code>Integer</code> 对象，首先 <code>sum</code> 进行自动拆箱操作，进行数值相加操作，最后发生自动装箱操作转换成 <code>Integer</code> 对象。其内部变化如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> sum.intValue() + i;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(result);</span><br></pre></td></tr></table></figure>

<p>因为 <code>sum</code> 声明为 <code>Integer</code> 类型，上面的循环中会创建 1000 个无用的 <code>Integer</code> 对象，会降低程序的性能，加重垃圾回收的工作量。因此在编程的时候，需要正确地声明变量类型，避免因为自动装箱引起的性能问题</p>
<h2 id="Java-为什么要有包装类？"><a href="#Java-为什么要有包装类？" class="headerlink" title="Java 为什么要有包装类？"></a>Java 为什么要有包装类？</h2><p>包装类就是将基本数据类型包装成 <code>Object</code> 对象，对象封装有诸多好处：</p>
<ol>
<li>可以把属性和方法结合在一起，比如 <code>Integer</code> 有 <code>parseInte()</code> 方法来专门处理 <code>int</code> 相关的数据</li>
<li>Java 中大部分类和方法都是用来处理<strong>引用类型</strong>的。像 <code>ArrayList</code> 这样的集合类，不能直接存储基本类型（如 <code>int</code>、<code>double</code>），而是必须使用其对应的包装类（如 <code>Integer</code>、<code>Double</code>）</li>
<li>在 Java 中，泛型只能使用<strong>引用类型</strong>，而不能使用<strong>基本数据类型</strong>。例如：对一个列表的元素进行排序，如果使用基本类型 <code>int</code>（实际上基本类型无法作为泛型参数，所以连 <code>List&lt;int&gt;</code> 都不合法），无法直接使用 <code>Collections.sort()</code> 方法，如果使用 <code>Integer</code> 包装类，则可以</li>
<li>在 Java 中，集合中只能存储引用类型，而不能存储基本类型。比如 <code>List&lt;int&gt;</code> 是不合法的，需要使用 <code>List&lt;Integer&gt;</code></li>
</ol>
<p>需要注意空指针异常。例如：<code>int</code> 可以赋值为 0，而 <code>Integer</code> 必须通过实例化对象来赋值，如果对一个未经初始化的 <code>Integer</code> 变量进行操作，就会出现 <code>NullPointerException</code>，这是因为它被赋值为 <code>null</code>，而 <code>null</code> 是无法进行自动拆箱的</p>
<h2 id="7-为什么还要保留基本数据类型？"><a href="#7-为什么还要保留基本数据类型？" class="headerlink" title="7# 为什么还要保留基本数据类型？"></a>7# 为什么还要保留基本数据类型？</h2><p>包装类是引用类型，对象的引用和对象本身是分开存储的，而对于基本数据类型，变量对应的内存块直接存储数据本身。因此，基本数据类型在读写效率方面，要比包装类高效</p>
<p>此外，在 64 位 JVM 上，在开启引用压缩的情况下，一个 <code>Integer</code> 对象占用 16 个字节的内存空间，而一个 <code>int</code> 类型数据只占用 4 字节的内存空间</p>
<p>不管在读写效率，还是存储效率，基本类型都比包装类高效</p>
<h2 id="8-说一下-Integer-的基本缓存"><a href="#8-说一下-Integer-的基本缓存" class="headerlink" title="8# 说一下 Integer 的基本缓存"></a>8# 说一下 Integer 的基本缓存</h2><p>Java 的 <code>Integer</code> 类内部实现了一个静态缓存池，用于存储特定范围内的整数值对应的 <code>Integer</code> 对象</p>
<p>默认情况下，这个范围是 -128 到 127。当通过 <code>Integer.valueOf(int)</code> 方法创建一个在这个范围内的整数对象时，并不会每次都生成新的对象实例，而是复用缓存中的对象，直接从内存中取出，不需要新建一个对象</p>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="1-怎么理解面向对象？简单说说封装、继承、多态"><a href="#1-怎么理解面向对象？简单说说封装、继承、多态" class="headerlink" title="1# 怎么理解面向对象？简单说说封装、继承、多态"></a>1# 怎么理解面向对象？简单说说封装、继承、多态</h2><p>面向对象是一种编程范式，它将现实世界中的事物抽象为对象，对象具有属性和方法。面向对象编程的设计思想是以对象为中心，通过对象之间的交互来完成程序的功能，具有灵活性和可扩展性</p>
<p>Java 面向对象的三大特性包括**：封装、继承、多态**</p>
<ul>
<li><strong>封装</strong>：封装是指将对象的属性（成员变量）和行为（方法）封装在一个类中，并通过访问控制符（如 <code>private</code>、<code>public</code> 等）隐藏内部实现细节，只暴露必要的接口供外部使用。封装的作用是<strong>增强安全性、提高模块独立性</strong>，防止外部对对象状态的非法访问或修改</li>
<li><strong>继承</strong>：继承是面向对象编程中实现代码复用的机制，它允许一个类（子类）继承另一个类（父类）的属性和方法。继承使得子类可以在父类基础上扩展功能，从而构建更清晰、更有层次的类结构</li>
<li><strong>多态</strong>：多态是指<strong>同一个方法调用，在不同对象上可以表现出不同的行为</strong>。它分为两种形式：<ul>
<li><strong>编译时多态（方法重载）</strong>：同一类中方法名相同、参数不同</li>
<li><strong>运行时多态（方法重写）</strong>：子类重写父类方法，并通过父类引用调用子类对象。<br> 多态使程序具备更好的<strong>扩展性和可维护性</strong>，是实现面向接口编程的关键</li>
</ul>
</li>
</ul>
<h2 id="2-多态体现在哪几个方面？"><a href="#2-多态体现在哪几个方面？" class="headerlink" title="2# 多态体现在哪几个方面？"></a>2# 多态体现在哪几个方面？</h2><ol>
<li><p><strong>方法重载</strong>：方法重载是指同一类中可以有多个同名方法，它们具有不同的参数列表。虽然方法名相同，但根据传入的不同参数，编译器会在编译时确定调用哪个方法。注意：方法返回值不同但参数相同，<strong>不构成重载</strong></p>
</li>
<li><p><strong>方法重写</strong>：方法重写是指子类能够提供对父类中同名方法的具体实现。在运行时，JVM 会根据对象的实际类型确定调用哪个版本的方法，这是实现多态的主要方式。注意：重写的方法必须具有<strong>相同的方法签名</strong>，且<strong>访问权限不能比父类更严格</strong></p>
</li>
<li><p><strong>接口与实现</strong>：Java 中的接口是一种行为规范，类通过 <code>implements</code> 关键字实现接口。多个类可以实现同一个接口，通过<strong>接口引用来调用方法</strong>，可以实现<strong>调用方与实现方的解耦</strong>，体现了多态特性</p>
</li>
<li><p><strong>向上转型和向下转型</strong>：</p>
<ul>
<li><p><strong>向上转型</strong>：子类对象可以被赋值给父类类型的引用（即：<code>Parent p = new Child()</code>），这在 Java 中是<strong>自动进行</strong>的，也是多态的前提。可以只调用父类中定义的方法，实际运行的是子类的重写实现（如果有）</p>
</li>
<li><p><strong>向下转型</strong>：将父类引用转换为子类类型（即：<code>Child c = (Child) p</code>），这通常需要<strong>强制类型转换</strong>，并应使用 <code>instanceof</code> 检查其实际类型，避免出现 <code>ClassCastException</code>。向下转型常用于访问子类特有的方法</p>
</li>
</ul>
</li>
</ol>
<h2 id="3-多态解决了什么问题？"><a href="#3-多态解决了什么问题？" class="headerlink" title="3# 多态解决了什么问题？"></a>3# 多态解决了什么问题？</h2><p>多态是指<strong>同一个方法调用，在不同对象上可以表现出不同的行为</strong>。多态的这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类</p>
<p>多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等</p>
<h2 id="4-面向对象的设计原则有哪些？"><a href="#4-面向对象的设计原则有哪些？" class="headerlink" title="4# 面向对象的设计原则有哪些？"></a>4# 面向对象的设计原则有哪些？</h2><ol>
<li><strong>单一职责原则（SRP）</strong>：一个类应该只有一个引起它变化的原因，即一个类应该只负责一项职责。例如：考虑一个员工类，它应该只负责管理员工信息，而不负责其他无关的工作</li>
<li><strong>开放封闭原则（OCP）</strong>：软件实体应该对扩展开放，对修改封闭。例如：定义一个图形类，然后让不同类型的图形继承这个类，而不需要修改图形类本身</li>
<li><strong>里式替换原则（LSP）</strong>：父类出现的地方，子类必须能够替代父类，并且保证原有功能不被破坏。例如：如果一个公司类包含部门类，应该考虑使用合成&#x2F;聚合关系，而不是将公司类继承自部门类</li>
<li><strong>接口隔离原则（ISP）</strong>：客户端不应该依赖那些它不需要的接口，即接口应该小而专。例如：你设计了一个 “多功能设备接口”，里面包含<strong>打印</strong>、<strong>扫描</strong>、<strong>传真</strong>、<strong>装订</strong>四个方法，结果，公司后来要做一款<strong>廉价入门级打印机</strong>，它只能打印，其余功能都没有。为了实现接口，这台打印机被迫提供空实现或抛异常</li>
<li><strong>依赖倒置原则（DIP）</strong>：高层模块不应该依赖低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。例如：假设有一个通知服务类 ，需要发送消息。错误的做法是它直接创建并依赖一个 <code>EmailSender</code> 类，这样如果以后要改用短信或微信，就必须修改通知服务的代码。正确的做法是先定义一个接口并实现它。通知服务类只依赖接口，而不是具体实现</li>
<li><strong>最少知识原则（Law of Demeter）</strong>：一个对象应当对其他对象有最少的了解，只与其直接的朋友交互。例如：你要点一杯咖啡，应该说：“服务员，请给我一杯拿铁。”，由服务员自己决定找谁、怎么做</li>
</ol>
<h2 id="5-抽象类和普通类的区别？"><a href="#5-抽象类和普通类的区别？" class="headerlink" title="5# 抽象类和普通类的区别？"></a>5# 抽象类和普通类的区别？</h2><ol>
<li><strong>实例化</strong>：普通类可以直接实例化对象，而抽象类不能被实例化，只能被继承</li>
<li><strong>方法实现</strong>：普通类中的方法可以有具体的实现，而抽象类中的方法可以有实现也可以没有实现</li>
<li><strong>实现限制</strong>：普通类可以被其他类继承和使用，而抽象类一般用于作为基类，被其他类继承和扩展使用</li>
</ol>
<h2 id="6-抽象类和接口的区别是什么？"><a href="#6-抽象类和接口的区别是什么？" class="headerlink" title="6# 抽象类和接口的区别是什么？"></a>6# 抽象类和接口的区别是什么？</h2><p><strong>两者的特点</strong>：</p>
<ul>
<li>抽象类用于描述类的共同特性和行为，可以有成员变量、构造方法和具体方法。适用于有明显继承关系的场景</li>
<li>接口用于定义行为规范，可以多实现，只能有常量和抽象方法（Java 8 以后可以有默认方法和静态方法）。适用于定义类的能力或功能</li>
</ul>
<p><strong>两者的区别:</strong></p>
<ol>
<li><strong>实现方式</strong>：实现接口的关键字为 <code>implements</code>，继承抽象类的关键字为 <code>extends</code>。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承</li>
<li><strong>方法方式</strong>：接口只有定义，不能有方法的实现，Java 8 中可以定义 <code>default</code> 方法体，而抽象类可以有定义与实现，方法可在抽象类中实现</li>
<li><strong>访问修饰符</strong>：接口成员变量默认为 <code>public static final</code>，必须赋初值，不能被修改；其所有的成员方法都是 <code>public abstract</code> 的。抽象类中成员变量默认 <code>default</code>，可在子类中被重新定义，也可被重新赋值；抽象方法被 <code>abstract</code> 修饰，不能被 <code>private</code>、<code>static</code>、<code>synchronized</code> 和 <code>native</code> 等修饰，必须以分号结尾，不带花括号</li>
<li><strong>变量</strong>：抽象类可以包含实例变量和静态变量，而接口只能包含常量（静态常量）</li>
</ol>
<h2 id="7-抽象类能加-final-修饰吗？"><a href="#7-抽象类能加-final-修饰吗？" class="headerlink" title="7# 抽象类能加 final 修饰吗？"></a>7# 抽象类能加 final 修饰吗？</h2><p><strong>不能</strong>。Java 中的抽象类是用来被继承的，而 <code>final</code> 修饰符用于禁止类被继承或方法被重写，因此，抽象类和 <code>final</code> 修饰符是互斥的，不能同时使用</p>
<h2 id="8-接口里面可以定义哪些方法"><a href="#8-接口里面可以定义哪些方法" class="headerlink" title="8# 接口里面可以定义哪些方法"></a>8# 接口里面可以定义哪些方法</h2><ol>
<li><strong>抽象方法</strong>：抽象方法是接口的核心部分，所有实现接口的类必须实现这些方法。抽象方法默认是 <code>public</code> 和 <code>abstract</code>，这些修饰符可以省略</li>
<li><strong>默认方法</strong>：默认方法是在 Java 8 引入的，允许接口提供具体实现，实现类可以选择重写默认方法</li>
<li><strong>静态方法</strong>：静态方法也是在 Java 8 引入的，它们属于接口本身，可以通过接口名直接调用，而不需要实现类的对象</li>
<li><strong>私有方法</strong>：私有方法是在 Java 9 引入的，用于在接口中为默认方法和其他私有方法提供辅助功能，这些方法不能被实现类访问，只能在接口内部使用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sleeping...&quot;</span>);</span><br><span class="line">        logSleep();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method in interface&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logSleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logging sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="9-抽象类可以被实例化吗？"><a href="#9-抽象类可以被实例化吗？" class="headerlink" title="9# 抽象类可以被实例化吗？"></a>9# 抽象类可以被实例化吗？</h2><p><strong>不能</strong>。这意味着不能使用 <code>new</code> 关键字直接创建一个抽象类的对象。抽象类的存在主要是为了被继承，它通常包含一个或多个抽象方法（由 <code>abstract</code> 关键字修饰且无方法体），这些方法在子类中被实现</p>
<p>抽象类可以有构造器，这些构造器在子类实例化时会被调用，以便进行必要的初始化工作。然而，这个过程并不是直接实例化抽象类，而是创建了子类的实例，间接地使用了抽象类的构造器。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 构造器代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ConcreteClass &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 调用抽象类的构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实现抽象方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ConcreteClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass</span>();</span><br></pre></td></tr></table></figure>



<h2 id="10-接口可以包含构造函数吗？"><a href="#10-接口可以包含构造函数吗？" class="headerlink" title="10# 接口可以包含构造函数吗？"></a>10# 接口可以包含构造函数吗？</h2><p><strong>不能</strong>。接口不会有自己的实例，所以不需要有构造函数</p>
<p>这是因为，构造函数就是初始化类的属性或方法，在 new 的一瞬间自动调用，然而接口是不能 new 的</p>
<h2 id="11-解释-Java-中的静态变量和静态方法"><a href="#11-解释-Java-中的静态变量和静态方法" class="headerlink" title="11# 解释 Java 中的静态变量和静态方法"></a>11# 解释 Java 中的静态变量和静态方法</h2><p>在 Java 中，静态变量和静态方法是与类本身关联的，而不是与类的实例（对象）关联，它们在内存中只存在一份，可以被类的所有实例共享</p>
<ul>
<li><strong>静态变量</strong>：静态变量（类变量）是在类中使用 <code>static</code> 关键字声明的变量，他们属于类而不是任何具体的对象。常用于需要在所有对象间共享的数据，如计数器、常量等。主要的特点：<ul>
<li><strong>共享性</strong>：所有该类的实例共享同一个静态变量。如果一个实例修改了静态变量的值，其他实例也会看到这个更改</li>
<li><strong>初始化</strong>：静态变量在类被加载时初始化，只会对其进行一次内存分配</li>
<li><strong>访问方式</strong>：静态变量可以直接通过类名访问，也可以通过实例访问，但推荐使用类名</li>
</ul>
</li>
<li><strong>静态方法</strong>：静态方法是在类中使用 <code>static</code> 关键字声明的方法，类似于静态变量，静态方法也属于类而不是任何具体的对象。常用于助手方法、获取类级别的信息或者是没有依赖于实例的数据处理。主要的特点：<ul>
<li><strong>访问静态成员</strong>：静态方法可以直接调用其他静态变量和静态方法，但不能直接访问非静态成员</li>
<li><strong>无实例依赖</strong>：静态方法可以在没有创建类实例的情况下调用。对于静态方法来说，不能直接访问非静态的成员变量或方法，因为静态方法没有上下文的实例</li>
<li><strong>多态性</strong>：静态方法不支持重写（Override），但可以被隐藏（Hide）</li>
</ul>
</li>
</ul>
<h2 id="12-非静态内部类和静态内部类的区别？"><a href="#12-非静态内部类和静态内部类的区别？" class="headerlink" title="12# 非静态内部类和静态内部类的区别？"></a>12# 非静态内部类和静态内部类的区别？</h2><ol>
<li>非静态内部类依赖于外部类的实例，而静态内部类不依赖于外部类的实例</li>
<li>非静态内部类可以访问外部类的实例变量和方法，而静态内部类只能访问外部类的静态成员</li>
<li>非静态内部类不能定义静态成员，而静态内部类可以定义静态成员</li>
<li>非静态内部类在外部类实例化后才能实例化，而静态内部类可以独立实例化</li>
<li>非静态内部类可以访问外部类的私有成员，而静态内部类不能直接访问外部类的私有成员，需要通过实例化外部类来访问</li>
</ol>
<h2 id="13-非静态内部类可以直接访问外部类的实例变量和方法，编译器是怎么做到的？"><a href="#13-非静态内部类可以直接访问外部类的实例变量和方法，编译器是怎么做到的？" class="headerlink" title="13# 非静态内部类可以直接访问外部类的实例变量和方法，编译器是怎么做到的？"></a>13# 非静态内部类可以直接访问外部类的实例变量和方法，编译器是怎么做到的？</h2><p>这是因为编译器在生成字节码时，会为非静态内部类维护一个指向外部类实例的引用，将外部类实例作为参数传入，并在内部类的实例化过程中建立外部类实例与内部类实例之间的联系，从而实现直接访问外部方法的功能</p>
<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="1-Java-中-final-的作用是什么？"><a href="#1-Java-中-final-的作用是什么？" class="headerlink" title="1# Java 中 final 的作用是什么？"></a>1# Java 中 final 的作用是什么？</h2><ol>
<li><strong>装饰类</strong>：当 <code>final</code> 修饰一个类时，表示这个类不能被继承，是类继承体系中的最终形态。例如：Java 中的 <code>String</code> 类就是用 <code>final</code> 修饰的，着保证了 <code>String</code> 类的不可变性和安全性，防止其他类通过继承来改变 <code>String</code> 类的行为和特性</li>
<li><strong>修饰方法</strong>：用 <code>final</code> 修饰的方法不能在子类中被重写。例如：<code>java.lang.Object</code> 类中的 <code>getClass</code> 方法就是 <code>final</code> 的，因为这个方法的行为是由 JVM 底层实现来保证的，不应该被子类修改</li>
<li><strong>修饰变量</strong>：当 <code>final</code> 修饰基本数据类型的变量时，改变量一旦被赋值就不能再改变。例如：<code>final int num = 10</code>，这里的 <code>num</code> 就是一个常量，不能再对齐进行重新赋值操作，否则会导致编译错误。对于引用类型，<code>final</code> 修饰意味着这个引用变量不能再指向其他对象，但对象本身的内容是可以改变的。例如：<code>final StringBuilder sb = new StringBuilder(&quot;Hello&quot;);</code>，不能让 <code>sb</code> 再指向其他 <code>StringBuilder</code> 对象，但可以通过 <code>sb.append(&quot; World!&quot;);</code> 来修改字符串的内容</li>
</ol>
<h1 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h1><h2 id="1-浅拷贝和深拷贝的区别？"><a href="#1-浅拷贝和深拷贝的区别？" class="headerlink" title="1# 浅拷贝和深拷贝的区别？"></a>1# 浅拷贝和深拷贝的区别？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1720683675376-c5af6668-4538-479f-84e8-42d4143ab101.webp" alt="深拷贝和浅拷贝的区别"></p>
<ul>
<li><strong>浅拷贝</strong>：只复制对象本身以及其字段中的基本类型值和引用类型的引用地址，不会递归复制引用对象本身。也就是说，浅拷贝会创建一个新的对象，但其中引用类型的字段仍指向原对象中引用的<strong>同一内存地址</strong>，所以原对象和拷贝对象会<strong>共享</strong>这些引用</li>
<li><strong>深拷贝</strong>：不仅复制对象本身，还会递归复制对象中所有的引用类型字段，确保所有嵌套的对象也被复制一份。这样，深拷贝生成的是一个完全独立的对象及其所有内部对象，原对象和拷贝对象之间互不影响</li>
</ul>
<h2 id="2-实现深拷贝的三种方法是什么"><a href="#2-实现深拷贝的三种方法是什么" class="headerlink" title="2# 实现深拷贝的三种方法是什么?"></a>2# 实现深拷贝的三种方法是什么?</h2><ul>
<li><strong>实现 <code>Cloneable</code> 接口并重写 <code>clone()</code> 方法</strong>：在 <code>clone()</code> 方法中，通过递归克隆引用类型字段来实现深拷贝</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String field1;</span><br><span class="line">    <span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">cloned</span> <span class="operator">=</span> (MyClass) <span class="built_in">super</span>.clone();</span><br><span class="line">        cloned.nestedObject = (NestedClass) nestedObject.clone(); <span class="comment">// 深拷贝内部的引用对象</span></span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>使用序列化和反序列化</strong>：通过将对象序列化为字节流，再从字节流反序列化为对象来实现深拷贝。要求对象及其所有引用类型字段都实现 <code>Serializable</code> 接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String field1;</span><br><span class="line">    <span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Myclass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">			<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">			oos.writeObject(<span class="built_in">this</span>);</span><br><span class="line">			oos.flush();</span><br><span class="line">			oos.close();</span><br><span class="line">			<span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray());</span><br><span class="line">			<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">			<span class="keyword">return</span> (MyClass) ois.readObject();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>手动递归复制</strong>：针对特定对象结构，手动递归复制对象及其引用类型字段。适用于对象结构复杂度不高的情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String field1;</span><br><span class="line">	<span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> MyClass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">MyClass</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">		copy.setField1(<span class="built_in">this</span>.field1);</span><br><span class="line">		copy.setNestedObject(<span class="built_in">this</span>.nestedObject.deepCopy());</span><br><span class="line">		<span class="keyword">return</span> copy;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line">	<span class="keyword">public</span> NestedClass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">NestedClass</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NestedClass</span>();</span><br><span class="line">		copy.setNestedField(<span class="built_in">this</span>.nestedField);</span><br><span class="line">		<span class="keyword">return</span> copy;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="1-什么是泛型？"><a href="#1-什么是泛型？" class="headerlink" title="1# 什么是泛型？"></a>1# 什么是泛型？</h2><p>泛型是 Java 编程语言中的一个重要特性，它允许类、接口和方法在定义时使用一个或多个类型参数，这些类型参数在使用时可以被指定为具体的类型</p>
<p>泛型的主要目的是在编译时提供更强的类型检查，并且在编译后能够保留类型信息，避免了在运行时出现类型转换异常</p>
<h2 id="2-为什么需要泛型？"><a href="#2-为什么需要泛型？" class="headerlink" title="2# 为什么需要泛型？"></a>2# 为什么需要泛型？</h2><ul>
<li><strong>适用于多种数据类型执行相同的代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">	System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">add</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> &#123;</span><br><span class="line">	System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">	System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个 <code>add()</code> 方法；通过泛型，我们可以复用为一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="type">double</span> <span class="title function_">add</span> <span class="params">(T a, T b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a.doubleValue() + b.doubleValue()));</span><br><span class="line">    <span class="keyword">return</span> a.doubleValue() + b.doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）</strong></li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.add(<span class="number">123</span>); <span class="comment">// 添加的是 Integer</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) list.get(<span class="number">1</span>); <span class="comment">// 编译通过，但运行时抛出 CCE</span></span><br></pre></td></tr></table></figure>

<p><code>list</code> 中的元素都是 <code>Object</code> 类型（无法约束其中的类型），所以在取出集合元素时需要人为地强制类型转换到具体的目标类型，且很容易出现 <code>ClassCastException</code> 异常</p>
<p>引入泛型，它将提供类型的约束，提供编译前的检查：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">// list.add(123); // 编译错误，不允许添加非 String 类型</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> list.get(<span class="number">0</span>); <span class="comment">// 不需要强制类型转换</span></span><br></pre></td></tr></table></figure>



<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="1-Java-创建对象有哪些方式？"><a href="#1-Java-创建对象有哪些方式？" class="headerlink" title="1# Java 创建对象有哪些方式？"></a>1# Java 创建对象有哪些方式？</h2><ol>
<li><p><strong>使用 <code>new</code> 关键字</strong>：通过 <code>new</code> 关键字直接调用类的构造方法来创建对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过反射创建对象</strong>：通过 Java 的反射机制可以再运行时动态地创建对象。可以使用 <code>Class</code> 类的 <code>newInstance()</code> 或者 <code>Constructor</code> 类的 <code>newInstance()</code> 方法创建对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Class 类</span></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>).newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Construcotr 类</span></span><br><span class="line">Constructor&lt;MyClass&gt; constructor = MyClass.class.getConstructor();</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>clone()</code> 方法</strong>：如果类实现了 <code>Cloneable</code> 接口，可以使用 <code>clone()</code> 方法复制对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj2</span> <span class="operator">=</span> (MyClass) obj1.clone();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用反序列化</strong>：通过将对象序列化到文件流中，然后再进行反序列化来创建对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">	<span class="comment">// Class definition</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// Serialize object</span></span><br><span class="line">		<span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">		<span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> 					<span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.ser&quot;</span>))</span><br><span class="line">		out.writeObject(obj);</span><br><span class="line">		out.close();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// Deserialize object</span></span><br><span class="line">		<span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> 						<span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line">		<span class="type">MyClass</span> <span class="variable">newObj</span> <span class="operator">=</span> (MyClass) in.readObject();</span><br><span class="line">		in.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-new-出的对象什么时候回收？"><a href="#2-new-出的对象什么时候回收？" class="headerlink" title="2# new 出的对象什么时候回收？"></a>2# new 出的对象什么时候回收？</h2><p>通过关键字 <code>new</code> 创建的对象，由 Java 的**垃圾回收器（Garbage Collector）**负责回收。垃圾回收器的工作是在程序运行过程中自动进行的，它会周期性地检测不再被引用的对象，并将其回收释放内存</p>
<p>具体来说，Java 对象的回收时机是由垃圾回收器根据一些算法来决定的，主要有以下几种情况：</p>
<ol>
<li><strong>引用计数法</strong>：某个对象的引用计数为 0 时，表示该对象不再被引用，可以被回收</li>
<li><strong>可达性分析算法</strong>：从根对象（如方法区中的类静态属性、方法中的局部变量等）出发，通过对象之间的引用链进行遍历，如果存在一条引用链到达某个对象，则说明该对象是可达的，反之则不可达，不可达的对象将被回收</li>
<li><strong>终结器（Finalizer）</strong>：如果对象重写了 <code>finalize()</code> 方法，垃圾回收器会在回收该对象之前调用 <code>finalize()</code> 方法，对象可以在 <code>finalize()</code> 方法中进行一些清理操作。然而，终结器机制的使用不被推荐，因为它的执行时间是不确定的，可能会导致不可预测的性能问题</li>
</ol>
<h2 id="3-如何获取私有对象？"><a href="#3-如何获取私有对象？" class="headerlink" title="3# 如何获取私有对象？"></a>3# 如何获取私有对象？</h2><p>在 Java 中，私有对象通常指的是类中被声明为 <code>private</code>  的成员变量或方法。由于 <code>private</code> 访问修饰符的限制，这些成员只能在其所在的类内部被访问</p>
<p>不过，可以通过下面两种方式来间接获取私有对象</p>
<ol>
<li><p><strong>使用公共访问器方法（<code>getter</code> 方法）</strong>：如果类的设计者遵循良好的编程规范，通常会为私有成员变量提供公共的访问器方法（<code>getter</code> 方法），通过调用这些方法可以安全地获取私有对象</p>
</li>
<li><p><strong>反射机制</strong>：反射机制允许在运行时检查和修改类、方法、字段等信息，通过反射可以绕过 <code>private</code> 访问修饰符的限制来获取私有对象。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">privateField</span> <span class="operator">=</span> <span class="string">&quot;私有字段的值&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessExcept &#123;</span><br><span class="line">		<span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">		Class&lt;?&gt; clazz = obj.getClass(); <span class="comment">// 获取 Class 对象</span></span><br><span class="line">		<span class="type">Field</span> <span class="variable">privateField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;privateField&quot;</span>); <span class="comment">// 获取私有字段</span></span><br><span class="line">		privateField.setAccessible(<span class="literal">true</span>); <span class="comment">// 设置可访问性</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) privateField.get(obj); <span class="comment">// 获取私有字段的值</span></span><br><span class="line">		System.out.println(value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="1-什么是反射？"><a href="#1-什么是反射？" class="headerlink" title="1# 什么是反射？"></a>1# 什么是反射？</h2><p><strong>Java 反射机制</strong>是指在程序运行期间，能够动态地获取一个类的结构信息（如类名、属性、方法、构造函数等），并且可以在运行时操作这些信息，例如创建对象、访问属性、调用方法等。这使得 Java 拥有强大的动态性和灵活性，是实现诸如框架设计、依赖注入、动态代理等高级功能的重要基础</p>
<img src="https://cdn.xiaolincoding.com//picgo/1718957173277-863d2ec6-a754-423b-9066-9f28610d1a31.png" alt="反射机制" style="zoom: 67%;" />

<p><strong>反射具有以下特性</strong>：</p>
<ol>
<li><strong>运行时类信息访问</strong>：反射允许程序在运行时获取一个类的完整结构信息，包括类名、字段、方法、构造器等，即使在编译时并不知道具体的类</li>
<li><strong>动态创建对象</strong>：通过反射，可以在运行时动态地创建对象实例。即便类名是在运行时才确定，也可以使用 <code>Class.newInstance()</code> 或 <code>Constructor.newInstance()</code> 方法完成对象的创建</li>
<li><strong>动态方法调用</strong>：反射支持在运行时调用对象的方法，包括私有方法。这通常通过 <code>Method.invoke()</code> 实现，允许传入对象实例和参数，从而执行对应的方法</li>
<li><strong>字段访问与修改</strong>：反射还可以访问和修改对象的字段值，包括私有字段。可以使用 <code>Field.set()</code> 方法设置字段的值，必要时可通过 <code>setAccessible(true)</code> 打破访问限制</li>
</ol>
<h2 id="2-反射在你平时写代码或者框架中的应用场景有哪些？"><a href="#2-反射在你平时写代码或者框架中的应用场景有哪些？" class="headerlink" title="2# 反射在你平时写代码或者框架中的应用场景有哪些？"></a>2# 反射在你平时写代码或者框架中的应用场景有哪些？</h2><p><strong>一、加载数据库驱动</strong>：在使用 JDBC 连接数据库时，常常需要根据实际使用的数据库类型（如 MySQL、Oracle）动态加载对应的驱动类。此时可以使用 <code>Class.forName()</code> 方法通过反射机制加载指定的驱动类，而无需在代码中硬编码具体的驱动实现，从而提升系统的灵活性和可配置性。例如：</p>
  <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;db.properties&quot;</span>));</span><br><span class="line"><span class="type">String</span> <span class="variable">driverClass</span> <span class="operator">=</span> props.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">Class.forName(driverClass); <span class="comment">// 反射方式动态加载驱动</span></span><br></pre></td></tr></table></figure>

<p><strong>二、配置文件加载</strong>：在 Spring 框架中，IoC（控制反转）容器能够根据配置文件（如 XML 或 properties）动态加载和管理 Bean。你只需在配置文件中声明需要的类及其属性，Spring 就会自动通过反射机制实例化相应的对象并注入依赖，极大地提高了程序的可扩展性与解耦性</p>
<p>  下面以简单示例说明 Spring 通过配置文件和反射加载 Bean 的过程：</p>
<ul>
<li>将所有 XML 或 properties 配置文件加载到内存中</li>
<li>通过 Java 代码解析配置文件，提取类的全限定名（即类的完整包名路径）及其属性等配置信息</li>
<li>利用反射机制，根据提取的类名动态获取对应的 <code>Class</code> 实例，并创建对象或调用方法</li>
</ul>
<p>  配置文件（如 <code>config.properties</code>）</p>
  <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">className</span>=<span class="string">com.example.reflectdemo.TestInvoke</span></span><br><span class="line"><span class="attr">methodName</span>=<span class="string">printlnState</span></span><br></pre></td></tr></table></figure>

<p>  实体类（<code>TestInvoke.java</code>）</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInvoke</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printlnState</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;I am fine&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  配置读取工具方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getName</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\config.properties&quot;</span>);</span><br><span class="line">    properties.load(in);</span><br><span class="line">    in.close();</span><br><span class="line">    <span class="keyword">return</span> properties.getProperty(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  主方法：使用反射加载类并调用方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1. 通过配置文件读取类名和方法名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> getName(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> getName(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 加载类</span></span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取并访问方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(methodName);</span><br><span class="line">    method.setAccessible(<span class="literal">true</span>); <span class="comment">// 允许访问私有方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 实例化对象并调用方法</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">    method.invoke(instance); <span class="comment">// 输出：I am fine</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="1-能讲一讲注解的原理吗？"><a href="#1-能讲一讲注解的原理吗？" class="headerlink" title="1# 能讲一讲注解的原理吗？"></a>1# 能讲一讲注解的原理吗？</h2><p>在 Java 中，注解（Annotation）本质上是继承了 <code>java.lang.annotation.Annotation</code> 接口的特殊接口。每个注解类型在编译后都会生成一个 <code>.class</code> 文件，JVM 会根据字节码中的信息，在运行时动态创建该注解的<strong>代理对象</strong></p>
<p>当我们通过反射调用 <code>clazz.getAnnotation(MyAnnotation.class)</code> 获取注解时，返回的并不是一个普通对象，而是一个由 JVM 动态生成的代理实例。该代理实现了注解接口，并会将方法调用转发给 <code>AnnotationInvocationHandler</code> 的 <code>invoke()</code> 方法</p>
<p>在 <code>AnnotationInvocationHandler</code> 中维护了一个 <code>memberValues</code> 的 <code>Map</code>，它存储了注解的属性名与属性值。这个 Map 的内容来源于 <code>.class</code> 文件中的常量池，类加载时被 JVM 解析并缓存</p>
<p><strong>总结整个流程</strong>：</p>
<ol>
<li>注解被编写并编译后，相关信息存入 <code>.class</code> 文件的字节码结构中；</li>
<li>如果注解的保留策略为 <code>RUNTIME</code>，JVM 在加载类时会解析注解信息；</li>
<li>调用反射 API 获取注解对象时，JVM 返回的是一个动态代理实例；</li>
<li>调用注解方法（如 <code>value()</code>）时，方法会被代理对象拦截；</li>
<li>代理将调用转发至 <code>AnnotationInvocationHandler</code>，从 <code>memberValues</code> 中取出实际值并返回。</li>
</ol>
<h2 id="2-对注解解析的底层实现了解吗？"><a href="#2-对注解解析的底层实现了解吗？" class="headerlink" title="2# 对注解解析的底层实现了解吗？"></a>2# 对注解解析的底层实现了解吗？</h2><p>注解本质上是一个接口，继承自 <code>java.lang.annotation.Annotation</code>。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后，注解类型会被转换成一个普通接口的形式，并保留相关元数据到 <code>.class</code> 文件中</p>
<p>Java 中通过 <code>@Retention</code> 注解指定注解的保留策略，常见的三种为：</p>
<ul>
<li><code>SOURCE</code>：仅保留在源码中，编译后丢弃</li>
<li><code>CLASS</code>：编译时保留在 <code>.class</code> 文件中，运行时不可访问</li>
<li><code>RUNTIME</code>：编译后保留，并可通过反射访问（<strong>实际参与运行时行为</strong>）</li>
</ul>
<p>只有 <code>RUNTIME</code> 注解会被 JVM 加载并参与反射处理，JVM 会将注解元数据存储在 <code>.class</code> 文件的**属性表（Attribute Table）**中，包括：</p>
<ul>
<li><strong><code>RuntimeVisibleAnnotations</code></strong>：存储运行时可见的注解信息</li>
<li><strong><code>RuntimeInvisibleAnnotations</code></strong>：存储运行时不可见的注解信息</li>
<li><strong><code>RuntimeVisibleParameterAnnotations</code></strong>：存储方法参数上的注解信息</li>
</ul>
<p>通过反射 API 可以获取类、方法、字段等元素上的注解。反射的核心类 <code>AnnotatedElement</code>（如 <code>Class</code>、<code>Method</code>、<code>Field</code> 都实现了它）提供了访问注解的接口，如：</p>
<ul>
<li><strong><code>getAnnotation(Class&lt;T&gt; annotationClass)</code></strong>：获取指定类型的注解</li>
<li><strong><code>getAnnotations()</code></strong>：获取所有注解</li>
<li><strong><code>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</code></strong>：判断是否包含指定注解</li>
</ul>
<p>这些方法最终调用的是 JVM 的 native 方法，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">native</span> Annotation[] getDeclaredAnnotations0(<span class="type">boolean</span> publicOnly);</span><br></pre></td></tr></table></figure>

<p>这些 native 方法在类加载时解析 <code>.class</code> 文件中保存的注解字节码信息，并生成<strong>动态代理对象</strong>，用于运行时访问</p>
<p>因此，注解解析的底层实现主要依赖于 Java 的反射机制和字节码文件的存储。通过 <code>@Retention</code> 元注解可以控制注解的保留策略，当使用 <code>RetentionPolicy.RUNTIME</code> 时，可以在运行时通过反射 API 来解析注解信息。在 JVM 层面，会从字节码文件中读取注解信息，并创建注解的代理对象来获取注解的属性值</p>
<h2 id="3-注解的适用范围（Target）是什么？"><a href="#3-注解的适用范围（Target）是什么？" class="headerlink" title="3# 注解的适用范围（Target）是什么？"></a>3# 注解的适用范围（Target）是什么？</h2><p>Java 中注解的“适用范围”由 <code>@Target</code> 元注解指定，用于定义注解可以作用于哪些程序元素。常见的范围包括：</p>
<ul>
<li><code>ElementType.TYPE</code>：类、接口（包括注解类型）或枚举</li>
<li><code>ElementType.METHOD</code>：方法</li>
<li><code>ElementType.FIELD</code>：字段（包括枚举常量）</li>
<li><code>ElementType.CONSTRUCTOR</code>：构造方法</li>
<li><code>ElementType.PARAMETER</code>：参数</li>
<li><code>ElementType.LOCAL_VARIABLE</code>：局部变量</li>
<li><code>ElementType.ANNOTATION_TYPE</code>：注解类型本身</li>
<li><code>ElementType.PACKAGE</code>：包</li>
<li><code>ElementType.TYPE_USE</code>：任何使用类型的地方（如泛型、强转、注解类型参数等）</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个注解就只能用于类或方法</p>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="1-介绍一下-Java-的异常"><a href="#1-介绍一下-Java-的异常" class="headerlink" title="1# 介绍一下 Java 的异常"></a>1# 介绍一下 Java 的异常</h2><img src="https://cdn.xiaolincoding.com//picgo/1720683900898-1d0ce69d-4b5d-41a6-a5df-022e42f8f4c5.webp" alt="Java 异常类层次结构图" style="zoom:50%;" />

<p>Java 的异常体系是围绕 <code>Throwable</code> 类及其子类构建的。<code>Throwable</code> 有两个直接子类：<code>Error</code> 和 <code>Exception</code>，它们代表了两类不同性质的问题：</p>
<ol>
<li><p><strong>Error（错误）</strong>：表示 JVM 运行时出现的严重错误，通常是系统级的问题，程序无法控制和恢复。常见的错误包括 <code>OutOfMemoryError</code>、<code>StackOverflowError</code> 等，这类错误 <strong>不建议</strong> 程序捕获或处理，因为处理后也难以恢复</p>
</li>
<li><p><strong>Exception（异常）</strong>：表示程序本身可以<strong>感知并处理</strong>的问题，又细分为：</p>
<ul>
<li><p><strong>受检查异常</strong>：编译器会强制检查，必须显式处理（try-catch）或声明抛出（throws）。例如 <code>IOException</code>、<code>SQLException</code>、<code>ClassNotFoundException</code> 等，这些异常多与外部资源或环境因素有关（如文件、数据库、网络），处理它们可以提升程序的健壮性</p>
</li>
<li><p><strong>非受检查异常</strong>：<code>RuntimeException</code> 及其子类，编译器<strong>不会强制检查</strong>，通常由程序逻辑错误引起。例如 <code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code>、<code>ArithmeticException</code> 等。虽然不是强制处理，但良好的程序设计应尽量避免这类异常</p>
</li>
</ul>
</li>
</ol>
<h2 id="2-Java-的异常处理方式有哪些？"><a href="#2-Java-的异常处理方式有哪些？" class="headerlink" title="2# Java 的异常处理方式有哪些？"></a>2# Java 的异常处理方式有哪些？</h2><p>Java 提供了一套完整的异常处理机制，用于捕获和处理运行时可能出现的异常，以增强程序的健壮性和可维护性。主要包括以下几种方式：</p>
<p><strong>一、<code>try-catch-finally</code> 语句块</strong>：用于捕获并处理代码执行过程中可能抛出的异常</p>
<ul>
<li><code>try</code> 块包含可能抛出异常的代码</li>
<li><code>catch</code> 块用于捕获并处理特定类型的异常</li>
<li><code>finally</code> 块（可选）用于释放资源或执行善后操作，无论是否发生异常都会执行，常用于资源释放（如关闭文件流、数据库连接等）</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType1 e1) &#123;</span><br><span class="line">    <span class="comment">// 处理异常类型1</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType2 e2) &#123;</span><br><span class="line">    <span class="comment">// 处理异常类型2</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论是否发生异常，都会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二、<code>throw</code> 语句</strong>：用于<strong>手动抛出</strong>一个异常实例，抛出的对象必须是 <code>Throwable</code> 类型或其子类，通常用于业务逻辑判断，如参数校验失败时主动抛出异常</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>三、<code>throws</code> 关键字</strong>：用于在<strong>方法签名</strong>中声明该方法可能抛出的异常类型，通知调用者需要处理这些异常，如果是受检异常，必须显式处理或继续声明抛出</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 可能抛出 IOException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-抛出异常为什么不用-throws？"><a href="#3-抛出异常为什么不用-throws？" class="headerlink" title="3# 抛出异常为什么不用 throws？"></a>3# 抛出异常为什么不用 throws？</h2><p>在 Java 中，如果异常属于<strong>非受检异常</strong>，或者在方法内部已经<strong>被捕获并处理</strong>，那么就不需要在方法签名中使用 <code>throws</code> 关键字</p>
<ol>
<li><strong>非受检异常</strong>：非检查异常是指继承自 <code>RuntimeException</code> 或 <code>Error</code> 的异常类型。编译器<strong>不会强制要求</strong>开发者显式地处理这些异常，也不要求在方法签名中声明它们。包括 <code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code>、<code>IllegalArgumentException</code>、<code>ArithmeticException</code> 等，由于这类异常往往是由程序逻辑错误引起的，Java 更倾向于通过代码修复，而不是强制捕获或声明</li>
<li><strong>异常已被捕获并处理</strong>：如果在方法内部使用了 <code>try-catch</code> 块对异常进行了处理，那么该异常就<strong>不会继续向外抛出</strong>，因此也不需要在方法签名中使用 <code>throws</code></li>
</ol>
<h2 id="4-try-catch-中的语句运行情况"><a href="#4-try-catch-中的语句运行情况" class="headerlink" title="4# try-catch 中的语句运行情况"></a>4# try-catch 中的语句运行情况</h2><p>在 Java 中，<code>try</code> 块中的代码会按顺序执行：</p>
<ul>
<li>如果 <code>try</code> 块中<strong>未发生异常</strong>，则跳过所有 <code>catch</code> 块，<strong>直接执行 <code>finally</code>（如果有）</strong>，然后继续执行后续代码</li>
<li>如果 <code>try</code> 块中<strong>发生了异常</strong>，Java 会依次检查每个 <code>catch</code> 块，看是否有匹配的异常类型：<ul>
<li>如果匹配成功，对应的 <code>catch</code> 块会执行，然后进入 <code>finally</code>（如果有）</li>
<li>如果没有匹配的 <code>catch</code>，异常将<strong>向上抛出</strong>，由调用者处理，<code>finally</code> 块仍会执行</li>
</ul>
</li>
<li><strong><code>finally</code> 块始终会执行</strong>，无论是否发生异常，除非 JVM 退出或程序崩溃</li>
</ul>
<h2 id="5-try-return-“a”-finally-return-“b”-返回什么？"><a href="#5-try-return-“a”-finally-return-“b”-返回什么？" class="headerlink" title="5# try { return “a” } finally { return “b” } 返回什么？"></a>5# try { return “a” } finally { return “b” } 返回什么？</h2><p>该语句的返回值是 <code>&quot;b&quot;</code></p>
<p>在 Java 中，如果 <code>try</code> 和 <code>finally</code> 中都包含 <code>return</code> 语句，<strong><code>finally</code> 中的 <code>return</code> 会覆盖 <code>try</code> 中的返回值</strong>。即使 <code>try</code> 中已经准备好返回 <code>&quot;a&quot;</code>，在执行 <code>finally</code> 时仍会被 <code>&quot;b&quot;</code> 替代</p>
<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><h2 id="1-与-equals-有什么区别？"><a href="#1-与-equals-有什么区别？" class="headerlink" title="1# &#x3D;&#x3D; 与 equals() 有什么区别？"></a>1# &#x3D;&#x3D; 与 equals() 有什么区别？</h2><p>在 Java 中，<code>==</code> 和 <code>equals()</code> 都可用于比较两个对象，但它们的行为有本质上的不同：</p>
<ul>
<li><p><strong><code>==</code></strong>：比较的是引用是否相等</p>
<ul>
<li><p><code>==</code> 判断两个对象<strong>是否指向同一块内存地址</strong>，即它们是否是<strong>同一个对象的引用</strong></p>
</li>
<li><p>对于基本数据类型，<code>==</code> 比较的是<strong>数值本身是否相等</strong></p>
</li>
<li><p>对于引用类型（如字符串、对象等），<code>==</code> 比较的是两个引用是否指向<strong>同一对象</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(a == b); <span class="comment">// false：不同对象，地址不同</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>equals()</code></strong>：比较的是内容是否相等</p>
<ul>
<li><p><code>equals()</code> 是 <code>Object</code> 类中的方法，默认行为与 <code>==</code> 相同，即<strong>比较引用地址</strong></p>
</li>
<li><p>但很多类（如 <code>String</code>、<code>Integer</code>、<code>List</code> 等）都<strong>重写了 <code>equals()</code> 方法</strong>，改为比较对象的<strong>内容</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(a.equals(b)); <span class="comment">// true：内容相同</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>需要注意</strong>：字符串是 Java 中的特殊对象，字面量字符串会被放入<strong>字符串常量池</strong>，如果你写 <code>String s1 = &quot;abc&quot;; String s2 = &quot;abc&quot;;</code>，则 <code>s1 == s2</code> 会返回 <code>true</code>，因为它们引用的是常量池中的同一个对象</p>
<h2 id="2-hashCode-和-equals-方法有什么关系？"><a href="#2-hashCode-和-equals-方法有什么关系？" class="headerlink" title="2# hashCode() 和 equals() 方法有什么关系？"></a>2# hashCode() 和 equals() 方法有什么关系？</h2><p>在 Java 中，对于重写 <code>equals()</code> 方法的类，通常也需要重写 <code>hashCode()</code> 方法，并且需要遵循以下规定：</p>
<ul>
<li><strong>一致性</strong>：如果两个对象使用 <code>equals()</code> 方法比较结果为 <code>true</code>，那么它们的 <code>hashCode()</code> 的值必须相同。也就是说，如果 <code>obj1.equals(obj2)</code> 返回 <code>true</code>，那么 <code>obj1.hashCode()</code> 必须等于 <code>obj2.hashCode()</code></li>
<li><strong>非一致性</strong>：如果两个对象的 <code>hashCode()</code> 的值相同，它们使用 <code>equals()</code> 方法比较的结果不一定为 <code>true</code>。即 <code>obj1.hashCode() == obj2.hashCode()</code> 时，<code>obj1.equals(obj2)</code> 可能为 <code>false</code>，这种情况称为哈希冲突</li>
</ul>
<p><code>hashCode()</code> 和 <code>equals()</code> 方法是紧密相关的，重写 <code>equals()</code> 方法时必须重写 <code>hashCode()</code> 方法，以保证在使用哈希表等数据结构时，对象的相等性判断和存储查找操作能够正常工作。而重写 <code>hashCode()</code> 方法时，需要确保相等的对象具有相同的哈希码，但相同哈希码的对象不一定相等</p>
<h2 id="3-String、StringBuilder、StringBuffer-的区别和联系"><a href="#3-String、StringBuilder、StringBuffer-的区别和联系" class="headerlink" title="3# String、StringBuilder、StringBuffer 的区别和联系"></a>3# String、StringBuilder、StringBuffer 的区别和联系</h2><ol>
<li><p><strong>可变性</strong>： <code>String</code> 是不可变的（Immutable），一旦创建，内容无法修改，每次修改都会生成一个新的对象。<code>StringBuilder</code> 和 <code>StringBuffer</code> 是可变的（Mutable），可以直接对字符串内容进行修改而不会创建新对象</p>
</li>
<li><p>**线程安全性 **：<code>String</code> 因为不可变，天然线程安全。<code>StringBuilder</code> 不是线程安全的，适用于单线程环境。<code>StringBuffer</code> 是线程安全的，其方法通过 <code>synchronized</code> 关键字实现同步，适用于多线程环境</p>
</li>
<li><p>**性能 **：<code>String</code> 性能最低，尤其是在频繁修改字符串时会生成大量临时对象，增加内存开销和垃圾回收压力。<code>StringBuilder</code> 性能最高，因为它没有线程安全的开销，适合单线程下的字符串操作。<code>StringBuffer</code> 性能略低于 <code>StringBuilder</code>，因为它的线程安全机制引入了同步开销</p>
</li>
<li><p>**使用场景 **：如果字符串内容固定或不常变化，优先使用 <code>String</code>。如果需要频繁修改字符串且在单线程环境下，使用 <code>StringBuilder</code>。如果需要频繁修改字符串且在多线程环境下，使用 <code>StringBuffer</code></p>
</li>
</ol>
<p>对比总结如下：</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>String</strong></th>
<th><strong>StringBuilder</strong></th>
<th><strong>StringBuffer</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>不可变性</strong></td>
<td>不可变</td>
<td>可变</td>
<td>可变</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>是（因不可变）</td>
<td>否</td>
<td>是（同步方法）</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>低（频繁修改时）</td>
<td>高（单线程）</td>
<td>中（多线程安全）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>静态字符串</td>
<td>单线程动态字符串</td>
<td>多线程动态字符串</td>
</tr>
</tbody></table>
<h1 id="Java-新特性"><a href="#Java-新特性" class="headerlink" title="Java 新特性"></a>Java 新特性</h1><h2 id="1-Java-8-有什么新特性？"><a href="#1-Java-8-有什么新特性？" class="headerlink" title="1# Java 8 有什么新特性？"></a>1# Java 8 有什么新特性？</h2><p>下面是 Java 8 主要新特性的整理表格，包含关键改进和示例说明：</p>
<table>
<thead>
<tr>
<th><strong>特性名称</strong></th>
<th><strong>描述</strong></th>
<th><strong>示例或说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Lambda 表达式</strong></td>
<td>简化匿名内部类，支持函数式编程</td>
<td><code>(a, b) -&gt; a + b</code> 代替匿名类实现接口</td>
</tr>
<tr>
<td><strong>函数式接口</strong></td>
<td>仅含一个抽象方法的接口，可用 <code>@FunctionalInterface</code> 注解标记</td>
<td><code>Runnable</code>, <code>Comparator</code> 或自定义接口 <code>@FunctionalInterface interface MyFunc &#123; void run(); &#125;</code></td>
</tr>
<tr>
<td><strong>Stream API</strong></td>
<td>提供链式操作处理集合数据，支持并行处理</td>
<td><code>list.stream().filter(x -&gt; x &gt; 0).collect(Collectors.toList())</code></td>
</tr>
<tr>
<td><strong>Optional 类</strong></td>
<td>封装可能为 <code>null</code> 的对象，减少空指针异常</td>
<td><code>Optional.ofNullable(value).orElse(&quot;default&quot;)</code></td>
</tr>
<tr>
<td><strong>方法引用</strong></td>
<td>简化 Lambda 表达式，直接引用现有方法</td>
<td><code>System.out::println</code> 等价于 <code>x -&gt; System.out.println(x)</code></td>
</tr>
<tr>
<td><strong>接口的默认方法与静态方法</strong></td>
<td>接口可定义默认实现和静态方法，增强扩展性</td>
<td><code>interface A &#123; default void print() &#123; System.out.println(&quot;默认方法&quot;); &#125; &#125;</code></td>
</tr>
<tr>
<td><strong>并行数组排序</strong></td>
<td>使用多线程加速数组排序</td>
<td><code>Arrays.parallelSort(array)</code></td>
</tr>
<tr>
<td><strong>重复注解</strong></td>
<td>允许同一位置多次使用相同注解</td>
<td><code>@Repeatable</code> 注解配合容器注解使用</td>
</tr>
<tr>
<td><strong>类型注解</strong></td>
<td>注解可应用于更多位置（如泛型、异常等）</td>
<td><code>List&lt;@NonNull String&gt; list</code></td>
</tr>
<tr>
<td><strong>CompletableFuture</strong></td>
<td>增强异步编程能力，支持链式调用和组合操作</td>
<td><code>CompletableFuture.supplyAsync(() -&gt; &quot;result&quot;).thenAccept(System.out::println)</code></td>
</tr>
</tbody></table>
<h2 id="2-Lambda-表达式了解吗？"><a href="#2-Lambda-表达式了解吗？" class="headerlink" title="2# Lambda 表达式了解吗？"></a>2# Lambda 表达式了解吗？</h2><p>Lambda 表达式是一种简洁的语法，用于创建匿名函数，主要用于简化函数式接口（只有一个抽象方法的接口）的使用。其基本语法有以下两种形式：</p>
<ul>
<li><strong><code>(parameters) -&gt; expression</code></strong>：当 Lambda 体只有一个表达式时使用，表达式的结果会作为返回值</li>
<li><strong><code>(parameters) -&gt; &#123; statements; &#125;</code></strong>：当 Lambda 体包含多条语句时，需要使用大括号将语句括起来，若有返回值则需要使用 <code>return</code> 语句</li>
</ul>
<p>传统的匿名内部类实现方式代码较为冗长，<strong>而 Lambda 表达式可以用更简洁的语法实现相同的功能</strong>。例如，使用匿名内部类实现 <code>Runnable</code> 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousClassExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Running using anonymous class&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Lambda 表达式实现相同功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;Running using lambda expression&quot;</span>));</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Lambda 表达式能够更清晰地表达代码的意图</strong>，尤其是在处理集合操作时，如过滤、映射等。例如，过滤出列表中所有偶数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadabilityExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式结合 Stream API 过滤偶数</span></span><br><span class="line">        List&lt;Integer&gt; evenNumbers = numbers.stream()</span><br><span class="line">                                           .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                                           .collect(Collectors.toList());</span><br><span class="line">        System.out.println(evenNumbers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Lambda 表达式使得 Java 支持函数式编程范式</strong>，允许将函数作为参数传递，从而可以编写更灵活、可复用的代码。例如，定义一个通用的计算函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionalProgrammingExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">operate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, Calculator calculator)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> calculator.calculate(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式传递加法函数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> operate(<span class="number">3</span>, <span class="number">5</span>, (x, y) -&gt; x + y);</span><br><span class="line">        System.out.println(<span class="string">&quot;Sum: &quot;</span> + sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式传递乘法函数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> operate(<span class="number">3</span>, <span class="number">5</span>, (x, y) -&gt; x * y);</span><br><span class="line">        System.out.println(<span class="string">&quot;Product: &quot;</span> + product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然 Lambda 表达式优点蛮多的，不过也有一些缺点，比如会增加调试困难，因为 Lambda 表达式是匿名的，在调试时很难定位具体是哪个 Lambda 表达式出现了问题。尤其是当 Lambda 表达式嵌套使用或者比较复杂时，调试难度会进一步增加</p>
<h2 id="3-介绍一下-Stream-API"><a href="#3-介绍一下-Stream-API" class="headerlink" title="3# 介绍一下 Stream API"></a>3# 介绍一下 Stream API</h2><p>Java 8 引入了 Stream API，它提供了一种高效且易于使用的数据处理方式，特别适合集合对象的操作，如过滤、映射、排序等。Stream API 不仅可以提高代码的可读性和简洁性，还能利用多核处理器的优势进行并行处理</p>
<p><strong>案例1：过滤并收集满足条件的元素</strong></p>
<p><strong>问题场景</strong>：从一个列表中筛选出所有长度大于 3 的字符串，并收集到一个新的列表中</p>
<p><strong>没有 Stream API 的做法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; originalList = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;fig&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;kiwi&quot;</span>);</span><br><span class="line">List&lt;String&gt; filteredList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String item : originalList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.length() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        filteredList.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码需要显式地创建一个新的 <code>ArrayList</code>，并通过循环遍历原列表，手动检查每个元素是否满足条件，然后添加到新列表中</p>
<p><strong>使用 Stream API 的做法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; originalList = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;fig&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;kiwi&quot;</span>);</span><br><span class="line">List&lt;String&gt; filteredList = originalList.stream()</span><br><span class="line">                                        .filter(s -&gt; s.length() &gt; <span class="number">3</span>)</span><br><span class="line">                                        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>这里，我们直接在原始列表上调用 <code>stream()</code> 方法创建了一个流，使用 <code>filter()</code> 中间操作筛选出长度大于 3 的字符串，最后使用 <code>collect(Collectors.toList())</code> 终端操作将结果收集到一个新的列表中。代码更加简洁明了，逻辑一目了然</p>
<p><strong>案例2：计算列表中所有数字的总和</strong></p>
<p><strong>问题场景</strong>：计算一个数字列表中所有元素的总和</p>
<p><strong>没有 Stream API 的做法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Integer number : numbers) &#123;</span><br><span class="line">    sum += number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个传统的 for-each 循环遍历列表中的每一个元素，累加它们的值来计算总和</p>
<p><strong>使用 Stream API 的做法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers.stream()</span><br><span class="line">                 .mapToInt(Integer::intValue)</span><br><span class="line">                 .sum();</span><br></pre></td></tr></table></figure>

<p>通过 Stream API，我们可以先使用 <code>mapToInt()</code> 将 Integer 流转换为 IntStream（这是为了高效处理基本类型），然后直接调用 <code>sum()</code> 方法来计算总和，极大地简化了代码</p>
<h2 id="4-Stream-流的并行-API-是什么？"><a href="#4-Stream-流的并行-API-是什么？" class="headerlink" title="4# Stream 流的并行 API 是什么？"></a>4# Stream 流的并行 API 是什么？</h2><p><strong>是 ParallelStream</strong></p>
<p>并行流（ParallelStream）就是将源数据分为多个子流对象进行多线程操作，然后将处理的结果再汇总为一个流对象，底层是使用通用的 fork&#x2F;join 池来实现，即将一个任务拆分成多个 “小任务” 并行计算，再把多个 “小任务” 的结果合并成总的计算结果</p>
<p>Stream 串行流与并行流的主要区别：</p>
<p> <img src="https://cdn.xiaolincoding.com//picgo/1716365522454-4b56a07e-9b54-4cbb-9832-26b099fc35cd.png" alt="Stream 串行流与并行流的主要区别"></p>
<p>对 CPU 密集型的任务来说，并行流使用 ForkJoinPool 线程池，为每个 CPU 分配一个任务，这是非常有效率的，但是如果任务不是 CPU 密集的，而是 IO 密集的，并且任务数相对线程数比较大，那么直接用 ParallelStream 并不是很好的选择</p>
<h2 id="5-CompletableFuture-怎么用的？"><a href="#5-CompletableFuture-怎么用的？" class="headerlink" title="5# CompletableFuture 怎么用的？"></a>5# CompletableFuture 怎么用的？</h2><p><code>CompletableFuture</code> 是由 Java 8 引入的，在 Java 8 之前我们一般通过 Future 实现异步</p>
<ul>
<li><code>Future</code> 用于表示异步计算的结果，只能通过阻塞或者轮询的方式获取结果，而且不支持设置回调方法，Java 8 之前若要设置回调一般会使用 guava 的 <code>ListenableFuture</code> ，回调的引入又会导致臭名昭著的回调地狱</li>
<li><code>CompletableFuture</code> 对 <code>Future</code> 进行了扩展，可以通过设置回调的方式处理计算结果，同时也支持组合操作，支持进一步的编排，同时一定程度解决了回调地狱的问题</li>
</ul>
<p><code>Future</code>（<code>ListenableFuture</code>）的实现（回调地狱）如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="type">ListeningExecutorService</span> <span class="variable">guavaExecutor</span> <span class="operator">=</span> MoreExecutors.listeningDecorator(executor);</span><br><span class="line">ListenableFuture&lt;String&gt; future1 = guavaExecutor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//step 1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step1 result&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">ListenableFuture&lt;String&gt; future2 = guavaExecutor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//step 2</span></span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step2 result&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">ListenableFuture&lt;List&lt;String&gt;&gt; future1And2 = Futures.allAsList(future1, future2);</span><br><span class="line">Futures.addCallback(future1And2, <span class="keyword">new</span> <span class="title class_">FutureCallback</span>&lt;List&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(List&lt;String&gt; result)</span> &#123;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        ListenableFuture&lt;String&gt; future3 = guavaExecutor.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行step 3&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;step3 result&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        Futures.addCallback(future3, <span class="keyword">new</span> <span class="title class_">FutureCallback</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String result)</span> &#123;</span><br><span class="line">                System.out.println(result);</span><br><span class="line">            &#125;        </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, guavaExecutor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">    &#125;&#125;, guavaExecutor);</span><br></pre></td></tr></table></figure>

<p><code>CompletableFuture</code> 的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step1 result&quot;</span>;</span><br><span class="line">&#125;, executor);</span><br><span class="line">CompletableFuture&lt;String&gt; cf2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step2 result&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">cf1.thenCombine(cf2, (result1, result2) -&gt; &#123;</span><br><span class="line">    System.out.println(result1 + <span class="string">&quot; , &quot;</span> + result2);</span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 3&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step3 result&quot;</span>;</span><br><span class="line">&#125;).thenAccept(result3 -&gt; System.out.println(result3));</span><br></pre></td></tr></table></figure>

<p>显然，<code>CompletableFuture</code> 的实现更为简洁，可读性更好</p>
<img src="https://cdn.xiaolincoding.com//picgo/1713777049912-2268a5fc-c7f1-477d-8c9c-310aae18f51a.png" alt="CompletableFuture" style="zoom:50%;" />

<p><code>CompletableFuture</code> 实现了两个接口：<code>Future</code>、<code>CompletionStage</code></p>
<ul>
<li><code>Future</code> 表示异步计算的结果，<code>CompletionStage</code> 用于表示异步执行过程中的一个步骤（Stage），这个步骤可能是由另外一个 <code>CompletionStage</code> 触发的，随着当前步骤的完成，也可能会触发其他一系列 <code>CompletionStage</code> 的执行</li>
<li>从而我们可以根据实际业务对这些步骤进行多样化的编排组合，<code>CompletionStage</code> 接口正是定义了这样的能力，我们可以通过其提供的 <code>thenAppy</code>、<code>thenCompose</code> 等函数式编程方法来组合编排这些步骤</li>
</ul>
<h2 id="6-Java-21-新特性知道哪些？"><a href="#6-Java-21-新特性知道哪些？" class="headerlink" title="6# Java 21 新特性知道哪些？"></a>6# Java 21 新特性知道哪些？</h2><p><strong>新语言特性</strong>：</p>
<ol>
<li><strong>Switch 语句的模式匹配</strong>：该功能在 Java 21 中也得到了增强。它允许在 <code>switch</code> 的 <code>case</code> 标签中使用模式匹配，使操作更加灵活和类型安全，减少了样板代码和潜在错误。例如：对于不同类型的账户类，可以在 <code>switch</code> 语句中直接根据账户类型的模式来获取相应的余额，如 <code>case savingsAccount sa -&gt; result = sa.getSavings();</code></li>
<li><strong>数组模式</strong>：将模式匹配扩展到数组中，使开发者能够在条件语句中更高效地解构和检查数组内容。例如：<code>if (arr instanceof int[] &#123;1, 2, 3&#125;)</code>，可以直接判断数组 <code>arr</code> 是否匹配指定的模式</li>
<li><strong>字符串模板（预览版）</strong>：提供了一种更可读、更易维护的方式来构建复杂字符串，支持在字符串字面量中直接嵌入表达式。例如，以前可能需要使用 <code>&quot;hello &quot; + name + &quot;, welcome to the geeksforgeeks!&quot;</code> 这样的方式来拼接字符串，在 Java 21 中可以使用  <code>hello &#123;name&#125;, welcome to the geeksforgeeks!</code> 这种更简洁的写法</li>
</ol>
<p><strong>新并发特性方面</strong>：</p>
<ol>
<li><strong>虚拟线程</strong>：这是 Java 21 引入的一种轻量级并发的新选择。它通过共享堆栈的方式，大大降低了内存消耗，同时提高了应用程序的吞吐量和响应速度。可以使用静态构建方法、构建器或 <code>ExecutorService</code> 来创建和使用虚拟线程</li>
<li><strong>Scoped Values（范围值）</strong>：提供了一种在线程间共享不可变数据的新方式，避免使用传统的线程局部存储，促进了更好的封装性和线程安全，可用于在不通过方法参数传递的情况下，传递上下文信息，如用户会话或配置设置</li>
</ol>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><h2 id="1-怎么把一个对象从一个-JVM-转移到另一个-JVM"><a href="#1-怎么把一个对象从一个-JVM-转移到另一个-JVM" class="headerlink" title="1# 怎么把一个对象从一个 JVM 转移到另一个 JVM"></a>1# 怎么把一个对象从一个 JVM 转移到另一个 JVM</h2><ol>
<li><strong>使用序列化和反序列化</strong>：将对象序列化为字节流，并将其发送到另一个 JVM，然后在另一个 JVM 中反序列化字节流恢复对象。这可以通过 Java 的 <code>ObjectOutputStream</code> 和 <code>ObjectInputStream</code> 来实现。</li>
<li><strong>使用消息传递机制</strong>：利用消息传递机制，比如使用消息队列（如 RabbitMQ、Kafka）或者通过网络套接字进行通信，将对象从一个 JVM 发送到另一个。这需要自定义协议来序列化对象并在另一个 JVM 中反序列化</li>
<li><strong>使用远程方法调用（RPC）</strong>：可以使用远程方法调用框架，如 gRPC，来实现对象在不同 JVM 之间的传输。远程方法调用可以让你在分布式系统中调用远程 JVM 上的对象的方法</li>
<li><strong>使用共享数据库或缓存</strong>：将对象存储在共享数据库（如 MySQL、PostgreSQL）或共享缓存（如 Redis）中，让不同的 JVM 可以访问这些共享数据。这种方法适用于需要共享数据但不需要直接传输对象的场景</li>
</ol>
<h2 id="2-让你自己实现序列化和反序列化，你会怎么做"><a href="#2-让你自己实现序列化和反序列化，你会怎么做" class="headerlink" title="2# 让你自己实现序列化和反序列化，你会怎么做?"></a>2# 让你自己实现序列化和反序列化，你会怎么做?</h2><p>Java 默认的序列化虽然实现方便，但却存在安全漏洞、不跨语言以及性能差等缺陷：</p>
<ol>
<li><strong>无法跨语言</strong>： Java 序列化目前只适用基于 Java 语言实现的框架，其它语言大部分都没有使用 Java 的序列化框架，也没有实现 Java 序列化这套协议。因此，如果是两个基于不同语言编写的应用程序相互通信，则无法实现两个应用服务之间传输对象的序列化与反序列化</li>
<li><strong>容易被攻击</strong>：Java 序列化是不安全的，我们知道对象是通过在 <code>ObjectInputStream</code> 上调用 <code>readObject()</code> 方法进行反序列化的，这个方法其实是一个神奇的构造器，它可以将类路径上几乎所有实现了 <code>Serializable</code> 接口的对象都实例化。这也就意味着，在反序列化字节流的过程中，该方法可以执行任意类型的代码，这是非常危险的</li>
<li><strong>序列化后的流太大</strong>：序列化后的二进制流大小能体现序列化的性能。序列化后的二进制数组越大，占用的存储空间就越多，存储硬件的成本就越高。如果我们是进行网络传输，则占用的带宽就更多，这时就会影响到系统的吞吐量</li>
</ol>
<p>我会考虑用主流序列化框架，比如 FastJson、Protobuf 来替代 Java 序列化</p>
<p>如果追求性能的话，Protobuf 序列化框架会比较合适，Protobuf 的这种数据存储格式，不仅压缩存储数据的效果好， 在编码和解码的性能方面也很高效。Protobuf 的编码和解码过程结合 <code>.proto</code> 文件格式，加上 Protocol Buffer 独特的编码格式，只需要简单的数据运算以及位移等操作就可以完成编码与解码。可以说 Protobuf 的整体性能非常优秀</p>
<h2 id="3-将对象转为二进制字节流具体怎么实现"><a href="#3-将对象转为二进制字节流具体怎么实现" class="headerlink" title="3# 将对象转为二进制字节流具体怎么实现?"></a>3# 将对象转为二进制字节流具体怎么实现?</h2><p>其实，像序列化和反序列化，无论这些可逆操作是什么机制，都会有对应的<strong>处理和解析协议</strong>，例如加密和解密，TCP的粘包和拆包，序列化机制是通过序列化协议来进行处理的，和 <code>.class</code> 文件类似，它其实是定义了序列化后的字节流格式，然后对此格式进行操作，生成符合格式的字节流或者将字节流解析成对象</p>
<p>在 Java 中通过序列化对象流来完成序列化和反序列化：</p>
<ul>
<li><code>ObjectOutputStream</code>：通过 <code>writeObject()</code> 方法做序列化操作</li>
<li><code>ObjectInputStrean</code>：通过 <code>readObject()</code> 方法做反序列化操作</li>
</ul>
<p>只有实现了 <code>Serializable</code> 或 <code>Externalizable</code> 接口的类的对象才能被序列化，否则抛出异常</p>
<p><strong>一、实现对象序列化</strong></p>
<ul>
<li>让类实现 <code>Serializable</code> 接口：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// class code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建输出流并写入对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.ser&quot;</span>);</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOut);</span><br><span class="line">    out.writeObject(obj);</span><br><span class="line">    out.close();</span><br><span class="line">    fileOut.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二、实现对象反序列化</strong></p>
<ul>
<li>创建输入流并读取对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">newObj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>);</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileIn);</span><br><span class="line">    newObj = (MyClass) in.readObject();</span><br><span class="line">    in.close();</span><br><span class="line">    fileIn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上步骤，对象 <code>obj</code> 会被序列化并写入到文件 <code>object.ser</code> 中，然后通过反序列化操作，从文件中读取字节流并恢复为对象 <code>newObj</code>。这种方式可以方便地将对象转换为字节流用于持久化存储、网络传输等操作。需要注意的是，要确保类实现了 <code>Serializable</code> 接口，并且所有成员变量都是 <code>Serializable</code> 的才能被正确序列化</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="1-volatile-和-sychronized-如何实现单例模式"><a href="#1-volatile-和-sychronized-如何实现单例模式" class="headerlink" title="1# volatile 和 sychronized 如何实现单例模式"></a>1# volatile 和 sychronized 如何实现单例模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleTon</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止指令重排，保证可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">SingleTon</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleTon</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleTon <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingleTon.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">SingleTon</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>volatile</code> 的作用：</p>
<ol>
<li><strong>保证可见性</strong>：多个线程访问 <code>instance</code> 时，能看到最新的值</li>
<li><strong>禁止指令重排序</strong>：确保对象在完全构造前，其他线程不会看到它的引用，避免出现 “半初始化” 对象</li>
</ol>
<p>双重检查锁定（DCL）原理：</p>
<ul>
<li><strong>第一次检查</strong>：避免进入同步块（提升性能）</li>
<li><strong>同步块内部再次检查</strong>：保证线程安全，仅在首次创建对象时同步</li>
</ul>
<h2 id="2-代理模式和适配器模式有什么区别？"><a href="#2-代理模式和适配器模式有什么区别？" class="headerlink" title="2# 代理模式和适配器模式有什么区别？"></a>2# 代理模式和适配器模式有什么区别？</h2><ol>
<li><strong>目的不同</strong>：代理模式主要关注控制对对象的访问，而适配器模式则用于接口转换，使不兼容的类能够一起工作</li>
<li><strong>结构不同</strong>：代理模式一般包含抽象主题、真实主题和代理三个角色，适配器模式包含目标接口、适配器和被适配者三个角色</li>
<li><strong>应用场景不同</strong>：代理模式常用于添加额外功能或控制对对象的访问，适配器模式常用于让不兼容的接口协同工作</li>
</ol>
<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="1-Java-怎么实现网络-IO-高并发编程？"><a href="#1-Java-怎么实现网络-IO-高并发编程？" class="headerlink" title="1# Java 怎么实现网络 IO 高并发编程？"></a>1# Java 怎么实现网络 IO 高并发编程？</h2><p><strong>可以用 Java NIO</strong>，是一种同步非阻塞的 IO 模型，也是 IO 多路复用的基础</p>
<p>传统的 BIO 里面 <code>socket.read()</code>，如果 TCP RecvBuffer 里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据， 如果使用 BIO 要想要并发处理多个客户端的 IO，那么会使用多线程模式，一个线程专门处理一个客户端 IO，这种模式随着客户端越来越多，所需要创建的线程也越来越多，会急剧消耗系统的性能</p>
<img src="https://cdn.xiaolincoding.com//picgo/image-20240820112641716.png" alt="BIO" style="zoom:50%;" />

<p>NIO 是基于 IO 多路复用实现的，它可以只用一个线程处理多个客户端 IO，如果你需要同时管理成千上万的连接，但是每个连接只发送少量数据，例如一个聊天服务器，用NIO实现会更好一些</p>
<img src="https://cdn.xiaolincoding.com//picgo/image-20240820112656259.png" alt="NIO" style="zoom:50%;" />



<h2 id="2-BIO、NIO、AIO区别是什么？"><a href="#2-BIO、NIO、AIO区别是什么？" class="headerlink" title="2# BIO、NIO、AIO区别是什么？"></a>2# BIO、NIO、AIO区别是什么？</h2><table>
<thead>
<tr>
<th>模型</th>
<th>特点</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>BIO</strong></td>
<td>同步阻塞，每个连接一个线程，简单但性能差</td>
<td>适用于连接数少、对实时性要求不高的系统</td>
</tr>
<tr>
<td><strong>NIO</strong></td>
<td>同步非阻塞，使用 <code>Selector</code> 管理多个通道，一个线程可处理多个连接</td>
<td>适用于高并发、大量连接的服务端程序</td>
</tr>
<tr>
<td><strong>AIO</strong></td>
<td>异步非阻塞，基于回调通知，IO 操作完全由系统异步完成</td>
<td>适用于连接数非常多、IO 操作频繁的高性能场景</td>
</tr>
</tbody></table>
<ul>
<li><strong>BIO（Blocking IO）</strong>：传统 <code>java.io</code>，线程阻塞直至完成读写操作，编程简单但不适合高并发</li>
<li><strong>NIO（Non-blocking IO）</strong>：Java 1.4 引入，引入 <code>Channel</code>、<code>Selector</code>、<code>Buffer</code>，可以实现单线程处理多连接</li>
<li><strong>AIO（Asynchronous IO）</strong>：Java 1.7 引入，真正的异步非阻塞，系统完成 IO 后自动回调通知业务线程处理</li>
</ul>
<h2 id="3-NIO-是怎么实现的？"><a href="#3-NIO-是怎么实现的？" class="headerlink" title="3# NIO 是怎么实现的？"></a>3# NIO 是怎么实现的？</h2><p>NIO 是一种<strong>同步非阻塞</strong>的 IO 模型 </p>
<p>同步是指线程不断轮询 IO 事件是否就绪，同步的核心是 Selector（IO多路复用），Selector 代替了线程本身轮询 IO 事件，避免了阻塞，同时减少了不必要的线程消耗；非阻塞是指线程在等待 IO 的时候，可以同时做其他任务，非阻塞的核心就是通道和缓冲区，当 IO 事件就绪时，可以通过写到缓冲区，保证 IO 的成功，而无需线程阻塞式地等待</p>
<p>NIO 通常由一个专门的线程负责监听所有 IO 事件，并进行分发处理。它基于事件驱动机制：当感兴趣的事件（如连接就绪、数据可读）发生时，线程被唤醒进行处理，而不是长时间阻塞等待</p>
<p><strong>NIO 的核心组件</strong>：</p>
<ul>
<li><p><strong>Channel（通道）</strong><br> 类似传统 IO 的流，但既可读也可写，支持非阻塞模式</p>
</li>
<li><p><strong>Buffer（缓冲区）</strong><br> 所有数据读写都要通过 Buffer，Channel 与 Buffer 相互配合实现数据交换</p>
</li>
<li><p><strong>Selector（选择器）</strong><br> 允许单线程监听多个 Channel 的 IO 事件（如连接建立、数据可读），实现 <strong>IO 多路复用</strong></p>
</li>
</ul>
<img src="https://cdn.xiaolincoding.com//picgo/1716018476312-e5525ca7-acf8-46b1-8fff-8a7d22db5304.webp" alt="NIO 原理" style="zoom:67%;" />



<h2 id="4-你知道有哪个框架用到-NIO-了吗？"><a href="#4-你知道有哪个框架用到-NIO-了吗？" class="headerlink" title="4# 你知道有哪个框架用到 NIO 了吗？"></a>4# 你知道有哪个框架用到 NIO 了吗？</h2><p><strong>Netty</strong></p>
<p>Netty 的 IO 模型是基于非阻塞 IO 实现的，底层依赖的是 NIO 框架的多路复用器 Selector。采用 epoll 模式后，只需要一个线程负责 Selector 的轮询。当有数据处于就绪状态后，需要一个事件分发器（Event Dispather），它负责将读写事件分发给对应的读写事件处理器（Event Handler）。事件分发器有两种设计模式：Reactor 和 Proactor，Reactor 采用同步 IO， Proactor 采用异步 IO</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1715424254674-7a7159b1-d1ed-4236-ae18-09421c9837ed.png" alt="Netty 的 IO 模型"></p>
<p>Reactor 实现相对简单，适合处理耗时短的场景，对于耗时长的 IO 操作容易造成阻塞。Proactor 性能更高，但是实现逻辑非常复杂，适合图片或视频流分析服务器，目前主流的事件驱动模型还是依赖 select 或 epoll 来实现</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="1-有一个学生类，想按照分数排序，再按学号排序，应该怎么做？"><a href="#1-有一个学生类，想按照分数排序，再按学号排序，应该怎么做？" class="headerlink" title="1# 有一个学生类，想按照分数排序，再按学号排序，应该怎么做？"></a>1# 有一个学生类，想按照分数排序，再按学号排序，应该怎么做？</h2><p>在学生类中实现 <code>Comparable</code> 接口，并重写 <code>compareTo</code> 方法，然后在 <code>compareTo</code> 方法中实现按照分数排序和按照学号排序的逻辑:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法和其他属性、方法省略</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student other)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.score != other.score) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(other.score, <span class="built_in">this</span>.score); <span class="comment">// 按照分数降序排序</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.id, other.id); <span class="comment">// 如果分数相同，则按照学号升序排序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在需要对学生列表进行排序的地方，使用 <code>Collections.sort()</code> 方法对学生列表进行排序即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 添加学生对象到列表中</span></span><br><span class="line">Collections.sort(students);</span><br></pre></td></tr></table></figure>



<h2 id="2-解释一下-native-方法"><a href="#2-解释一下-native-方法" class="headerlink" title="2# 解释一下 native 方法"></a>2# 解释一下 native 方法</h2><p>在 Java 中，native 方法是一种特殊类型的方法，它允许 Java 代码调用外部的本地代码，即用 C、CPP 或其他语言编写的代码</p>
<p>native 方法看起来与其他方法相似，只是其方法体由 <code>native</code> 关键字代替，标记一个方法的实现将在外部定义，没有实际的实现代码。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeMethod</span><span class="params">()</span>; <span class="comment">// 声明为 native，无方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用 native 方法的一般流程</strong>：</p>
<ol>
<li><strong>声明 native 方法</strong>：在 Java 类中使用 <code>native</code> 关键字声明方法，无需提供方法体</li>
<li><strong>生成 JNI 头文件</strong>：使用 <code>javac</code> 编译 Java 类，然后用 <code>javah</code>（或 <code>javac -h</code>，较新版本）生成对应的 C&#x2F;CPP 头文件（<code>.h</code>），该文件包含 native 方法的函数签名</li>
<li><strong>实现本地代码</strong>：编写本地代码，实现 <code>.h</code> 文件中声明的方法逻辑。函数名需严格匹配 JNI 的命名规范</li>
<li><strong>编译为本地库</strong>：将本地代码编译成动态链接库（<code>.dll</code>，在 Windows 上），共享库（<code>.so</code>，在 Linux 上）</li>
<li><strong>加载本地库</strong>：使用 <code>System.loadLibrary(&quot;库名&quot;)</code> 加载编译好的本地库，使 JVM 能调用 native 方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeExample</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;nativeLib&quot;</span>); <span class="comment">// 加载名为 nativeLib 的本地库</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeMethod</span><span class="params">()</span>; <span class="comment">// 声明 native 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NativeExample</span>().nativeMethod(); <span class="comment">// 调用本地方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>八股文笔记 #2 Java 集合</title>
    <url>/2025/07/02/boilerplate-answers-2-java-collection/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="1-数组与集合的区别是？用过哪些？"><a href="#1-数组与集合的区别是？用过哪些？" class="headerlink" title="1# 数组与集合的区别是？用过哪些？"></a>1# 数组与集合的区别是？用过哪些？</h2><p>数组和集合的区别：</p>
<ul>
<li>数组是固定长度的数据结构，一旦创建长度就无法改变，而集合是动态长度的数据结构，可以根据需要动态增加或减少元素</li>
<li>数组可以包含基本数据类型和对象，而集合只能包含对象</li>
<li>数组可以直接访问元素，而集合需要通过迭代器或其他方法访问元素</li>
</ul>
<span id="more"></span>

<p>我用过的一些 Java 集合类：</p>
<ol>
<li><p><strong><code>List</code> 系列（有序、可重复）</strong>：</p>
<ul>
<li><strong><code>ArrayList</code></strong>： 动态数组，随机访问快，适合读多写少场景</li>
<li><strong><code>LinkedList</code></strong>： 双向链表，插入&#x2F;删除快，适合频繁操作头尾</li>
</ul>
</li>
<li><p><strong><code>Set</code> 系列（无序&#x2F;有序、不可重复）</strong>：</p>
<ul>
<li><strong><code>HashSet</code></strong>： 基于 <code>HashMap</code> 实现的 <code>Set</code> 集合，用于存储唯一元素</li>
<li><strong><code>LinkedHashSet</code></strong>：有插入顺序的 <code>HashSet</code></li>
<li><strong><code>TreeSet</code></strong>：基于红黑树，元素自动排序（按自然顺序或比较器）</li>
</ul>
</li>
<li><p><strong><code>Map</code> 系列（键值对）</strong>：</p>
<ul>
<li><strong><code>HashMap</code></strong>： 基于哈希表的 <code>Map</code> 实现，存储键值对，通过键快速查找值</li>
<li><strong><code>ConcurrentHashMap</code></strong>：线程安全的高性能并发 <code>Map</code></li>
<li><strong><code>TreeMap</code></strong>： 基于红黑树实现的有序 <code>Map</code> 集合，可以按照键的顺序进行排序</li>
<li><strong><code>LinkedHashMap</code></strong>： 基于哈希表和双向链表实现的 <code>Map</code> 集合，保持插入顺序或访问顺序</li>
</ul>
</li>
<li><p><strong><code>Queue</code> 系列（队列&#x2F;优先队列）</strong>：</p>
<ul>
<li><p><strong><code>PriorityQueue</code></strong>： 优先队列，可以按照比较器或元素的自然顺序进行排序</p>
</li>
<li><p><strong><code>ArrayDeque</code></strong>：双端队列，可用于栈或队列结构</p>
</li>
</ul>
</li>
</ol>
<h2 id="2-说说-Java-中的集合？"><a href="#2-说说-Java-中的集合？" class="headerlink" title="2# 说说 Java 中的集合？"></a>2# 说说 Java 中的集合？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1717481094793-b8ffe6ae-2ee6-4de5-b61b-8468e32bf269.webp" alt="Java 集合"></p>
<p><code>List</code> 是一个<strong>有序、可重复</strong>的集合，它允许根据索引精确控制元素的插入位置，也支持根据索引访问、搜索和修改元素</p>
<ul>
<li><code>ArrayList</code> 基于<strong>动态数组</strong>实现，元素按插入顺序排序。因为底层是数组，支持<strong>快速随机访问</strong>（时间复杂度 O(1)），插入和删除操作（特别是在中间位置）较慢，需移动大量元素（时间复杂度 O(n)）。当几何扩容时，会创建更大的数组，并把原数组复制到新数组。<strong>线程不安全</strong>，适用于单线程环境</li>
<li><code>LinkedList</code> 基于<strong>双向链表</strong>实现，每个节点都保存前后指针。插入和删除操作性能较好，尤其是在首尾位置添加&#x2F;删除元素时（O(1)），不支持高效的随机访问（访问第 n 个元素需从头或尾遍历，时间复杂度 O(n)）。同样是<strong>线程不安全</strong>的</li>
<li><code>Vector</code>：与 <code>ArrayList</code> 类似，也是基于<strong>动态数组</strong>实现的。<code>Vector</code> 是<strong>线程安全的</strong>，其大多数方法都使用了 <code>synchronized</code> 关键字修饰，保证线程同步。属于<strong>过时类</strong>，在 JDK 的后续发展中不再推荐使用</li>
<li><code>Stack</code>：是 <code>Vector</code> 的子类，继承了 <code>Vector</code> 的所有特性，线程安全。它实现的是**后进先出（LIFO）**的数据结构，提供了栈操作方法。同样存在设计上的历史局限，不推荐在新的项目中使用</li>
</ul>
<p><code>Set</code> 是一个<strong>不包含重复元素</strong>的集合，元素通常是<strong>无序</strong>的，但具体顺序取决于其实现类</p>
<ul>
<li><code>HashSet</code> ：基于 <code>HashMap</code> 实现，底层以 <code>HashMap</code> 的 key 存储元素，所有 key 对应的 value 都是一个统一的常量 <code>PRESENT</code>。它不保证元素顺序，插入顺序和取出顺序可能不同。由于依赖 <code>HashMap</code>，因此是<strong>线程不安全的</strong></li>
<li><code>LinkedHashSet</code>：继承自 <code>HashSet</code>，通过 <code>LinkedHashMap</code> 实现，内部使用<strong>双向链表</strong>维护元素的插入顺序，因此是<strong>有序的（按插入顺序）</strong></li>
<li><code>TreeSet</code>：基于 <code>TreeMap</code> 实现，底层结构为<strong>红黑树</strong>。元素将根据其<strong>自然顺序</strong>或提供的<strong>比较器（Comparator）进行排序，因此是有序集合</strong></li>
</ul>
<p><code>Map</code> 是一种键值对集合，<strong>key 不可重复</strong>，<strong>value 可重复</strong>。它不是 <code>Collection</code> 的子接口，但同样是 Java 集合框架的核心部分</p>
<ul>
<li><code>HashMap</code>：最常用的 <code>Map</code> 实现，key 无序、唯一，value 可重复。JDK 1.8 之前底层是<strong>数组 + 链表</strong>结构，使用<strong>拉链法</strong>解决哈希冲突；JDK 1.8 之后，当单个桶中的链表长度超过阈值（默认 8），链表将转为<strong>红黑树</strong>以提高性能。线程不安全，适用于单线程环境</li>
<li><code>LinkedHashMap</code>：是 <code>HashMap</code> 的子类，底层在 <code>HashMap</code> 基础上添加了<strong>双向链表</strong>，以维护插入顺序或访问顺序。可以通过构造函数设置为按<strong>访问顺序排序</strong>，常用于实现 LRU 缓存</li>
<li><code>HashTable</code>：较早的实现，底层为<strong>数组 + 链表</strong>，链表主要是为了解决哈希冲突。所有方法都使用 <code>synchronized</code> 修饰，线程安全但性能较差，已基本被 <code>ConcurrentHashMap</code> 替代</li>
<li><code>TreeMap</code>：是基于红黑树实现的<code>Map</code>，它可以对键进行排序，默认按照自然顺序排序，也可以通过指定的比较器进行排序。<code>TreeMap</code> 是非线程安全的，在多线程环境下，如果多个线程同时对 <code>TreeMap</code> 进行插入、删除等操作，可能会破坏红黑树的结构，导致数据不一致或程序出现异常</li>
<li><code>ConcurrentHashMap</code>：支持高并发访问的线程安全 <code>Map</code> 实现。JDK 1.8 以前使用 <strong>Segment 分段锁机制</strong>；JDK 1.8 后采用<strong>数组 + 链表 + 红黑树</strong>结构，并通过 <strong>CAS + synchronized</strong> 等机制实现更细粒度的并发控制，性能显著提升</li>
</ul>
<h2 id="3-Java-中线程安全的集合有什么？"><a href="#3-Java-中线程安全的集合有什么？" class="headerlink" title="3# Java 中线程安全的集合有什么？"></a>3# Java 中线程安全的集合有什么？</h2><p>在 <code>java.util</code> 包中的线程安全的类主要 2 个，其他都是非线程安全的：</p>
<ul>
<li><code>Vector</code>：和 <code>ArrayList</code> 类似，也是基于数组实现。其大多数方法通过 <code>synchronized</code> 保证线程安全，但在单线程场景中同步开销大，性能略低于 <code>ArrayList</code>。<code>Vector</code> 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据</li>
<li><code>Hashtable</code>：线程安全的哈希表，<code>HashTable</code> 的加锁方法是给每个方法加上 <code>synchronized</code> 关键字，这样锁住的是整个 <code>Table</code> 对象，不支持 <code>null</code> 键和值，由于同步导致的性能开销，所以已经很少被推荐使用，如果要保证线程安全的哈希表，可以用 <code>ConcurrentHashMap</code></li>
</ul>
<p><code>java.util.concurrent</code> 包提供的都是线程安全的集合：</p>
<p><strong>并发 Map</strong>：</p>
<ul>
<li><code>ConcurrentHashMap</code>：它与 <code>HashTable</code> 的主要区别是二者加锁粒度的不同，在 JDK 1.8 前，<code>ConcurrentHashMap</code> 加的是分段锁，也就是 Segment 锁，每个 Segment 含有整个 table 的一部分，这样不同分段之间的并发操作就互不影响。在 JDK 1.8 后，它取消了 Segment 字段，直接在 table 元素上加锁，实现对每一行进行加锁，进一步减小了并发冲突的概率。对于 put 操作，如果 key 对应的数组元素为 <code>null</code>，则通过 CAS 操作（Compare and Swap）将其设置为当前值。如果 key 对应的数组元素（也即链表表头或者树的根元素）不为 <code>null</code>，则对该元素使用 <code>synchronized</code> 关键字申请锁，然后进行操作。如果该 put 操作使得当前链表长度超过一定阈值，则将该链表转换为红黑树，从而提高寻址效率</li>
<li><code>ConcurrentSkipListMap</code>：实现了一个基于 <code>SkipList</code>（跳表）算法的可排序的并发集合，<code>SkipList</code> 是一种可以在对数预期时间内完成搜索、插入、删除等操作的数据结构，通过维护多个指向其他元素的 “跳跃” 链接来实现高效查找</li>
</ul>
<p><strong>并发 Set</strong>：</p>
<ul>
<li><code>ConcurrentSkipListSet</code>：是线程安全的有序的集合。底层是使用 <code>ConcurrentSkipListMap</code> 实现</li>
<li><code>CopyOnWriteArraySet</code>：是线程安全的 <code>Set</code> 实现，它是线程安全的无序的集合，可以将它理解成线程安全的 <code>HashSet</code>。有意思的是，<code>CopyOnWriteArraySet</code> 和 <code>HashSet</code> 虽然都继承于共同的父类 <code>AbstractSet</code>；但是，<code>HashSet</code> 是通过散列表实现的，而 <code>CopyOnWriteArraySet</code> 则是通过动态数组 <code>CopyOnWriteArrayList</code> 实现的，并不是散列表</li>
</ul>
<p><strong>并发 List</strong>：</p>
<ul>
<li><code>CopyOnWriteArrayList</code>：它是 <code>ArrayList</code> 的线程安全的变体，其中所有写操作（add，set 等）都通过对底层数组进行全新复制来实现，允许存储 <code>null</code> 元素。即当对象进行写操作时，使用了 Lock 锁做同步处理，内部拷贝了原数组，并在新数组上进行添加操作，最后将新数组替换掉旧数组；若进行的读操作，则直接返回结果，操作过程中不需要进行同步</li>
</ul>
<p><strong>并发 Queue</strong>：</p>
<ul>
<li><code>ConcurrentLinkedQueue</code>：是一个适用于高并发场景下的队列，它通过无锁的方式（CAS），实现了高并发状态下的高性能。通常，<code>ConcurrentLinkedQueue</code> 的性能要好于 <code>BlockingQueue</code></li>
<li><code>BlockingQueue</code>：与 <code>ConcurrentLinkedQueue</code> 的使用场景不同，<code>BlockingQueue</code> 的主要功能并不是在于提升高并发时的队列性能，而在于简化多线程间的数据共享。<code>BlockingQueue</code> 提供一种读写阻塞等待的机制，即如果消费者速度较快，则 <code>BlockingQueue</code> 则可能被清空，此时消费线程再试图从 <code>BlockingQueue</code> 读取数据时就会被阻塞。反之，如果生产线程较快，则 <code>BlockingQueue</code> 可能会被装满，此时，生产线程再试图向 <code>BlockingQueue</code> 队列装入数据时，便会被阻塞等待</li>
</ul>
<p><strong>并发 Deque</strong>：</p>
<ul>
<li><code>LinkedBlockingDeque</code>：是一个线程安全的双端队列实现。它的内部使用链表结构，每一个节点都维护了一个前驱节点和一个后驱节点。<code>LinkedBlockingDeque</code> 没有进行读写锁的分离，因此同一时间只能有一个线程对其进行操作</li>
<li><code>ConcurrentLinkedDeque</code>：<code>ConcurrentLinkedDeque</code> 是一种基于链接节点的无限并发链表。可以安全地并发执行插入、删除和访问操作。当许多线程同时访问一个公共集合时，<code>ConcurrentLinkedDeque</code> 是一个合适的选择</li>
</ul>
<p><del><strong>太长不看版</strong>：</del></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>主要实现</th>
<th>线程安全机制 &amp; 典型特性</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>早期同步类（<code>java.util</code>）</strong></td>
<td><code>Vector</code>、<code>Hashtable</code></td>
<td>整体 <code>synchronized</code>，简单但锁粒度大，已基本淘汰</td>
<td>兼容遗留代码</td>
</tr>
<tr>
<td><strong>并发 Map</strong></td>
<td><code>ConcurrentHashMap``ConcurrentSkipListMap</code></td>
<td>JDK 8：数组 + 链表&#x2F;红黑树 + <strong>CAS &#x2F; synchronized</strong>（行锁）SkipList：基于跳表，<strong>有序</strong>、读写并发</td>
<td>高并发 KV 存储；有序场景用 SkipList</td>
</tr>
<tr>
<td><strong>并发 Set</strong></td>
<td><code>ConcurrentSkipListSet``CopyOnWriteArraySet</code></td>
<td>前者基于 SkipList（有序）后者基于 Copy‑On‑Write，读多写少</td>
<td>排序去重 &#x2F; 读多写少</td>
</tr>
<tr>
<td><strong>并发 List</strong></td>
<td><code>CopyOnWriteArrayList</code></td>
<td>写时复制：写操作复制数组，读无需加锁</td>
<td>读多写少、迭代不要求实时一致</td>
</tr>
<tr>
<td><strong>并发 Queue &#x2F; Deque</strong></td>
<td><code>ConcurrentLinkedQueue</code>（无锁链表）<code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>、<code>LinkedBlockingDeque</code>（阻塞队列）<code>ConcurrentLinkedDeque</code>（无锁双端）</td>
<td>CAS 或 <code>ReentrantLock</code> + 条件队列，实现非阻塞或阻塞语义</td>
<td>生产者&#x2F;消费者模型、任务队列、并发栈&#x2F;队列</td>
</tr>
</tbody></table>
<h2 id="4-Collection-和-Collections-的区别"><a href="#4-Collection-和-Collections-的区别" class="headerlink" title="4# Collection 和 Collections 的区别"></a>4# Collection 和 Collections 的区别</h2><ul>
<li><code>Collection</code> 是 Java 集合框架的顶层接口，位于 <code>java.util</code> 包中，定义了集合的基本操作，如增删改查、遍历等。它是 <code>List</code>、<code>Set</code>、<code>Queue</code> 等集合接口的父接口，用于表示一组元素的抽象结构</li>
<li><code>Collections</code> 是 Java 提供的一个 <strong>工具类</strong>，同样位于 <code>java.util</code> 包中，专门用于对集合进行操作。它包含大量的<strong>静态方法</strong>，如排序 <code>sort()</code>、查找 <code>binarySearch()</code>、替换、反转 <code>reverse()</code>、线程安全包装 <code>synchronizedList()</code>等，可用于处理实现了 <code>Collection</code> 接口的集合对象（如 <code>List</code>、<code>Set</code> 等）</li>
</ul>
<h2 id="5-遍历集合的方式有哪些？"><a href="#5-遍历集合的方式有哪些？" class="headerlink" title="5# 遍历集合的方式有哪些？"></a>5# 遍历集合的方式有哪些？</h2><ol>
<li><strong>普通 for 循环</strong>：可以使用带有索引的普通 for 循环来遍历 <code>List</code></li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>增强 for 循环（for-each 循环）</strong>： 用于循环访问数组或集合中的元素</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String element : list) &#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>Iterator 迭代器</strong>： 可以使用迭代器来遍历集合，特别适用于需要删除元素的情况</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>ListIterator 列表迭代器</strong>： <code>ListIterator</code> 是迭代器的子类，可以双向访问列表并在迭代过程中修改元素</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListIterator&lt;String&gt; listIterator = list.listIterator();</span><br><span class="line"><span class="keyword">while</span> (listIterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> listIterator.next();</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>使用 <code>forEach()</code> 方法</strong>： Java 8 引入了 <code>forEach()</code> 方法，可以对集合进行快速遍历</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.forEach(element -&gt; System.out.println(element));</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>Stream API</strong>： Java 8 的 Stream API 提供了丰富的功能，可以对集合进行函数式操作，如过滤、映射等</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.stream().forEach(element -&gt; System.out.println(element));</span><br></pre></td></tr></table></figure>



<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="1-说说常见的-list-集合？"><a href="#1-说说常见的-list-集合？" class="headerlink" title="1# 说说常见的 list 集合？"></a>1# 说说常见的 list 集合？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1737438845596-760eb59b-c34c-441c-bea7-5b4eb1da4db4.png" alt="List 集合"></p>
<p><strong>非线程安全</strong>：</p>
<ul>
<li><code>ArrayList</code> ：基于<strong>动态数组</strong>实现，元素按插入顺序排序。因为底层是数组，支持<strong>快速随机访问</strong>（时间复杂度 O(1)），插入和删除操作（特别是在中间位置）较慢，需移动大量元素（时间复杂度 O(n)）。当几何扩容时，会创建更大的数组，并把原数组复制到新数组。<strong>线程不安全</strong>，适用于单线程环境</li>
<li><code>LinkedList</code> ：基于<strong>双向链表</strong>实现，每个节点都保存前后指针。插入和删除操作性能较好，尤其是在首尾位置添加&#x2F;删除元素时（O(1)），不支持高效的随机访问（访问第 n 个元素需从头或尾遍历，时间复杂度 O(n)）。同样是<strong>线程不安全</strong>的</li>
</ul>
<p><strong>线程安全</strong>：</p>
<ul>
<li><p><code>Vector</code>：和 <code>ArrayList</code> 类似，也是基于数组实现。其大多数方法通过 <code>synchronized</code> 保证线程安全，但在单线程场景中同步开销大，性能略低于 <code>ArrayList</code>。<code>Vector</code> 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据</p>
</li>
<li><p><code>CopyOnWriteArrayList</code>：一种<strong>并发容器类</strong>，写操作（如添加、删除）时会复制一份底层数组，并在新数组上修改，写完后再替换旧数组；读操作无需加锁，始终在旧数组上执行，实现了<strong>读写分离</strong>，大幅提升读性能。适用于<strong>读多写少</strong>的并发场景，如事件监听器列表、缓存快照等。缺点是写操作开销较大，且不适合大数据量频繁写入的场景</p>
</li>
</ul>
<h2 id="2-讲一下-List-的几种实现，几种实现有什么不同？"><a href="#2-讲一下-List-的几种实现，几种实现有什么不同？" class="headerlink" title="2# 讲一下 List 的几种实现，几种实现有什么不同？"></a>2# 讲一下 List 的几种实现，几种实现有什么不同？</h2><p><code>ArrayList</code>、<code>Vector</code>、<code>LinkedList</code>，概念如上</p>
<p><code>ArrayList</code> 和 <code>Vector</code> 作为动态数组，因为底层是数组，支持<strong>快速随机访问</strong>（时间复杂度 O(1)），插入和删除操作（特别是在中间位置）较慢，需移动大量元素（时间复杂度 O(n)）</p>
<p>而 <code>LinkedList</code> 插入和删除操作性能较好，尤其是在首尾位置添加&#x2F;删除元素时（O(1)），不支持高效的随机访问（访问第 n 个元素需从头或尾遍历，时间复杂度 O(n)）</p>
<h2 id="3-List-可以一边遍历一边修改元素吗？"><a href="#3-List-可以一边遍历一边修改元素吗？" class="headerlink" title="3# List 可以一边遍历一边修改元素吗？"></a>3# List 可以一边遍历一边修改元素吗？</h2><ol>
<li><strong>使用普通 for 循环遍历</strong>：可以在遍历过程中修改元素，只要修改的索引不超出<code>List</code>的范围即可</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">	list.set(i, list.get(i) * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>使用 for-earch 循环遍历</strong>：一般不建议在 <code>for-earch</code> 循环中直接修改正在遍历的 <code>List</code> 元素，可能会导致意外的结果或 <code>ConcurrentModificationException</code> 异常。因为 <code>for-earch</code> 循环底层是基于迭代器实现的，在遍历过程中修改集合结构，会导致迭代器的预期结构和实际结构不一致</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Integer num : list) &#123;</span><br><span class="line">	list.set(list.indexOf(num), num * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>使用迭代器遍历</strong>：可以使用迭代器的 <code>remove()</code> 方法来删除元素，但如果要修改元素的值，需要通过迭代器的 <code>set()</code> 方法来进行，而不是直接通过 <code>List</code> 的 <code>set()</code> 方法，否则也可能会抛出 <code>ConcurrentModificationException</code> 异常</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">	<span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">	iterator.set(num * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-List-如何快速删除指定下标的元素？"><a href="#4-List-如何快速删除指定下标的元素？" class="headerlink" title="4# List 如何快速删除指定下标的元素？"></a>4# List 如何快速删除指定下标的元素？</h2><ol>
<li><p><strong><code>ArrayList</code> 的 <code>remove(int index)</code> 方法</strong>：该方法在删除元素后，会将后续元素向前移动，以填补被删除元素的位置。如果删除的是列表中间的元素，时间复杂度为 O (n)；如果删除的是列表末尾的元素，时间复杂度为 O (1)</p>
</li>
<li><p><strong><code>LinkedList</code> 的 <code>remove(int index)</code> 方法</strong>：它需要先遍历到指定下标位置，然后修改链表的指针来删除元素，时间复杂度为 O (n)；如果删除的是链表的头节点或尾节点的元素，可以直接通过修改头指针或尾指针来实现删除，时间复杂度为 O (1)</p>
</li>
<li><p><strong><code>CopyOnWriteArrayList</code> 的 <code>remove(int index)</code> 方法</strong>：由于 <code>CopyOnWriteArrayList</code> 在写操作时会创建一个新的数组，所以删除操作的时间复杂度取决于数组的复制速度，通常为 O (n)。但在并发环境下，它的删除操作不会影响读操作，具有较好的并发性能</p>
</li>
</ol>
<h2 id="5-ArrayList-线程安全吗？把-Arraylist-变成线程安全的方式有哪些？"><a href="#5-ArrayList-线程安全吗？把-Arraylist-变成线程安全的方式有哪些？" class="headerlink" title="5# ArrayList 线程安全吗？把 Arraylist 变成线程安全的方式有哪些？"></a>5# ArrayList 线程安全吗？把 Arraylist 变成线程安全的方式有哪些？</h2><p><strong>不是线程安全的</strong>。变成线程安全的方式：</p>
<ol>
<li>使用 <code>Collections</code> 类的 <code>synchronizedList</code> 方法将 <code>ArrayList</code> 包装成线程安全的 <code>List</code>：</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; synchronizedList = Collections.synchronizedList(arrayList);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 <code>CopyOnWriteArrayList</code> 类代替 <code>ArrayList</code>，它是一个线程安全的 <code>List</code> 实现：</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CopyOnWriteArrayList&lt;String&gt; copyOnWriteArrayList = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;(arrayList);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用 <code>Vector</code> 类代替 <code>ArrayList</code>，<code>Vector</code> 是线程安全的 <code>List</code> 实现：</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Vector&lt;String&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;(arrayList);</span><br></pre></td></tr></table></figure>



<h2 id="6-为什么-ArrayList-不是线程安全的"><a href="#6-为什么-ArrayList-不是线程安全的" class="headerlink" title="6# 为什么 ArrayList 不是线程安全的?"></a>6# 为什么 ArrayList 不是线程安全的?</h2><p>在高并发添加数据时，<code>ArrayList</code> 会暴露三个问题：</p>
<ul>
<li>部分值为 <code>null</code></li>
<li>索引越界异常（<code>IndexOutOfBoundsException</code>）</li>
<li>size 与 add 的数量不符</li>
</ul>
<p><code>ArrayList</code> 添加元素的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">	ensureCapacityInternal(size + <span class="number">1</span>); <span class="comment">// 可能扩容</span></span><br><span class="line">	elementData[size++] = e;          <span class="comment">// 赋值后再自增 size</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ensureCapacityInternal()</code> 方法判断将当前的新元素加到列表后面，列表的 <code>elementData</code> 数组的大小是否满足，如果 size + 1 的这个需求长度大于了 <code>elementData</code> 这个数组的长度，那么就要对这个数组进行扩容</p>
<p>大体可以分为三步：</p>
<ol>
<li><p>判断数组需不需要扩容，如果需要的话，调用 <code>grow()</code> 方法进行扩容</p>
</li>
<li><p>将数组的 size 位置设置值（因为数组的下标是从 0 开始的）</p>
</li>
<li><p>将当前集合的大小加 1</p>
</li>
</ol>
<p>那么三个问题都是如何产生的？</p>
<ul>
<li>部分值为 <code>null</code>：根因是同一索引被<strong>重复写</strong>，导致后继位置空洞。线程 T1 与 T2 都判断无需扩容（容量 &#x3D;10，size &#x3D;9） → T1 把元素写入 <code>elementData[9]</code>，尚未 <code>size++</code> 就被抢占 → T2 也把元素写入同一槽位并随后 <code>size++</code> → 槽位 10 从未被写入，被视为 <code>null</code></li>
<li>索引越界异常：根因是第二线程基于<strong>过期的容量判断</strong>，写到实际不存在的索引。线程 T1 与 T2 都判断无需扩容（容量 &#x3D;10，size &#x3D;9）→ T1 写索引  9  并 <code>size++</code> → size&#x3D;10 → T2 继续写 <strong>索引 10</strong> → 数组下标越界（数组的下标索引从 0 开始）</li>
<li>size 与 add 的数量不符：根因是<code>size++</code> 是<strong>非原子</strong>递增，发生 “写覆盖”。两线程几乎同时执行 <code>size++</code>：都读取到 size&#x3D;5 → 都各自加1 → 都写回 6 → 少加了一次</li>
</ul>
<h2 id="7-ArrayList-和-LinkedList-的应用场景分别是什么？"><a href="#7-ArrayList-和-LinkedList-的应用场景分别是什么？" class="headerlink" title="7# ArrayList 和 LinkedList 的应用场景分别是什么？"></a>7# ArrayList 和 LinkedList 的应用场景分别是什么？</h2><ul>
<li><code>ArrayList</code>：适用于需要频繁访问集合元素的场景。它基于<strong>动态数组</strong>实现，可以通过索引快速访问元素，因此在按索引查找、遍历和随机访问元素的操作上具有较高的性能</li>
<li><code>LinkedList</code>：适用于频繁进行插入和删除操作的场景。它基于<strong>双向链表</strong>实现，插入和删除元素的操作只需要调整节点的指针，因此在插入和删除操作上具有较高的性能</li>
</ul>
<h2 id="8-说一下-ArrayList-的扩容机制"><a href="#8-说一下-ArrayList-的扩容机制" class="headerlink" title="8# 说一下 ArrayList 的扩容机制"></a>8# 说一下 ArrayList 的扩容机制</h2><p><code>ArrayList</code> 在添加元素时，如果当前元素数量已达到内部数组的容量上限，就会触发扩容操作。<code>ArrayList</code> 的扩容操作主要包括以下几个步骤：</p>
<ol>
<li><strong>计算新的容量</strong>：一般情况下，<code>ArrayList</code> 会将容量扩大为原来的 <strong>1.5 倍</strong>（在 JDK 10 之后，扩容策略做了调整），这是通过移位运算来避免浮点运算，效率较高，例如：</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>创建新的数组</strong>：根据新的容量创建一个更大的数组</p>
</li>
<li><p><strong>将元素复制</strong>：将旧数组中的元素逐个复制到新数组中</p>
</li>
<li><p><strong>更新引用</strong>：将内部数组引用指向新的数组</p>
</li>
<li><p><strong>完成扩容</strong>：之后即可继续向列表中添加新元素</p>
</li>
</ol>
<p>扩容过程中涉及到<strong>数组复制和内存重新分配</strong>，是一个相对开销较大的操作。因此，在预计会添加大量元素的场景下，建议在构造 <code>ArrayList</code> 时指定初始容量，以减少扩容次数，提高性能</p>
<h2 id="9-CopyonWriteArraylist-是如何实现线程安全的？"><a href="#9-CopyonWriteArraylist-是如何实现线程安全的？" class="headerlink" title="9# CopyonWriteArraylist 是如何实现线程安全的？"></a>9# CopyonWriteArraylist 是如何实现线程安全的？</h2><p><code>CopyOnWriteArrayList</code> 是一种<strong>线程安全</strong>的列表实现，其核心思想是**：写时复制**（Copy-On-Write）。它的底层通过一个被 <code>volatile</code> 修饰的数组来保存数据，并结合 <code>ReentrantLock</code> 实现写操作的互斥，确保线程安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// 加锁，保证写操作互斥</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();               <span class="comment">// 获取当前数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;                    <span class="comment">// 原数组长度</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>); <span class="comment">// 创建新数组</span></span><br><span class="line">        newElements[len] = e;                         <span class="comment">// 添加新元素</span></span><br><span class="line">        setArray(newElements);                        <span class="comment">// 替换原数组引用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行写入操作时，首先获取当前的底层数组，然后创建一个长度为原数组长度加一的新数组，并将旧数组中的所有元素复制到新数组中。接着，将待添加的新元素放置到新数组的末尾位置。最后，将内部数组的引用更新为这个新数组。整个写入过程在加锁的保护下进行，确保在并发环境中写操作的互斥性和数据的一致性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于新数组是在写操作期间独立构建的，读操作始终访问旧数组，因此不会受到影响，实现了读写分离的线程安全策略。因为数组引用是 <code>volatile</code> 的，所以读取总是能看到最新或一致的有效数据</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="1-说说常见的-Map-集合？"><a href="#1-说说常见的-Map-集合？" class="headerlink" title="1# 说说常见的 Map 集合？"></a>1# 说说常见的 Map 集合？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1737437072655-fd232d5c-f89c-4d28-b2f2-a29f908ecaba.png" alt="Map 集合"></p>
<p><strong>非线程安全</strong>：</p>
<ul>
<li><p><code>HashMap</code>：最常用的 <code>Map</code> 实现，key 无序、唯一，value 可重复。JDK 1.8 之前底层是<strong>数组 + 链表</strong>结构，使用<strong>拉链法</strong>解决哈希冲突；JDK 1.8 之后，当单个桶中的链表长度超过阈值（默认 8），链表将转为<strong>红黑树</strong>以提高性能。<code>HashMap</code> 是非线程安全的，在多线程环境下，当多个线程同时对 <code>HashMap</code> 进行操作时，可能会导致数据不一致或出现死循环等问题</p>
</li>
<li><p><code>LinkedHashMap</code>：是 <code>HashMap</code> 的子类，底层在 <code>HashMap</code> 基础上添加了<strong>双向链表</strong>，以维护插入顺序或访问顺序。可以通过构造函数设置为按<strong>访问顺序排序</strong>，常用于实现 LRU 缓存。由于它继承自<code>HashMap</code>，在多线程并发访问时，同样会出现与<code>HashMap</code>类似的线程安全问题</p>
</li>
<li><p><code>TreeMap</code>：是基于红黑树实现的<code>Map</code>，它可以对键进行排序，默认按照自然顺序排序，也可以通过指定的比较器进行排序。<code>TreeMap</code> 是非线程安全的，在多线程环境下，如果多个线程同时对 <code>TreeMap</code> 进行插入、删除等操作，可能会破坏红黑树的结构，导致数据不一致或程序出现异常</p>
</li>
</ul>
<p><strong>线程安全</strong>：</p>
<ul>
<li><code>HashTable</code>：较早的实现，底层为<strong>数组 + 链表</strong>，链表主要是为了解决哈希冲突。所有方法都使用 <code>synchronized</code> 修饰，线程安全但性能较差，已基本被 <code>ConcurrentHashMap</code> 替代</li>
<li><code>ConcurrentHashMap</code>：支持高并发访问的线程安全 <code>Map</code> 实现。JDK 1.8 以前使用 <strong>Segment 分段锁机制</strong>，将数据分成多个段（Segment），每个段都有自己的锁。在进行插入、删除等操作时，只需要获取相应段的锁，而不是整个 <code>Map</code> 的锁，这样可以允许多个线程同时访问不同的段，提高了并发访问的效率；JDK 1.8 后采用<strong>数组 + 链表 + 红黑树</strong>结构，并通过 <strong>CAS + synchronized</strong> 等机制实现更细粒度的并发控制，性能显著提升</li>
</ul>
<h2 id="2-如何对-Map-进行快速遍历？"><a href="#2-如何对-Map-进行快速遍历？" class="headerlink" title="2# 如何对 Map 进行快速遍历？"></a>2# 如何对 Map 进行快速遍历？</h2><ol>
<li><strong>使用 for-each 循环和 <code>entrySet()</code> 方法</strong>：这是一种较为常见和简洁的遍历方式，它可以同时获取 <code>Map</code> 中的键和值</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;Key: &quot;</span> + entry.getKey() + <span class="string">&quot;, Value: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>使用 for-each 循环和 <code>keySet()</code> 方法</strong>：只需要遍历 <code>Map</code> 中的键，这种方式相对简单，性能也较好</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;Key: &quot;</span> + key + <span class="string">&quot;, Value: &quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>使用迭代器</strong>：通过获取 <code>Map</code> 的 <code>entrySet()</code> 或 <code>keySet()</code> 的迭代器，也可以实现对 <code>Map</code> 的遍历，这种方式在需要删除元素等操作时比较有用</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">	Entry&lt;String, Integer&gt; entry = iterator.next();</span><br><span class="line">	System.out.println(<span class="string">&quot;Key: &quot;</span> + entry.getKey() + <span class="string">&quot;, Value: &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>使用 Lambda 表达式和 <code>forEach()</code> 方法</strong>：这种方式更加简洁和函数式</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; System.out.println(<span class="string">&quot;Key: &quot;</span> + key + <span class="string">&quot;, Value: &quot;</span> + value));</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>使用 Stream API</strong>：可以将 <code>Map</code> 转换为流，然后进行各种操作</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.entrySet().stream().forEach(entry -&gt; System.out.println(<span class="string">&quot;Key: &quot;</span> + entry.getKey() + <span class="string">&quot;, Value: &quot;</span> + entry.getValue()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以进行其他操作，如过滤、映射等</span></span><br><span class="line">Map&lt;String, Integer&gt; filteredMap = map.entrySet().stream()</span><br><span class="line">    .filter(entry -&gt; entry.getValue() &gt; <span class="number">1</span>)</span><br><span class="line">    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));</span><br><span class="line">System.out.println(filteredMap);</span><br></pre></td></tr></table></figure>



<h2 id="3-介绍一下-HashMap实现原理？"><a href="#3-介绍一下-HashMap实现原理？" class="headerlink" title="3# 介绍一下 HashMap实现原理？"></a>3# 介绍一下 HashMap实现原理？</h2><p>在 JDK 1.8 之前，<code>HashMap</code> 数据结构是<strong>数组和链表</strong>，<code>HashMap</code> 通过哈希算法将元素的键映射到数组中的槽位（Bucket）。如果多个键映射到同一个槽位，它们会以链表的形式存储在同一个槽位上，因为链表的查询时间是O(n)，所以冲突很严重，一个索引上的链表非常长，效率就很低了</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1719565480532-57a14329-c36b-4514-8e7d-2f2f1df88a82.webp" alt="Java7 HashMap 结构"></p>
<p>所以在 <strong>JDK 1.8</strong> 做了优化，当一个链表的长度超过 8 的时候就转换数据结构，不再使用链表存储，而是使用<strong>红黑树</strong>，查找时使用红黑树，时间复杂度O（log n），可以提高查询性能，但是在数量较少时，即数量小于 6 时，会将红黑树转换回链表</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1719565481289-0c2164f4-f755-46e3-bb39-b5f28621bb6b.webp" alt="Java8 HashMap 结构"></p>
<h2 id="4-哈希冲突的解决方式有哪些？"><a href="#4-哈希冲突的解决方式有哪些？" class="headerlink" title="4# 哈希冲突的解决方式有哪些？"></a>4# 哈希冲突的解决方式有哪些？</h2><ol>
<li><strong>链接法</strong>：使用链表或其他数据结构来存储冲突的键值对，将它们链接在同一个哈希桶中</li>
<li><strong>开放寻址法</strong>：在哈希表中找到另一个可用的位置来存储冲突的键值对，而不是存储在链表中。常见的开放寻址方法包括线性探测、二次探测和双重散列</li>
<li><strong>再哈希法（Rehashing）</strong>：当发生冲突时，使用另一个哈希函数再次计算键的哈希值，直到找到一个空槽来存储键值对</li>
<li><strong>哈希桶扩容</strong>：当哈希冲突过多时，可以动态地扩大哈希桶的数量，重新分配键值对，以减少冲突的概率</li>
</ol>
<h2 id="5-HashMap-是线程安全的吗？"><a href="#5-HashMap-是线程安全的吗？" class="headerlink" title="5# HashMap 是线程安全的吗？"></a>5# HashMap 是线程安全的吗？</h2><p><code>HashMap</code> 不是线程安全的，<code>HashMap</code> 在多线程会存在下面的问题：</p>
<ul>
<li>JDK 1.7 的 <code>HashMap</code> 采用<strong>数组 + 链表</strong>的数据结构，多线程背景下，在数组扩容的时候，有可能导致环形链表的出现，形成死循环</li>
<li>JDK 1.8 的 <code>HashMap</code> 采用<strong>数组 + 链表 + 红黑树</strong>的数据结构，优化了 1.7 中数组扩容的方案，使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。但是多线程同时执行 <code>put()</code> 方法，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失</li>
</ul>
<p>如果要保证线程安全，可以通过这些方法来保证：</p>
<ul>
<li>多线程环境可以使用 <code>Collections.synchronizedMap</code> 同步加锁的方式，还可以使用 <code>HashTable</code>，但是同步的方式显然性能不达标，而 <code>ConcurrentHashMap </code> 更适合高并发场景使用</li>
<li><code>ConcurrentHashMap</code> 在 JDK 1.7 和 1.8 的版本改动比较大，1.7 使用 <strong>Segment + HashEntry</strong> 分段锁的方式实现，1.8 则抛弃了 Segment，改为使用 <strong>CAS + synchronized + Node</strong> 实现，同样也加入了红黑树，避免链表过长导致性能的问题</li>
</ul>
<h2 id="6-HashMap-的常见方法有哪些？"><a href="#6-HashMap-的常见方法有哪些？" class="headerlink" title="6# HashMap 的常见方法有哪些？"></a>6# HashMap 的常见方法有哪些？</h2><p><code>HashMap</code> 常用于存储和快速查找 <strong>键值对</strong> 数据。常见方法包括：</p>
<ol>
<li><code>put(K key, V value)</code>：添加或更新键值对</li>
<li><code>get(Object key)</code>：根据键获取对应的值</li>
<li><code>containsKey(Object key)</code>：判断某个键是否存在</li>
<li><code>remove(Object key)</code>：移除指定键的键值对</li>
<li><code>keySet()</code>、<code>values()</code>、<code>entrySet()</code>：遍历键、值或整个映射项</li>
</ol>
<h2 id="7-讲一下-HashMap-的-put-过程"><a href="#7-讲一下-HashMap-的-put-过程" class="headerlink" title="7# 讲一下 HashMap 的 put 过程"></a>7# 讲一下 HashMap 的 put 过程</h2><img src="https://cdn.xiaolincoding.com//picgo/1720684054342-1e3cb2a9-532e-40b8-b5cf-0043811391dc.png" alt="HashMap 的 put 过程" style="zoom:67%;" />

<p>当调用 <code>put(key, value)</code> 向 <code>HashMap</code> 添加键值对时，会按以下步骤执行：</p>
<ol>
<li><p><strong>计算索引</strong></p>
<p>根据键的哈希码，通过扰动函数（hash 方法）计算出其在数组中的位置（桶索引）</p>
</li>
<li><p><strong>检查该位置是否为空</strong></p>
<ul>
<li>如果该位置为空（无碰撞），直接创建一个新节点存入该桶</li>
<li>修改计数器 <code>modCount</code>，以支持快速失败机制（fail-fast）</li>
</ul>
</li>
<li><p><strong>该位置已有节点（发生哈希冲突）</strong></p>
<ul>
<li><p>比较头节点的哈希值和键，若相同则直接替换其值</p>
</li>
<li><p>否则遍历链表或红黑树：</p>
<ul>
<li><p><strong>链表结构</strong>：遍历节点，比较键的 <code>equals()</code> 方法，若找到则替换；否则将新节点追加到链尾</p>
</li>
<li><p><strong>红黑树结构</strong>：使用哈希和键比较规则在树中查找，若找到则替换；否则插入为新节点</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>检查是否需要树化</strong><br> 如果该桶中链表长度 ≥ 8 且数组容量 ≥ 64，则将链表转换为红黑树，以提升查询效率。</p>
</li>
<li><p><strong>检查是否需要扩容</strong><br> 若当前键值对总数超过阈值（容量 × 负载因子，默认 0.75），则触发扩容。</p>
</li>
<li><p><strong>扩容操作</strong></p>
<ul>
<li><p>创建新数组，容量为原数组的 2 倍。</p>
</li>
<li><p>重新计算所有节点的索引位置，并迁移到新数组。</p>
</li>
<li><p>更新阈值与数组引用。</p>
</li>
</ul>
</li>
<li><p><strong>插入完成</strong><br> 最终完成键值对的添加，否则返回 <code>null</code></p>
</li>
</ol>
<h2 id="8-HashMap-的-put-key-val-和-get-key-过程"><a href="#8-HashMap-的-put-key-val-和-get-key-过程" class="headerlink" title="8# HashMap 的 put(key, val) 和 get(key) 过程"></a>8# HashMap 的 put(key, val) 和 get(key) 过程</h2><p><strong>插入数据（<code>put(key, value)</code>）时</strong>，<code>HashMap</code> 首先通过 <code>hashCode()</code> 方法计算哈希值，再根据哈希值定位到对应的桶位置。如果该位置为空，直接插入；如果已存在元素（哈希冲突），则通过链表或红黑树的方式将新节点插入其中。若元素数量超过负载因子（默认 0.75）与容量的乘积，<code>HashMap</code> 会触发扩容，通常为原容量的 2 倍</p>
<p><strong>查询数据（<code>get(key)</code>）时</strong>，同样根据 <code>hashCode()</code> 方法定位到桶，再遍历桶中节点（通过 <code>equals()</code> 判断键是否相等）以查找目标键值对。若该桶中的节点数超过阈值（默认 8），且总容量大于等于 64，链表将转化为红黑树，以提高查找效率</p>
<h2 id="9-HashMap-调用-get-方法一定安全吗？"><a href="#9-HashMap-调用-get-方法一定安全吗？" class="headerlink" title="9# HashMap 调用 get() 方法一定安全吗？"></a>9# HashMap 调用 get() 方法一定安全吗？</h2><p>并不，调用 <code>get()</code> 方法有几点需要注意的地方：</p>
<ul>
<li><strong>空指针异常</strong>：如果你尝试用 <code>null</code> 作为键调用 <code>get()</code> 方法，而 <code>HashMap</code> 没有被初始化（即为 <code>null</code>），那么会抛出空指针异常。不过，如果 <code>HashMap</code> 已经初始化，使用 <code>null</code> 作为键是允许的，因为 <code>HashMap</code> 支持 <code>null</code> 键</li>
<li><strong>线程安全</strong>：<code>HashMap</code> 本身不是线程安全的。如果在多线程环境中，没有适当的同步措施，同时对 <code>HashMap</code> 进行读写操作可能会导致不可预测的行为。例如，在一个线程中调用 <code>get()</code> 方法读取数据，而另一个线程同时修改了结构（如增加或删除元素），可能会导致读取操作得到错误的结果或抛出 <code>ConcurrentModificationException</code>。如果需要在多线程环境中使用类似 <code>HashMap</code> 的数据结构，可以考虑使用 <code>ConcurrentHashMap</code></li>
</ul>
<h2 id="10-为什么-String-适合作为HashMap-的-key？"><a href="#10-为什么-String-适合作为HashMap-的-key？" class="headerlink" title="10# 为什么 String 适合作为HashMap 的 key？"></a>10# 为什么 String 适合作为HashMap 的 key？</h2><p>因为 <code>String</code> 对象是不可变的，一旦创建就不能被修改，这确保了 key 的稳定性。如果 key 是可变的，可能会导致 <code>hashCode</code> 和 <code>equals()</code> 方法的不一致，进而影响 <code>HashMap</code> 的正确性</p>
<h2 id="11-为什么-HashMap-要用红黑树而不是平衡二叉树？"><a href="#11-为什么-HashMap-要用红黑树而不是平衡二叉树？" class="headerlink" title="11# 为什么 HashMap 要用红黑树而不是平衡二叉树？"></a>11# 为什么 HashMap 要用红黑树而不是平衡二叉树？</h2><p>平衡二叉树追求的是一种 <strong>“完全平衡”</strong> 状态：任何结点的左右子树的高度差不会超过 1，优势是树的结点是很平均分配的。这个要求实在是太严了，导致每次进行插入&#x2F;删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过<strong>左旋</strong>和<strong>右旋</strong>来进行调整，使之再次成为一颗符合要求的平衡树 1</p>
<p>红黑树不追求这种完全平衡状态，而是追求一种 <strong>“弱平衡”</strong> 状态：整个树最长路径不会超过最短路径的 2 倍。优势是虽然牺牲了一部分查找的性能效率，但是能够换取一部分维持树平衡状态的成本。与平衡树不同的是，红黑树在插入、删除等操作，<strong>不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整</strong>，这也是我们为什么大多数情况下使用红黑树的原因</p>
<h2 id="12-HashMap-的-key-可以为-null-吗？"><a href="#12-HashMap-的-key-可以为-null-吗？" class="headerlink" title="12# HashMap 的 key 可以为 null 吗？"></a>12# HashMap 的 key 可以为 null 吗？</h2><p><strong>可以</strong></p>
<p><code>HashMap</code> 中使用 <code>hash()</code> 方法来计算 key 的哈希值，当 key 为空时，哈希值为 0，不走 <code>key.hashCode()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>HashMap</code> 虽然支持 key 和 value 为 <code>null</code>，但是 <code>null</code> 作为 key 只能有一个， <code>null</code> 作为 value 可以有多个</p>
<h2 id="13-重写-HashMap-的-equals-和-hashCode-方法需要注意什么？"><a href="#13-重写-HashMap-的-equals-和-hashCode-方法需要注意什么？" class="headerlink" title="13# 重写 HashMap 的 equals() 和 hashCode() 方法需要注意什么？"></a>13# 重写 HashMap 的 equals() 和 hashCode() 方法需要注意什么？</h2><p>在使用 <code>HashMap</code> 时，键对象的 <code>hashCode()</code> 和 <code>equals()</code> 方法起着决定性作用：</p>
<ul>
<li><code>hashCode()</code> 用于确定键值对在哈希表中的存储位置（即桶的位置）</li>
<li><code>equals()</code> 用于在哈希冲突时，判断两个键是否 “真正相等”</li>
</ul>
<p>当我们向 <code>HashMap</code> 中存入或读取数据时，会先调用键的 <code>hashCode()</code> 方法定位桶，再通过 <code>equals()</code> 判断桶中是否已存在相同的键。如果这两个方法没有被正确重写：</p>
<ul>
<li>可能导致不同的键被误认为相同，从而覆盖原有的数据（没有正确重写 <code>equals()</code> 方法）</li>
<li></li>
<li>或者导致相同的键被误认为不同，存储在不同位置，无法正确获取（没有正确重写 <code>hashCode()</code> 方法）</li>
</ul>
<p>此外，所有基于哈希结构、不允许键重复的集合类（如 <code>HashSet</code>）也依赖这两个方法判断元素的唯一性</p>
<p>重写时必须遵循 Java 规范中规定的以下契约：</p>
<ul>
<li>如果 <code>o1.equals(o2)</code> 为 <code>true</code>，那么 <code>o1.hashCode() == o2.hashCode()</code> 必须也为 <code>true</code></li>
<li>如果 <code>o1.hashCode() == o2.hashCode()</code>，并不要求 <code>o1.equals(o2)</code> 一定为 <code>true</code></li>
</ul>
<h2 id="14-介绍一下-HashMap-的扩容机制"><a href="#14-介绍一下-HashMap-的扩容机制" class="headerlink" title="14# 介绍一下 HashMap 的扩容机制"></a>14# 介绍一下 HashMap 的扩容机制</h2><p><code>HashMap</code> 的默认负载因子是 <strong>0.75</strong>，也就是说，当哈希表中元素数量超过总容量的 75% 时，就会触发扩容操作。扩容主要包括两个步骤：</p>
<ol>
<li><strong>扩展数组容量为原来的 2 倍</strong></li>
<li><strong>将旧数组中的元素重新映射到新数组中（即重新分配位置）</strong></li>
</ol>
<p>因为 <code>HashMap</code> 使用的是 <strong>2 次幂</strong>的扩展，所以，元素在新数组中的位置，要么与原位置相同，要么是在原位置再移动 2 次幂</p>
<p>例如，从 16 扩展为 32 时，具体的变化如下所示：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1713514753772-9467a399-6b18-4a47-89d4-957adcc53cc0.webp" alt="img"></p>
<p>在计算桶索引时，<code>HashMap</code> 使用 <code>(n - 1) &amp; hash</code> 来定位元素。扩容时，数组长度 <code>n</code> 变为原来的两倍，n - 1 的二进制表示会在高位多出一个 1，因此新的索引就会发生这样的变化：</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1713514753786-cdca10bf-6eda-47f9-9bbe-0cc3beb67d76.webp" alt="img"></p>
<p>因此我们只需观察原哈希值中的这个新 bit：如果该 bit 是 0，元素在新数组中的位置不变；如果该 bit 是 1，元素的新位置 &#x3D; 原位置 + oldCap</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1713514753885-d1529537-322c-49b1-beec-5d9953da5150.webp" alt="img"></p>
<p>这意味着<strong>不需要重新计算 hash 值</strong>，只需简单地判断一个 bit 位即可完成重新分配，极大提升了扩容效率。同时，由于新增的 bit 是 0 还是 1 可以认为是随机的，<strong>原先冲突的元素更均匀地分布到了新的桶中</strong>，从而提升了查找性能</p>
<h2 id="15-为什么-HashMap-的容量是-2-的幂次方？"><a href="#15-为什么-HashMap-的容量是-2-的幂次方？" class="headerlink" title="15# 为什么 HashMap 的容量是 2 的幂次方？"></a>15# 为什么 HashMap 的容量是 2 的幂次方？</h2><p>在 JDK 1.7 中，<code>HashMap</code> 扩容时，会遍历旧数组中的每个元素，并根据它们的 hash 值重新计算在新数组中的位置。这些元素通常以链表形式存储。当链表中的元素被转移到新数组时，会根据新数组容量重新计算索引位置。由于遍历是从链表头节点开始，重新插入时顺序发生变化，原本在尾部的元素可能被移到新链表的头部</p>
<p>到了 JDK 1.8，<code>HashMap</code> 的扩容过程做了优化，避免了重新计算完整的 hash 值。扩容时数组长度总是原来的两倍（即左移一位），因此可以通过 <strong>hash 值中新增的那一位是否为 1</strong>，来判断元素的新位置：</p>
<ul>
<li>如果该位为 <code>0</code>，则元素在新数组中的索引与原索引相同</li>
<li>如果该位为 <code>1</code>，则元素的新索引为 <code>原索引 + oldCap</code></li>
</ul>
<p>这依赖于 <code>HashMap</code> 中定位桶的位置是通过 <code>index = (n - 1) &amp; hash</code> 计算的。当 <code>n</code> 是 2 的幂次方时，这个与运算可以高效地代替取模操作，同时保证索引分布的均匀性</p>
<h2 id="16-往-HashMap-存入-20-个元素，会扩容几次？"><a href="#16-往-HashMap-存入-20-个元素，会扩容几次？" class="headerlink" title="16# 往 HashMap 存入 20 个元素，会扩容几次？"></a>16# 往 HashMap 存入 20 个元素，会扩容几次？</h2><p>总共会触发 <strong>一次扩容操作</strong>。在默认情况下，<code>HashMap</code> 的初始容量为 16，负载因子为 0.75。也就是说，当元素个数超过 <code>16 × 0.75 = 12</code> 时，就会触发扩容操作：</p>
<ul>
<li><strong>初始容量：16</strong><ul>
<li>插入第 1 到第 12 个元素时，不会触发扩容；</li>
<li>插入第 13 个元素时，超过负载因子阈值（12），触发扩容，容量翻倍为 32。</li>
</ul>
</li>
<li><strong>扩容后容量：32</strong><ul>
<li>插入第 14 到第 20 个元素时，元素总数仍未超过 <code>32 × 0.75 = 24</code>，因此不会再次扩容。</li>
</ul>
</li>
</ul>
<h2 id="17-说说-HashMap-的负载因子"><a href="#17-说说-HashMap-的负载因子" class="headerlink" title="17# 说说 HashMap 的负载因子"></a>17# 说说 HashMap 的负载因子</h2><p><code>HashMap</code> 的负载因子（<code>loadFactor</code>）默认值为 <strong>0.75</strong>，表示当元素个数超过当前容量的 75% 时，就会触发扩容操作</p>
<p>这个默认值是在 <strong>时间效率和空间利用率之间取得的权衡</strong></p>
<ul>
<li>如果负载因子设置过低，会导致哈希表中存在大量空桶，浪费内存空间；</li>
<li>如果设置过高，会增加哈希冲突的概率，导致查找效率下降。</li>
</ul>
<p><strong>0.75</strong> 是在实际使用中得出的一个经验值，能够在 <strong>减少冲突次数</strong> 和 <strong>节省空间成本</strong> 之间实现较好的平衡</p>
<h2 id="18-ConcurrentHashMap-怎么实现的？"><a href="#18-ConcurrentHashMap-怎么实现的？" class="headerlink" title="18# ConcurrentHashMap 怎么实现的？"></a>18# ConcurrentHashMap 怎么实现的？</h2><p><strong>ConcurrentHashMap 的两代实现思路</strong></p>
<table>
<thead>
<tr>
<th>JDK 版本</th>
<th>主要结构</th>
<th>加锁策略</th>
<th>冲突链</th>
<th>典型特征</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1.7</strong></td>
<td><strong>Segment 数组</strong> → Segment 内部 <strong>HashEntry 数组 + 链表</strong></td>
<td>每个 Segment 一把 <code>ReentrantLock</code>（分段锁）</td>
<td>单向链表</td>
<td>锁粒度 &#x3D; Segment，最大并发度 &#x3D; Segment 数</td>
</tr>
<tr>
<td><strong>1.8</strong></td>
<td><strong>Node 数组</strong> → 单个桶为 <strong>链表 &#x2F; 红黑树</strong></td>
<td>① 首次初始化和扩容：<code>CAS</code> + <code>synchronized</code>② 桶内插入&#x2F;替换：给桶头节点加 <code>synchronized</code></td>
<td>链表 → 长度 ≥ 8 时且容量 ≥ 64 转红黑树</td>
<td>锁粒度 &#x3D; 单个桶头节点，并发更高；查询 O(1)&#x2F;O(log n)</td>
</tr>
</tbody></table>
<p><strong>一、JDK 1.7：Segment‑Lock 方案</strong></p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1721807523151-41ad316a-6264-48e8-9704-5b362bc0083c.webp" alt="JDK 1.7 ConcurrentHashMap"></p>
<ol>
<li><strong>数据分段</strong>：整个表被切分为若干 Segment，每段内部维护一个 <code>HashEntry[]</code>（桶数组）</li>
<li><strong>分段加锁</strong>：线程操作键值对时，只需竞争目标 Segment 的 <code>ReentrantLock</code>，其它 Segment 可并行访问</li>
<li><strong>缺点</strong>：Segment 数固定，极端高并发下仍存在锁争用。桶内冲突仅靠<strong>链表</strong>，数据量大时查找性能 O(n)</li>
</ol>
<hr>
<p><strong>二、JDK 1.8：CAS + Node + 红黑树</strong></p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1721807523128-7b1419e7-e6ba-47e6-aba0-8b29423a8ce7.webp" alt="JDK 1.8 ConcurrentHashMap"></p>
<ol>
<li><strong>取消 Segment</strong>：直接对头结点加锁来保证线程安全的，锁的粒度相比 Segment 来说更小了，发生冲突和加锁的频率降低了，并发操作的性能就提高了</li>
<li><strong>初始化 &amp; 扩容</strong>：采用 <strong>volatile + CAS</strong> 竞争表头，少量线程失败后退让，再由 “领头线程” 使用 <code>synchronized</code> 完成初始化&#x2F;迁移</li>
<li><strong>插入流程</strong><ul>
<li>计算索引 idx，判断桶是否为空</li>
<li>桶为空：CAS 直接放节点</li>
<li>桶非空：对桶头节点加 <code>synchronized</code>，遍历链表 &#x2F; 红黑树，并替换或追加节点，最后再判断是否需要转为红黑树（链表长度 ≥ 8 且容量 ≥ 64 → 树化）</li>
</ul>
</li>
<li><strong>优点</strong><ul>
<li><strong>锁粒度更小</strong>：仅锁冲突桶的头节点</li>
<li><strong>查询性能提升</strong>：链表转为红黑树后，桶内查找由 O(n) → O(log n)</li>
<li><strong>更高并发度</strong>：大量场景下只用 CAS，无显式锁</li>
</ul>
</li>
</ol>
<h2 id="19-分段锁是如何加锁的？"><a href="#19-分段锁是如何加锁的？" class="headerlink" title="19# 分段锁是如何加锁的？"></a>19# 分段锁是如何加锁的？</h2><p>在 <strong>JDK 1.7 的 ConcurrentHashMap</strong> 中，采用了一种叫作 <strong>分段锁（Segment Lock）</strong> 的机制来实现线程安全</p>
<p>整个 <code>ConcurrentHashMap</code> 被划分为多个 <strong>Segment</strong>，每个 Segment 本质上就是一个小型的 <code>HashMap</code>，并配有一把独立的锁。这样一来，多个线程只要访问的是不同的 Segment，就可以<strong>并发地进行读写操作</strong>，无需互相等待，从而大大提升了并发性能</p>
<p>当执行插入、更新或删除操作时，<code>ConcurrentHashMap</code> 首先会根据 key 的 hash 定位到对应的 Segment，然后<strong>只对这个 Segment 加锁</strong>，而不是对整个 Map 加锁。这种粒度更细的加锁方式，相比传统的全表锁（如 <code>Hashtable</code> 中的 <code>synchronized</code> 方法），性能提升非常明显</p>
<h2 id="20-分段锁是可重入的吗？"><a href="#20-分段锁是可重入的吗？" class="headerlink" title="20# 分段锁是可重入的吗？"></a>20# 分段锁是可重入的吗？</h2><p>在 <strong>JDK 1.7 的 ConcurrentHashMap</strong> 中，分段锁是通过 <strong>ReentrantLock（可重入锁）</strong> 实现的。也就是说，每个 Segment 内部维护了一把 ReentrantLock，使得同一个线程在未释放锁的情况下，可以多次获取同一把锁而不会发生死锁。这种设计既保证了线程安全，又提高了灵活性</p>
<h2 id="21-已经用了-synchronized，为什么还要用-CAS-呢？"><a href="#21-已经用了-synchronized，为什么还要用-CAS-呢？" class="headerlink" title="21# 已经用了 synchronized，为什么还要用 CAS 呢？"></a>21# 已经用了 synchronized，为什么还要用 CAS 呢？</h2><p>在 <code>ConcurrentHashMap</code> 中，<strong>CAS 和 synchronized 是互补使用的</strong>，目的是在不同的并发场景下权衡性能与安全性</p>
<p>例如，在 <code>putVal()</code> 方法中，如果计算出的桶（槽）位置为空，也就是说没有发生哈希冲突，那么就会尝试使用 <strong>CAS（无锁操作）</strong> 来插入新节点。由于哈希值经过扰动处理后冲突概率较低，这种情况下通过少量自旋即可完成插入操作，<strong>避免了加锁的开销</strong>，性能更高</p>
<p>而当发生哈希冲突、桶中已有节点时，说明当前桶出现竞争或者数据较多，此时再使用 CAS 会导致频繁失败和自旋，反而浪费资源。因此在这种场景下，<strong>ConcurrentHashMap 会退而使用 synchronized 来保证线程安全</strong>，处理冲突的链表或红黑树操作</p>
<p>总结来说：</p>
<ul>
<li><strong>无冲突时优先用 CAS，提高性能；</strong></li>
<li><strong>发生冲突时使用 synchronized，降低竞争消耗</strong></li>
</ul>
<h2 id="22-ConcurrentHashMap用了悲观锁还是乐观锁"><a href="#22-ConcurrentHashMap用了悲观锁还是乐观锁" class="headerlink" title="22# ConcurrentHashMap用了悲观锁还是乐观锁?"></a>22# ConcurrentHashMap用了悲观锁还是乐观锁?</h2><p><strong>ConcurrentHashMap 同时使用了乐观锁和悲观锁，依据场景选择不同的并发策略，以实现性能与线程安全之间的平衡</strong></p>
<p>在添加元素（<code>put</code> 操作）时，其执行流程如下：</p>
<ol>
<li><strong>初始化阶段</strong>：</li>
</ol>
<p>  如果表为空，使用 <code>volatile</code> 配合 <strong>CAS（乐观锁）</strong> 来初始化桶数组</p>
<ol start="2">
<li><strong>定位桶位时</strong>：<br> 如果目标位置（槽位）为空，尝试使用 <strong>CAS（乐观锁）</strong> 直接将节点插入该位置，无需加锁</li>
<li><strong>发生哈希冲突时</strong>：<br> 如果目标位置已有其他节点（发生哈希碰撞），则使用 <strong><code>synchronized</code>（悲观锁）</strong> 加锁处理。在锁定的情况下，会遍历链表或红黑树，更新或新增节点，并在必要时判断是否需要将链表转为红黑树，以提升性能</li>
</ol>
<h2 id="23-HashTable-底层实现原理是什么？"><a href="#23-HashTable-底层实现原理是什么？" class="headerlink" title="23# HashTable 底层实现原理是什么？"></a>23# HashTable 底层实现原理是什么？</h2><img src="https://cdn.xiaolincoding.com//picgo/1719982934770-8587cb0a-6e1d-4007-9a22-bc1e41276491.png" alt="HashTable 原理" style="zoom: 50%;" />

<ul>
<li>Hashtable 底层主要由<strong>数组 + 链表</strong>组成，数组负责存储数据，而链表用来解决哈希冲突</li>
<li>为了保证线程安全，Hashtable 中所有的公共方法都使用了 <code>synchronized</code> 关键字进行同步。当一个线程访问同步方法时，其他线程如果也想访问这些方法，就会被阻塞，直到锁被释放</li>
</ul>
<h2 id="24-HashTable-线程安全是怎么实现的？"><a href="#24-HashTable-线程安全是怎么实现的？" class="headerlink" title="24# HashTable 线程安全是怎么实现的？"></a>24# HashTable 线程安全是怎么实现的？</h2><p><code>Hashtable</code> 之所以线程安全，是因为其所有涉及数据访问的方法（如 <code>put</code>、<code>get</code> 等）都使用了 <code>synchronized</code> 关键字进行同步控制。这意味着，在任何时刻，<strong>只能有一个线程对整个 Hashtable 实例进行操作</strong>，从而保证了线程安全性，但也带来了性能瓶颈</p>
<p>源码示例（以 <code>put()</code> 和 <code>get()</code> 方法为例）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;?,?&gt;[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">    <span class="keyword">for</span> (; entry != <span class="literal">null</span>; entry = entry.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.hash == hash &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;?,?&gt;[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (V) e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，<code>Hashtable</code> 通过给整个方法加上 <code>synchronized</code>，确保了多线程环境下的可见性与互斥访问</p>
<p><strong>同步机制说明</strong></p>
<p>在 Java 中，<code>synchronized</code> 是一种内置锁机制。它可以修饰方法或代码块，当一个线程进入 <code>synchronized</code> 方法或代码块时，会独占该对象的锁，其他线程只能等待该锁被释放后才能继续执行</p>
<p>这种做法虽然简单直接，但由于<strong>锁粒度较大（作用于整个对象），并发性能相对较低</strong>。因此在高并发场景下，<code>Hashtable</code> 逐渐被 <code>ConcurrentHashMap</code> 等更高效的并发容器取代</p>
<h2 id="25-HashTable-和-ConcurrentHashMap-有什么区别？"><a href="#25-HashTable-和-ConcurrentHashMap-有什么区别？" class="headerlink" title="25# HashTable 和 ConcurrentHashMap 有什么区别？"></a>25# HashTable 和 ConcurrentHashMap 有什么区别？</h2><p><strong>底层数据结构</strong></p>
<ul>
<li><strong>ConcurrentHashMap</strong><ul>
<li>JDK 1.7，采用 <strong>分段锁机制（Segment）+ 数组 + 链表</strong> 的结构。整个 Map 被划分为多个 Segment，每个 Segment 内部是一个小的 <code>HashMap</code>，具备独立锁</li>
<li>JDK 1.8 及以后，移除了 Segment，使用 <strong>数组 + 链表 + 红黑树</strong> 实现，结构与 <code>HashMap</code> 类似。链表过长（超过 8 个元素）时转为红黑树以提升查询效率</li>
</ul>
</li>
<li><strong>HashTable</strong><ul>
<li>始终采用 <strong>数组 + 链表</strong> 的结构，数组是主体，链表用于处理哈希冲突</li>
</ul>
</li>
</ul>
<p><strong>实现线程安全的方式</strong></p>
<ul>
<li><strong>ConcurrentHashMap</strong><ul>
<li><strong>JDK 1.7</strong>：通过 <strong>分段锁（Segment + ReentrantLock）</strong> 实现部分同步，锁粒度小，多个线程可并发访问不同的 Segment，提升并发性能</li>
<li><strong>JDK 1.8</strong>：采用 <strong>CAS（乐观锁） + synchronized（悲观锁）</strong> 结合的方式实现更细粒度的同步控制：<ul>
<li>桶位为空时，用 CAS 插入节点</li>
<li>桶位非空（发生哈希冲突）时，用 <code>synchronized</code> 加锁处理</li>
<li>结构中引入红黑树，优化了链表查询性能</li>
</ul>
</li>
</ul>
</li>
<li><strong>HashTable</strong><ul>
<li>所有方法都使用了 <code>synchronized</code> 关键字，属于<strong>粗粒度锁</strong>，整个对象在同一时刻只能被一个线程访问，线程安全但效率低下</li>
</ul>
</li>
</ul>
<h2 id="26-HashMap、HashTable-和-ConcurrentHashMap-的区别"><a href="#26-HashMap、HashTable-和-ConcurrentHashMap-的区别" class="headerlink" title="26# HashMap、HashTable 和 ConcurrentHashMap 的区别"></a>26# HashMap、HashTable 和 ConcurrentHashMap 的区别</h2><p><strong>HashMap</strong></p>
<ul>
<li><strong>线程不安全</strong>，但性能较高，适合单线程或线程安全有保障的场景</li>
<li>允许一个 <code>null</code> key 和多个 <code>null</code> value</li>
<li>默认初始容量为 <strong>16</strong>，扩容时按 <strong>2 的倍数增长</strong></li>
<li>如果用户指定初始容量，内部会将其调整为 <strong>最接近且大于该值的 2 的幂次方</strong></li>
<li><strong>底层结构</strong>：数组 + 链表（JDK 1.8 以后引入红黑树），当链表长度超过阈值（默认为 8），并且数组长度大于 64 时，会将链表转换为 <strong>红黑树</strong>，以提升查询效率；若数组长度不够，则优先选择扩容</li>
</ul>
<p><strong>HashTable</strong></p>
<ul>
<li><strong>线程安全</strong>，但效率低，<strong>所有公共方法都使用 <code>synchronized</code> 修饰</strong>，属于<strong>粗粒度锁</strong>。</li>
<li>不允许 <code>null</code> 的 key 和 value</li>
<li>默认初始容量为 <strong>11</strong>，扩容时容量变为 <code>2n + 1</code></li>
<li>创建时如果指定容量，就直接使用该容量（不会调整为 2 的幂次方）</li>
<li><strong>底层结构</strong>：数组 + 链表，用于解决哈希冲突</li>
<li>已逐渐被淘汰，如需线程安全更推荐使用 <strong><code>ConcurrentHashMap</code></strong></li>
</ul>
<p><strong>ConcurrentHashMap</strong></p>
<ul>
<li><strong>线程安全</strong>，性能优于 <code>HashTable</code>，适合高并发场景</li>
<li>不允许 <code>null</code> 的 key 或 value（防止空值导致歧义）</li>
<li><strong>JDK 1.7 实现</strong>：基于 <strong>分段锁（Segment）</strong>，将哈希表分为若干段，每段维护自己的锁，多个线程可同时访问不同段，提高并发性</li>
<li><strong>JDK 1.8 实现</strong>：移除了 Segment，改为使用 <strong>CAS（乐观锁）+ synchronized（悲观锁）</strong> 的组合方式进行细粒度同步<ul>
<li>使用 <strong>CAS</strong> 插入空桶节点，避免加锁</li>
<li>若发生哈希冲突，再使用 <strong>synchronized</strong> 锁定桶进行处理</li>
<li>链表过长时转为 <strong>红黑树</strong>，提升查询效率</li>
</ul>
</li>
<li>读操作在多数情况下是无锁的，性能更优</li>
</ul>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="1-Set-集合有什么特点？如何实现-key-无重复的？"><a href="#1-Set-集合有什么特点？如何实现-key-无重复的？" class="headerlink" title="1# Set 集合有什么特点？如何实现 key 无重复的？"></a>1# Set 集合有什么特点？如何实现 key 无重复的？</h2><p><strong>Set 的特点</strong></p>
<p>Set 集合用于存储<strong>不重复的元素</strong>，<strong>不保证元素的顺序</strong>（具体顺序取决于其具体实现，例如 <code>HashSet</code>、<code>TreeSet</code>、<code>LinkedHashSet</code>）</p>
<p><strong>如何保证元素唯一性</strong></p>
<p>Set 是通过内部使用的 <strong>数据结构</strong> 来保证元素不重复的：</p>
<ul>
<li>对于 <code>HashSet</code>：底层基于 <strong>HashMap</strong> 实现，插入元素时会计算其 <code>hashCode()</code>，再通过 <code>equals()</code> 方法判断是否已经存在相同元素，若存在，则不会重复插入</li>
<li>对于 <code>TreeSet</code>：底层基于 <strong>红黑树（TreeMap）</strong> 实现，依赖元素的自然顺序或指定的 <code>Comparator</code> 来比较是否相等</li>
<li>对于 <code>LinkedHashSet</code>：底层是 <strong>HashMap + 双向链表</strong>，既保证了插入顺序，又保证了元素唯一性</li>
</ul>
<p>因此，Set 保证元素不重复，依赖的是 <code>hashCode()</code> 和 <code>equals()</code> 方法（哈希结构）或 <code>compareTo()</code> &#x2F; <code>Comparator</code>（排序结构）</p>
<h2 id="2-有序的-Set-是什么？记录插入顺序的集合是哪种？"><a href="#2-有序的-Set-是什么？记录插入顺序的集合是哪种？" class="headerlink" title="2# 有序的 Set 是什么？记录插入顺序的集合是哪种？"></a>2# 有序的 Set 是什么？记录插入顺序的集合是哪种？</h2><p><strong>有序的 Set</strong></p>
<ul>
<li><code>TreeSet</code> ：它基于<strong>红黑树</strong>实现，能够按照元素的<strong>自然顺序</strong>（或自定义的 <code>Comparator</code>）自动排序</li>
<li><code>LinkedHashSet</code> ：它基于 <strong>哈希表 + 双向链表</strong> 实现，保持的是<strong>元素的插入顺序</strong>，而非排序顺序</li>
</ul>
<p><strong>记录插入顺序的 Set</strong></p>
<ul>
<li><code>LinkedHashSet</code> 是专门用来记录插入顺序的 Set。它在保证元素不重复的同时，也能按照插入的顺序进行迭代访问</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>八股文笔记 #3 Java 并发</title>
    <url>/2025/07/03/boilerplate-answers-3-java-concurrent/</url>
    <content><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="1-Java-的线程和操作系统的线程一样吗？"><a href="#1-Java-的线程和操作系统的线程一样吗？" class="headerlink" title="1# Java 的线程和操作系统的线程一样吗？"></a>1# Java 的线程和操作系统的线程一样吗？</h2><p>是的，Java 中的线程本质上与操作系统的线程是一致的</p>
<img src="https://cdn.xiaolincoding.com//picgo/image-20240725230425385.png" alt="Java 线程" style="zoom: 25%;" />

<span id="more"></span>

<p>在现代 JVM（如 HotSpot）中，Java 使用的是 <strong>一对一的线程模型</strong>，即每创建一个 Java 线程，JVM 底层都会调用操作系统的 API（如 Linux 下的 <code>pthread_create</code>）来创建一个 <strong>原生线程</strong></p>
<p>因此，Java 线程与操作系统线程是 <strong>一一对应</strong> 的，拥有独立的调用栈、程序计数器等资源，由操作系统负责调度和管理</p>
<p>这种设计使得 Java 能够充分利用多核 CPU 的并发能力，同时也意味着 Java 线程的性能和行为，受到操作系统线程调度策略的影响</p>
<h2 id="2-使用多线程要注意哪些问题？"><a href="#2-使用多线程要注意哪些问题？" class="headerlink" title="2# 使用多线程要注意哪些问题？"></a>2# 使用多线程要注意哪些问题？</h2><p>在使用多线程编程时，最关键的是确保<strong>线程安全</strong>，避免由于<strong>数据竞争</strong>导致的数据不一致、程序行为异常等问题</p>
<p>Java 中的线程安全主要体现在以下三个方面：</p>
<ol>
<li><strong>原子性</strong>：原子性保证<strong>某个操作在执行过程中不会被其他线程打断</strong>，即<strong>同一时刻只能有一个线程对共享数据进行修改</strong>。可以通过以下方式保障原子性<ul>
<li>使用 <code>synchronized</code> 关键字对代码块或方法加锁</li>
<li>使用 <code>java.util.concurrent.atomic</code> 包下的原子类（如 <code>AtomicInteger</code>、<code>AtomicReference</code>）来进行原子操作</li>
</ul>
</li>
<li><strong>可见性</strong>：可见性指的是<strong>一个线程对共享变量的修改能够及时地被其他线程看到</strong>。 Java 中通过以下机制保证可见性<ul>
<li><code>synchronized</code> 隐含地保证了进入和退出临界区时的内存刷新</li>
<li><code>volatile</code> 关键字用于标记变量，确保对该变量的读写不会被线程本地缓存，从而强制线程从主内存读取</li>
</ul>
</li>
<li><strong>有序性</strong>：在多线程环境下，Java 编译器和 CPU 可能对指令进行<strong>重排序</strong>以优化性能，导致线程间看到的执行顺序不一致。Java 使用<strong>happens-before 原则</strong>来建立线程间操作的执行顺序关系，确保必要的有序性</li>
</ol>
<h2 id="3-保证数据的一致性有哪些方案呢？"><a href="#3-保证数据的一致性有哪些方案呢？" class="headerlink" title="3# 保证数据的一致性有哪些方案呢？"></a>3# 保证数据的一致性有哪些方案呢？</h2><p>在并发编程或分布式系统中，确保数据一致性是至关重要的。以下是常见的几种实现方案：</p>
<ol>
<li><p><strong>事务管理</strong>：事务遵循 ACID 原则，通过数据库事务机制，确保一组操作要么<strong>全部执行成功并提交</strong>，要么<strong>全部失败并回滚</strong>，从而保证数据在操作过程中的一致性</p>
<ul>
<li><p><strong>原子性</strong>：事务中的所有操作要么全部执行，要么全部不执行</p>
</li>
<li><p><strong>一致性</strong>：事务执行前后，数据库始终处于一致的状态</p>
</li>
<li><p><strong>隔离性</strong>：多个事务之间的操作互不干扰</p>
</li>
<li><p><strong>持久性</strong>：事务一旦提交，数据变更就是永久性的</p>
</li>
</ul>
</li>
<li><p><strong>锁机制</strong>：锁机制是一种<strong>悲观并发控制策略</strong>，适合冲突概率较高的场景。通过加锁可以控制多个线程对共享资源的访问，避免并发读写导致的数据不一致问题。可以使用 Java 的 <code>synchronized</code> 关键字、<code>ReentrantLock</code> 等显示锁或者读写锁（<code>ReadWriteLock</code>）等</p>
</li>
<li><p><strong>版本控制（乐观锁）</strong>：乐观锁适用于<strong>读多写少、冲突较少</strong>的场景，可以有效提高系统的吞吐量。通过乐观锁的方式，在更新数据时记录数据的版本信息，从而避免同时对同一数据进行修改，进而保证数据的一致性</p>
</li>
</ol>
<h2 id="4-线程的创建方式有哪些"><a href="#4-线程的创建方式有哪些" class="headerlink" title="4# 线程的创建方式有哪些?"></a>4# 线程的创建方式有哪些?</h2><p><del><strong>太长不看版</strong></del></p>
<table>
<thead>
<tr>
<th>方式</th>
<th>关键点</th>
<th>优点</th>
<th>局限</th>
</tr>
</thead>
<tbody><tr>
<td><strong>继承 <code>Thread</code></strong></td>
<td>重写 <code>run()</code>，调用 <code>start()</code></td>
<td>编写简单；<code>this</code> 即当前线程</td>
<td>已继承 <code>Thread</code>，无法再继承其他类，线程与任务代码强耦合</td>
</tr>
<tr>
<td><strong>实现 <code>Runnable</code></strong></td>
<td>实现 <code>run()</code>，包装进 <code>Thread</code></td>
<td>可继承其它父类；多个线程可共享同一任务对象</td>
<td>需用 <code>Thread.currentThread()</code> 取当前线程；无返回值</td>
</tr>
<tr>
<td><strong>实现 <code>Callable</code> + <code>FutureTask</code></strong></td>
<td>实现 <code>call()</code>，包装成 <code>FutureTask</code> 再交给 <code>Thread</code></td>
<td>任务可返回结果，可抛异常；多个线程可共享同一任务对象</td>
<td>代码略复杂；同样需 <code>Thread.currentThread()</code></td>
</tr>
<tr>
<td><strong>线程池（<code>ExecutorService</code>）</strong></td>
<td>任务提交给池；池内部复用线程</td>
<td>复用线程、限制并发、便于管理</td>
<td>参数配置不当易导致资源耗尽或死锁；调优、排错复杂</td>
</tr>
</tbody></table>
<ol>
<li><p><strong>继承 <code>Thread</code></strong>：这是最直接的一种方式，用户自定义类继承 <code>java.lang.Thread</code> 类，需要重写 <code>run()</code> 方法，<code>run()</code> 方法中定义了线程执行的具体任务。创建该类的实例后，通过调用 <code>start()</code> 方法启动线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">/* 任务逻辑 */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：编写简单，如果需要访问当前线程，无需使用 <code>Thread.currentThread()</code> 方法，直接使用 <code>this</code>，即可获得当前线程</li>
<li>缺点：因为线程类已经继承了 <code>Thread</code> 类，所以不能再继承其他的父类</li>
</ul>
</li>
<li><p><strong>实现 <code>Runnable</code></strong>：如果一个类已经继承了其他类，就不能再继承 <code>Thread</code> 类，此时可以实现 <code>java.lang.Runnable</code> 接口，需要重写 <code>run()</code> 方法，然后将此 <code>Runnable</code> 对象作为参数传递给 <code>Thread</code> 类的构造器，调用 <code>start()</code> 方法启动线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">/* 任务逻辑 */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyTask</span>()).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：线程类只是实现了 <code>Runable</code> 接口，还可以继承其他的类。在这种方式下，可以多个线程共享同一个目标对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将 CPU 代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想</li>
<li>缺点：编程稍微复杂，如果需要访问当前线程，必须使用 <code>Thread.currentThread()</code> 方法</li>
</ul>
</li>
<li><p><strong>实现 <code>Callable</code> 接口 + <code>FutureTask</code></strong>：<code>java.util.concurrent.Callable</code> 接口类似于 <code>Runnable</code>，但 <code>Callable</code> 的 <code>call()</code> 方法可以有返回值并且可以抛出异常。要执行 <code>Callable</code> 任务，需将它包装进一个 <code>FutureTask</code>，因为 <code>Thread</code> 类的构造器只接受 <code>Runnable</code> 参数，而 <code>FutureTask</code> 实现了 <code>Runnable</code> 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCall</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyCall</span>());</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(ft).start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> ft.get();  <span class="comment">// 阻塞拿结果</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>缺点：编程稍微复杂，如果需要访问当前线程，必须调用 <code>Thread.currentThread()</code> 方法</li>
<li>优点：线程只是实现 <code>Runnable</code> 或实现 <code>Callable</code> 接口，还可以继承其他类。这种方式下，多个线程可以共享一个 target 对象，非常适合多线程处理同一份资源的情形</li>
</ul>
</li>
<li><p><strong>使用线程池（Executor 框架）</strong>：从 Java 5 开始引入的 <code>java.util.concurrent.ExecutorService</code> 和相关类提供了线程池的支持，这是一种更高效的线程管理方式，避免了频繁创建和销毁线程的开销。可以通过 <code>Executors</code> 类的静态方法创建不同类型的线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    pool.submit(() -&gt; &#123;<span class="comment">/* 任务逻辑 */</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>缺点：程池增加了程序的复杂度，特别是当涉及线程池参数调整和故障排查时。错误的配置可能导致死锁、资源耗尽等问题，这些问题的诊断和修复可能较为复杂</p>
</li>
<li><p>优点：线程池可以重用预先创建的线程，避免了线程创建和销毁的开销，显著提高了程序的性能。对于需要快速响应的并发请求，线程池可以迅速提供线程来处理任务，减少等待时间。并且，线程池能够有效控制运行的线程数量，防止因创建过多线程导致的系统资源耗尽（如内存溢出）。通过合理配置线程池大小，可以最大化 CPU 利用率和系统吞吐量</p>
</li>
</ul>
</li>
</ol>
<h2 id="5-如何启动线程-？"><a href="#5-如何启动线程-？" class="headerlink" title="5# 如何启动线程 ？"></a>5# 如何启动线程 ？</h2><p>在 Java 中，启动线程的标准方式是调用 <code>Thread</code> 类的 <strong><code>start()</code> 方法</strong>。该方法会通知 JVM 去创建一个新的线程，并由系统调度线程执行 <code>run()</code> 方法中定义的任务逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建两个线程，并使用 start() 启动它们</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"></span><br><span class="line">myThread1.start();  <span class="comment">// 启动线程1</span></span><br><span class="line">myThread2.start();  <span class="comment">// 启动线程2</span></span><br></pre></td></tr></table></figure>



<h2 id="6-如何停止线程"><a href="#6-如何停止线程" class="headerlink" title="6# 如何停止线程?"></a>6# 如何停止线程?</h2><p>停止线程应遵循 <strong>协作式</strong> 原则，既让线程 <strong>自行结束</strong>，又确保资源得到正确释放</p>
<p><del><strong>太长不看版</strong></del></p>
<table>
<thead>
<tr>
<th>#</th>
<th>停止方式</th>
<th>简要说明</th>
<th>场景适配性</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>volatile</code> 标志位控制循环</td>
<td>主线程控制标志，工作线程轮询判断是否退出</td>
<td>简单计算任务</td>
</tr>
<tr>
<td>2</td>
<td>使用 <code>interrupt()</code> + 判断中断状态</td>
<td>发送中断信号，由线程检查 <code>isInterrupted()</code> 响应退出</td>
<td>阻塞&#x2F;非阻塞任务</td>
</tr>
<tr>
<td>3</td>
<td>可中断阻塞操作（<code>sleep()</code> &#x2F; <code>wait()</code> &#x2F; <code>join()</code>）</td>
<td>阻塞时响应中断，捕获异常后安全退出</td>
<td>阻塞型任务</td>
</tr>
<tr>
<td>4</td>
<td>使用 <code>return</code> 提前结束 <code>run()</code> 方法</td>
<td>可配合中断或标志位，在逻辑判断处直接返回退出</td>
<td>控制逻辑明确</td>
</tr>
<tr>
<td>5</td>
<td>使用线程池 + <code>Future.cancel(true)</code></td>
<td>在线程池中通过 Future 中断任务</td>
<td>线程池管理的任务</td>
</tr>
<tr>
<td>6</td>
<td>关闭底层资源解除不可中断阻塞</td>
<td>关闭资源触发异常，中断无法生效的情况专用</td>
<td>I&#x2F;O、Socket 阻塞</td>
</tr>
<tr>
<td>7</td>
<td><code>Thread.stop()</code>（已废弃）</td>
<td>强制终止，风险极高，不建议使用</td>
<td>禁止使用</td>
</tr>
</tbody></table>
<ol>
<li><p><strong>使用 volatile 标志位控制循环退出</strong>：通过定义共享的 <code>volatile</code> 布尔变量，线程在 <code>run()</code> 中轮询该变量判断是否继续执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SafeStopFlag</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread exiting safely.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123; running = <span class="literal">false</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>interrupt()</code> + 判断中断状态</strong>：主线程调用 <code>interrupt()</code> 设置中断标志，线程通过 <code>isInterrupted()</code> 判断是否终止</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InterruptCheck</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="comment">// 正常执行逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread interrupted, exiting.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>处理中断异常：可中断阻塞操作（如 sleep&#x2F;wait&#x2F;join）</strong>：调用 <code>interrupt()</code> 后，线程在阻塞方法中抛出 <code>InterruptedException</code>，在异常处理中结束线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SleepInterruptDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>); <span class="comment">// 阻塞</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Interrupted during sleep.&quot;</span>);</span><br><span class="line">            Thread.currentThread().interrupt(); <span class="comment">// 恢复中断状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>return</code> 提前结束 <code>run()</code> 方法</strong>：配合中断标志或其他条件判断，在满足某条件时通过 <code>return</code> 直接结束 <code>run()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReturnEarlyDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 提前退出</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行任务逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线程池 + <code>Future.cancel(true)</code> 中断任务</strong>：将任务提交给线程池，通过 <code>Future.cancel(true)</code> 向线程发送中断信号来终止执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">Future&lt;?&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">future.cancel(<span class="literal">true</span>); <span class="comment">// 触发中断</span></span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>关闭资源解除不可中断阻塞（如 Socket.accept()）</strong>：对于不能响应中断的阻塞方法，通过关闭相关底层资源（如 <code>ServerSocket</code>）使其抛出异常退出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SocketTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerSocket server;</span><br><span class="line"></span><br><span class="line">    SocketTask(ServerSocket server) &#123; <span class="built_in">this</span>.server = server; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> server.accept(); <span class="comment">// 阻塞不可中断</span></span><br><span class="line">                <span class="comment">// 处理 socket</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Interrupted while blocked.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        server.close(); <span class="comment">// 触发 accept() 抛异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不推荐：使用 <code>Thread.stop()</code> 强制终止线程（已废弃）</strong>：直接停止线程执行，不会进行资源清理，存在严重安全隐患</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">/* 永久循环 */</span> &#125;</span><br><span class="line">&#125;);</span><br><span class="line">t.start();</span><br><span class="line">t.stop(); <span class="comment">// 已废弃，可能导致数据不一致</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="7-interrupt-是如何让线程抛出异常的"><a href="#7-interrupt-是如何让线程抛出异常的" class="headerlink" title="7# interrupt() 是如何让线程抛出异常的?"></a>7# interrupt() 是如何让线程抛出异常的?</h2><p>在 Java 中，每个线程都关联一个布尔类型的<strong>中断标志位</strong>，用于表示线程是否被中断。该标志的初始值为 <code>false</code>，可以通过调用线程的 <code>interrupt()</code> 方法将其设为 <code>true</code></p>
<p>当其他线程调用某个线程的 <code>interrupt()</code> 方法时，具体表现分为两种情况：</p>
<ul>
<li><p>如果线程<strong>处于阻塞状态</strong>：如果调用了 <code>Thread.sleep()</code>、<code>Thread.join()</code> 或 <code>Object.wait()</code> 等方法，则调用 <code>interrupt()</code> 会立即<strong>中断阻塞状态</strong>，并在该线程中<strong>抛出 <code>InterruptedException</code> 异常</strong>。此机制允许线程及时响应中断请求，跳出阻塞操作并执行善后处理</p>
</li>
<li><p>如果线程<strong>没有处于阻塞状态</strong>：此时调用 <code>interrupt()</code> 并不会抛出异常，仅仅是<strong>将中断标志设置为 <code>true</code></strong>。线程可以在运行过程中<strong>自行检查中断状态</strong>，例如通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.currentThread().isInterrupted();</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Thread.interrupted()) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>来自行决定是否退出当前任务，进行资源释放或中断处理</p>
</li>
</ul>
<h2 id="8-Java-线程的状态有哪些？"><a href="#8-Java-线程的状态有哪些？" class="headerlink" title="8# Java 线程的状态有哪些？"></a>8# Java 线程的状态有哪些？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1712648206670-824228d1-be28-449d-8509-fd4df4ff63d3.webp" alt="Java 线程状态变迁"></p>
<p>Java 中的线程状态由 <code>java.lang.Thread.State</code> 枚举类定义，总共有六种状态。你可以通过线程对象的 <code>getState()</code> 方法来获取当前线程所处的状态</p>
<table>
<thead>
<tr>
<th>线程状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>NEW</code></td>
<td>新建状态：线程对象已创建，但尚未调用 <code>start()</code> 方法，尚未启动执行</td>
</tr>
<tr>
<td><code>RUNNABLE</code></td>
<td>可运行状态：线程已调用 <code>start()</code>，处于<strong>就绪状态</strong>或<strong>正在运行</strong>中</td>
</tr>
<tr>
<td><code>BLOCKED</code></td>
<td>阻塞状态：线程尝试获取某个对象的监视器锁时被阻塞，等待锁的释放</td>
</tr>
<tr>
<td><code>WAITING</code></td>
<td>等待状态：线程无限期等待另一个线程执行某个操作（如 <code>notify()</code>）</td>
</tr>
<tr>
<td><code>TIMED_WAITING</code></td>
<td>超时等待状态：线程在指定时间内等待另一个线程的操作（如 <code>sleep()</code>、<code>join(long)</code>）</td>
</tr>
<tr>
<td><code>TERMINATED</code></td>
<td>终止状态：线程执行完毕或被异常中止，生命周期结束</td>
</tr>
</tbody></table>
<p><strong>补充说明</strong></p>
<ul>
<li><strong><code>RUNNABLE</code> 包含两种实际状态</strong>：<ul>
<li>就绪（Ready）：已准备好等待 CPU 分配时间片</li>
<li>运行中（Running）：正在由 CPU 执行</li>
</ul>
</li>
<li><strong><code>BLOCKED</code>、<code>WAITING</code> 和 <code>TIMED_WAITING</code></strong> 都表示线程处于非运行态，但它们的等待条件不同，需结合具体方法（如 <code>synchronized</code>、<code>wait()</code>、<code>sleep()</code> 等）来区分</li>
</ul>
<h2 id="9-sleep-和-wait-的区别是什么？"><a href="#9-sleep-和-wait-的区别是什么？" class="headerlink" title="9# sleep() 和 wait() 的区别是什么？"></a>9# sleep() 和 wait() 的区别是什么？</h2><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><code>sleep()</code></th>
<th><code>wait()</code></th>
</tr>
</thead>
<tbody><tr>
<td>所属类</td>
<td><code>Thread</code>（静态方法）</td>
<td><code>Object</code>（实例方法）</td>
</tr>
<tr>
<td>是否释放锁</td>
<td>不释放锁</td>
<td>会释放锁</td>
</tr>
<tr>
<td>使用前提</td>
<td>可在任何线程上下文中调用</td>
<td>必须在同步块或同步方法中调用（即持有对象锁）</td>
</tr>
<tr>
<td>唤醒方式</td>
<td>到达指定时间自动唤醒</td>
<td>需要其他线程调用 <code>notify()</code> &#x2F; <code>notifyAll()</code> 或超时</td>
</tr>
<tr>
<td>设计目的</td>
<td>使线程暂停指定时间，不涉及线程协作</td>
<td>用于线程之间通信与协作，主动释放锁进入等待队列</td>
</tr>
</tbody></table>
<p><strong>一、类归属不同</strong>：</p>
<ul>
<li><code>sleep()</code> 是 <code>Thread</code> 类的静态方法，通过 <code>Thread.sleep()</code> 调用，无需依赖对象实例</li>
<li><code>wait()</code> 是 <code>Object</code> 类的实例方法，必须通过对象调用，例如 <code>obj.wait()</code></li>
</ul>
<p><strong>二、是否释放锁</strong>：</p>
<ul>
<li><code>sleep()</code> 不释放任何锁，即使在同步代码块中调用，线程休眠期间仍然占有锁，其他线程无法访问同步资源</li>
<li><code>wait()</code> 会释放当前线程持有的对象锁，使其他线程可以获得该锁并继续执行</li>
</ul>
<p><strong>三、使用条件</strong>：</p>
<ul>
<li><code>sleep()</code> 可在任意代码位置调用，无需持有任何锁</li>
<li><code>wait()</code> 只能在同步块或同步方法中调用（即必须先获取该对象的监视器锁），否则会抛出 <code>IllegalMonitorStateException</code> 异常</li>
</ul>
<p><strong>四、唤醒机制</strong>：</p>
<ul>
<li><code>sleep()</code> 会在指定时间后自动唤醒，回到可运行状态等待 CPU 调度</li>
<li><code>wait()</code> 必须依赖 <code>notify()</code> 或 <code>notifyAll()</code> 显式唤醒，或设置超时时间（如 <code>wait(5000)</code>）后自动唤醒</li>
</ul>
<h2 id="10-sleep-会释放-CPU-吗？"><a href="#10-sleep-会释放-CPU-吗？" class="headerlink" title="10# sleep() 会释放 CPU 吗？"></a>10# sleep() 会释放 CPU 吗？</h2><p>是的，调用 <code>Thread.sleep()</code> 时，线程会<strong>释放 CPU 使用权</strong>，但<strong>不会释放它所持有的锁</strong></p>
<p>当线程执行 <code>Thread.sleep()</code> 方法时，它会<strong>进入 <code>TIMED_WAITING</code>（计时等待）状态</strong>，暂停执行指定的时间；在这段时间内，<strong>线程主动让出 CPU 时间片</strong>，操作系统会进行线程调度，将 CPU 分配给其他处于可运行状态的线程；这使得其他线程可以获得 CPU 并执行任务，从而提高系统的并发性能</p>
<p>虽然线程暂停执行，但<strong>不会释放它已持有的同步锁</strong>（例如通过 <code>synchronized</code> 获取的锁）。如果其他线程尝试获取这些锁，仍会被阻塞，直到当前线程恢复执行并释放锁</p>
<h2 id="11-BLOCKED-和-WAITING-有什么区别？"><a href="#11-BLOCKED-和-WAITING-有什么区别？" class="headerlink" title="11# BLOCKED 和 WAITING 有什么区别？"></a>11# BLOCKED 和 WAITING 有什么区别？</h2><p>Java 中线程的 <code>BLOCKED</code> 和 <code>WAITING</code> 状态都表示线程当前没有运行，但两者产生的原因和恢复机制完全不同，主要区别如下：</p>
<img src="https://cdn.xiaolincoding.com//picgo/93a0d1531ea1271770686b9e91664a9c.png" alt="线程竞争锁后的状态" style="zoom:50%;" />

<ol>
<li><strong>触发条件</strong>：<ul>
<li><strong><code>BLOCKED</code>（阻塞状态）</strong>：当线程尝试<strong>获取某个对象的锁</strong>（例如进入一个 <code>synchronized</code> 块或方法）而该锁已被其他线程占用时，线程会进入 <code>BLOCKED</code> 状态。此状态下线程在等待锁的释放，<strong>无法参与锁竞争</strong>，也不会执行任何指令</li>
<li><strong><code>WAITING</code>（等待状态）</strong>：当线程<strong>主动调用</strong>如 <code>Object.wait()</code>、<code>Thread.join()</code> 或 <code>LockSupport.park()</code> 方法时，会进入 <code>WAITING</code> 状态。此时线程进入<strong>无限期等待</strong>，线程将不会消耗 CPU 资源，并且不会参与锁的竞争</li>
</ul>
</li>
<li><strong>唤醒机制</strong>：<ul>
<li><strong><code>BLOCKED</code> 状态的线程</strong>会在持有锁的线程释放锁后，<strong>自动进入就绪（<code>RUNNABLE</code>）状态</strong>，并参与下一轮的锁竞争</li>
<li><strong><code>WAITING</code> 状态的线程</strong>不会自动唤醒，必须由其他线程显式地调用 <code>notify()</code>、<code>notifyAll()</code>、<code>unpark()</code> 等方法，或者使用 <code>join()</code> 等触发条件满足后，才会恢复运行</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>BLOCKED</code> 状态</th>
<th><code>WAITING</code> 状态</th>
</tr>
</thead>
<tbody><tr>
<td>触发方式</td>
<td>被动触发，等待锁的释放</td>
<td>主动调用等待方法（如 <code>wait()</code>、<code>join()</code>）</td>
</tr>
<tr>
<td>是否释放锁</td>
<td>❌ 不释放</td>
<td>✅ 调用 <code>wait()</code> 时会释放当前锁</td>
</tr>
<tr>
<td>唤醒机制</td>
<td>自动唤醒（当锁可用时）</td>
<td>必须显式唤醒（如 <code>notify()</code>）或条件满足</td>
</tr>
<tr>
<td>是否参与锁竞争</td>
<td>❌ 不参与</td>
<td>❌ 不参与，直到被唤醒</td>
</tr>
</tbody></table>
<ul>
<li><code>BLOCKED</code> 是因<strong>锁竞争失败被动进入</strong>的状态，<code>WAITING</code> 是线程<strong>主动进入等待</strong>的状态</li>
<li><code>BLOCKED</code> 的唤醒是<strong>自动的</strong>，<code>WAITING</code> 的唤醒是<strong>手动触发的</strong>。</li>
</ul>
<h2 id="12-线程处于-WAITING-状态时，如何恢复为-RUNNING-状态"><a href="#12-线程处于-WAITING-状态时，如何恢复为-RUNNING-状态" class="headerlink" title="12# 线程处于 WAITING 状态时，如何恢复为 RUNNING 状态?"></a>12# 线程处于 WAITING 状态时，如何恢复为 RUNNING 状态?</h2><p>核心机制是<strong>通过外部事件触发或资源可用性变化</strong>，比如<strong>其他线程调用 <code>notify()</code> 或 <code>notifyAll()</code> 唤醒它</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待线程</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    lock.wait();  <span class="comment">// 当前线程进入 WAITING 状态，并释放锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒线程</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    lock.notify();      <span class="comment">// 唤醒一个等待该锁的线程</span></span><br><span class="line">    <span class="comment">// lock.notifyAll(); // 唤醒所有在该锁上等待的线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<ul>
<li><code>notify()</code> 会随机唤醒一个正在该对象上等待的线程</li>
<li><code>notifyAll()</code> 会唤醒所有在该对象上等待的线程（通常用于多个线程等待同一条件的场景）</li>
<li>被唤醒的线程会重新尝试获取锁，<strong>一旦成功获取锁，就会从 <code>WAITING</code> 状态转为 <code>RUNNABLE</code>，最终进入 <code>RUNNING</code> 状态</strong>继续执行</li>
<li>如果唤醒后竞争锁失败，线程会暂时进入 <code>BLOCKED</code> 状态，直到成功获取锁</li>
</ul>
<h2 id="13-notify-和-notifyAll-的区别"><a href="#13-notify-和-notifyAll-的区别" class="headerlink" title="13# notify() 和 notifyAll() 的区别?"></a>13# notify() 和 notifyAll() 的区别?</h2><p>两者都用于唤醒因调用 <code>wait()</code> 而处于等待状态的线程，但在唤醒数量和行为上存在显著差异：</p>
<ul>
<li><strong>共同点</strong>：<ul>
<li>都只能在同步代码块或同步方法中调用</li>
<li>都会将等待中的线程从 <code>WAITING</code> 状态变为 <code>BLOCKED</code>，接着尝试竞争锁资源</li>
<li>被唤醒的线程只有在重新获得锁后才能继续执行</li>
</ul>
</li>
<li><strong>区别</strong>：<ul>
<li><code>notify()</code>：<strong>只唤醒一个</strong>正在等待当前对象锁的线程，具体唤醒哪个线程不可控。如果被唤醒的线程没有在运行过程中再次调用 <code>notify()</code> 或 <code>notifyAll()</code>，其他线程将继续处于等待状态，可能导致<strong>线程 “永久等待”</strong> 的问题（死锁风险）</li>
<li><code>notifyAll()</code>：<strong>唤醒所有</strong>等待当前对象锁的线程。所有被唤醒的线程将同时进入阻塞状态（<code>BLOCKED</code>），并竞争锁资源。最终只有一个线程获得锁并进入运行状态，其余线程继续等待锁，避免了遗漏唤醒的情况</li>
</ul>
</li>
<li><strong>推荐使用场景</strong>：<ul>
<li>当只有一个线程需要被唤醒时，可使用 <code>notify()</code></li>
<li>当可能有多个线程等待，且不能确定具体唤醒哪一个为最佳时，应使用 <code>notifyAll()</code>，以防遗漏唤醒导致系统阻塞</li>
</ul>
</li>
</ul>
<h2 id="14-notify-唤醒的是哪个线程"><a href="#14-notify-唤醒的是哪个线程" class="headerlink" title="14# notify() 唤醒的是哪个线程?"></a>14# notify() 唤醒的是哪个线程?</h2><p>从语义上讲，<code>notify()</code> 唤醒的是<strong>任意一个正在等待该对象锁的线程</strong>，具体唤醒哪一个线程，不在 Java 语言层面定义，而是<strong>由 JVM 的实现来决定的</strong></p>
<p>虽然规范中声明唤醒是 “非确定性” 的，但主流 JVM 实现（如 <strong>HotSpot</strong>）在内部的实际处理方式却并非真正随机：在 <strong>HotSpot JVM</strong> 中，<code>notify()</code> 通常按照**等待队列中的先后顺序（FIFO）**来唤醒线程，也就是说，<strong>先进入等待队列的线程，通常会先被唤醒</strong></p>
<h2 id="15-线程间通信方式有哪些？"><a href="#15-线程间通信方式有哪些？" class="headerlink" title="15# 线程间通信方式有哪些？"></a>15# 线程间通信方式有哪些？</h2><p><del><strong>太长不看版</strong></del></p>
<table>
<thead>
<tr>
<th>方案</th>
<th>适用场景</th>
<th>优点</th>
<th>注意点 &#x2F; 限制</th>
</tr>
</thead>
<tbody><tr>
<td><code>volatile</code> &#x2F; 共享变量</td>
<td>极简标志位、写少读多</td>
<td>语法简单</td>
<td>无法做复杂同步；需防 busy‑wait</td>
</tr>
<tr>
<td><code>wait/notify</code></td>
<td>经典线程协作</td>
<td>JDK 原生；释放锁</td>
<td>必须同步块；易误用</td>
</tr>
<tr>
<td><code>Lock</code> + <code>Condition</code></td>
<td>多条件、更高灵活度</td>
<td>可多队列；响应中断</td>
<td>需显式加&#x2F;解锁</td>
</tr>
<tr>
<td><code>BlockingQueue</code></td>
<td>生产‑消费模型、任务队列</td>
<td>封装好并发控制；易用</td>
<td>需选合适容量及实现</td>
</tr>
</tbody></table>
<ol>
<li><p><strong>共享变量（<code>volatile</code> &#x2F; <code>synchronized</code>）</strong>：多线程读写同一变量完成信息传递</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedVarDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;   <span class="comment">// 保证可见性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="comment">// 生产者</span></span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;Producer → flag=true&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="comment">// 消费者</span></span><br><span class="line">            <span class="keyword">while</span> (!flag) &#123; <span class="comment">/* busy‑wait */</span> &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer  ← flag=true&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> s)</span> &#123; <span class="keyword">try</span> &#123; Thread.sleep(s * <span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>volatile</code> → 可见性；若需原子更新，可配合 <code>synchronized</code> 或原子类</li>
<li><strong>缺点</strong>：忙等浪费 CPU；适合极简单的状态标志</li>
</ul>
</li>
<li><p><strong><code>wait/notify</code></strong>：线程在<strong>对象监视器</strong>上等待并释放锁，唤醒后再次竞争锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WaitNotifyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 消费者</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!ready) &#123;        <span class="comment">// 避免虚假唤醒</span></span><br><span class="line">                    <span class="keyword">try</span> &#123; lock.wait(); &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer  ← ready&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                ready = <span class="literal">true</span>;</span><br><span class="line">                lock.notify();          <span class="comment">// 或 notifyAll()</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Producer → notify&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> s)</span> &#123; <span class="keyword">try</span> &#123; Thread.sleep(s * <span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>必须</strong>在同步块&#x2F;同步方法内调用，否则抛 <code>IllegalMonitorStateException</code></p>
</li>
<li><p>建议 <code>while</code> 循环重判条件，防止虚假唤醒</p>
</li>
</ul>
</li>
<li><p><strong><code>Lock</code> + <code>Condition</code></strong>：<code>Condition</code> 提供与 <code>wait/notify</code> 等价但更灵活的 API，可配多条件队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LockConditionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">done</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 消费者</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!ready) done.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer  ← ready&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123; lock.unlock(); &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ready = <span class="literal">true</span>;</span><br><span class="line">                done.signal();          <span class="comment">// 或 signalAll()</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Producer → signal&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123; lock.unlock(); &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> s)</span> &#123; <span class="keyword">try</span> &#123; Thread.sleep(s * <span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>与 <code>wait/notify</code> 相比，可针对不同条件建多条等待队列，更易管理</li>
</ul>
</li>
<li><p><strong><code>BlockingQueue</code></strong>：使用 <strong>线程安全</strong> 的阻塞队列负责生产&#x2F;消费，完全无需显式加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BlockingQueueDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 消费者</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">item</span> <span class="operator">=</span> queue.take();                <span class="comment">// 阻塞直到有元素</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer  ← &quot;</span> + item);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="number">1</span>);                           <span class="comment">// 队列满则阻塞</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Producer → 1&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> s)</span> &#123; <span class="keyword">try</span> &#123; Thread.sleep(s * <span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>阻塞队列内部已处理好并发与等待逻辑，是<strong>最推荐</strong>的生产‑消费实现。</p>
</li>
<li><p>常见实现：<code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>、<code>SynchronousQueue</code> 等</p>
</li>
</ul>
</li>
</ol>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="1-juc-包下你常用的类有哪些？"><a href="#1-juc-包下你常用的类有哪些？" class="headerlink" title="1# juc 包下你常用的类有哪些？"></a>1# juc 包下你常用的类有哪些？</h2><p><strong>一、线程池相关</strong></p>
<ul>
<li><code>ThreadPoolExecutor</code>：最核心的线程池类，用于创建和管理线程池。通过它可以灵活地配置线程池的参数，如核心线程数、最大线程数、任务队列等，以满足不同的并发处理需求</li>
<li><code>Executors</code>：线程池工厂类，提供了一系列静态方法来创建不同类型的线程池，如 <code>newFixedThreadPool</code>（创建固定线程数的线程池）、<code>newCachedThreadPool</code>（创建可缓存线程池）、<code>newSingleThreadExecutor</code>（创建单线程线程池）等，方便开发者快速创建线程池</li>
</ul>
<p><strong>二、并发集合类</strong></p>
<ul>
<li><code>ConcurrentHashMap</code>：线程安全的哈希映射表，用于在多线程环境下高效地存储和访问键值对。它采用了分段锁等技术，允许多个线程同时访问不同的段，提高了并发性能，在高并发场景下比传统的 <code>Hashtable</code> 性能更好</li>
<li><code>CopyOnWriteArrayList</code>：线程安全的列表，在对列表进行修改操作时，会创建一个新的底层数组，将修改操作应用到新数组上，而读操作仍然可以在旧数组上进行，从而实现了读写分离，提高了并发读的性能，适用于读多写少的场景</li>
</ul>
<p><strong>三、同步工具类</strong></p>
<ul>
<li><code>CountDownLatch</code>：允许一个或多个线程等待其他一组线程完成操作后再继续执行。它通过一个计数器来实现，计数器初始化为线程的数量，每个线程完成任务后调用 <code>countDown()</code> 方法将计数器减一，当计数器为零时，等待的线程可以继续执行。常用于多个线程完成各自任务后，再进行汇总或下一步操作的场景</li>
<li><code>CyclicBarrier</code>：让一组线程互相等待，直到所有线程都到达某个屏障点后，再一起继续执行。与 <code>CountDownLatch</code> 不同的是，<code>CyclicBarrier</code> 可以重复使用，当所有线程都通过屏障后，计数器会重置，可以再次用于下一轮的等待。适用于多个线程需要协同工作，在某个阶段完成后再一起进入下一个阶段的场景</li>
<li><code>Semaphore</code>：信号量，用于控制同时访问某个资源的线程数量。它维护了一个许可计数器，线程在访问资源前需要获取许可，如果有可用许可，则获取成功并将许可计数器减一，否则线程需要等待，直到有其他线程释放许可。常用于控制对有限资源的访问，如数据库连接池、线程池中的线程数量等</li>
</ul>
<p><strong>四、原子类</strong></p>
<ul>
<li><code>AtomicInteger</code>：原子整数类，提供了对整数类型的原子操作，如自增、自减、比较并交换等。通过硬件级别的原子指令来保证操作的原子性和线程安全性，避免了使用锁带来的性能开销，在多线程环境下对整数进行计数、状态标记等操作非常方便</li>
<li><code>AtomicReference</code>：原子引用类，用于对对象引用进行原子操作。可以保证在多线程环境下，对对象的更新操作是原子性的，即要么全部成功，要么全部失败，不会出现数据不一致的情况。常用于实现无锁数据结构或需要对对象进行原子更新的场景</li>
</ul>
<h2 id="2-怎么保证多线程安全？"><a href="#2-怎么保证多线程安全？" class="headerlink" title="2# 怎么保证多线程安全？"></a>2# 怎么保证多线程安全？</h2><ol>
<li><strong><code>synchronized</code> 关键字</strong>：通过内置锁实现互斥访问，<code>Synchronized</code> 可用于修饰方法或代码块，确保同一时刻只有一个线程能访问同步区域。其本质是基于对象的监视器锁（monitor）机制</li>
<li><strong><code>volatile</code> 关键字</strong>：确保变量的可见性，使用 <code>volatile</code> 修饰的变量不会被线程缓存，所有线程访问的都是主内存中的最新值。适用于状态标志等无需原子性但需要可见性的场景</li>
<li><strong>显式锁 <code>Lock</code> 接口与 <code>ReentrantLock</code></strong>：更灵活的同步控制，<code>ReentrantLock</code> 是一种可重入互斥锁，提供了 <code>tryLock()</code>、<code>lockInterruptibly()</code> 等高级控制方式，相较 <code>synchronized</code> 更灵活</li>
<li><strong>原子类（<code>AtomicInteger</code> 等）</strong>：原子性操作无需加锁，<code>java.util.concurrent.atomic</code> 包提供了多种原子类，支持无锁线程安全操作，适用于高并发计数、状态标志等场景</li>
<li><strong>线程局部变量（<code>ThreadLocal</code>）</strong>：每个线程独享变量副本，<code>ThreadLocal</code> 为每个线程提供独立的变量副本，避免了共享带来的同步问题，适合线程封闭（Thread Confinement）场景</li>
<li><strong>并发集合类</strong>：内置线程安全机制，使用 <code>java.util.concurrent</code> 包中的并发集合（如 <code>ConcurrentHashMap</code>、<code>ConcurrentLinkedQueue</code> 等）可以避免手动加锁，提升并发性能</li>
<li><strong>JUC 工具类</strong>：协调线程间协作，Java 并发包提供了一系列同步工具类，用于线程间的通信与协作控制，如：<code>Semaphore</code>（限制并发线程数）、<code>CountDownLatch</code>（等待多个线程完成任务）、<code>CyclicBarrier</code>（多线程在屏障点统一继续执行）、<code>Exchanger</code>（线程间交换数据）</li>
</ol>
<h2 id="3-Java-中有哪些常用的锁？各自适用于什么场景？"><a href="#3-Java-中有哪些常用的锁？各自适用于什么场景？" class="headerlink" title="3# Java 中有哪些常用的锁？各自适用于什么场景？"></a>3# Java 中有哪些常用的锁？各自适用于什么场景？</h2><p>在多线程编程中，锁是保障线程安全、避免并发冲突的核心机制</p>
<ol>
<li><strong>内置锁（synchronized）</strong>：最基本的互斥机制，<code>Synchronized</code> 是 Java 内置的同步机制，用于修饰方法或代码块。线程在进入同步区域前需要获取锁，离开后自动释放，保证同一时间只有一个线程能访问被保护的资源。其中，<code>syncronized</code> 加锁时有无锁、偏向锁、轻量级锁和重量级锁几个级别。偏向锁用于当一个线程进入同步块时，如果没有任何其他线程竞争，就会使用偏向锁，以减少锁的开销。轻量级锁使用线程栈上的数据结构，避免了操作系统级别的锁。重量级锁则涉及操作系统级的互斥锁</li>
<li><strong>可重入锁（<code>ReentrantLock</code>）</strong>：功能更强的显式锁，<code>ReentrantLock</code> 是 <code>java.util.concurrent.locks</code> 包中的显式锁，功能上比 <code>synchronized</code> 更灵活，支持<strong>可中断锁获取、限时等待锁、公平锁&#x2F;非公平锁切换、多条件变量（Condition）支持</strong>等。<code>ReentrantLock</code> 使用 <code>lock()</code> 和 <code>unlock()</code> 方法来获取和释放锁。其中，公平锁按照线程请求锁的顺序来分配锁，保证了锁分配的公平性，但可能增加锁的等待时间。非公平锁不保证锁分配的顺序，可以减少锁的竞争，提高性能，但可能造成某些线程的饥饿</li>
<li><strong>读写锁（ReadWriteLock）</strong>：提高读多写少场景的并发性，<code>ReadWriteLock</code> 允许多个线程并发读取共享资源，但写操作是独占的。常见实现如 <code>ReentrantReadWriteLock</code></li>
<li><strong>乐观锁和悲观锁</strong>：<strong>悲观锁（Pessimistic Locking）</strong>：默认认为并发冲突频繁，访问数据前先加锁，如 <code>synchronized</code> 和 <code>ReentrantLock</code>；<strong>乐观锁（Optimistic Locking）</strong>：假设冲突很少，不加锁而是通过版本号或时间戳在更新时校验数据是否被修改，常用 <code>CAS</code> 机制实现</li>
<li><strong>自旋锁（SpinLock）</strong>：短时等待情况下的非阻塞锁机制，自旋锁不会让线程阻塞，而是持续循环尝试获取锁（通常基于 <code>CAS</code> 操作）。适合锁竞争时间非常短的场景，避免线程频繁上下文切换</li>
</ol>
<h2 id="4-怎么在实践中用锁的？"><a href="#4-怎么在实践中用锁的？" class="headerlink" title="4# 怎么在实践中用锁的？"></a>4# 怎么在实践中用锁的？</h2><p><del><strong>太长不看版</strong></del></p>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>使用方式示例</th>
<th>优点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>synchronized</code></td>
<td><code>synchronized</code> 方法或代码块</td>
<td>简单易用、JVM 自动管理</td>
<td>一般同步逻辑</td>
</tr>
<tr>
<td><code>ReentrantLock</code></td>
<td><code>lock()</code> &#x2F; <code>unlock()</code></td>
<td>可中断、公平锁、尝试锁等高级功能</td>
<td>对同步控制要求更高的场景</td>
</tr>
<tr>
<td><code>ReadWriteLock</code></td>
<td><code>readLock()</code> &#x2F; <code>writeLock()</code></td>
<td>多读并发、写独占、提升读多写少性能</td>
<td>缓存、配置读取等并发读取场景</td>
</tr>
</tbody></table>
<ol>
<li><p><strong>使用 <code>synchronized</code> 实现简单互斥</strong>：<code>synchronized</code> 是 Java 中最早的同步机制，可用于方法或代码块，隐式地为指定对象加锁，保证同一时间只有一个线程执行被保护的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步代码块</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> ( ) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用代码块可以灵活控制加锁粒度，并避免同步整个方法带来的性能损耗</p>
</li>
<li><p><strong>使用 <code>Lock</code> 接口实现显式加锁</strong>：<code>Lock</code> 接口提供了比 <code>synchronized</code> 更强大的锁控制能力，如<strong>可中断锁</strong>、<strong>限时尝试锁</strong>、<strong>公平锁</strong>等。<code>ReentrantLock</code> 是最常用的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 显式加锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 确保锁最终释放，避免死锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>try-finally</code> 块是使用 <code>Lock</code> 的规范做法，以确保即使抛出异常也能正确释放锁</p>
</li>
<li><p><strong>使用 <code>ReadWriteLock</code> 提升读多写少的并发性能</strong>：<code>ReadWriteLock</code> 提供一对互斥锁：<strong>读锁（<code>readLock()</code>）</strong> 和 <strong>写锁（<code>writeLock()</code>）</strong>。它允许多个线程同时读取数据，但写操作必须是独</p>
</li>
<li><p>占的。典型实现为 <code>ReentrantReadWriteLock</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">readData</span><span class="params">()</span> &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeData</span><span class="params">(Object newData)</span> &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data = newData;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个线程可以同时读取 <code>data</code>，而写操作则是互斥的，这种设计大幅提升了<strong>读多写少场景</strong>的并发性能</p>
</li>
</ol>
<h2 id="5-Java-并发工具你知道哪些？"><a href="#5-Java-并发工具你知道哪些？" class="headerlink" title="5# Java 并发工具你知道哪些？"></a>5# Java 并发工具你知道哪些？</h2><p>Java 的并发工具类大多位于 <code>java.util.concurrent</code> 包中，提供了丰富的 API 来简化并发编程。这里主要提供代码参考，它们的详细概念见 [1# juc 包下你常用的类有哪些？](#1# juc 包下你常用的类有哪些？)</p>
<ol>
<li><p><code>CountDownLatch</code> 是一个同步辅助类，它允许一个或多个线程等待其他线程完成一组操作。它通过一个倒计时计数器来协调线程之间的执行顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行任务&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                latch.countDown();  <span class="comment">// 任务完成，计数器减一</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成任务&quot;</span>);</span><br><span class="line">            &#125;, <span class="string">&quot;Worker-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程等待所有子线程完成...&quot;</span>);</span><br><span class="line">        latch.await();  <span class="comment">// 阻塞直到计数器为 0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;所有子线程已完成，主线程继续执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>CyclicBarrier</code> 允许一组线程互相等待，直到所有线程都到达屏障点（barrier）为止，然后一同继续执行。它可以循环使用，适合分阶段并行计算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(threadCount, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;所有线程已到达屏障，执行后续操作&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行任务&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    barrier.await();  <span class="comment">// 等待其他线程</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 通过屏障&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;Worker-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Semaphore</code> 是一个计数信号量，用于控制同时访问某资源的线程数量。可用于流量控制、资源池等场景</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">2</span>);  <span class="comment">// 同时允许两个线程访问</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();  <span class="comment">// 获取许可</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获得许可&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);  <span class="comment">// 模拟处理资源</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放许可&quot;</span>);</span><br><span class="line">                    semaphore.release();  <span class="comment">// 释放许可</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;Worker-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Callable</code> 接口类似于 <code>Runnable</code>，但可以返回结果或抛出异常。<code>Future</code> 表示异步任务的结果，用于查询任务是否完成、取消任务或获取结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureCallableExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        Callable&lt;Integer&gt; task = () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行任务&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt; future = executor.submit(task);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程继续执行其他任务&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get();  <span class="comment">// 阻塞直到结果返回</span></span><br><span class="line">        System.out.println(<span class="string">&quot;异步任务结果: &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ConcurrentHashMap</code> 是高并发环境下的线程安全哈希表。它在内部对桶进行分段锁处理，支持高效的并发读写操作，适用于读多写少或高并发环境</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMapExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ConcurrentHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;key1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key2&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并发读操作</span></span><br><span class="line">        map.forEach((key, value) -&gt; System.out.println(key + <span class="string">&quot;: &quot;</span> + value));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并发写操作</span></span><br><span class="line">        map.computeIfAbsent(<span class="string">&quot;key3&quot;</span>, k -&gt; <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="6-CountDownLatch-是做什么的？"><a href="#6-CountDownLatch-是做什么的？" class="headerlink" title="6# CountDownLatch 是做什么的？"></a>6# CountDownLatch 是做什么的？</h2><p><code>CountDownLatch</code> 是 Java 并发包（<code>java.util.concurrent</code>）中的一个同步辅助类，用于<strong>让一个或多个线程等待其他线程完成任务后再继续执行</strong></p>
<p>它的核心机制是一个<strong>计数器</strong>（Counter），常用于多线程协作场景，例如主线程等待多个子线程就绪、任务分批执行等，工作原理：</p>
<ol>
<li><strong>初始化计数器</strong>：创建 <code>CountDownLatch</code> 时指定一个初始计数值（如 <code>N</code>）</li>
<li><strong>等待阻塞</strong>：调用 <code>await()</code> 方法的线程会被阻塞，直到计数器变为 0</li>
<li><strong>计数递减</strong>：其他线程完成任务后调用 <code>countDown()</code> 方法，使计数器减 1</li>
<li><strong>唤醒等待线程</strong>：当计数器归零，所有调用了 <code>await()</code> 的线程将被唤醒，继续执行</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainThreadWaitExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在执行任务&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">                    latch.countDown();  <span class="comment">// 当前线程完成，计数器减 1</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成任务&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;Worker-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程等待所有子线程完成任务...&quot;</span>);</span><br><span class="line">        latch.await(); <span class="comment">// 主线程阻塞，直到所有子线程完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;所有任务已完成，主线程继续执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-synchronized-的工作原理？"><a href="#7-synchronized-的工作原理？" class="headerlink" title="7# synchronized 的工作原理？"></a>7# synchronized 的工作原理？</h2><p><img src="https://cdn.xiaolincoding.com//picgo/1719918642412-181e3769-49d8-4c78-8f33-a866367a4693.png" alt="synchronized 的工作原理"></p>
<ol>
<li><p><strong>编译层：生成字节码指令</strong></p>
<ul>
<li>在同步代码块（或同步方法）前后，编译器会插入 <code>monitorenter</code> &#x2F; <code>monitorexit</code> 指令</li>
<li>这两条指令由 JVM 调用 <strong>对象监视器（Monitor）</strong> 完成加锁与解锁</li>
</ul>
</li>
<li><p><strong>运行时：Monitor 的加锁 &#x2F; 解锁流程</strong></p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>① 线程执行 <code>monitorenter</code></td>
<td>尝试获取对象监视器： • 若对象<strong>未被锁定</strong>或<strong>当前线程已持有</strong>锁⇒ 计数器 <code>+1</code>，线程继续执行； • 否则将线程加入 <strong>EntryList</strong>，进入 <strong>BLOCKED</strong> 状态，等待锁可用。</td>
</tr>
<tr>
<td>② 线程执行 <code>monitorexit</code></td>
<td>将计数器 <code>-1</code>；当计数器变为 <strong>0</strong> 时： • 释放锁； • 从 <strong>EntryList</strong> 取出一个线程（或按公平策略）尝试获取锁。</td>
</tr>
</tbody></table>
<p><strong>Wait &#x2F; Notify 机制</strong></p>
<ul>
<li>当线程在同步块内调用 <code>wait()</code>：释放锁，计数器 <code>-1</code>，自身进入 <strong>WaitSet</strong></li>
<li>其他线程执行 <code>notify()</code> &#x2F; <code>notifyAll()</code> 会将 WaitSet 中的线程移动到 EntryList，再次参与锁竞争</li>
</ul>
</li>
<li><p><strong>内存语义</strong></p>
<ul>
<li><strong>加锁</strong>：先 <strong>清空当前线程工作内存</strong> 中共享变量，再从主内存读取，保证后续操作能看到最新值</li>
<li><strong>解锁</strong>：将工作内存中被修改的共享变量 <strong>刷新回主内存</strong>，保证其他线程可见</li>
</ul>
</li>
<li><p><strong>锁的性质与性能影响</strong></p>
<ul>
<li><code>synchronized</code> 属于 <strong>排他锁</strong>（互斥锁），同一时刻只能有一个线程持有</li>
<li>Java 线程与 OS 原生线程 1:1 对应，阻塞 &#x2F; 唤醒需要从<strong>用户态切换到内核态</strong>，成本较高</li>
<li>JVM 为降低开销引入 <strong>偏向锁、轻量级锁、重量级锁</strong> 的分级优化策略，尽量在用户态完成自旋或 CAS 竞争，仅在竞争激烈时才升级为重量级锁</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<p><code>synchronized</code> 通过 <strong>对象监视器</strong> 保证了：</p>
<ul>
<li><strong>原子性</strong>：同一时刻只有一个线程进入同步块</li>
<li><strong>可见性 &amp; 有序性</strong>：锁的释放与获取隐式包含内存屏障，满足 happens‑before 规则</li>
</ul>
<p>在实际编码中，只需使用 <code>synchronized</code> 关键字即可享受上述语义；理解其底层机制能帮助我们在性能调优、死锁排查等场景中更有针对性地分析问题</p>
<h2 id="8-除了用-synchronized，还有哪些方式可以实现线程同步？"><a href="#8-除了用-synchronized，还有哪些方式可以实现线程同步？" class="headerlink" title="8# 除了用 synchronized，还有哪些方式可以实现线程同步？"></a>8# 除了用 synchronized，还有哪些方式可以实现线程同步？</h2><ol>
<li><strong>使用 <code>ReentrantLock</code> 类</strong>：<code>ReentrantLock</code> 是一个可重入的互斥锁，相比 <code>synchronized</code> 提供了更灵活的锁定和解锁操作。它还支持公平锁和非公平锁，以及可以响应中断的锁获取操作</li>
<li><strong>使用<code>volatile</code>关键字</strong>：虽然 <code>volatile</code> 不是一种锁机制，但它可以确保变量的可见性。当一个变量被声明为 <code>volatile</code> 后，线程将直接从主内存中读取该变量的值，这样就能保证线程间变量的可见性。但它不具备原子性</li>
<li><strong>使用<code>Atomic</code>类</strong>：Java 提供了一系列的原子类，例如 <code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicReference </code>等，用于实现对单个变量的原子操作，这些类在实现细节上利用了 CAS（Compare-And-Swap）算法，可以用来实现无锁的线程安全</li>
</ol>
<h2 id="9-synchronized-锁静态方法与普通方法的区别"><a href="#9-synchronized-锁静态方法与普通方法的区别" class="headerlink" title="9# synchronized 锁静态方法与普通方法的区别"></a>9# synchronized 锁静态方法与普通方法的区别</h2><ol>
<li><p><strong>锁的对象不同</strong></p>
<ul>
<li><p><strong>普通方法</strong>：锁的是当前对象实例（<code>this</code>）。<strong>同一个对象实例</strong>的多个线程访问同步方法时会互斥；而<strong>不同实例对象</strong>之间互不干扰，可以并发执行各自的同步方法</p>
</li>
<li><p><strong>静态方法</strong>：锁的是当前类的 <code>Class</code> 对象（<code>ClassName.class</code>）。JVM 中每个类对应唯一一个 <code>Class</code> 对象，因此无论多少个实例，访问静态同步方法时都竞争同一把锁</p>
</li>
</ul>
</li>
<li><p><strong>作用范围不同</strong></p>
<ul>
<li><p><strong>普通方法</strong>：仅对<strong>同一对象实例</strong>的同步方法调用互斥，<strong>不同实例</strong>的调用互不干扰</p>
</li>
<li><p><strong>静态方法</strong>：对<strong>整个类范围内的该静态方法调用都互斥</strong>，无论是哪个实例，甚至没有实例化对象时也是如此</p>
</li>
</ul>
</li>
<li><p><strong>多实例场景影响不同</strong></p>
<ul>
<li><p><strong>普通方法</strong>：如果多个线程访问<strong>不同对象实例的同步普通方法</strong>，由于锁对象不同，它们之间<strong>可以并发执行</strong></p>
</li>
<li><p><strong>静态方法</strong>：而多个线程访问<strong>静态同步方法</strong>，即使是通过不同实例调用，<strong>也会串行执行</strong>，因为它们竞争的是同一个 <code>Class</code> 对象锁</p>
</li>
</ul>
</li>
</ol>
<h2 id="10-讲一下-synchronized-的锁升级过程"><a href="#10-讲一下-synchronized-的锁升级过程" class="headerlink" title="10# 讲一下 synchronized 的锁升级过程"></a>10# 讲一下 synchronized 的锁升级过程</h2><p>具体的锁升级的过程是：<strong>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</strong></p>
<ol>
<li><strong>无锁</strong>：在对象创建初期，处于无锁状态，此时对象的对象头（Mark Word）中未记录线程相关信息，如果 JVM 未开启偏向锁（或偏向锁延迟生效），线程进入同步块将直接尝试升级为轻量级锁</li>
<li><strong>偏向锁</strong>：当对象第一次被某线程获取锁时，Mark Word 会记录该线程的 ID，之后该线程再次进入同步块时，只需比较 Mark Word 中的线程 ID 是否匹配，即可直接获取锁，无需 CAS 操作，也不会挂起线程；如果另一个线程尝试获取偏向锁，会触发 <strong>偏向锁撤销</strong>，撤销后锁升级为<strong>轻量级锁</strong>，同时偏向锁将不可再用于该对象（或类）</li>
<li><strong>轻量级锁</strong>：适用于多线程存在竞争，但<strong>竞争不激烈</strong>的场景。当前线程在进入同步块时，在自己虚拟机栈中创建 <strong>锁记录（Lock Record）</strong>，并将对象的 Mark Word 复制到锁记录中，然后尝试通过 <strong>CAS</strong> 将对象头中的 Mark Word 替换为指向这个锁记录的指针，如果 CAS 成功，表示线程获得锁；如果 CAS 失败，说明有其他线程竞争该锁 —— 进入自旋尝试再次获取，自旋多次仍无法获取，则升级为重量级锁</li>
<li><strong>重量级锁</strong>：发生在多线程高竞争场景。无法通过自旋获取锁的线程将被 <strong>挂起</strong>（阻塞），由操作系统调度，等待唤醒，重量级锁的获取和释放涉及<strong>用户态与内核态切换</strong>，开销较大，但保证线程安全</li>
</ol>
<img src="https://cdn.xiaolincoding.com//picgo/1721808326210-cce43537-20e7-4b7d-bed3-737dc7904d9a.png" alt="synchronized 的锁升级过程" style="zoom: 33%;" />

<ul>
<li><p><strong>线程 A</strong> 首次进入 <code>synchronized</code> 块：</p>
<ul>
<li>如果偏向锁已启用且对象未被锁定，则偏向 A，记录其线程 ID</li>
<li>A 再次进入同步代码时，<strong>直接命中偏向锁</strong>，无阻塞、无 CAS</li>
</ul>
</li>
<li><p><strong>线程 B</strong> 也尝试获取锁：</p>
<ul>
<li><p>偏向锁被撤销，升级为轻量级锁</p>
</li>
<li><p>B 通过自旋尝试获取锁</p>
</li>
<li><p>如果自旋失败，锁升级为重量级，B 被挂起等待唤醒</p>
</li>
</ul>
</li>
</ul>
<h2 id="11-JVM-对-synchronized-的优化机制"><a href="#11-JVM-对-synchronized-的优化机制" class="headerlink" title="11# JVM 对 synchronized 的优化机制"></a>11# JVM 对 synchronized 的优化机制</h2><ol>
<li><p><strong>锁膨胀</strong>：<code>synchronized</code> 支持从<strong>无锁 → 偏向锁 → 轻量级锁 → 重量级锁</strong>的渐进式升级过程（也称“锁膨胀”）：初始状态为无锁，当一个线程独占锁时，使用 <strong>偏向锁</strong>，几乎无性能开销。有线程竞争时升级为 <strong>轻量级锁</strong>，通过 CAS 和自旋尝试获取锁。多线程竞争激烈、自旋失败后，升级为 <strong>重量级锁</strong>，线程阻塞、由操作系统调度。这一机制极大减少了用户态与内核态之间的切换，提升了 <code>synchronized</code> 的性能</p>
</li>
<li><p><strong>锁消除</strong>：指的是在某些情况下，JVM 虚拟机如果检测不到某段代码被共享和竞争的可能性，就会将这段代码所属的同步锁消除掉，从而到底提高程序性能的目的</p>
</li>
<li><p><strong>锁粗化</strong>：如果 JVM 发现某个线程在<strong>短时间内频繁进行加锁和解锁操作</strong>，则会将这些操作合并成一个<strong>更大粒度的锁范围</strong></p>
</li>
<li><p><strong>自适应自旋锁</strong>：如果锁在短时间内就能被释放，则自旋线程可以快速获得锁，避免线程挂起&#x2F;恢复所造成的性能开销。若线程在之前的自旋中成功获取过锁，则可能增加下一次的自旋次数；若多次自旋失败，则减少自旋次数甚至不再自旋，直接阻塞</p>
</li>
</ol>
<h2 id="12-怎么理解可重入锁？"><a href="#12-怎么理解可重入锁？" class="headerlink" title="12#  怎么理解可重入锁？"></a>12#  怎么理解可重入锁？</h2><p><strong>可重入锁</strong>指的是：<strong>同一个线程在已经获取锁的情况下，仍然可以再次获取该锁而不会发生死锁</strong>。这种机制确保了在方法调用嵌套或递归时，线程不会因为已经持有的锁而被自己阻塞</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">outer</span><span class="params">()</span> &#123;</span><br><span class="line">    inner(); <span class="comment">// inner 也是 synchronized 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">inner</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果锁不具备可重入性，那么线程在调用 <code>outer()</code> 后再次尝试进入 <code>inner()</code> 时就会阻塞自己，造成死锁。而使用可重入锁机制，线程能够<strong>顺利重入</strong>，程序才能正常执行</p>
<p><code>ReentrantLock</code> 是 <code>java.util.concurrent.locks</code> 包下的可重入互斥锁，其可重入机制的核心是<strong>锁持有线程记录和重入计数器</strong>：</p>
<ul>
<li>当一个线程<strong>首次获取锁</strong>时：锁的持有线程被设置为当前线程，重入计数器设置为 <code>1</code></li>
<li>当该线程<strong>再次获取该锁</strong>时：如果判断当前线程已是锁的持有者，则只需将计数器加 <code>1</code>，<strong>不会被阻塞</strong></li>
<li>当线程执行完毕，<strong>释放锁时</strong>：每释放一次锁，计数器减 <code>1</code>，<strong>只有当计数器减为 0 时</strong>，锁才真正释放，其他线程才有机会获取</li>
</ul>
<p>这种计数机制避免了重复阻塞和死锁问题</p>
<h2 id="13-synchronized-支持重入吗？如何实现的？"><a href="#13-synchronized-支持重入吗？如何实现的？" class="headerlink" title="13# synchronized 支持重入吗？如何实现的？"></a>13# synchronized 支持重入吗？如何实现的？</h2><p>是的，<code>synchronized</code> 是<strong>可重入锁</strong>。这意味着：<strong>同一个线程在已经持有某个对象锁的情况下，可以再次获取该对象的锁而不会被阻塞</strong>。例如，在一个 <code>synchronized</code> 方法中调用该对象的另一个 <code>synchronized</code> 方法，当前线程不会因为再次请求锁而被挂起，这正是可重入性的体现</p>
<p><strong>如何实现？</strong></p>
<p><code>synchronized</code> 的底层实现依赖于 JVM 的<strong>监视器锁机制</strong>，而这些监视器锁通常是通过操作系统的 <strong>互斥量</strong> 实现的。其内部维护了两个核心状态：<strong>锁的持有线程和重入计数器</strong></p>
<ol>
<li><p><strong>锁的获取流程</strong></p>
<ul>
<li><p>**当线程首次请求锁：**检查锁的状态，若当前锁未被持有（状态为 0），则通过 CAS操作设置当前线程为锁持有者，同时将锁状态设为 1</p>
</li>
<li><p><strong>当锁已被占用时：<strong>如果当前线程再次请求该锁（即线程 ID 与持有锁线程一致），表示是重入，允许请求成功，并将</strong>重入计数器加 1</strong>；否则，线程将进入阻塞状态，等待锁释放</p>
<ol start="2">
<li><strong>锁的释放流程</strong></li>
</ol>
<ul>
<li>当线程执行完同步代码块或方法后，会释放锁</li>
<li>对于可重入锁，<strong>每释放一次锁，重入计数器减 1</strong>，仅当计数器减到 0 时，锁才真正释放，其他线程才能竞争该锁</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="14-ReentrantLock-工作原理"><a href="#14-ReentrantLock-工作原理" class="headerlink" title="14# ReentrantLock 工作原理"></a>14# ReentrantLock 工作原理</h2><p>ReentrantLock 的底层实现主要依赖于 AbstractQueuedSynchronizer（AQS）这个抽象类。AQS 是一个提供了基本同步机制的框架，其中包括了队列、状态值等</p>
<p>ReentrantLock 在 AQS 的基础上通过内部类 Sync 来实现具体的锁操作。不同的 Sync 子类实现了公平锁和非公平锁的不同逻辑：</p>
<ul>
<li><p><strong>可中断性</strong>： ReentrantLock 实现了可中断性，这意味着线程在等待锁的过程中，可以被其他线程中断而提前结束等待。在底层，ReentrantLock 使用了与 LockSupport.park() 和 LockSupport.unpark() 相关的机制来实现可中断性</p>
</li>
<li><p><strong>设置超时时间</strong>： ReentrantLock 支持在尝试获取锁时设置超时时间，即等待一定时间后如果还未获得锁，则放弃锁的获取。这是通过内部的 tryAcquireNanos 方法来实现的</p>
</li>
<li><p><strong>公平锁和非公平锁</strong>： 在直接创建 ReentrantLock 对象时，默认情况下是非公平锁。公平锁是按照线程等待的顺序来获取锁，而非公平锁则允许多个线程在同一时刻竞争锁，不考虑它们申请锁的顺序。公平锁可以通过在创建 ReentrantLock 时传入 true 来设置，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>多个条件变量</strong>： ReentrantLock 支持多个条件变量，每个条件变量可以与一个 ReentrantLock 关联。这使得线程可以更灵活地进行等待和唤醒操作，而不仅仅是基于对象监视器的 wait() 和 notify()。多个条件变量的实现依赖于 Condition 接口，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="comment">// 使用下面方法进行等待和唤醒</span></span><br><span class="line">condition.await();</span><br><span class="line">condition.signal();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>可重入性</strong>： ReentrantLock 支持可重入性，即同一个线程可以多次获得同一把锁，而不会造成死锁。这是通过内部的 holdCount 计数来实现的。当一个线程多次获取锁时，holdCount 递增，释放锁时递减，只有当 holdCount 为零时，其他线程才有机会获取锁</p>
</li>
</ul>
<h2 id="15-synchronized-和-ReentrantLock-的区别"><a href="#15-synchronized-和-ReentrantLock-的区别" class="headerlink" title="15# synchronized 和 ReentrantLock 的区别"></a>15# synchronized 和 ReentrantLock 的区别</h2><p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是 Java 中常用的<strong>可重入锁机制</strong>，用于实现线程间的互斥访问，但它们在语法、特性和底层实现等方面存在显著差异</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>synchronized</th>
<th>ReentrantLock</th>
</tr>
</thead>
<tbody><tr>
<td><strong>语法使用</strong></td>
<td>关键字形式，可修饰方法或代码块</td>
<td>通过显式调用 <code>lock()</code> 和 <code>unlock()</code> 进行加锁与释放，仅支持代码块</td>
</tr>
<tr>
<td><strong>加锁&#x2F;释放机制</strong></td>
<td>自动加锁与释放，进入同步块即加锁，退出即释放</td>
<td>需手动加锁与释放，必须配合 <code>try-finally</code> 使用避免死锁</td>
</tr>
<tr>
<td><strong>锁的公平性</strong></td>
<td>默认非公平，无法更改</td>
<td>支持公平锁（先到先得）与非公平锁（默认），通过构造函数设置</td>
</tr>
<tr>
<td><strong>中断响应能力</strong></td>
<td>不支持中断，线程在等待锁时无法被中断</td>
<td>支持中断，如 <code>lockInterruptibly()</code> 可响应中断，适用于死锁恢复</td>
</tr>
<tr>
<td><strong>条件变量支持</strong></td>
<td>支持单一条件队列（即 <code>wait()</code> &#x2F; <code>notify()</code>）</td>
<td>支持多个条件变量，基于 <code>Condition</code> 对象，控制更精细</td>
</tr>
<tr>
<td><strong>性能差异</strong></td>
<td>在现代 JVM 中性能已大幅优化，轻量、适合简单场景</td>
<td>灵活性强，适用于高并发场景，但使用复杂度稍高</td>
</tr>
<tr>
<td><strong>底层实现</strong></td>
<td>基于 JVM 实现，使用对象的<strong>监视器锁（Monitor）</strong>，生成 <code>monitorenter/monitorexit</code> 字节码</td>
<td>基于 AQS（AbstractQueuedSynchronizer）实现</td>
</tr>
</tbody></table>
<h2 id="16-介绍一下-AQS"><a href="#16-介绍一下-AQS" class="headerlink" title="16# 介绍一下 AQS"></a>16# 介绍一下 AQS</h2><p><strong>一、简介</strong></p>
<p>AQS 是 Java 提供的一个用于构建锁和同步器的抽象类，位于 <code>java.util.concurrent.locks</code> 包中。它是并发包的核心组件之一，被广泛应用于构建如 <code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code>、<code>ReentrantReadWriteLock</code>、<code>FutureTask</code> 等高级并发工具类</p>
<p>AQS 的核心思想是：<strong>如果共享资源空闲，则当前线程可直接获取锁；否则，线程需进入队列等待，直到被唤醒重新尝试获取锁</strong>。这个等待机制基于 <strong>CLH（Craig, Landin, and Hagersten）队列的变体</strong> —— 一个 <strong>虚拟的双向 FIFO 队列</strong>。AQS 会将每个请求资源但未成功的线程封装成一个 <code>Node</code> 节点，并串联到队列中，形成有序等待</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1721809581196-7c09ce04-1429-4810-ade4-bb3098a9303d.png" alt="CLH 变体队列"></p>
<p><strong>二、AQS 的核心组成</strong></p>
<p>AQS 的工作机制可以拆解为以下三大核心部分：</p>
<ol>
<li><p><strong>同步状态 <code>state</code></strong>：AQS 通过一个 <code>volatile int state</code> 变量来表示当前的同步状态，在不同的同步器中，<code>state</code> 表示不同含义：在 <code>ReentrantLock</code> 中：表示锁的重入次数；在 <code>Semaphore</code> 中：表示剩余的许可证数量；在 <code>CountDownLatch</code> 中：表示计数器的剩余数量</p>
<p>AQS 提供如下原子操作方法对 <code>state</code> 进行管理，这些操作基于底层的 <strong>Unsafe 类</strong> 和 CAS 机制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getState()</span><br><span class="line">setState(<span class="type">int</span> newState)</span><br><span class="line">compareAndSetState(<span class="type">int</span> expect, <span class="type">int</span> update)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>FIFO 同步队列（CLH 变体）</strong>：当线程无法成功获取同步状态时，它会被封装为一个 <code>Node</code> 并加入到 AQS 内部维护的 <strong>FIFO 双向等待队列</strong>中。该队列保证了线程获取锁的<strong>先来先服务</strong>原则，同时用于线程的阻塞与唤醒管理</p>
<p>AQS 就像一个“<strong>线程调度管家</strong>”，协调着所有竞争资源的线程：排队入列；等待唤醒；出队重新尝试获取锁</p>
</li>
<li><p><strong>获取与释放的模板方法（需子类实现）</strong>：AQS 通过模板方法设计模式，将核心的锁获取与释放逻辑交给具体的同步器子类实现。常用需要重写的方法包括：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> arg)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>获取操作</strong>：通常涉及 <code>acquire</code> 或 <code>acquireShared</code> 方法，若获取失败，线程将进入等待队列</li>
<li><strong>释放操作</strong>：通常是 <code>release</code> 或 <code>releaseShared</code>，当资源释放后，唤醒下一个等待的线程</li>
</ul>
<p>各个具体同步器类会根据自身语义实现这些方法，比如：<code>ReentrantLock</code> 实现了独占锁的获取与释放；<code>CountDownLatch</code> 实现了共享锁逻辑中的“倒计时”功能；<code>Semaphore</code> 控制并发线程数量，即许可数量管理</p>
</li>
</ol>
<p><strong>三、AQS 的职责总结</strong></p>
<table>
<thead>
<tr>
<th>作用</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>同步状态管理</strong></td>
<td>通过 <code>state</code> 和 CAS 保证原子性操作</td>
</tr>
<tr>
<td><strong>线程排队机制</strong></td>
<td>构建 CLH 队列，管理线程排队与调度</td>
</tr>
<tr>
<td><strong>模板方法扩展</strong></td>
<td>子类通过重写 <code>tryAcquire</code> 等方法定制锁语义</td>
</tr>
</tbody></table>
<h2 id="17-CAS-与-AQS-的关系与区别"><a href="#17-CAS-与-AQS-的关系与区别" class="headerlink" title="17# CAS 与 AQS 的关系与区别"></a>17# CAS 与 AQS 的关系与区别</h2><p><strong>一、两者的区别</strong></p>
<ol>
<li><strong>CAS（Compare-And-Swap）</strong>：CAS 是一种<strong>乐观锁机制</strong>，它通过对比内存中当前值和预期值是否一致，来决定是否更新数据。整个过程具备<strong>原子性</strong>，通常由底层硬件指令实现。<strong>CAS 的逻辑是</strong>：若内存地址 V 当前的值等于 A，则将 V 的值更新为 B；否则不做任何修改</li>
<li><strong>AQS（AbstractQueuedSynchronizer）</strong>：AQS 是一个用于构建同步器的抽象框架，例如 <code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code> 等都基于它实现。其核心机制包括：<ul>
<li>使用一个 <code>volatile int state</code> 表示<strong>同步状态</strong></li>
<li>使用一个变体的 <strong>CLH FIFO 队列</strong> 管理<strong>等待线程</strong></li>
<li>通过模板方法模式暴露出 <code>tryAcquire()</code>、<code>tryRelease()</code> 等方法，供具体同步器实现</li>
<li>AQS 提供了如 <code>acquire()</code>、<code>release()</code> 等通用同步操作，这些操作背后依赖状态的原子修改</li>
</ul>
</li>
</ol>
<p><strong>二、两者的关系</strong></p>
<p><strong>CAS 是 AQS 实现的基础手段之一</strong>。在 AQS 内部，为了实现线程安全地更新共享状态（即 <code>state</code> 变量），大量使用了 CAS 操作。其关键联系如下：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>状态修改</strong></td>
<td>AQS 通过 <code>CAS</code> 原子地修改 <code>state</code> 值，避免加锁操作</td>
</tr>
<tr>
<td><strong>获取资源</strong></td>
<td>在 <code>acquire()</code> 操作中，线程首先使用 CAS 尝试获取资源（修改 <code>state</code>）；如果失败，才进入阻塞队列</td>
</tr>
<tr>
<td><strong>释放资源</strong></td>
<td>在 <code>release()</code> 操作中，线程使用 CAS 安全地减少或重置 <code>state</code>，并唤醒下一个等待线程</td>
</tr>
<tr>
<td><strong>保证并发安全</strong></td>
<td>CAS 保证了 <code>state</code> 更新过程中的原子性，是整个 AQS 框架并发控制的关键保障</td>
</tr>
</tbody></table>
<h2 id="18-如何用-AQS-实现一个可重入的公平锁？"><a href="#18-如何用-AQS-实现一个可重入的公平锁？" class="headerlink" title="18# 如何用 AQS 实现一个可重入的公平锁？"></a>18# 如何用 AQS 实现一个可重入的公平锁？</h2><p>AQS 实现一个可重入的公平锁的详细步骤：</p>
<ol>
<li><strong>继承 AbstractQueuedSynchronizer</strong>：创建一个内部类继承自 <code>AbstractQueuedSynchronizer</code>，重写 <code>tryAcquire</code>、<code>tryRelease</code>、<code>isHeldExclusively</code> 等方法，这些方法将用于实现锁的获取、释放和判断锁是否被当前线程持有</li>
<li><strong>实现可重入逻辑</strong>：在 <code>tryAcquire</code> 方法中，检查当前线程是否已经持有锁，如果是，则增加锁的持有次数（通过 <code>state</code> 变量）；如果不是，尝试使用 CAS 操作来获取锁</li>
<li><strong>实现公平性</strong>：在 <code>tryAcquire</code> 方法中，按照队列顺序来获取锁，即先检查等待队列中是否有线程在等待，如果有，当前线程必须进入队列等待，而不是直接竞争锁</li>
<li><strong>创建锁的外部类</strong>：创建一个外部类，内部持有 <code>AbstractQueuedSynchronizer</code> 的子类对象，并提供 <code>lock</code> 和 <code>unlock</code> 方法，这些方法将调用 <code>AbstractQueuedSynchronizer</code> 子类中的方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FairReentrantLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 核心同步器，继承 AQS */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ========= 独占锁基础 ========= */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 当前线程是否占有锁 */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 尝试获取锁（公平 + 可重入）*/</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;                                     <span class="comment">// 锁空闲</span></span><br><span class="line">                <span class="comment">// ★ 公平性：队列前面有人 → 当前线程必须排队</span></span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors()</span><br><span class="line">                        &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// ★ 可重入</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (next &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;lock count overflow&quot;</span>);</span><br><span class="line">                setState(next);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 竞争失败</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 尝试释放锁 */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="literal">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);               <span class="comment">// 可重入计数减 1</span></span><br><span class="line">            <span class="keyword">return</span> free;               <span class="comment">// true → 唤醒队列首线程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ========= 条件变量 ========= */</span></span><br><span class="line"></span><br><span class="line">        Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;      <span class="comment">// 每个锁可派生多个条件队列</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ========= 对外 API ========= */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>           &#123; sync.acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="comment">// 解锁方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>         &#123; sync.release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="comment">// 判断当前线程是否持有锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHeldByMe</span><span class="params">()</span>  &#123; <span class="keyword">return</span> sync.isHeldExclusively(); &#125;</span><br><span class="line">    <span class="comment">// 提供一个条件变量，用于实现更复杂的同步需求，这里只是简单实现</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123; <span class="keyword">return</span> sync.newCondition(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>代码解释</strong></p>
<p><strong>内部类 Sync</strong>：</p>
<ul>
<li><code>isHeldExclusively</code>：使用 <code>getExclusiveOwnerThread</code> 方法检查当前锁是否被当前线程持有</li>
<li><code>tryAcquire</code>：<ul>
<li>首先获取当前锁的状态 <code>c</code></li>
<li>如果 <code>c</code> 为 0，表示锁未被持有，此时进行公平性检查，通过 <code>hasQueuedPredecessors</code> 检查是否有前驱节点在等待队列中。如果没有，使用 <code>compareAndSetState</code> 尝试将状态设置为 <code>acquires</code>（通常为 1），并设置当前线程为锁的持有线程</li>
<li>如果 <code>c</code> 不为 0，说明锁已被持有，检查是否为当前线程持有。如果是，增加锁的持有次数（可重入），但要防止溢出</li>
</ul>
</li>
<li><code>tryRelease</code>：<ul>
<li>先将状态减 <code>releases</code>（通常为 1）</li>
<li>检查当前线程是否为锁的持有线程，如果不是，抛出异常</li>
<li>如果状态减为 0，说明锁被完全释放，将持有线程设为 <code>null</code></li>
</ul>
</li>
<li><code>newCondition</code>：创建一个 <code>ConditionObject</code> 用于更复杂的同步操作，如等待 &#x2F; 通知机制。</li>
</ul>
<p><strong>外部类 FairReentrantLock</strong>：</p>
<ul>
<li><code>lock</code> 方法：调用 <code>sync.acquire(1)</code> 尝试获取锁</li>
<li><code>unlock</code> 方法：调用 <code>sync.release(1)</code> 释放锁</li>
<li><code>isLocked</code> 方法：调用 <code>sync.isHeldExclusively</code> 判断锁是否被当前线程持有</li>
<li><code>newCondition</code> 方法：调用 <code>sync.newCondition</code> 提供条件变量</li>
</ul>
<p><strong>使用示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FairReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FairReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    <span class="keyword">while</span> (!ready)              <span class="comment">// 条件不满足</span></span><br><span class="line">        condition.await();      <span class="comment">// 原子释放锁 + 挂起</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="19-ThreadLocal-的作用、结构、原理与潜在问题"><a href="#19-ThreadLocal-的作用、结构、原理与潜在问题" class="headerlink" title="19# ThreadLocal 的作用、结构、原理与潜在问题"></a>19# ThreadLocal 的作用、结构、原理与潜在问题</h2><p><code>ThreadLocal</code> 是 Java 提供的一种线程本地变量机制，它为每个线程提供独立的变量副本，避免多线程共享变量导致的线程安全问题</p>
<p><strong>一、ThreadLocal 的作用</strong></p>
<ol>
<li><p><strong>线程隔离</strong><br> 每个线程都维护自己的变量副本，线程之间互不影响，天然线程安全。常用于用户信息、数据库连接、事务上下文等场景</p>
</li>
<li><p><strong>简化参数传递，降低耦合度</strong><br> 不需要在方法间层层传递参数，便于在过滤器、拦截器等框架中保存线程上下文</p>
</li>
<li><p><strong>提升性能</strong><br> 避免加锁带来的开销，相比同步机制具有更优的性能，尤其适合高并发场景下的读操作</p>
</li>
</ol>
<p><strong>二、ThreadLocalMap 的内部结构</strong></p>
<img src="https://cdn.xiaolincoding.com//picgo/1719982991053-c983c4b8-7c5f-4e2d-a90d-5b42ebd533d5.png" alt="ThreadLocalMap" style="zoom:67%;" />

<ul>
<li>实际由一个 <strong>Entry 数组</strong> 实现（本质是一个定制的 HashMap）；</li>
<li><strong>Entry 的 key 是 ThreadLocal 实例（使用弱引用 WeakReference）</strong>；</li>
<li><strong>Entry 的 value 是对应线程的变量副本</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        Object value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：虽然 key 是 <code>WeakReference</code>（GC 可回收），但 value 是强引用，这种设计容易引发内存泄漏问题：</p>
<ul>
<li>如果 <code>ThreadLocal</code> 对象被外部代码丢弃（无强引用指向），而没有调用 <code>remove()</code>，即使 key 被 GC 回收，但 value 仍在 ThreadLocalMap 中，Entry 不会被自动清除，若线程是线程池中的线程（不会很快销毁），就会导致该 value 无法回收，造成 <strong>内存泄漏</strong></li>
</ul>
<p><strong>三、ThreadLocal 的工作原理</strong></p>
<p><code>ThreadLocal</code> 的实现依赖于 <strong>Thread 类中一个专属的 <code>ThreadLocalMap</code> 字段</strong>，每个 <code>ThreadLocal</code> 实例就是这个 Map 的 key，Map 中的 Value 就是当前线程对应的变量值</p>
<ul>
<li><strong>get() 方法</strong>：读取当前线程的 <code>ThreadLocalMap</code>，查找当前 <code>ThreadLocal</code> 作为 key 的 entry，找到则返回 value；找不到时，调用 <code>initialValue()</code> 初始化，存入 Map 并返回</li>
<li><strong>set(value) 方法</strong>：将当前 <code>ThreadLocal</code> 作为 key，value 存入当前线程的 <code>ThreadLocalMap</code> 中</li>
<li><strong>remove() 方法</strong>：移除当前线程中与该 <code>ThreadLocal</code> 实例关联的 entry，释放引用，防止内存泄漏</li>
</ul>
<h2 id="20-悲观锁和乐观锁的区别？"><a href="#20-悲观锁和乐观锁的区别？" class="headerlink" title="20# 悲观锁和乐观锁的区别？"></a>20# 悲观锁和乐观锁的区别？</h2><p>在并发编程中，<strong>悲观锁</strong>与<strong>乐观锁</strong>是两种常见的并发控制策略，它们的核心区别在于对<strong>资源竞争冲突的预期和处理方式</strong>不同</p>
<p><strong>一、悲观锁</strong></p>
<p>悲观锁对并发持谨慎态度，假设资源竞争一定会发生，因此在访问数据之前<strong>主动加锁</strong>，确保同一时间只有一个线程能访问该资源</p>
<p>悲观锁通过各种加锁机制实现，在操作数据之前即加锁，阻止其他线程并发访问。性能损耗较大，但冲突处理成本低，适合写操作频繁、冲突概率高或对一致性要求极高的业务场景（如金融、订单系统）</p>
<hr>
<p><strong>二、乐观锁</strong></p>
<p>乐观锁采取 “乐观” 的态度，认为线程之间的资源竞争是偶发的，大多数情况下不会发生冲突，因此不会在操作前加锁</p>
<p>乐观锁采用 <strong>“先检查再更新”</strong> 的方式进行控制，一般通过 <strong>CAS 机制</strong> 实现，在读取数据时不加锁，在更新时，通过对比数据是否被修改来决定是否成功更新，如果检测到冲突（数据已被其他线程修改），则重试或失败。适合读多写少或并发量大但冲突概率低的业务场景（如计数器、缓存更新等）</p>
<h2 id="21-Java-中实现乐观锁的常见方式？"><a href="#21-Java-中实现乐观锁的常见方式？" class="headerlink" title="21# Java 中实现乐观锁的常见方式？"></a>21# Java 中实现乐观锁的常见方式？</h2><table>
<thead>
<tr>
<th>实现方式</th>
<th>原理</th>
<th>场景适用</th>
<th>优点</th>
</tr>
</thead>
<tbody><tr>
<td>CAS 原子操作</td>
<td>比较并交换（无锁）</td>
<td>高并发、无共享状态的并发控制</td>
<td>快速、无阻塞</td>
</tr>
<tr>
<td>版本号控制</td>
<td>基于值的一致性检测</td>
<td>ORM 框架、数据库并发更新</td>
<td>精确控制、简单可靠</td>
</tr>
<tr>
<td>时间戳控制</td>
<td>基于时间的一致性检测</td>
<td>对更新时序敏感的场景</td>
<td>直观、可追踪</td>
</tr>
</tbody></table>
<ol>
<li><strong>CAS 操作：</strong> CAS 是乐观锁的基础。Java 提供了 <code>java.util.concurrent.atomic</code> 包中的原子类（如 <code>AtomicInteger</code>、<code>AtomicLong</code>），这些类使用 CAS 操作实现了线程安全的原子操作，可以用来实现乐观锁</li>
<li><strong>版本号控制</strong>：为共享资源维护一个“版本号”字段（或称 <code>version</code> &#x2F; <code>revision</code>），在更新前后对比版本号是否一致</li>
<li><strong>时间戳</strong>：使用数据的<strong>更新时间戳</strong>进行冲突检测。在更新数据时，在比较时间戳，如果当前时间戳大于数据的时间戳，则说明数据已经被其他线程更新，更新失败</li>
</ol>
<h2 id="22-CAS-有什么缺点？"><a href="#22-CAS-有什么缺点？" class="headerlink" title="22# CAS 有什么缺点？"></a>22# CAS 有什么缺点？</h2><ol>
<li><strong>ABA 问题</strong>：CAS 更新的过程中，当读取到的值是 A，然后准备赋值的时候仍然是 A，但是实际上有可能 A 的值被改成了 B，然后又被改回了 A，这个 CAS 更新的漏洞就叫做 ABA。只是 ABA 的问题大部分场景下都不影响并发的最终效果。Java 中有 <code>AtomicStampedReference</code> 来解决这个问题，它加入了预期标志和更新后标志两个字段，更新时不光检查值，还要检查当前的标志是否等于预期标志，全部相等的话才会更新</li>
<li><strong>循环时间长开销大</strong>：自旋 CAS 的方式如果长时间不成功，会给 CPU 带来很大的开销</li>
<li><strong>只能保证一个共享变量的原子操作</strong>：CAS 只能保证<strong>单个变量</strong>的原子更新。对于多个变量的复合操作，CAS 无法直接确保整体的原子性，容易产生中间状态或数据不一致的问题。可以使用 <code>AtomicReference</code> 进行对象整体引用的原子替换，对于复杂的多变量一致性需求，仍需使用传统的同步机制（如 <code>synchronized</code> 或 <code>ReentrantLock</code>）</li>
</ol>
<h2 id="23-为什么不能所有的锁都使用-CAS？"><a href="#23-为什么不能所有的锁都使用-CAS？" class="headerlink" title="23# 为什么不能所有的锁都使用 CAS？"></a>23# 为什么不能所有的锁都使用 CAS？</h2><ol>
<li><strong>自旋重试开销大，浪费 CPU 资源</strong>：当 CAS 失败时，线程不会挂起，而是不断地进行重试，大量线程同时自旋，频繁占用 CPU，会导致系统负载升高，甚至出现性能下降</li>
<li><strong>无法处理复杂的临界区逻辑</strong>：CAS 适合用于更新<strong>简单变量（如整数、引用）<strong>的场景，但不适合处理具有</strong>复杂临界区逻辑</strong>的同步问题（如多个变量同时更新、存在阻塞等待、必须保证某段代码原子执行）</li>
<li><strong>缺乏阻塞机制，不适用于等待&#x2F;唤醒模型</strong>：CAS 本身没有提供线程挂起与唤醒机制，一旦失败只能选择不停地重试</li>
</ol>
<h2 id="24-volatile-关键字有什么作用？"><a href="#24-volatile-关键字有什么作用？" class="headerlink" title="24# volatile 关键字有什么作用？"></a>24# volatile 关键字有什么作用？</h2><p><strong>一、保证可见性</strong></p>
<p>当一个变量被声明为 <code>volatile</code> 时，它保证了<strong>该变量对所有线程的可见性</strong>。一个线程对 <code>volatile</code> 变量的写操作，<strong>会立即刷新到主内存</strong>，其他线程在读取该变量时，<strong>总是直接从主内存中获取值</strong>，而不是从线程本地缓存中读取， 这样可以避免由于线程工作内存（缓存）不同步导致的数据不一致问题</p>
<p><strong>二、禁止指令重排序）</strong></p>
<p><code>volatile</code> 可以通过插入<strong>内存屏障</strong>来禁止特定类型的指令重排序，从而在一定程度上保证有序性：</p>
<ul>
<li><strong>写屏障</strong>：在对 <code>volatile</code> 变量写入之前插入。在 <code>volatile</code> 写之前的所有普通写操作在内存中都可见，防止这些写操作被重排序到 <code>volatile</code> 写之后</li>
<li><strong>读屏障</strong>：在读取 <code>volatile</code> 变量之后插入。防止后续普通读操作被提前到 <code>volatile</code> 读操作之前执行，确保读取的是最新数据</li>
<li><strong>写-读屏障</strong>：在 <code>volatile</code> 写之后和 <code>volatile</code> 读之间。<code>volatile</code> 写之前的所有写操作在 <code>volatile</code> 读之前对其他线程可见；同时防止 <code>volatile</code> 读之后的操作被重排到前面</li>
</ul>
<h2 id="25-指令重排序的原理是什么？"><a href="#25-指令重排序的原理是什么？" class="headerlink" title="25# 指令重排序的原理是什么？"></a>25# 指令重排序的原理是什么？</h2><p>为了提升程序运行效率，<strong>编译器</strong>和<strong>CPU处理器</strong>通常会对指令执行顺序进行优化，称为<strong>指令重排序</strong>。这是一种在保证单线程语义不变的前提下，重新调整代码执行顺序的技术，它必须遵守以下两个核心原则：</p>
<ol>
<li><p><strong>单线程语义等价</strong>：重排序不能改变<strong>单线程环境下程序的执行结果</strong>。换句话说，从单线程的角度看，重排序前后程序的行为应保持一致</p>
</li>
<li><p>**遵守数据依赖性约束：如果两条语句存在数据依赖关系（如读写同一个变量），它们的执行顺序不能被重排</p>
<ul>
<li><p>写后读（Write → Read）</p>
</li>
<li><p>写后写（Write → Write）</p>
</li>
<li><p>读后写（Read → Write）</p>
</li>
</ul>
</li>
</ol>
<p>所以重排序不会对单线程有影响，只会破坏多线程的执行语义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// A</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;  <span class="comment">// B</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;  <span class="comment">// C</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>C</code> 依赖 <code>A</code> 和 <code>B</code>，即它需要在 <code>A</code> 和 <code>B</code> 之后执行</li>
<li>因此，<strong><code>C</code> 不能被重排序</strong>到 <code>A</code> 或 <code>B</code> 之前</li>
<li>但是 <code>A</code> 和 <code>B</code> 之间没有依赖关系，它们的执行顺序可以被编译器或处理器重排</li>
</ul>
<p>虽然在<strong>单线程中</strong>重排序不会影响最终结果，但在<strong>多线程环境下</strong>，不同线程看到的执行顺序可能不一致，从而引发不可预期的问题，尤其是涉及共享变量的读写操作时。因此，Java 提供了 <code>volatile</code> 关键字和 <code>synchronized</code> 等机制，来<strong>禁止特定的重排序</strong>，确保在多线程下的可见性和有序性</p>
<h2 id="26-volatile-能保证线程安全吗？"><a href="#26-volatile-能保证线程安全吗？" class="headerlink" title="26# volatile 能保证线程安全吗？"></a>26# volatile 能保证线程安全吗？</h2><p><code>volatile</code> 关键字<strong>只能保证变量的可见性</strong>，<strong>不能保证原子性</strong>，因此 <strong>并不能完全保证线程安全</strong></p>
<ul>
<li><code>volatile</code> 并不能保证原子性（如 <code>i++</code> 操作就不是原子的）</li>
<li>如果需要保证原子性，应考虑使用 <code>synchronized</code> 或原子类（如 <code>AtomicInteger</code>）</li>
<li>它适用于状态标志类变量（如 <code>stopFlag</code>、<code>ready</code> 等），但不适合用于涉及复合操作（读-改-写）的逻辑</li>
</ul>
<h2 id="27-volatile-与-sychronized-的区别？"><a href="#27-volatile-与-sychronized-的区别？" class="headerlink" title="27# volatile 与 sychronized 的区别？"></a>27# volatile 与 sychronized 的区别？</h2><table>
<thead>
<tr>
<th>特性</th>
<th><code>volatile</code></th>
<th><code>synchronized</code></th>
</tr>
</thead>
<tbody><tr>
<td>可见性</td>
<td>✅ 保证</td>
<td>✅ 保证</td>
</tr>
<tr>
<td>原子性</td>
<td>❌ 不保证</td>
<td>✅ 保证（代码块原子执行）</td>
</tr>
<tr>
<td>互斥性</td>
<td>❌ 无</td>
<td>✅ 存在</td>
</tr>
<tr>
<td>禁止重排序</td>
<td>✅ 有效</td>
<td>✅ 间接实现（通过内存语义）</td>
</tr>
<tr>
<td>使用成本</td>
<td>较低（无锁，非阻塞）</td>
<td>较高（可能阻塞，涉及上下文切换）</td>
</tr>
<tr>
<td>适用场景</td>
<td>状态标志、单例懒加载等</td>
<td>临界区保护、资源读写同步</td>
</tr>
</tbody></table>
<p><strong>一、synchronized 重量级同步机制</strong></p>
<ul>
<li><strong>作用</strong>：解决多线程访问共享资源时可能出现的竞态条件和数据不一致问题，<strong>保证线程安全</strong></li>
<li><strong>特性</strong>：<ul>
<li>保证<strong>互斥性</strong>（同一时刻只有一个线程能执行同步代码块）</li>
<li>保证<strong>可见性</strong>（进入同步块前会将线程工作内存与主内存同步）</li>
<li>隐式<strong>原子性保障</strong>（对共享资源的操作是原子的）</li>
</ul>
</li>
<li><strong>使用方式</strong>：可用于方法或代码块，加锁的对象可以是类、实例或任意对象</li>
<li><strong>性能</strong>：开销较大，尤其在高并发下容易导致线程阻塞和上下文切换</li>
</ul>
<hr>
<p><strong>二、volatile 轻量级可见性保证</strong></p>
<ul>
<li><strong>作用</strong>：用于保证变量在多线程环境下的<strong>可见性</strong>和<strong>禁止指令重排序</strong>，<strong>不保证原子性</strong></li>
<li><strong>特性</strong>：<ul>
<li><strong>不具备互斥性</strong>，无法保证操作的原子性</li>
<li>保证<strong>可见性</strong>（修改立即对其他线程可见）</li>
<li>禁止<strong>指令重排序</strong>（通过内存屏障防止重排序破坏执行语义）</li>
</ul>
</li>
<li><strong>使用方式</strong>：用于修饰变量，一般用于状态标志、配置开关等场景</li>
<li><strong>性能</strong>：非常轻量，线程不会阻塞</li>
</ul>
<h2 id="28-什么是公平锁和非公平锁？"><a href="#28-什么是公平锁和非公平锁？" class="headerlink" title="28# 什么是公平锁和非公平锁？"></a>28# 什么是公平锁和非公平锁？</h2><p><strong>一、公平锁</strong></p>
<ul>
<li><strong>定义</strong>：按照线程<strong>请求锁的顺序</strong>来获取锁，先请求的线程先获得锁，后请求的线程排队等待</li>
<li><strong>特点</strong>：类似 “排队买票”，线程按照先来先服务的原则依次执行。每个线程都有公平的机会获得锁，不容易发生<strong>线程饥饿</strong></li>
<li><strong>优点</strong>：公平性强，避免某些线程长时间得不到锁</li>
<li><strong>缺点</strong>：等待队列的调度成本较高，频繁上下文切换会降低<strong>吞吐量</strong>和<strong>整体性能</strong></li>
</ul>
<hr>
<p><strong>二、 非公平锁</strong></p>
<ul>
<li><strong>定义</strong>：线程在尝试获取锁时<strong>不考虑等待队列的顺序</strong>，先尝试<strong>直接获取锁</strong>，获取失败才进入队列排队等待。</li>
<li><strong>特点</strong>：类似 “插队”，后来的线程可能比排队线程更早获得锁。提高了竞争成功的可能性，但可能导致部分线程长时间得不到锁（<strong>线程饥饿</strong>）</li>
<li><strong>优点</strong>：整体<strong>性能更高</strong>，<strong>吞吐量更大</strong>，减少线程切换</li>
<li><strong>缺点</strong>：公平性较差，某些线程可能长期 “饿死”</li>
</ul>
<h2 id="29-非公平锁吞吐量为什么比公平锁大？"><a href="#29-非公平锁吞吐量为什么比公平锁大？" class="headerlink" title="29# 非公平锁吞吐量为什么比公平锁大？"></a>29# 非公平锁吞吐量为什么比公平锁大？</h2><p>主要原因在于其<strong>减少了线程上下文切换和排队等待</strong>的开销。以下是两者执行流程的对比说明：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>公平锁</th>
<th>非公平锁</th>
</tr>
</thead>
<tbody><tr>
<td>获取顺序</td>
<td>严格按排队顺序，先来先得</td>
<td>不保证顺序，可能“插队”</td>
</tr>
<tr>
<td>性能表现</td>
<td>有更多上下文切换，性能相对较低</td>
<td>避免频繁挂起与恢复，性能更优</td>
</tr>
<tr>
<td>实现机制</td>
<td>线程入队 → 挂起 → 唤醒 → 获取锁</td>
<td>CAS尝试获取 → 失败则入队等待</td>
</tr>
<tr>
<td>吞吐量</td>
<td>相对较低</td>
<td>相对较高</td>
</tr>
<tr>
<td>是否可能饥饿</td>
<td>否，公平调度</td>
<td>是，排在后面的线程可能长时间得不到锁</td>
</tr>
</tbody></table>
<p><strong>一、公平锁执行流程</strong></p>
<ul>
<li>当线程尝试获取锁时，会<strong>先被加入到等待队列的尾部</strong>，然后<strong>挂起（休眠）</strong>，等待被调度</li>
<li>当前持有锁的线程释放锁后，会<strong>唤醒队列中最前面的线程</strong>来尝试获取锁</li>
<li>整个过程保证了 “先来先服务” 的公平性，每个等待线程需要经历从<strong>运行态 → 阻塞态 → 运行态</strong>的切换，这些状态切换涉及<strong>用户态与内核态之间的转换</strong>，这是一种昂贵的操作</li>
<li>因此，在高并发场景下，公平锁的<strong>上下文切换频繁</strong>，导致<strong>整体性能下降、吞吐量变</strong></li>
</ul>
<hr>
<p><strong>二、非公平锁执行流程</strong></p>
<ul>
<li>当线程尝试获取锁时，会<strong>先直接通过 CAS 操作抢占锁</strong>：如果抢到锁，就直接执行，无需排队；如果没抢到，再进入等待队列排队等待下一次竞争机会</li>
<li>由于不强制按照排队顺序执行，非公平锁能<strong>减少线程挂起&#x2F;恢复的频率</strong>，避免了大量上下文切换，<strong>线程有更高的概率 “插队” 获取锁</strong>，因此锁的利用效率更高</li>
<li>这使得非公平锁在高并发环境下的<strong>响应更快，吞吐量更大</strong></li>
</ul>
<h2 id="30-synchronized-是公平锁吗？"><a href="#30-synchronized-是公平锁吗？" class="headerlink" title="30# synchronized 是公平锁吗？"></a>30# synchronized 是公平锁吗？</h2><p>不是。<code>synchronized</code> 并<strong>不保证公平性</strong>，因此它并不是一种公平锁。在多线程竞争锁资源时，<code>synchronized</code> 采用的是<strong>非公平策略</strong>：当锁被释放时，<strong>所有等待线程都会同时竞争该锁</strong>，谁先抢到谁执行，线程的获取顺序<strong>不一定按照等待的先后顺序</strong></p>
<p>相比之下，<code>ReentrantLock</code> 是 Java 中提供的<strong>可重入锁</strong>，它<strong>支持公平和非公平两种模式</strong>，默认情况下，<code>ReentrantLock</code> 使用的是非公平策略；若需要公平性，可以通过构造方法 <code>new ReentrantLock(true)</code> 来显式指定为<strong>公平锁</strong></p>
<h2 id="31-ReentrantLock是怎么实现公平锁的？"><a href="#31-ReentrantLock是怎么实现公平锁的？" class="headerlink" title="31# ReentrantLock是怎么实现公平锁的？"></a>31# ReentrantLock是怎么实现公平锁的？</h2><p><code>ReentrantLock</code> 通过 <strong>Sync 内部类</strong>（继承自 AQS） 来区分 “公平锁” 和 “非公平锁”。二者在<strong>获取锁</strong>时的关键分支不同：</p>
<p><del><strong>太长不看版</strong></del></p>
<table>
<thead>
<tr>
<th>比较维度</th>
<th>公平锁 (<code>tryAcquire</code>)</th>
<th>非公平锁 (<code>nonfairTryAcquire</code>)</th>
</tr>
</thead>
<tbody><tr>
<td>获取策略</td>
<td>先检查 <code>hasQueuedPredecessors()</code>，前驱为空才能抢锁</td>
<td>直接 CAS 抢锁，失败后再排队</td>
</tr>
<tr>
<td>性能</td>
<td>上下文切换多，吞吐量稍低</td>
<td>吞吐量高，但可能产生线程饥饿</td>
</tr>
<tr>
<td>场景选择</td>
<td>需要严格先来先得 &#x2F; 避免饥饿</td>
<td>追求吞吐量、对公平性不敏感</td>
</tr>
</tbody></table>
<p><strong>公平锁源码（节选）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();                 <span class="comment">// ① 读锁状态</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ② “排队检查”：AQS 队列前面是否还有线程？</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">// 公平锁核心：必须排第一</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// ③ 可重入</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>核心语句</strong>：<code>hasQueuedPredecessors()</code></p>
<ul>
<li>返回 <code>true</code> ⇒ 队列中已有前驱线程，当前线程<strong>不得“插队”</strong>，必须排队</li>
<li>返回 <code>false</code> ⇒ 当前线程位于队首，可立即 CAS 抢锁</li>
</ul>
<p>因此，公平锁 <strong>严格按照先来后到</strong> 的排队顺序获取锁，避免了饿死现象，但带来了更多<strong>上下文切换</strong>成本</p>
<hr>
<p> <strong>非公平锁源码（节选）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();                 <span class="comment">// ① 读锁状态</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ② 直接 CAS 抢锁，不看队列</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// ③ 可重入</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>没有队列检查</strong>：线程一来就尝试 CAS 抢锁，成功则立即进入临界区，失败再进入队列挂起</li>
<li>好处：<strong>吞吐量更高</strong>（锁刚释放时附近线程可立即命中锁）</li>
<li>风险：可能出现“插队”，导致等待队列里的某些线程<strong>长时间得不到锁</strong>（轻度饥饿）</li>
</ul>
<hr>
<p><strong><code>tryLock()</code> 的特例</strong></p>
<p>无论 <code>ReentrantLock</code> 创建时指定的是公平 (<code>new ReentrantLock(true)</code>) 还是非公平模式，<strong><code>tryLock()</code> 一律使用非公平策略</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);   <span class="comment">// 始终调用非公平实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tryLock()</code> 本身语义就是“立即尝试一次”，所以可以“插队”成功，而不保证排队顺序</p>
<h2 id="32-什么情况会产生死锁问题？如何解决？"><a href="#32-什么情况会产生死锁问题？如何解决？" class="headerlink" title="32# 什么情况会产生死锁问题？如何解决？"></a>32# 什么情况会产生死锁问题？如何解决？</h2><p>死锁的发生必须<strong>同时满足以下四个条件</strong>：</p>
<ol>
<li><strong>互斥条件</strong>：某个资源一次只能被一个线程占用，不能共享使用</li>
<li><strong>占有且等待条件</strong>： 线程已持有至少一个资源，并且在等待获取其他被别的线程占用的资源，<strong>不释放当前已有资源</strong></li>
<li><strong>不可抢占条件</strong>：线程已获取的资源在未使用完之前<strong>不能被强行剥夺</strong>，只能线程自己释放</li>
<li><strong>循环等待条件</strong>：存在一个线程资源的循环等待链，即线程 A 等待线程 B 占用的资源，而线程 B 又在等待线程 A 的资源</li>
</ol>
<p>只要<strong>打破任意一个死锁条件</strong>，就可以有效避免死锁。最常见的并且可行的就是<strong>使用资源有序分配法，来破环环路等待条件</strong>：给资源编号，规定线程必须<strong>按照固定顺序申请资源</strong>，例如，无论线程 A 还是线程 B，始终按照 “先申请资源 R1，再申请资源 R2” 的顺序来获取资源</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="1-介绍一下线程池的工作原理"><a href="#1-介绍一下线程池的工作原理" class="headerlink" title="1# 介绍一下线程池的工作原理"></a>1# 介绍一下线程池的工作原理</h2><img src="https://cdn.xiaolincoding.com//picgo/1719389039034-0de42388-4ec6-44a6-9583-5d018e5cb4f3.png" alt="线程池的工作原理" style="zoom: 67%;" />

<p>线程池的主要作用是<strong>复用线程资源，避免频繁创建和销毁线程带来的性能开销</strong>。它通过预先创建一定数量的线程，并维护一个任务队列来管理并发任务，从而提高系统整体吞吐量和响应速度</p>
<p>线程池的设计理念是通过<strong>线程重用 + 队列排队 + 最大并发限制</strong>来管理资源和任务调度，它的典型执行策略是：</p>
<ul>
<li><strong>优先使用核心线程</strong></li>
<li><strong>核心线程满 → 入队列</strong></li>
<li><strong>队列满 → 创建非核心线程（直到最大线程数）</strong></li>
<li><strong>超出最大线程数 → 执行拒绝策略</strong></li>
</ul>
<h2 id="2-线程池的参数有哪些？"><a href="#2-线程池的参数有哪些？" class="headerlink" title="2# 线程池的参数有哪些？"></a>2# 线程池的参数有哪些？</h2><ol>
<li><p><strong><code>corePoolSize</code>（核心线程数）</strong>：线程池中<strong>常驻的线程数量</strong>。即使这些线程处于空闲状态，也不会被销毁，除非设置了 <code>allowCoreThreadTimeOut(true)</code></p>
</li>
<li><p><strong><code>maximumPoolSize</code>（最大线程数）</strong>：线程池中允许创建的<strong>最大线程数量</strong>。当任务过多、核心线程和队列都满时，线程池才会继续创建新线程，直到达到该上限</p>
</li>
<li><p><strong><code>keepAliveTime</code>（空闲线程存活时间）</strong>：当线程数<strong>大于核心线程数</strong>时，空闲线程在达到该时间后将被销毁，以节省资源</p>
</li>
<li><p><strong><code>unit</code>（时间单位）</strong>：<code>keepAliveTime</code> 的时间单位，例如 <code>TimeUnit.SECONDS</code>、<code>TimeUnit.MILLISECONDS</code> 等。</p>
</li>
<li><p><strong><code>workQueue</code>（任务队列）</strong>：用来保存<strong>待执行的任务</strong>。当所有核心线程都在忙时，新的任务会被加入该队列等待执行。常见实现包括：</p>
<ul>
<li><p><code>ArrayBlockingQueue</code>（有界队列）</p>
</li>
<li><p><code>LinkedBlockingQueue</code>（无界队列）</p>
</li>
<li><p><code>SynchronousQueue</code>（直接交付）</p>
</li>
<li><p><code>PriorityBlockingQueue</code>（优先级队列）</p>
</li>
</ul>
</li>
<li><p><strong><code>threadFactory</code>（线程工厂）</strong>：用于自定义线程的创建方式，通常可用来设置线程名称、优先级、是否为守护线程等</p>
</li>
<li><p><strong><code>handler</code>（拒绝策略）</strong>：当线程池<strong>达到最大线程数并且任务队列已满</strong>时的处理策略</p>
</li>
</ol>
<h2 id="3-线程池有哪些拒绝策略？"><a href="#3-线程池有哪些拒绝策略？" class="headerlink" title="3# 线程池有哪些拒绝策略？"></a>3# 线程池有哪些拒绝策略？</h2><ul>
<li><p><code>AbortPolicy</code>（抛出异常策略）：默认策略，直接<strong>抛出 <code>RejectedExecutionException</code> 异常</strong>，提醒程序任务已被拒绝处理</p>
</li>
<li><p><code>CallerRunsPolicy</code>（调用者执行策略）：由提交任务的线程（通常是主线程）<strong>直接执行该任务</strong>，从而降低任务提交的速度，避免任务快速堆积</p>
</li>
<li><p><code>DiscardPolicy</code>（静默丢弃策略）：<strong>不抛异常，也不执行被拒绝的任务</strong>，直接丢弃任务</p>
</li>
<li><p><code>DiscardOldestPolicy</code>（丢弃最旧任务策略）：<strong>丢弃任务队列中最早的任务</strong>，然后尝试重新提交当前任务</p>
</li>
</ul>
<p>此外，通过实现 <code>RejectedExecutionHandler</code> 接口，可以根据业务需求编写自定义拒绝策略，例如记录日志、报警、持久化任务等：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomRejectHandler</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义处理逻辑，如记录日志、发送告警、持久化等</span></span><br><span class="line">        System.out.println(<span class="string">&quot;任务被拒绝：&quot;</span> + r.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-如何设置线程池参数？"><a href="#4-如何设置线程池参数？" class="headerlink" title="4# 如何设置线程池参数？"></a>4# 如何设置线程池参数？</h2><p><strong>核心线程数（<code>corePoolSize</code>）设置原则：</strong></p>
<ul>
<li><p><strong>CPU 密集型任务</strong>（如加解密、图像处理等）：<code>corePoolSize = CPU 核数 + 1</code>，避免线程频繁上下文切换，充分利用每个核心</p>
</li>
<li><p><strong>IO 密集型任务</strong>（如网络、数据库访问）：<code>corePoolSize = CPU 核数 × 2</code> 或更高，线程大部分时间阻塞于 IO，适当提高线程数以提升吞吐</p>
</li>
</ul>
<p><strong>场景一：电商高并发请求处理</strong>，突发流量高、任务处理快、对响应时间敏感</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">16</span>,                     <span class="comment">// corePoolSize（假设8核CPU × 2）</span></span><br><span class="line">    <span class="number">32</span>,                     <span class="comment">// maximumPoolSize，短时扩容</span></span><br><span class="line">    <span class="number">10</span>, TimeUnit.SECONDS,   <span class="comment">// 非核心线程空闲 10 秒后回收</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(), <span class="comment">// 无缓冲，任务直达线程</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy() <span class="comment">// 拒绝策略：快速失败</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>SynchronousQueue</code> 保证任务直达线程，响应及时</li>
<li>非核心线程可临时扩容，适应突发流量</li>
<li>拒绝策略使用 <code>AbortPolicy</code>，快速失败，结合前端提示“活动火爆”与缓存降级，保护系统稳定</li>
</ul>
<hr>
<p><strong>场景二：后台批处理或日志分析</strong>，流量稳定、任务耗时长、允许延迟</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">8</span>,                             <span class="comment">// 固定线程数，避免资源波动</span></span><br><span class="line">    <span class="number">8</span>,</span><br><span class="line">    <span class="number">0</span>, TimeUnit.SECONDS,           <span class="comment">// 线程始终保留，不回收</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1000</span>), <span class="comment">// 有界队列，容量1000</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="comment">// 调用线程兜底执行</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>限制线程数量，避免资源过载</li>
<li>队列缓冲大量任务，适用于慢速处理</li>
<li>使用 <code>CallerRunsPolicy</code>，队列满时由调用线程执行任务，起到背压效果</li>
<li>配合监控系统，当队列使用率超过阈值（如 80%）可自动触发扩容或报警</li>
</ul>
<hr>
<p><strong>场景三：微服务中处理 HTTP 请求</strong>，IO 密集型，依赖下游服务响应，需考虑请求超时和排队时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">16</span>,                            <span class="comment">// 8 核 CPU × 2，适应 IO 阻塞</span></span><br><span class="line">    <span class="number">64</span>,                            <span class="comment">// 最大线程数，支持更多并发</span></span><br><span class="line">    <span class="number">60</span>, TimeUnit.SECONDS,          <span class="comment">// 非核心线程空闲 1 分钟后回收</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">200</span>), <span class="comment">// 有界队列，防止OOM</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CustomRetryPolicy</span>()         <span class="comment">// 自定义拒绝策略</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>较高的最大线程数应对下游慢响应</li>
<li>有界队列防止内存泄露</li>
<li>自定义拒绝策略（例如将任务放入 Redis 或消息队列）实现异步重试或降级</li>
<li>可配合服务熔断、限流等机制构建完整容灾链路</li>
</ul>
<h2 id="5-核心线程数设置为-0-可以吗？"><a href="#5-核心线程数设置为-0-可以吗？" class="headerlink" title="5# 核心线程数设置为 0 可以吗？"></a>5# 核心线程数设置为 0 可以吗？</h2><p>可以，当核心线程数为 0 的时候，会创建一个非核心线程进行执行</p>
<p>任务提交后，<strong>任务会先尝试加入任务队列</strong>，如果当前没有线程在运行（即 <code>workerCount == 0</code>），则会创建一个<strong>非核心线程</strong>来处理队列中的任务，当任务处理完毕，且该线程处于空闲状态超过 <code>keepAliveTime</code>，它也会被回收</p>
<h2 id="6-线程池种类有哪些？"><a href="#6-线程池种类有哪些？" class="headerlink" title="6# 线程池种类有哪些？"></a>6# 线程池种类有哪些？</h2><p>Java 提供了多种内置线程池，位于 <code>java.util.concurrent.Executors</code> 工具类中，适用于不同的任务调度场景：</p>
<ol>
<li><p><strong>ScheduledThreadPool</strong></p>
<ul>
<li><p><strong>功能：</strong> 支持<strong>定时执行</strong>或<strong>周期性执行</strong>任务</p>
</li>
<li><p><strong>适用场景：</strong> 适合需要在固定时间间隔内重复执行任务的场景，例如：每隔 10 秒执行一次日志清理任务</p>
</li>
<li><p><strong>核心特点：</strong> 使用 <code>ScheduledExecutorService</code> 接口，可通过 <code>schedule()</code> 或 <code>scheduleAtFixedRate()</code> 方法配置延迟或周期性任务</p>
</li>
</ul>
</li>
<li><p><strong>FixedThreadPool</strong></p>
<ul>
<li><p><strong>功能：</strong> 创建一个固定线程数量的线程池</p>
</li>
<li><p><strong>适用场景：</strong> 稳定并发量的业务场景，如处理日志、消息消费等</p>
</li>
<li><p><strong>核心特点：</strong></p>
<ul>
<li>核心线程数 &#x3D; 最大线程数，线程数固定</li>
<li>超过线程数的任务会被放入阻塞队列等待执行</li>
<li>队列满时不会再扩展线程数量，可能触发拒绝策略</li>
<li>线程空闲不会被销毁，长期占用资源</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>CachedThreadPool</strong></p>
<ul>
<li><p><strong>功能：</strong> 创建一个可以无限扩展线程数量的线程池（理论上最大线程数为 <code>Integer.MAX_VALUE</code>）</p>
</li>
<li><p><strong>适用场景：</strong> 适合执行大量、短生命周期的异步任务</p>
</li>
<li><p><strong>核心特点：</strong></p>
<ul>
<li>使用 <code>SynchronousQueue</code> 作为任务队列（容量为 0，不存储任务，只做转交）</li>
<li>没有核心线程，任务来就创建线程</li>
<li>空闲线程在 60 秒后回收</li>
<li>创建和销毁线程代价相对较高，慎用</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>SingleThreadExecutor</strong></p>
<ul>
<li><p><strong>功能：</strong> 创建一个只有<strong>单个工作线程</strong>的线程池</p>
</li>
<li><p><strong>适用场景：</strong> 所有任务需要<strong>严格按照提交顺序</strong>执行的场景</p>
</li>
<li><p><strong>核心特点：</strong></p>
<ul>
<li>使用一个线程串行执行所有任务</li>
<li>线程异常退出时，会自动创建新的线程保障执行连续性</li>
<li>类似 <code>FixedThreadPool(1)</code>，但具备更强的顺序性保障</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>SingleThreadScheduledExecutor</strong></p>
<ul>
<li><p><strong>功能：</strong> 单线程版本的 <code>ScheduledThreadPool</code>，支持定时和周期性任务调度</p>
</li>
<li><p><strong>适用场景：</strong> 需要按顺序、定时执行任务的单线程场景</p>
</li>
<li><p><strong>核心特点：</strong></p>
<ul>
<li>内部只有一个线程</li>
<li>能保证任务按顺序定时执行</li>
<li>是 <code>ScheduledThreadPoolExecutor</code> 的特例</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>是否固定线程</th>
<th>是否支持定时</th>
<th>是否支持扩容</th>
<th>是否保证顺序</th>
</tr>
</thead>
<tbody><tr>
<td><code>FixedThreadPool</code></td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td><code>CachedThreadPool</code></td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td><code>ScheduledThreadPool</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td><code>SingleThreadExecutor</code></td>
<td>✅（1个）</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td><code>SingleThreadScheduledExecutor</code></td>
<td>✅（1个）</td>
<td>✅</td>
<td>❌</td>
<td>✅</td>
</tr>
</tbody></table>
<h2 id="7-线程池一般是怎么用的？"><a href="#7-线程池一般是怎么用的？" class="headerlink" title="7# 线程池一般是怎么用的？"></a>7# 线程池一般是怎么用的？</h2><p>Java 中的 <code>Executors</code> 类定义了一些快捷的工具方法，来帮助我们快速创建线程池。《阿里巴巴 Java 开发手册》中提到，禁止使用这些方法来创建线程池，而应该手动 <code>new ThreadPoolExecutor</code> 来创建线程池</p>
<p>为什么尽量不要用 <code>Executors</code> 快捷工厂？</p>
<table>
<thead>
<tr>
<th><code>Executors</code> 工厂方法</th>
<th>潜在风险</th>
<th>典型事故场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>newFixedThreadPool</code></td>
<td><strong>无界阻塞队列</strong>任务持续堆积 → 内存飙升</td>
<td>高并发秒杀、批量导入，队列挤满导致 OOM</td>
</tr>
<tr>
<td><code>newCachedThreadPool</code></td>
<td><strong>线程无限制增长</strong> (<code>Integer.MAX_VALUE</code>)快速消耗 CPU &#x2F; 句柄</td>
<td>下游接口持续超时，线程池疯狂扩容抢锁、最终拖垮机器</td>
</tr>
</tbody></table>
<ul>
<li>我们需要根据自己的场景、并发情况来评估线程池的几个核心参数，确保线程池的工作行为符合需求，一般都需要设置有界的工作队列和可控的线程数</li>
<li>任何时候，都应该为自定义线程池指定有意义的名称，以方便排查问题。当出现线程数量暴增、线程死锁、线程占用大量 CPU、线程执行出现异常等问题时，我们往往会抓取线程栈。此时，有意义的线程名称，就可以方便我们定位问题</li>
</ul>
<p>除了建议手动声明线程池以外，我还建议用一些监控手段来观察线程池的状态。线程池这个组件往往会表现得任劳任怨、默默无闻，除非是出现了拒绝策略，否则压力再大都不会抛出一个异常。如果我们能提前观察到线程池队列的积压，或者线程数量的快速膨胀，往往可以提早发现并解决问题。</p>
<h2 id="8-线程池中-shutdown-、shutdownNow-这两个方法有什么作用？"><a href="#8-线程池中-shutdown-、shutdownNow-这两个方法有什么作用？" class="headerlink" title="8# 线程池中 shutdown ()、shutdownNow() 这两个方法有什么作用？"></a>8# 线程池中 shutdown ()、shutdownNow() 这两个方法有什么作用？</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>行为特征</th>
</tr>
</thead>
<tbody><tr>
<td><code>shutdown()</code></td>
<td>优雅关闭：执行中的任务继续，等待队列中的任务照常处理</td>
</tr>
<tr>
<td><code>shutdownNow()</code></td>
<td>强制关闭：中断正在执行的任务，清空队列，立即返回未处理任务</td>
</tr>
<tr>
<td>共同点</td>
<td>都会拒绝新的任务提交，线程池状态都会改变，最终尝试终止线程池</td>
</tr>
</tbody></table>
<p><strong>一、<code>shutdown()</code></strong></p>
<p>调用 <code>shutdown()</code> 方法后，线程池的状态将被设置为 <code>SHUTDOWN</code>，此时：</p>
<ul>
<li>已提交但尚未执行的任务<strong>会继续排队等待执行</strong></li>
<li>正在执行的任务<strong>会继续执行直至完成</strong></li>
<li>线程池<strong>不再接收新的任务提交</strong>，否则会抛出 <code>RejectedExecutionException</code> 异常</li>
<li><strong>不会中断正在运行的线程</strong></li>
</ul>
<p>适用于<strong>优雅关闭线程池</strong>的场景</p>
<hr>
<p><strong>二、<code>shutdownNow()</code></strong></p>
<p>调用 <code>shutdownNow()</code> 方法后，线程池状态被设置为 <code>STOP</code>，并执行如下操作：</p>
<ul>
<li><strong>立即中断所有正在运行的线程</strong>（通过 <code>Thread.interrupt()</code> 实现）</li>
<li><strong>放弃队列中尚未执行的任务</strong>，并将这些任务作为 <code>List&lt;Runnable&gt;</code> 返回</li>
<li>同样<strong>不再接受新的任务提交</strong></li>
</ul>
<p>但请注意：<code>Thread.interrupt()</code> 仅能中断那些处于阻塞状态（如 <code>sleep()</code>、<code>wait()</code>、<code>join()</code>、<code>Condition.await()</code>、定时锁等）的线程，对于纯计算类任务并无实际中断效果</p>
<p>因此，调用 <code>shutdownNow()</code> 并不意味着线程池能够<strong>立即关闭</strong>，它可能仍需等待某些任务结束才能真正终止</p>
<h2 id="9-提交给线程池的任务可以撤回吗？"><a href="#9-提交给线程池的任务可以撤回吗？" class="headerlink" title="9# 提交给线程池的任务可以撤回吗？"></a>9# 提交给线程池的任务可以撤回吗？</h2><p>可以。在 Java 中，当向线程池提交任务时，会返回一个 <code>Future</code> 对象。通过这个对象，可以对任务的执行过程进行控制，例如：获取任务执行结果、判断任务是否完成、尝试取消任务执行</p>
<p><code>Future</code> 接口提供了 <code>cancel(boolean mayInterruptIfRunning)</code> 方法，用于取消任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>mayInterruptIfRunning = true</code>：如果任务正在运行，尝试中断该任务（调用 <code>Thread.interrupt()</code>）</li>
<li><code>mayInterruptIfRunning = false</code>：如果任务已启动，则不会中断，仅取消尚未开始的任务</li>
</ul>
<p>此外，<code>Future</code> 还提供了以下常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;   <span class="comment">// 判断任务是否已取消</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;        <span class="comment">// 判断任务是否已完成（成功/失败/取消都算完成）</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">()</span>;                 <span class="comment">// 获取任务结果（阻塞直到结果返回或异常抛出）</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span>; <span class="comment">// 限时获取任务结果</span></span><br></pre></td></tr></table></figure>

<p>取消线程池中的任务示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CancelTaskDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        Future&lt;?&gt; future = service.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟耗时任务</span></span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;任务完成&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务被中断&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 等待任务完成</span></span><br><span class="line">            future.get(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException | TimeoutException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务超时，尝试取消...&quot;</span>);</span><br><span class="line">            <span class="comment">// 超时后尝试取消任务（允许中断）</span></span><br><span class="line">            future.cancel(<span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            service.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><h2 id="1-多线程打印奇偶数，怎么控制打印的顺序？"><a href="#1-多线程打印奇偶数，怎么控制打印的顺序？" class="headerlink" title="1# 多线程打印奇偶数，怎么控制打印的顺序？"></a>1# 多线程打印奇偶数，怎么控制打印的顺序？</h2><p><strong>交替打印奇偶数（<code>wait/notify</code> 方案）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintOddEven</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">odd</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; printNumber(<span class="literal">true</span>),  <span class="string">&quot;OddThread&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">even</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; printNumber(<span class="literal">false</span>), <span class="string">&quot;EvenThread&quot;</span>);</span><br><span class="line">        odd.start();</span><br><span class="line">        even.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@param</span> printOdd true 打印奇数，false 打印偶数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printNumber</span><span class="params">(<span class="type">boolean</span> printOdd)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                <span class="keyword">if</span> (counter &gt; MAX) &#123;</span><br><span class="line">                    LOCK.notifyAll();          <span class="comment">// 唤醒对方后退出</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((counter &amp; <span class="number">1</span>) == (printOdd ? <span class="number">1</span> : <span class="number">0</span>)) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%s : %d%n&quot;</span>,</span><br><span class="line">                            Thread.currentThread().getName(), counter++);</span><br><span class="line">                    LOCK.notifyAll();          <span class="comment">// 打印完唤醒对方</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123; LOCK.wait(); &#125;       <span class="comment">// 条件不满足，挂起</span></span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么能交替输出？</strong></p>
<ol>
<li><strong>共享状态</strong>：<code>counter</code> 决定当前应打印奇数还是偶数</li>
<li><strong>互斥</strong>：<code>synchronized (LOCK)</code> 保证同一时刻只有一个线程在修改 <code>counter</code></li>
<li><strong>协作</strong>：打印线程完成一次输出后调用 <code>notifyAll()</code>，提醒对方线程条件可能满足,如果发现当前不该自己打印，则调用 <code>wait()</code> 释放锁并挂起，等待被唤醒</li>
</ol>
<p>这样就形成了“<strong>打印 → 唤醒对方 → 自己等待</strong>”的循环，保证奇、偶顺序交替</p>
<p><strong>注意</strong>：<code>notifyAll()</code> 比 <code>notify()</code> 更安全，避免“假唤醒”或只有单线程等待场景时对方仍沉睡</p>
<h2 id="2-单例模型既然已经用了-synchronized，为什么还要在加-volatile？"><a href="#2-单例模型既然已经用了-synchronized，为什么还要在加-volatile？" class="headerlink" title="2# 单例模型既然已经用了 synchronized，为什么还要在加 volatile？"></a>2# 单例模型既然已经用了 synchronized，为什么还要在加 volatile？</h2><p>使用 <code>synchronized</code> 和 <code>volatile</code> 一起，可以创建一个既线程安全又能正确初始化的单例模式，避免了多线程环境下的各种潜在问题。这是一种比较完善的线程安全的单例模式实现方式，尤其适用于高并发环境</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>synchronized</code> 关键字的作用用于确保在多线程环境下，只有一个线程能够进入同步块（这里是 <code>synchronized (Singleton.class)</code>）。在创建单例对象时，通过 <code>synchronized</code> 保证了创建过程的线程安全性，避免多个线程同时创建多个单例对象</p>
<p><code>volatile</code> 确保了对象引用的可见性和创建过程的有序性，避免了由于指令重排序而导致的错误</p>
<p><code>instance = new Singleton();</code> 这行代码并不是一个原子操作，它实际上可以分解为以下几个步骤：</p>
<ul>
<li>分配内存空间。</li>
<li>实例化对象。</li>
<li>将对象引用赋值给 <code>instance</code>。</li>
</ul>
<p>由于 Java 内存模型允许编译器和处理器对指令进行重排序，在没有 <code>volatile</code> 的情况下，可能会出现重排序，例如先将对象引用赋值给 <code>instance</code>，但对象的实例化操作尚未完成</p>
<p>这样，其他线程在检查 <code>instance == null</code> 时，会认为单例已经创建，从而得到一个未完全初始化的对象，导致错误</p>
<p><code>volatile</code> 可以保证变量的可见性和禁止指令重排序。它确保对 <code>instance</code> 的修改对所有线程都是可见的，并且保证了上述三个步骤按顺序执行，避免了在单例创建过程中因指令重排序而导致的问题</p>
<h2 id="3-3-个线程并发执行，1-个线程等待这三个线程全部执行完在执行，怎么实现？"><a href="#3-3-个线程并发执行，1-个线程等待这三个线程全部执行完在执行，怎么实现？" class="headerlink" title="3# 3 个线程并发执行，1 个线程等待这三个线程全部执行完在执行，怎么实现？"></a>3# 3 个线程并发执行，1 个线程等待这三个线程全部执行完在执行，怎么实现？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatchDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">workers</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(workers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 个工作线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= workers; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Worker-&quot;</span> + id + <span class="string">&quot; working...&quot;</span>);</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;Worker-&quot;</span> + id + <span class="string">&quot; done.&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    latch.countDown();         <span class="comment">// 完成后递减计数</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有工作线程结束</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Awaiting completion of workers...&quot;</span>);</span><br><span class="line">                latch.await();                 <span class="comment">// 阻塞，直到计数=0</span></span><br><span class="line">                System.out.println(<span class="string">&quot;All workers finished. Main task starts.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Coordinator&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码说明</strong></p>
<ol>
<li><code>CountDownLatch latch = new CountDownLatch(3);</code><br> 创建一个计数器，初始值为 3，代表有 3 个线程需要 “倒计时”</li>
<li>每个线程在执行完任务后，调用 <code>latch.countDown()</code> 将计数器减 1</li>
<li>第 4 个线程调用 <code>latch.await()</code>，阻塞等待直到计数器变为 0，再继续执行自己的任务</li>
</ol>
<h2 id="4-假设两个线程并发读写同一个整型变量，初始值为零，每个线程加-50-次，结果可能是什么？"><a href="#4-假设两个线程并发读写同一个整型变量，初始值为零，每个线程加-50-次，结果可能是什么？" class="headerlink" title="4# 假设两个线程并发读写同一个整型变量，初始值为零，每个线程加 50 次，结果可能是什么？"></a>4# 假设两个线程并发读写同一个整型变量，初始值为零，每个线程加 50 次，结果可能是什么？</h2><p>在没有任何同步机制的情况下，两个线程并发对同一个整型变量进行 50 次加 1 操作，最终结果可能是 100，也可能小于 100，最坏的结果是 50，也就是最终的结果可能是在 [50, 100] </p>
<p><strong>原因</strong></p>
<p><code>num++</code> 操作并不是原子操作，它实际包含以下三个步骤：</p>
<ol>
<li>读取变量的当前值</li>
<li>将值加 1</li>
<li>将新值写回变量</li>
</ol>
<p>在多线程环境中，如果两个线程同时读取了相同的值并分别加 1，然后再写回，就会导致 “加 1” 操作丢失，从而导致最终结果小于预期</p>
<p><strong>解决方案一：使用 AtomicInteger</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerAddition</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                num.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                num.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;最终结果: &quot;</span> + num.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案二：使用 synchronized 或 ReentrantLock</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedAddition</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;最终结果: &quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 hot100 笔记</title>
    <url>/2025/09/08/leetcode-notes/</url>
    <content><![CDATA[<p> leetcode hot100</p>
<span id="more"></span>

<h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 104</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
<li><strong>只会存在一个有效答案</strong></li>
</ul>
<p>**进阶：**你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p>
<p><strong>解题思路</strong></p>
<ol>
<li>遍历数组 <code>nums</code></li>
<li>对于当前数字 <code>x = nums[i]</code>，计算它的<strong>配对数</strong> <code>diff = target - x</code></li>
<li>如果 <code>diff</code> 已经在哈希表中出现过，说明找到了答案，返回下标</li>
<li>否则，将 <code>x</code> 和它的下标 <code>i</code> 存入哈希表，方便后续查找</li>
<li>时间复杂度 <strong>O(n)</strong>，空间复杂度 <strong>O(n)</strong></li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果配对数出现过，直接返回答案</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(diff)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;map.get(diff), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 否则存入当前值和下标</span></span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x。</p>
<p>空间复杂度：O(n)，其中 n 是数组中的元素数量。主要为哈希表的开销。</p>
<h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a>49. 字母异位词分组</h2><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p>
<p><strong>示例 1:</strong></p>
<p><strong>输入:</strong> strs &#x3D; [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]</p>
<p><strong>输出:</strong> [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]</p>
<p><strong>解释：</strong></p>
<ul>
<li>在 strs 中没有字符串可以通过重新排列来形成 <code>&quot;bat&quot;</code>。</li>
<li>字符串 <code>&quot;nat&quot;</code> 和 <code>&quot;tan&quot;</code> 是字母异位词，因为它们可以重新排列以形成彼此。</li>
<li>字符串 <code>&quot;ate&quot;</code> ，<code>&quot;eat&quot;</code> 和 <code>&quot;tea&quot;</code> 是字母异位词，因为它们可以重新排列以形成彼此。</li>
</ul>
<p><strong>示例 2:</strong></p>
<p><strong>输入:</strong> strs &#x3D; [“”]</p>
<p><strong>输出:</strong> [[“”]]</p>
<p><strong>示例 3:</strong></p>
<p><strong>输入:</strong> strs &#x3D; [“a”]</p>
<p><strong>输出:</strong> [[“a”]]</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= strs.length &lt;= 104</code></li>
<li><code>0 &lt;= strs[i].length &lt;= 100</code></li>
<li><code>strs[i]</code> 仅包含小写字母</li>
</ul>
<p><strong>解题思路</strong></p>
<ul>
<li>把字符串的字符排序后作为 key</li>
<li>用 <code>Map&lt;String, List&lt;String&gt;&gt;</code> 存储</li>
<li>时间复杂度：O(n * k log k)，k 为单词平均长度</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (String s : strs) &#123;</span><br><span class="line">            <span class="comment">// 将字符串排序</span></span><br><span class="line">            <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">            Arrays.sort(chars);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 放入对应的分组</span></span><br><span class="line">            map.computeIfAbsent(key, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(nk log k)，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度。需要遍历 n 个字符串，对于每个字符串，需要 O(k log k) 的时间进行排序以及 O(1) 的时间更新哈希表，因此总时间复杂度是 O(nk log k)。</p>
<p>空间复杂度：O(nk)，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度。需要用哈希表存储全部字符串。</p>
<h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a>128. 最长连续序列</h2><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,3,7,2,5,8,4,6,0,1]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,0,1,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 105</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li><p>把所有数字放进一个 <code>HashSet</code>，方便 O(1) 查询某个数字是否存在。</p>
</li>
<li><p>遍历每个数字 <code>num</code>：</p>
<ul>
<li><p>只从<strong>连续序列的起点</strong>开始往后数（即 <code>num - 1</code> 不在集合里时）</p>
</li>
<li><p>不然会重复计算，比如序列 [1,2,3,4]，从 2 开始也能找到长度 3，但没必要</p>
</li>
</ul>
</li>
<li><p>从起点 <code>num</code> 往后连续查找 <code>num+1, num+2, ...</code>，直到不连续为止，更新最大长度。</p>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">longest</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : set) &#123;</span><br><span class="line">            <span class="comment">// 只从序列起点开始查</span></span><br><span class="line">            <span class="keyword">if</span> (!set.contains(num - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">currentNum</span> <span class="operator">=</span> num;</span><br><span class="line">                <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (set.contains(currentNum + <span class="number">1</span>)) &#123;</span><br><span class="line">                    currentNum++;</span><br><span class="line">                    length++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                longest = Math.max(longest, length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 为数组的长度。具体分析已在上面正文中给出。</li>
<li>空间复杂度：O(n)。哈希表存储数组中所有的数需要 O(n) 的空间。</li>
</ul>
<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h2><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0]</span><br><span class="line">输出: [0]</span><br></pre></td></tr></table></figure>

<p><strong>提示</strong>:</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
</ul>
<p>**进阶：**你能尽量减少完成的操作次数吗？</p>
<p><strong>解题思路</strong></p>
<ol>
<li><p>双指针法：</p>
<ul>
<li><p><code>slow</code>：记录下一个非零元素应该放的位置</p>
</li>
<li><p><code>fast</code>：遍历数组</p>
</li>
</ul>
</li>
<li><p>遍历时：</p>
<ul>
<li>如果 <code>nums[fast] != 0</code>，就把 <code>nums[fast]</code> 放到 <code>nums[slow]</code>，<code>slow++</code></li>
</ul>
</li>
<li><p>遍历结束后，把从 <code>slow</code> 到末尾的元素全部置 0</p>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 指向下一个非零元素的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一轮：把非零元素往前放</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>; fast &lt; nums.length; fast++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != <span class="number">0</span>) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二轮：把剩下的位置填 0</span></span><br><span class="line">        <span class="keyword">while</span> (slow &lt; nums.length) &#123;</span><br><span class="line">            nums[slow] = <span class="number">0</span>;</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 为序列长度。每个位置至多被遍历两次。</li>
<li>空间复杂度：O(1)。只需要常数的空间存放若干变量。</li>
</ul>
<h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h2><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p>
<p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p>**说明：**你不能倾斜容器。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == height.length</code></li>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>0 &lt;= height[i] &lt;= 104</code></li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li><strong>左右指针</strong>分别从两端开始，计算当前容量</li>
<li>容量取决于较短的那条线，因为水不会溢出短板</li>
<li>移动<strong>短板指针</strong>，可能会找到更高的短板从而增大容量（移动长板无意义，因为高度受短板限制）</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxArea</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> Math.min(height[left], height[right]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> right - left;</span><br><span class="line">            maxArea = Math.max(h * width, maxArea);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移动短板</span></span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，双指针总计最多遍历整个数组一次。</li>
<li>空间复杂度：O(1)，只需要额外的常数级别的空间。</li>
</ul>
<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p>**注意：**答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 3000</code></li>
<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li><p><strong>排序</strong>数组（方便去重和使用双指针）。</p>
</li>
<li><p>遍历数组 <code>i</code> 作为第一个数 <code>nums[i]</code>。</p>
</li>
<li><p>对于每个 <code>i</code>，用<strong>双指针</strong> (<code>left</code>, <code>right</code>) 找出后面两数之和为 <code>-nums[i]</code> 的组合。</p>
</li>
<li><p>去重：</p>
<ul>
<li><p><code>i</code> 重复时跳过</p>
</li>
<li><p>找到一组解后，<code>left</code> 和 <code>right</code> 各自去掉重复的数，避免相同三元组重复加入结果。</p>
</li>
</ul>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);  <span class="comment">// 排序 O(n Log n)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 跳过重复的第一个元素</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 跳过重复的 left</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 跳过重复的 right</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;  <span class="comment">// 需要更大的和</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right--;  <span class="comment">// 需要更小的和</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n^2)，其中 n 是数组 nums 的长度。</p>
<p>空间复杂度：O(log n)。我们忽略存储答案的空间，额外的排序的空间复杂度为 O(log n)。然而我们修改了输入的数组 nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 nums 的副本并进行排序，空间复杂度为 O(n)。</p>
<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 104</code></li>
<li><code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li>用两个指针 <code>left</code> 和 <code>right</code> 表示窗口的左右边界。</li>
<li>用一个 <code>HashSet</code>（或 <code>Map</code>）存储当前窗口内的字符。</li>
<li>向右扩展窗口（<code>right++</code>），如果出现重复字符，就移动 <code>left</code> 缩小窗口，直到没有重复为止。</li>
<li>在过程中不断更新最大长度 <code>maxLen</code>。</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果重复，移动左指针</span></span><br><span class="line">            <span class="keyword">while</span> (set.contains(c)) &#123;</span><br><span class="line">                set.remove(s.charAt(left));</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加入新字符</span></span><br><span class="line">            set.add(c);</span><br><span class="line">            maxLen = Math.max(maxLen, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(N)，其中 N 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。</p>
<p>空间复杂度：O(∣Σ∣)，其中 Σ 表示字符集（即字符串中可以出现的字符），∣Σ∣ 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 [0,128) 内的字符，即 ∣Σ∣&#x3D;128。我们需要用到哈希集合来存储出现过的字符，而字符最多有 ∣Σ∣ 个，因此空间复杂度为 O(∣Σ∣)。</p>
<h2 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a>438. 找到字符串中所有字母异位词</h2><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span><br><span class="line">输出: [0,6]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</span><br></pre></td></tr></table></figure>

<p> <strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abab&quot;, p = &quot;ab&quot;</span><br><span class="line">输出: [0,1,2]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span><br><span class="line">起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。</span><br><span class="line">起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= s.length, p.length &lt;= 3 * 104</code></li>
<li><code>s</code> 和 <code>p</code> 仅包含小写字母</li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li><strong>异位词判断</strong>：两个字符串的字符出现频率相同即可。</li>
<li>用两个长度为 26 的整型数组：<ul>
<li><code>pCount</code> 记录 <code>p</code> 中每个字符的频率。</li>
<li><code>sCount</code> 记录当前窗口中每个字符的频率。</li>
</ul>
</li>
<li>滑动窗口大小固定为 <code>p.length()</code>，在滑动过程中更新 <code>sCount</code>，并比较 <code>sCount</code> 与 <code>pCount</code> 是否相等。</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt; p.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] sCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span>[] pCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">window</span> <span class="operator">=</span> p.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 p 的字符频率</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : p.toCharArray()) &#123;</span><br><span class="line">            pCount[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 右边进入窗口</span></span><br><span class="line">            sCount[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左边移出窗口</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= window) &#123;</span><br><span class="line">                sCount[s.charAt(i - window) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 比较两个频率数组</span></span><br><span class="line">            <span class="keyword">if</span> (Arrays.equals(sCount, pCount)) &#123;</span><br><span class="line">                res.add(i - window + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(m+(n−m)×Σ)，其中 n 为字符串 s 的长度，m 为字符串 p 的长度，Σ 为所有可能的字符数。我们需要 O(m) 来统计字符串 p 中每种字母的数量；需要 O(m) 来初始化滑动窗口；需要判断 n−m+1 个滑动窗口中每种字母的数量是否与字符串 p 中每种字母的数量相同，每次判断需要 O(Σ) 。因为 s 和 p 仅包含小写字母，所以 Σ&#x3D;26。</p>
<p>空间复杂度：O(Σ)。用于存储字符串 p 和滑动窗口中每种字母的数量。</p>
<h1 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h1><h2 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a>560. 和为 K 的子数组</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。</p>
<p>子数组是数组中元素的连续非空序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1], k = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3], k = 3</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li>
<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>-107 &lt;= k &lt;= 107</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>核心公式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prefixSum[j] - prefixSum[i] = k</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>prefixSum[j]</code> 表示从数组开头到 j 的元素和</li>
<li>如果 <code>prefixSum[j] - k</code> 在哈希表中出现过，说明存在以 j 结尾的子数组和为 k</li>
</ul>
<p>步骤：</p>
<ol>
<li>用 <code>sum</code> 记录当前前缀和</li>
<li>用 <code>map</code> 记录 <strong>某个前缀和出现的次数</strong></li>
<li>遍历数组：<ul>
<li><code>sum += nums[i]</code></li>
<li>查看 <code>map</code> 中是否存在 <code>sum - k</code></li>
<li>如果存在，把出现次数加到答案中</li>
<li>再把当前 <code>sum</code> 存入 <code>map</code></li>
</ul>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// 前缀和为 0 出现一次，表示从当前位置的和恰好为 k 的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查找是否有前缀和 = sum - k</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(sum - k)) &#123;</span><br><span class="line">                count += map.get(sum - k);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新当前前缀和出现的次数</span></span><br><span class="line">            map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 为数组的长度。我们遍历数组的时间复杂度为 O(n)，中间利用哈希表查询删除的复杂度均为 O(1)，因此总时间复杂度为 O(n)。</p>
<p>空间复杂度：O(n)，其中 n 为数组的长度。哈希表在最坏情况下可能有 n 个不同的键值，因此需要 O(n) 的空间复杂度。</p>
<h1 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h1><h2 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a>53. 最大子数组和</h2><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong>是数组中的一个连续部分。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,4,-1,7,8]</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
</ul>
<p>**进阶：**如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p>
<p><strong>解题思路</strong></p>
<p>我们要找的是一个 <strong>连续</strong> 子数组，和最大。<br> 每个位置 <code>i</code>，我们要么：</p>
<ul>
<li><strong>把当前元素 nums[i] 接在前面的子数组后面</strong>（如果前面和是正数，能帮它变大）</li>
<li><strong>从当前元素重新开始</strong>（如果前面的和是负数，还不如不要）</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentSum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 要么加上 nums[i]，要么从 nums[i] 重新开始</span></span><br><span class="line">            currentSum = Math.max(currentSum + nums[i], nums[i]);</span><br><span class="line">            maxSum = Math.max(maxSum, currentSum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 为 nums 数组的长度。我们只需要遍历一遍数组即可求得答案。</li>
<li>空间复杂度：O(1)。我们只需要常数空间存放若干变量。</li>
</ul>
<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h2><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[1,4],[4,5]]</span><br><span class="line">输出：[[1,5]]</span><br><span class="line">解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[4,7],[1,4]]</span><br><span class="line">输出：[[1,7]]</span><br><span class="line">解释：区间 [1,4] 和 [4,7] 可被视为重叠区间。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= intervals.length &lt;= 104</code></li>
<li><code>intervals[i].length == 2</code></li>
<li><code>0 &lt;= starti &lt;= endi &lt;= 104</code></li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li><p>按区间的起点 <code>start</code> 升序排序，这样所有可能重叠的区间都会相邻出现。</p>
</li>
<li><p>用一个临时变量 <code>current</code> 表示正在合并的区间：</p>
<ul>
<li><p>如果新区间的起点 ≤ <code>current</code> 的终点，说明重叠，更新 <code>current</code> 的终点为两者终点的最大值；</p>
</li>
<li><p>否则，没有重叠，把 <code>current</code> 加入结果，并开始合并下一个区间。</p>
</li>
</ul>
</li>
<li><p>记得最后一个 <code>current</code> 也要放进结果中。</p>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.length == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 按起点排序</span></span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; merged = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 初始化第一个区间</span></span><br><span class="line">        <span class="type">int</span>[] current = intervals[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果重叠</span></span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt;= current[<span class="number">1</span>]) &#123;</span><br><span class="line">                current[<span class="number">1</span>] = Math.max(current[<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有重叠，保存当前区间</span></span><br><span class="line">                merged.add(current);</span><br><span class="line">                current = intervals[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 加入最后一个区间</span></span><br><span class="line">        merged.add(current);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merged.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[merged.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n log n)，其中 n 为区间的数量。除去排序的开销，我们只需要一次线性扫描，所以主要的时间开销是排序的 O(n log n)。</p>
<p>空间复杂度：O(log n)，其中 n 为区间的数量。这里计算的是存储答案之外，使用的额外空间。O(log n) 即为排序所需要的空间复杂度。</p>
<h2 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a>189. 轮转数组</h2><p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右轮转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右轮转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右轮转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,-100,3,99], k = 2</span><br><span class="line">输出：[3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右轮转 1 步: [99,-1,-100,3]</span><br><span class="line">向右轮转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
<li><code>0 &lt;= k &lt;= 105</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>尽可能想出更多的解决方案，至少有 <strong>三种</strong> 不同的方法可以解决这个问题。</li>
<li>你可以使用空间复杂度为 <code>O(1)</code> 的 <strong>原地</strong> 算法解决这个问题吗？</li>
</ul>
<p><strong>解题思路</strong></p>
<p>右旋转 k 步相当于：</p>
<ol>
<li>先整体反转数组</li>
<li>再反转前 k 个元素</li>
<li>再反转剩余的 n - k 个元素</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        k = k % l;  <span class="comment">// 处理 k &gt; n 的情况</span></span><br><span class="line">        reverse(nums, <span class="number">0</span>, l - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[left];</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            nums[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<em>O</em>(<em>n</em>)，其中 <em>n</em> 为数组的长度。每个元素被翻转两次，一共 <em>n</em> 个元素，因此总时间复杂度为 <em>O</em>(2<em>n</em>)&#x3D;<em>O</em>(<em>n</em>)。</li>
<li>空间复杂度：<em>O</em>(1)。</li>
</ul>
<h2 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a>238. 除自身以外数组的乘积</h2><p>给你一个整数数组 <code>nums</code>，返回 数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积 。</p>
<p>题目数据 <strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内。</p>
<p>请 **不要使用除法，**且在 <code>O(n)</code> 时间复杂度内完成此题。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,1,0,-3,3]</span><br><span class="line">输出: [0,0,9,0,0]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 105</code></li>
<li><code>-30 &lt;= nums[i] &lt;= 30</code></li>
<li>输入 <strong>保证</strong> 数组 <code>answer[i]</code> 在 <strong>32 位</strong> 整数范围内</li>
</ul>
<p>**进阶：**你可以在 <code>O(1)</code> 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 <strong>不被视为</strong> 额外空间。）</p>
<p><strong>解题思路</strong></p>
<p>我们要求 <code>answer[i] = nums[0] * nums[1] * ... * nums[i-1] * nums[i+1] * ... * nums[n-1]</code><br> 也就是 <strong>当前位置的左边积 × 右边积</strong>。</p>
<ol>
<li>先计算左积：<ul>
<li><code>left[i]</code> 表示 <code>nums[0] ~ nums[i-1]</code> 的乘积</li>
<li>第 0 个位置没有左边元素，所以 <code>left[0] = 1</code></li>
</ul>
</li>
<li>再计算右积，并直接乘到结果数组上：<ul>
<li><code>right</code> 从末尾向前计算，不需要额外数组，用一个变量保存右积累乘值</li>
<li>每一步 <code>answer[i] = left[i] * right</code></li>
</ul>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span>[] answer = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 计算左积</span></span><br><span class="line">        answer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            answer[i] = answer[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 计算右积并乘在答案上</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 当前右边所有数的乘积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            answer[i] = answer[i] * right;</span><br><span class="line">            right *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 指的是数组 nums 的大小。分析与方法一相同。<br>空间复杂度：O(1)，输出数组不算进空间复杂度中，因此我们只需要常数的空间存放变量。</p>
<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a>73. 矩阵置零</h2><p>给定一个 <code>*m* x *n*</code> 的矩阵，如果一个元素为 <strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong>原地</strong> 算法**。**</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">输出：[[1,0,1],[0,0,0],[1,0,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]</span><br><span class="line">输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[0].length</code></li>
<li><code>1 &lt;= m, n &lt;= 200</code></li>
<li><code>-231 &lt;= matrix[i][j] &lt;= 231 - 1</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>一个直观的解决方案是使用  <code>O(*m**n*)</code> 的额外空间，但这并不是一个好的解决方案。</li>
<li>一个简单的改进方案是使用 <code>O(*m* + *n*)</code> 的额外空间，但这仍然不是最好的解决方案。</li>
<li>你能想出一个仅使用常量空间的解决方案吗？</li>
</ul>
<p><strong>解题思路</strong></p>
<p>如果不用额外数组，我们就需要 <strong>复用原矩阵的一部分来存储“这一行或这一列需要清零”的信息</strong>：</p>
<ol>
<li>先判断第一行和第一列是否本来就有 0<ul>
<li>因为第一行和第一列会被用来做标记，所以要提前单独记下来</li>
</ul>
</li>
<li>用第一行、第一列做标记<ul>
<li>遍历除第一行、第一列之外的元素，如果 <code>matrix[i][j] == 0</code><ul>
<li>标记 <code>matrix[i][0] = 0</code>（该行要清零）</li>
<li>标记 <code>matrix[0][j] = 0</code>（该列要清零）</li>
</ul>
</li>
</ul>
</li>
<li>根据标记清零<ul>
<li>再次遍历（不包括第一行第一列），如果当前行或列的标记是 0，就把它清零</li>
</ul>
</li>
<li>最后处理第一行、第一列<ul>
<li>如果第一行原来有 0，整行清零</li>
<li>如果第一列原来有 0，整列清零</li>
</ul>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZeroes</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">firstRowZero</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">firstColZero</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 判断第一行是否有 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                firstRowZero = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 判断第一列是否有 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                firstColZero = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 用第一行和第一列做标记</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4，根据标记清零（不动第一行和第一列）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 处理第一行</span></span><br><span class="line">        <span class="keyword">if</span> (firstRowZero) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6. 处理第一列</span></span><br><span class="line">        <span class="keyword">if</span> (firstColZero) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<em>O</em>(<em>mn</em>)，其中 <em>m</em> 是矩阵的行数，<em>n</em> 是矩阵的列数。我们至多只需要遍历该矩阵两次。</li>
<li>空间复杂度：<em>O</em>(1)。我们只需要常数空间存储若干变量。</li>
</ul>
<h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a>54. 螺旋矩阵</h2><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 10</code></li>
<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li>定义四个指针：<ul>
<li><code>top</code>：当前最上边界</li>
<li><code>bottom</code>：当前最下边界</li>
<li><code>left</code>：当前最左边界</li>
<li><code>right</code>：当前最右边界</li>
</ul>
</li>
<li>按照顺时针顺序循环：<ol>
<li>从左到右遍历上边界 <code>top</code>，然后 <code>top++</code></li>
<li>从上到下遍历右边界 <code>right</code>，然后 <code>right--</code></li>
<li>从右到左遍历下边界 <code>bottom</code>，然后 <code>bottom--</code></li>
<li>从下到上遍历左边界 <code>left</code>，然后 <code>left++</code></li>
</ol>
</li>
<li>每次遍历前都判断 <code>top &lt;= bottom &amp;&amp; left &lt;= right</code>，避免重复访问。</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>, right = matrix[<span class="number">0</span>].length - <span class="number">1</span>, bottom = matrix.length - <span class="number">1</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 1. 上边界从左到右</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left; j &lt;= right; j++) &#123;</span><br><span class="line">                res.add(matrix[top][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 右边界从上到下</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &lt;= bottom; i++) &#123;</span><br><span class="line">                res.add(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 下边界从右到左</span></span><br><span class="line">            <span class="keyword">if</span> (top &lt;= bottom) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right; j &gt;= left; j--) &#123;</span><br><span class="line">                    res.add(matrix[bottom][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                bottom--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 左边界从下到上</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bottom; i &gt;= top; i--) &#123;</span><br><span class="line">                    res.add(matrix[i][left]);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(mn)，其中 m 和 n 分别是输入矩阵的行数和列数。矩阵中的每个元素都要被访问一次。</p>
<p>空间复杂度：O(1)。除了输出数组以外，空间复杂度是常数。</p>
<h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a>48. 旋转图像</h2><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在<strong>原地</strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span><br><span class="line">输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == matrix.length == matrix[i].length</code></li>
<li><code>1 &lt;= n &lt;= 20</code></li>
<li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>顺时针旋转 90° &#x3D; <strong>先转置（transpose）</strong> + <strong>每行反转（reverse row）</strong></p>
<ol>
<li>转置矩阵：<ul>
<li>把 <code>matrix[i][j]</code> 和 <code>matrix[j][i]</code> 交换（只交换上三角部分，避免交换两次）</li>
<li>转置后行列互换</li>
</ul>
</li>
<li>每行反转：<ul>
<li>每一行首尾交换，得到最终顺时针 90° 的效果</li>
</ul>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> matrix.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 转置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; l; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 每行反转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; l / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[i][l - j - <span class="number">1</span>];</span><br><span class="line">                matrix[i][l - j - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n^2)，其中 n 是 matrix 的边长。对于每一次翻转操作，我们都需要枚举矩阵中一半的元素。</p>
<p>空间复杂度：O(1)。为原地翻转得到的原地旋转。</p>
<h2 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a>240. 搜索二维矩阵 II</h2><p>编写一个高效的算法来搜索 <code>*m* x *n*</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= n, m &lt;= 300</code></li>
<li><code>-109 &lt;= matrix[i][j] &lt;= 109</code></li>
<li>每行的所有元素从左到右升序排列</li>
<li>每列的所有元素从上到下升序排列</li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>当前位置元素 matrix[row][col] 与 target 比较</p>
<ul>
<li>如果 <code>matrix[row][col] == target</code> → 找到了，返回 <code>true</code></li>
<li>如果 <code>matrix[row][col] &gt; target</code> → 当前列都比 target 大，所以向 <strong>左</strong> 移动一列（<code>col--</code>）</li>
<li>如果 <code>matrix[row][col] &lt; target</code> → 当前行都比 target 小，所以向 <strong>下</strong> 移动一行（<code>row++</code>）</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从右上角开始</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (row &lt; m &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[row][col] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] &gt; target) &#123;</span><br><span class="line">                col--;  <span class="comment">// 向左移动</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                row++;  <span class="comment">// 向下移动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(m+n)。在搜索的过程中，如果我们没有找到 target，那么我们要么将 y 减少 1，要么将 x 增加 1。由于 (x,y) 的初始值分别为 (0,n−1)，因此 y 最多能被减少 n 次，x 最多能被增加 m 次，总搜索次数为 m+n。在这之后，x 和 y 就会超出矩阵的边界。</p>
<p>空间复杂度：O(1)。</p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h2><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p>
<p>图示两个链表在节点 <code>c1</code> 开始相交**：**</p>
<p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></a></p>
<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>
<p><strong>自定义评测：</strong></p>
<p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p>
<ul>
<li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li>
<li><code>listA</code> - 第一个链表</li>
<li><code>listB</code> - 第二个链表</li>
<li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li>
<li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li>
</ul>
<p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at &#x27;8&#x27;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br><span class="line">— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Intersected at &#x27;2&#x27;</span><br><span class="line">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：No intersection</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>listA</code> 中节点数目为 <code>m</code></li>
<li><code>listB</code> 中节点数目为 <code>n</code></li>
<li><code>1 &lt;= m, n &lt;= 3 * 104</code></li>
<li><code>1 &lt;= Node.val &lt;= 105</code></li>
<li><code>0 &lt;= skipA &lt;= m</code></li>
<li><code>0 &lt;= skipB &lt;= n</code></li>
<li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>
<li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li>
</ul>
<p>**进阶：**你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>
<p><strong>解题思路</strong></p>
<ul>
<li>两个指针 <code>pA</code> 和 <code>pB</code> 分别从 <code>headA</code> 和 <code>headB</code> 出发</li>
<li>当 <code>pA</code> 走到 A 链表的末尾，就跳到 B 链表的头继续走</li>
<li>当 <code>pB</code> 走到 B 链表的末尾，就跳到 A 链表的头继续走</li>
<li><strong>如果两条链表相交</strong>，那么它们会在某个节点相遇（就是交点）</li>
<li><strong>如果不相交</strong>，两个指针最终都会走到 <code>null</code>，同时结束</li>
</ul>
<p>这样做的原因：</p>
<ul>
<li>指针 pA 走过的路：<code>A 链表长度 + B 链表长度</code></li>
<li>指针 pB 走过的路：<code>B 链表长度 + A 链表长度</code></li>
<li>两者走的总长度相等，所以一定会在同一时刻到达交点或 null。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pA</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pB</span> <span class="operator">=</span> headB;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两指针走到同一个节点（可能是交点，也可能是 null）</span></span><br><span class="line">        <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">            pA = (pA == <span class="literal">null</span>) ? headB : pA.next;</span><br><span class="line">            pB = (pB == <span class="literal">null</span>) ? headA : pB.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pA;  <span class="comment">// 要么是交点，要么是 null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(m+n)，其中 m 和 n 是分别是链表 headA 和 headB 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次。</p>
<p>空间复杂度：O(1)。</p>
<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<p>**进阶：**链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
<p><strong>方法一：迭代</strong></p>
<p><strong>解题思路</strong></p>
<p>用三个指针：<code>prev</code>（前驱节点）、<code>curr</code>（当前节点）、<code>next</code>（暂存下一个节点）。</p>
<p>每次把 <code>curr.next</code> 指向 <code>prev</code>，然后整体往前推进。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;  <span class="comment">// 暂存下一个节点</span></span><br><span class="line">            curr.next = prev;           <span class="comment">// 反转指针</span></span><br><span class="line">            prev = curr;                <span class="comment">// 前驱前进</span></span><br><span class="line">            curr = next;                <span class="comment">// 当前前进</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev;  <span class="comment">// prev 指向新头</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<em>O</em>(<em>n</em>)，其中 <em>n</em> 是链表的长度。需要遍历链表一次。</li>
<li>空间复杂度：<em>O</em>(1)。</li>
</ul>
<p><strong>方法二：递归</strong></p>
<p><strong>解题思路</strong></p>
<p>从第二个节点开始递归反转后续链表，等反转完成后，将当前节点放到末尾。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归结束条件</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前节点放到后面</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是链表的长度。需要对链表的每个节点进行反转操作。</p>
<p>空间复杂度：O(n)，其中 n 是链表的长度。空间复杂度主要取决于递归调用的栈空间，最多为 n 层。</p>
<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a>234. 回文链表</h2><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点数目在范围<code>[1, 105]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
</ul>
<p>**进阶：**你能否用 <code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题？</p>
<p><strong>解题思路</strong></p>
<ol>
<li>找到链表中点（快慢指针）<ul>
<li>快指针一次走 2 步，慢指针一次走 1 步。</li>
<li>当快指针走到结尾，慢指针正好到中间。</li>
</ul>
</li>
<li>反转后半段链表<ul>
<li>从中点开始，把链表后半部分原地反转。</li>
</ul>
</li>
<li>比较前半段和后半段<ul>
<li>两个指针从链表头部和反转后的后半段同时往后走，逐个比较值是否相等。</li>
<li>比较完可选恢复链表（不要求可省略）。</li>
</ul>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 找中点（偶数时取左中点）</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 反转后半段</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">secondHalf</span> <span class="operator">=</span> reverse(slow.next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 比较两段</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> secondHalf;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (p2 != <span class="literal">null</span>) &#123;  <span class="comment">// 只需要遍历后半段</span></span><br><span class="line">            <span class="keyword">if</span> (p1.val != p2.val) &#123;</span><br><span class="line">                result = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 恢复链表</span></span><br><span class="line">        slow.next = reverse(secondHalf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转链表（迭代法）</span></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>, curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 指的是链表的大小。</li>
<li>空间复杂度：O(1)。我们只会修改原本链表中节点的指向，而在堆栈上的堆栈帧不超过 O(1)。</li>
</ul>
<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h2><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p>
<p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 104]</code></li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
<li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li>
</ul>
<p>**进阶：**你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p>
<p><strong>解题思路</strong></p>
<p>两个指针：</p>
<ul>
<li><code>slow</code> 每次走 1 步</li>
<li><code>fast</code> 每次走 2 步</li>
</ul>
<p>如果链表有环，那么 <code>fast</code> 最终会在环内追上 <code>slow</code>（就像跑道上跑步一样）。</p>
<p>如果链表无环，那么 <code>fast</code> 会先走到 <code>null</code>（链表尾）。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;       <span class="comment">// 慢指针走一步</span></span><br><span class="line">            fast = fast.next.next;  <span class="comment">// 快指针走两步</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;     <span class="comment">// 相遇 =&gt; 有环</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// fast 走到 null =&gt; 无环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(N)，其中 N 是链表中的节点数。</p>
<p>当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。</p>
<p>当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 N 轮。</p>
<p>空间复杂度：O(1)。我们只使用了两个指针的额外空间。</p>
<h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h2><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>
<p><strong>不允许修改</strong> 链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
<li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li>
</ul>
<p>**进阶：**你是否可以使用 <code>O(1)</code> 空间解决此题？</p>
<p><strong>解题思路</strong></p>
<ol>
<li>第一步：用快慢指针判断链表是否有环（跟 <code>hasCycle</code> 一样）。<ul>
<li><code>slow</code> 每次走一步</li>
<li><code>fast</code> 每次走两步</li>
<li>如果 <code>slow == fast</code>，说明有环</li>
<li>如果 <code>fast</code> 或 <code>fast.next</code> 为空，说明无环，直接返回 <code>null</code></li>
</ul>
</li>
<li>第二步：找到环的入口<ul>
<li>相遇后，让 一个指针从 <code>head</code> 出发，另一个指针从相遇点出发</li>
<li>两个指针都 每次走一步</li>
<li>它们再次相遇的点，就是 环的入口节点</li>
</ul>
</li>
</ol>
<p>为什么这样可行（数学推导）</p>
<p>设：</p>
<ul>
<li><code>a</code> &#x3D; 链表头到环入口的距离</li>
<li><code>b</code> &#x3D; 环入口到相遇点的距离</li>
<li><code>c</code> &#x3D; 相遇点到环入口的距离（即环剩余的长度）</li>
</ul>
<p>第一次相遇时：</p>
<ul>
<li><p><code>slow</code> 走了 <code>a + b</code></p>
</li>
<li><p><code>fast</code> 走了 <code>a + b + n(b + c)</code>（n 表示快指针多绕的圈数）</p>
</li>
<li><p>因为快指针速度是慢指针的 2 倍：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2(a + b) = a + b + n(b + c)</span><br><span class="line">a + b = n(b + c)</span><br><span class="line">a = n(b + c) - b</span><br><span class="line">a = (n - 1)(b + c) + c</span><br></pre></td></tr></table></figure>

<p>这说明：从头节点走 <code>a</code> 步，等价于从相遇点走 <code>c</code> 步（到达环入口）。</p>
</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 判断是否有环</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="comment">// 2. 寻找环入口</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">ptr</span> <span class="operator">=</span> head;</span><br><span class="line">                <span class="keyword">while</span> (ptr != slow) &#123;</span><br><span class="line">                    ptr = ptr.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 无环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(N)，其中 N 为链表中节点的数目。在最初判断快慢指针是否相遇时，slow 指针走过的距离不会超过链表的总长度；随后寻找入环点时，走过的距离也不会超过链表的总长度。因此，总的执行时间为 O(N)+O(N)&#x3D;O(N)。</p>
<p>空间复杂度：O(1)。我们只使用了 slow,fast,ptr 三个指针。</p>
<h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [], l2 = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>两个链表的节点数目范围是 <code>[0, 50]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li>创建一个 <strong>dummy 节点</strong>（值随便，比如 0），并用 <code>tail</code> 指向它。</li>
<li>遍历 <code>list1</code> 和 <code>list2</code>：<ul>
<li>比较 <code>list1.val</code> 和 <code>list2.val</code></li>
<li>取较小的节点挂到 <code>tail.next</code></li>
<li>移动对应的链表指针</li>
</ul>
</li>
<li>如果其中一个链表还没走完，把剩余部分直接接到 <code>tail.next</code></li>
<li>返回 <code>dummy.next</code>（因为 <code>dummy</code> 是占位用的）</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="comment">// 虚拟头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当两个链表都不为空时</span></span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="literal">null</span> &amp;&amp; list2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val &lt;= list2.val) &#123;</span><br><span class="line">                tail.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail.next;  <span class="comment">// 移动尾指针</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有一个链表没走完，直接接上</span></span><br><span class="line">        <span class="keyword">if</span> (list1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            tail.next = list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            tail.next = list2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， 因此 while 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 O(n+m)。</p>
<p>空间复杂度：O(1)。我们只需要常数的空间存放若干变量。</p>
<h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
<li>题目数据保证列表表示的数字不含前导零</li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li>创建虚拟头节点（dummy）简化链表操作，用 <code>curr</code> 指向当前处理位置。</li>
<li>初始化进位 <code>carry = 0</code>。</li>
<li>遍历 <code>l1</code> 和 <code>l2</code>：<ul>
<li>取当前节点的值（如果节点为 null，则值为 0）</li>
<li>计算和 <code>sum = x + y + carry</code></li>
<li>计算当前位的值 <code>sum % 10</code>，作为新节点的值</li>
<li>更新进位 <code>carry = sum / 10</code></li>
</ul>
</li>
<li>遍历结束后，如果 <code>carry &gt; 0</code>，要在链表末尾加一个节点。</li>
<li>返回 <code>dummy.next</code></li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (l1 == <span class="literal">null</span>) ? <span class="number">0</span> : l1.val;</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (l2 == <span class="literal">null</span>) ? <span class="number">0</span> : l2.val;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> x + y + carry;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            curr.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            curr = curr.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            curr.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(max(m,n))，其中 m 和 n 分别为两个链表的长度。我们要遍历两个链表的全部位置，而处理每个位置只需要 O(1) 的时间。</p>
<p>空间复杂度：O(1)。注意返回值不计入空间复杂度。</p>
<h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a>19. 删除链表的倒数第 N 个结点</h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中结点的数目为 <code>sz</code></li>
<li><code>1 &lt;= sz &lt;= 30</code></li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
<li><code>1 &lt;= n &lt;= sz</code></li>
</ul>
<p>**进阶：**你能尝试使用一趟扫描实现吗？</p>
<p><strong>解题思路</strong></p>
<p>虚拟头节点：加一个 <code>dummy</code>，指向 <code>head</code>，避免删除头节点时的特殊处理。</p>
<p>快慢指针：让 <code>fast</code> 先走 n+1 步，这样 <code>slow</code> 停在待删除节点的前一个位置。同时移动 <code>fast</code> 和 <code>slow</code>，直到 <code>fast</code> 到达链表末尾。</p>
<p>删除节点：<code>slow.next = slow.next.next</code></p>
<p>返回结果：返回 <code>dummy.next</code>（防止删除的是头节点）</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 快指针先走 n + 1 步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快慢指针同时移动</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除倒数第 n 个节点</span></span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<em>O</em>(<em>L</em>)，其中 <em>L</em> 是链表的长度。</li>
<li>空间复杂度：<em>O</em>(1)。</li>
</ul>
<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>dummy 节点</p>
<ul>
<li>避免处理 <code>head</code> 是空或需要交换第一个节点的特殊情况。</li>
<li>统一用 <code>prev.next</code> 来指向待交换的第一个节点。</li>
</ul>
<p>prev 节点</p>
<ul>
<li>指向当前待交换节点的前驱。</li>
<li>每次交换完成后，prev 移动到被交换后顺序靠后的节点（也就是 <code>first</code>）。</li>
</ul>
<p>while 条件</p>
<ul>
<li><code>prev.next != null &amp;&amp; prev.next.next != null</code> 保证有两个节点可以交换。</li>
</ul>
<p>交换过程</p>
<ul>
<li><code>first.next = second.next;</code> → 先把第一个节点指向第二个节点之后的节点。</li>
<li><code>second.next = first;</code> → 第二个节点指向第一个节点，实现反转。</li>
<li><code>prev.next = second;</code> → 前驱节点指向新的头节点。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个 dummy 节点，指向 head</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 用 prev 来跟踪待交换节点的前驱</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 当有两个节点可以交换时，循环</span></span><br><span class="line">        <span class="keyword">while</span> (prev.next != <span class="literal">null</span> &amp;&amp; prev.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 定位两个待交换节点</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> prev.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">second</span> <span class="operator">=</span> first.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 交换节点</span></span><br><span class="line">            first.next = second.next;</span><br><span class="line">            second.next = first;</span><br><span class="line">            prev.next = second;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移动 prev，准备下一轮交换</span></span><br><span class="line">            prev = first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 返回新的头节点</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h2 id="138-随机链表的复制"><a href="#138-随机链表的复制" class="headerlink" title="138. 随机链表的复制"></a>138. 随机链表的复制</h2><p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p>
<p>构造这个链表的 <strong>深拷贝</strong>。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。<strong>复制链表中的指针都不应指向原链表中的节点</strong> 。</p>
<p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p>
<p>返回复制链表的头节点。</p>
<p>用一个由 <code>n</code> 个节点组成的链表来表示输入&#x2F;输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p>
<ul>
<li><code>val</code>：一个表示 <code>Node.val</code> 的整数。</li>
<li><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为 <code>null</code> 。</li>
</ul>
<p>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [[1,1],[2,1]]</span><br><span class="line">输出：[[1,1],[2,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png" alt="img"></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [[3,null],[3,0],[3,null]]</span><br><span class="line">输出：[[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 1000</code></li>
<li><code>-104 &lt;= Node.val &lt;= 104</code></li>
<li><code>Node.random</code> 为 <code>null</code> 或指向链表中的节点。</li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li><p><strong>在每个原节点后面插入新节点</strong></p>
<ul>
<li>原链表：<code>A -&gt; B -&gt; C</code></li>
<li>插入新节点：<code>A -&gt; A&#39; -&gt; B -&gt; B&#39; -&gt; C -&gt; C&#39;</code></li>
<li>新节点 <code>A&#39;</code> 的 <code>val = A.val</code>，<code>next</code> 暂时指向原节点的 <code>next</code>。</li>
</ul>
</li>
<li><p><strong>复制 random 指针</strong></p>
<ul>
<li><p>对于原节点 <code>A</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (A.random != null)</span><br><span class="line">    A.next.random = A.random.next;</span><br></pre></td></tr></table></figure>
</li>
<li><p>因为 <code>A.next</code> 是新节点，<code>A.random.next</code> 正好是新节点对应的 random 指向。</p>
</li>
</ul>
</li>
<li><p><strong>拆分链表</strong></p>
<ul>
<li>将原链表和新链表拆开：<ul>
<li>原链表恢复：<code>A -&gt; B -&gt; C</code></li>
<li>新链表：<code>A&#39; -&gt; B&#39; -&gt; C&#39;</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 在每个节点后插入新节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(curr.val);</span><br><span class="line">            newNode.next = curr.next;</span><br><span class="line">            curr.next = newNode;</span><br><span class="line">            curr = newNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 复制 random 指针</span></span><br><span class="line">        curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr.random != <span class="literal">null</span>) &#123;</span><br><span class="line">                curr.next.random = curr.random.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 拆分链表</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">copyCurr</span> <span class="operator">=</span> dummy;</span><br><span class="line">        curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            copyCurr.next = curr.next;</span><br><span class="line">            copyCurr = copyCurr.next;</span><br><span class="line"></span><br><span class="line">            curr.next = curr.next.next;  <span class="comment">// 恢复原链表</span></span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是链表的长度。我们只需要遍历该链表三次。</p>
<p>读者们也可以自行尝试在计算拷贝节点的随机指针的同时计算其后继指针，这样只需要遍历两次。<br>空间复杂度：O(1)。注意返回值不计入空间复杂度。</p>
<h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a>148. 排序链表</h2><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [4,2,1,3]</span><br><span class="line">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [-1,5,3,4,0]</span><br><span class="line">输出：[-1,0,3,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 5 * 104]</code> 内</li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
</ul>
<p>**进阶：**你可以在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p>
<p><strong>解题思路</strong></p>
<ol>
<li><p>递归拆分链表</p>
<ul>
<li>用 快慢指针 找中点，将链表一分为二。</li>
<li>快指针一次走两步，慢指针一次走一步，快指针到尾时，慢指针就是中点。</li>
</ul>
</li>
<li><p>递归排序左右两部分</p>
</li>
<li><p>合并两个有序链表</p>
<ul>
<li>这个可以直接用 合并两个有序链表的题目 的方法。</li>
</ul>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归结束条件</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 快慢指针找中点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head, prev = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            prev = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev.next = <span class="literal">null</span>;  <span class="comment">// 断开链表</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 递归排序左右两部分</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> sortList(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l2</span> <span class="operator">=</span> sortList(slow);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 合并两个有序链表</span></span><br><span class="line">        <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                curr.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curr.next = (l1 == <span class="literal">null</span>) ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n log n)，其中 n 是链表的长度。</li>
<li>空间复杂度：O(log n)，其中 n 是链表的长度。空间复杂度主要取决于递归调用的栈空间。</li>
</ul>
<h2 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a>146. LRU 缓存</h2><p>请你设计并实现一个满足 LRU (最近最少使用) 缓存约束的数据结构。</p>
<p>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li>
<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li>
<li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li>
</ul>
<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache = new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;</span><br><span class="line">lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 1</span><br><span class="line">lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br><span class="line">lRUCache.get(2);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.get(3);    // 返回 3</span><br><span class="line">lRUCache.get(4);    // 返回 4</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= capacity &lt;= 3000</code></li>
<li><code>0 &lt;= key &lt;= 10000</code></li>
<li><code>0 &lt;= value &lt;= 105</code></li>
<li>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>这个 LRU 缓存题的核心是：</p>
<ul>
<li><strong>O(1)</strong> 查找 key → 哈希表（HashMap）</li>
<li><strong>O(1)</strong> 移动节点到最近使用位置 &amp; 删除最久未使用节点 → 双向链表（Doubly Linked List）</li>
</ul>
<p>哈希表负责 <strong>定位节点</strong>，双向链表负责 <strong>维护使用顺序</strong>。<br>新数据或最近访问的数据放在链表头，最久未使用的在链表尾。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> key, value;</span><br><span class="line">        Node prev, next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> k, <span class="type">int</span> val) &#123;</span><br><span class="line">            key = k;;</span><br><span class="line">            value = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> Node head, tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 伪头尾节点，方便处理边界</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);</span><br><span class="line">            map.put(key, node);</span><br><span class="line">            addToHead(node);</span><br><span class="line">            <span class="keyword">if</span> (map.size() &gt; capacity) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">removed</span> <span class="operator">=</span> removeTail();</span><br><span class="line">                map.remove(removed.key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助方法：把节点加到头部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助方法：移除节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助方法：把节点移动到头部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助方法：移除尾部节点</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">res</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：对于 <code>put</code> 和 <code>get</code> 都是 <em>O</em>(1)。</li>
<li>空间复杂度：<em>O</em>(capacity)，因为哈希表和双向链表最多存储 capacity+1 个元素。</li>
</ul>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h2><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,null,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
<p><strong>方法一：递归</strong></p>
<p><strong>解题思路</strong></p>
<p>略</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 方法一：递归法</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode node, List&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inorder(node.left, res);    <span class="comment">// 左</span></span><br><span class="line">        res.add(node.val);          <span class="comment">// 根</span></span><br><span class="line">        inorder(node.right, res);   <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</p>
<p>空间复杂度：O(n)。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</p>
<p><strong>方法二：迭代</strong></p>
<p><strong>解题思路</strong></p>
<p>略</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 不断往左子树走，并压栈</span></span><br><span class="line">            <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(curr);</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 弹出栈顶，访问节点</span></span><br><span class="line">            curr = stack.pop();</span><br><span class="line">            res.add(curr.val);</span><br><span class="line">            <span class="comment">// 转向右子树</span></span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</p>
<p>空间复杂度：O(n)。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</p>
<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h2><p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p>
<p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,null,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数量在 <code>[0, 104]</code> 区间内。</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>方法一：深度优先搜索</strong></p>
<p><strong>解题思路</strong></p>
<p>如果树为空，深度为 0；</p>
<p>否则最大深度 &#x3D; 1 + max(左子树深度, 右子树深度)。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 为二叉树节点的个数。每个节点在递归中只被遍历一次。</p>
<p>空间复杂度：O(h)，其中 h 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。</p>
<p><strong>方法二：广度优先搜索</strong></p>
<p><strong>解题思路</strong></p>
<p>用队列做层序遍历，每遍历一层，深度 +1。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 遍历当前层所有节点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            depth++;  <span class="comment">// 一层结束，深度 + 1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 为二叉树的节点个数。与方法一同样的分析，每个节点只会被访问一次。</p>
<p>空间复杂度：此方法空间的消耗取决于队列存储的元素数量，其在最坏情况下会达到 O(n)。</p>
<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h2><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围在 <code>[0, 100]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>方法一：递归</strong></p>
<p><strong>解题思路</strong></p>
<p>递归的思路是：对于每个节点，交换其左右子树，然后递归地交换其左右子树。基准条件是如果节点为空，直接返回。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode left;</span></span><br><span class="line"><span class="comment">*     TreeNode right;</span></span><br><span class="line"><span class="comment">*     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment">*     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment">*     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment">*         this.val = val;</span></span><br><span class="line"><span class="comment">*         this.left = left;</span></span><br><span class="line"><span class="comment">*         this.right = right;</span></span><br><span class="line"><span class="comment">*     &#125;</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果节点为空，则直接返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换左右子树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归翻转左右子树</span></span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 为二叉树节点的数目。我们会遍历二叉树中的每一个节点，对每个节点而言，我们在常数时间内交换其两棵子树。</p>
<p>空间复杂度：O(n)。使用的空间由递归栈的深度决定，它等于当前节点在二叉树中的高度。在平均情况下，二叉树的高度与节点个数为对数关系，即 O(log n)。而在最坏情况下，树形成链状，空间复杂度为 O(n)。</p>
<p><strong>方法二：迭代</strong></p>
<p><strong>解题思路</strong></p>
<p>迭代方法可以通过广度优先搜索（BFS）或深度优先搜索（DFS）来实现。这里我们使用队列来模拟广度优先搜索（BFS），逐层交换左右子树。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果节点为空，则直接返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用队列来进行广度优先遍历</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="comment">// 交换左右子树</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> curr.left;</span><br><span class="line">                curr.left = curr.right;</span><br><span class="line">                curr.right = temp;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将子节点加入队列</span></span><br><span class="line">                <span class="keyword">if</span> (curr.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(curr.left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (curr.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(curr.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，同「方法一」。<br>空间复杂度：这里需要用一个队列来维护节点，每个节点最多进队一次，出队一次，队列中最多不会超过 n 个点，故渐进空间复杂度为 O(n)。</p>
<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h2><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://pic.leetcode.cn/1698026966-JDYPDU-image.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://pic.leetcode.cn/1698027008-nPFLbM-image.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[1, 1000]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p>**进阶：**你可以运用递归和迭代两种方法解决这个问题吗？</p>
<p><strong>方法一：递归</strong></p>
<p><strong>解题思路</strong></p>
<p>我们可以定义一个辅助函数来比较两个子树是否对称。这个辅助函数接收两个节点作为参数，判断这两个节点是否镜像对称。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果根节点为空，是对称的</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归检查左右子树是否对称</span></span><br><span class="line">        <span class="keyword">return</span> isMirror(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查两个树是否镜像对称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isMirror</span><span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果两个节点都为空，是对称的</span></span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span> &amp;&amp; t2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果只有一个为空，或者值不同，不是对称的</span></span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span> || t2 == <span class="literal">null</span> || t1.val != t2.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归检查左右子树是否对称</span></span><br><span class="line">        <span class="keyword">return</span> isMirror(t1.left, t2.right) &amp;&amp; isMirror(t1.right, t2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：这里遍历了这棵树，渐进时间复杂度为 O(n)。<br>空间复杂度：这里的空间复杂度和递归使用的栈空间有关，这里递归层数不超过 n，故渐进空间复杂度为 O(n)。</p>
<p><strong>方法二：迭代</strong></p>
<p><strong>解题思路</strong></p>
<p>迭代方法可以通过使用队列来实现广度优先搜索（BFS）模拟递归过程。我们逐层遍历树，检查左右子树是否对称。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果根节点为空，是对称的</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用队列模拟广度优先搜索</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root.left);</span><br><span class="line">        queue.offer(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">t1</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">t2</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果两个节点都为空，继续检查下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (t1 == <span class="literal">null</span> &amp;&amp; t2 == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果只有一个节点为空，或者值不相等，不是对称的</span></span><br><span class="line">            <span class="keyword">if</span> (t1 == <span class="literal">null</span> || t2 == <span class="literal">null</span> || t1.val != t2.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将子节点按对称顺序加入队列</span></span><br><span class="line">            queue.offer(t1.left);</span><br><span class="line">            queue.offer(t2.right);</span><br><span class="line">            queue.offer(t1.right);</span><br><span class="line">            queue.offer(t2.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，同「方法一」。<br>空间复杂度：这里需要用一个队列来维护节点，每个节点最多进队一次，出队一次，队列中最多不会超过 n 个点，故渐进空间复杂度为 O(n)。</p>
<h2 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a>543. 二叉树的直径</h2><p>给你一棵二叉树的根节点，返回该树的 <strong>直径</strong> 。</p>
<p>二叉树的 <strong>直径</strong> 是指树中任意两个节点之间最长路径的 <strong>长度</strong> 。这条路径可能经过也可能不经过根节点 <code>root</code> 。</p>
<p>两节点之间路径的 <strong>长度</strong> 由它们之间边数表示。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5]</span><br><span class="line">输出：3</span><br><span class="line">解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[1, 104]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>为了计算二叉树的直径，我们可以通过深度优先搜索（DFS）来实现。对于每个节点，直径可能是通过该节点的路径，即左子树的深度加上右子树的深度。这个值可能是当前节点的直径。然后我们递归计算左右子树的直径，最终返回树的最大直径。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">diameter</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 记录树的最大直径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        depth(root);    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> diameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算树的深度并更新</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">depth</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果节点为空，深度为 0</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归左右子树的深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> depth(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> depth(node.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新直径</span></span><br><span class="line">        diameter = Math.max(diameter, leftDepth + rightDepth);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回该节点的深度</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 为二叉树的节点数，即遍历一棵二叉树的时间复杂度，每个结点只被访问一次。</p>
<p>空间复杂度：O(h)，其中 h 为二叉树的高度。由于递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，而递归的深度显然为二叉树的高度，并且每次递归调用的函数里又只用了常数个变量，所以所需空间复杂度为 O(h) 。</p>
<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a>102. 二叉树的层序遍历</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：[[3],[9,20],[15,7]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 2000]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<p><strong>解题思路</strong></p>
<ul>
<li>使用队列：队列是 BFS 的核心数据结构，它可以帮助我们按照层级访问节点。</li>
<li>遍历过程：<ol>
<li>初始时将根节点加入队列。</li>
<li>从队列中取出节点并访问。</li>
<li>如果当前节点有左子节点或右子节点，将它们加入队列。</li>
<li>继续这一过程，直到队列为空。</li>
</ol>
</li>
<li>每一层的节点：每次从队列中取出所有当前层的节点，访问它们并记录值，然后将其子节点加入队列。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个队列来进行 BFS</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();  <span class="comment">// 当前层的节点数</span></span><br><span class="line">            List&lt;Integer&gt; currentLevel = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                currentLevel.add(currentNode.val);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 把当前节点的左右子树加入到队列</span></span><br><span class="line">                <span class="keyword">if</span> (currentNode.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(currentNode.left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (currentNode.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(currentNode.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.add(currentLevel);  <span class="comment">// 将当前层的节点值加入到结果</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 O(n)。</p>
<p>空间复杂度：队列中元素的个数不超过 n 个，故渐进空间复杂度为 O(n)。</p>
<h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a>108. 将有序数组转换为二叉搜索树</h2><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 平衡 二叉搜索树。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-10,-3,0,5,9]</span><br><span class="line">输出：[0,-3,9,-10,null,5]</span><br><span class="line">解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3]</span><br><span class="line">输出：[3,1]</span><br><span class="line">解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li>选择中位数作为根节点：因为数组是升序排列的，选择中位数作为根节点可以确保树的左右两部分尽可能平衡。<ul>
<li>如果数组的长度是奇数，选择中间元素。</li>
<li>如果数组的长度是偶数，选择中间偏左的元素（例如，索引为 <code>(start + end) / 2</code>）。</li>
</ul>
</li>
<li>递归构建：通过递归地对数组的左半部分和右半部分重复上述操作，依次构建出整个树。</li>
<li>终止条件：当数组为空时，返回 <code>null</code>，表示树的子树为空。</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归的终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择中位数作为根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归构建左子树和右子树</span></span><br><span class="line">        node.left = buildTree(nums, start, mid - <span class="number">1</span>);</span><br><span class="line">        node.right = buildTree(nums, mid + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是数组的长度。每个节点都会被访问一次，并且每次都进行常数时间的操作（选择中位数和递归调用）。</p>
<p>空间复杂度：O(log n)，这是递归调用栈的最大深度。在最坏情况下（数组的长度为 n），递归的深度为 log(n)。</p>
<h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a>98. 验证二叉搜索树</h2><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>有效</strong> 二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含 <strong>严格小于</strong> 当前节点的数。</li>
<li>节点的右子树只包含 <strong>严格大于</strong> 当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [5,1,4,null,null,3,6]</span><br><span class="line">输出：false</span><br><span class="line">解释：根节点的值是 5 ，但是右子节点的值是 4 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围在<code>[1, 104]</code> 内</li>
<li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>我们可以通过递归来检查每个节点是否满足二叉搜索树的性质。为了避免重复检查，我们可以将每个节点的值限定在一个合法的区间内。递归过程中，我们可以利用以下规则：</p>
<ul>
<li>对于当前节点，左子树的所有节点值必须在 <code>(min, root.val)</code> 区间内，右子树的所有节点值必须在 <code>(root.val, max)</code> 区间内。</li>
<li>对于每一个节点，都需要检查其左子树和右子树是否满足这些条件。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始时，允许最小值为负无穷，最大值为正无穷</span></span><br><span class="line">        <span class="keyword">return</span> isValidBSTHelper(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助递归函数，检查根节点在 [min, max] 范围内</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValidBSTHelper</span><span class="params">(TreeNode node, <span class="type">long</span> min, <span class="type">long</span> max)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点为空，返回 true</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前值不在 [min, max] 范围内，返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (node.val &lt;= min || node.val &gt;= max) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归检查左右子树</span></span><br><span class="line">        <span class="keyword">return</span> isValidBSTHelper(node.left, min, node.val) &amp;&amp; isValidBSTHelper(node.right, node.val, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是二叉树的节点数。每个节点都被访问一次，且每次访问的操作是常数时间的。</p>
<p>空间复杂度：O(h)，其中 h 是二叉树的高度。最坏情况下（树是链表形式），空间复杂度为 O(n)；最好的情况下（树是平衡的），空间复杂度为 O(log n)，这与递归的栈深度有关。</p>
<h2 id="230-二叉搜索树中第-K-小的元素"><a href="#230-二叉搜索树中第-K-小的元素" class="headerlink" title="230. 二叉搜索树中第 K 小的元素"></a>230. 二叉搜索树中第 K 小的元素</h2><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 小的元素（从 1 开始计数）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,1,4,null,2], k = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中的节点数为 <code>n</code> 。</li>
<li><code>1 &lt;= k &lt;= n &lt;= 104</code></li>
<li><code>0 &lt;= Node.val &lt;= 104</code></li>
</ul>
<p>**进阶：**如果二叉搜索树经常被修改（插入&#x2F;删除操作）并且你需要频繁地查找第 <code>k</code> 小的值，你将如何优化算法？</p>
<p><strong>解题思路</strong></p>
<ol>
<li>中序遍历：中序遍历二叉搜索树会按升序访问节点。因此，我们可以通过中序遍历来依次访问节点，直到找到第 <code>k</code> 个节点。</li>
<li>递归或迭代实现：我们可以使用递归或迭代的方式来实现中序遍历。每遍历一个节点，就减小 <code>k</code>，当 <code>k</code> 减到 0 时，当前节点就是我们要找的第 <code>k</code> 小元素。</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 用于记录已经遍历的节点数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 用于存储第 k 小的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 开始中序遍历</span></span><br><span class="line">        inOrder(root, k);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode node, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归遍历子树</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问左子树</span></span><br><span class="line">        inOrder(node.left, k);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问当前节点</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">            result = node.val;  <span class="comment">// 记录第 k 小的值</span></span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// 提前返回，避免继续遍历</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问右子树</span></span><br><span class="line">        inOrder(node.right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是树的节点数。最坏情况下，我们需要遍历所有节点，直到找到第 k 小的元素。</p>
<p>空间复杂度：O(h)，其中 h 是二叉树的高度。由于递归栈的深度等于树的高度，在最坏情况下（树为链状），空间复杂度为 O(n)。</p>
<h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a>199. 二叉树的右视图</h2><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p><strong>示例 1：</strong></p>
<p>**输入：**root &#x3D; [1,2,3,null,5,null,4]</p>
<p><strong>输出：</strong>[1,3,4]</p>
<p><strong>解释：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2024/11/24/tmpd5jn43fs-1.png" alt="img"></p>
<p><strong>示例 2：</strong></p>
<p>**输入：**root &#x3D; [1,2,3,4,null,null,null,5]</p>
<p><strong>输出：</strong>[1,3,4,5]</p>
<p><strong>解释：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2024/11/24/tmpkpe40xeh-1.png" alt="img"></p>
<p><strong>示例 3：</strong></p>
<p>**输入：**root &#x3D; [1,null,3]</p>
<p><strong>输出：</strong>[1,3]</p>
<p><strong>示例 4：</strong></p>
<p>**输入：**root &#x3D; []</p>
<p><strong>输出：</strong>[]</p>
<p><strong>提示:</strong></p>
<ul>
<li>二叉树的节点个数的范围是 <code>[0,100]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li>层次遍历：从树的最上面一层开始，逐层遍历树。我们可以使用 BFS 来实现这一点。</li>
<li>每层的最后一个节点：对于每一层，我们将所有节点放入队列中，并逐个访问。每当我们遍历完当前层时，队列中的最后一个节点就是当前层从右侧看到的节点。</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列用于 BFS</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历当前层的所有节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果是当前层的最后一个节点，加入结果</span></span><br><span class="line">                <span class="keyword">if</span> (i == size - <span class="number">1</span>) &#123;</span><br><span class="line">                    result.add(node.val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将左右子树加入到队列</span></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度 : O(n)。 每个节点最多进队列一次，出队列一次，因此广度优先搜索的复杂度为线性。</p>
<p>空间复杂度 : O(n)。每个节点最多进队列一次，所以队列长度最大不不超过 n，所以这里的空间代价为 O(n)。</p>
<h2 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a>114. 二叉树展开为链表</h2><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li>
<li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,5,3,4,null,6]</span><br><span class="line">输出：[1,null,2,null,3,null,4,null,5,null,6]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中结点数在范围 <code>[0, 2000]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p>**进阶：**你可以使用原地算法（<code>O(1)</code> 额外空间）展开这棵树吗？</p>
<p><strong>解题思路</strong></p>
<ol>
<li>递归方法：可以采用递归的方式来进行展开。我们可以先遍历根节点，然后递归地展开左子树和右子树，最终将树的每个子树与其兄弟节点串联起来。</li>
<li>原地展开：我们可以在递归过程中直接修改 <code>root</code> 的 <code>left</code> 和 <code>right</code> 指针，而不使用额外的空间（如栈或队列）。</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归展开左右子树</span></span><br><span class="line">        flatten(root.left);</span><br><span class="line">        flatten(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存右子树，准备连接</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tempRight</span> <span class="operator">=</span> root.right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将左子树变为右子树</span></span><br><span class="line">        root.right = root.left;</span><br><span class="line">        root.left = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到新的右子树的最后一个节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (curr.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将原来的右子树连接到最后一个节点的右侧</span></span><br><span class="line">        curr.right = tempRight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是树的节点数。每个节点都被访问一次。</p>
<p>空间复杂度：O(h)，其中 h 是树的高度。递归栈的空间复杂度取决于树的深度，在最坏情况下为 O(n)（当树是线性的）。</p>
<h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h2><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p>
<p><strong>示例 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</span><br><span class="line">输出: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: preorder = [-1], inorder = [-1]</span><br><span class="line">输出: [-1]</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= preorder.length &lt;= 3000</code></li>
<li><code>inorder.length == preorder.length</code></li>
<li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li>
<li><code>preorder</code> 和 <code>inorder</code> 均 <strong>无重复</strong> 元素</li>
<li><code>inorder</code> 均出现在 <code>preorder</code></li>
<li><code>preorder</code> <strong>保证</strong> 为二叉树的前序遍历序列</li>
<li><code>inorder</code> <strong>保证</strong> 为二叉树的中序遍历序列</li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li><p>前序遍历的第一个元素就是树的根节点。</p>
</li>
<li><p>在中序遍历中找到根节点的位置，将中序遍历分为左右两部分：</p>
<ul>
<li><p>左边部分是左子树的节点。</p>
</li>
<li><p>右边部分是右子树的节点。</p>
</li>
</ul>
</li>
<li><p>递归地构建左子树和右子树。</p>
</li>
<li><p>使用递归的方式进行树的构建，并且通过索引来避免重复遍历。</p>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buildTreeHelper(preorder, inorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">buildTreeHelper</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder, <span class="type">int</span> preStart, <span class="type">int</span> preEnd, <span class="type">int</span> inStart, <span class="type">int</span> inEnd)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归出口</span></span><br><span class="line">        <span class="keyword">if</span> (preStart &gt; preEnd || inStart &gt; inEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根节点是 preorder 的第一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> preorder[preStart];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到根节点在 inorder 的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> inStart; i &lt;= inEnd; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == rootVal) &#123;</span><br><span class="line">                rootIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算左子树的大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> rootIndex - inStart;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归构建左右子树</span></span><br><span class="line">        root.left = buildTreeHelper(preorder, inorder, preStart + <span class="number">1</span>, preStart + leftSize, inStart, rootIndex - <span class="number">1</span>);</span><br><span class="line">        root.right = buildTreeHelper(preorder, inorder, preStart + leftSize + <span class="number">1</span>, preEnd, rootIndex + <span class="number">1</span>, inEnd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是树中的节点个数。</p>
<p>空间复杂度：O(n)，除去返回的答案需要的 O(n) 空间之外，我们还需要使用 O(n) 的空间存储哈希映射，以及 O(h)（其中 h 是树的高度）的空间表示递归时栈空间。这里 h&lt;n，所以总空间复杂度为 O(n)。</p>
<h2 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a>437. 路径总和 III</h2><p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p>
<p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8</span><br><span class="line">输出：3</span><br><span class="line">解释：和等于 8 的路径有 3 条，如图所示。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li>二叉树的节点个数的范围是 <code>[0,1000]</code></li>
<li><code>-109 &lt;= Node.val &lt;= 109</code> </li>
<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<p><strong>解题思路</strong></p>
<ol>
<li>从根节点开始，递归遍历二叉树，遍历到每个节点时，检查以该节点为起点的路径和。</li>
<li>在递归过程中，如果当前路径和等于 <code>targetSum</code>，则记录该路径。</li>
<li>对每个节点，递归地计算从该节点向下的路径和，同时递归左右子树。</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归遍历二叉树</span></span><br><span class="line">        <span class="keyword">return</span> helper(root, (<span class="type">long</span>) targetSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每一个节点，从该节点出发，统计路径和为 targetSum 的路径数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">helper</span><span class="params">(TreeNode node, <span class="type">long</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算从当前节点出发的路径中，路径和为 targetSum 的个数</span></span><br><span class="line">        <span class="keyword">return</span> countPaths(node, targetSum) + helper(node.left, targetSum) + helper(node.right, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算从当前节点出发，路径和为 targetSum 的路径数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countPaths</span><span class="params">(TreeNode node, <span class="type">long</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点的路径和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">long</span>) node.val == targetSum) &#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归计算左右子树</span></span><br><span class="line">        count += countPaths(node.left, targetSum - node.val);</span><br><span class="line">        count += countPaths(node.right, targetSum - node.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n^2)，其中 n 为该二叉树节点的个数。对于每一个节点，求以该节点为起点的路径数目时，则需要遍历以该节点为根节点的子树的所有节点，因此求该路径所花费的最大时间为 O(n)，我们会对每个节点都求一次以该节点为起点的路径数目，因此时间复杂度为 O(n^2)。</p>
<p>空间复杂度：O(n)，考虑到递归需要在栈上开辟空间。</p>
<h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2], p = 1, q = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[2, 105]</code> 内。</li>
<li><code>-109 &lt;= Node.val &lt;= 109</code></li>
<li>所有 <code>Node.val</code> <code>互不相同</code> 。</li>
<li><code>p != q</code></li>
<li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li>
</ul>
<p><strong>解题思路</strong></p>
<p>这个题是经典的「最近公共祖先 LCA」问题，可以用递归轻松解决。核心思想是：</p>
<ul>
<li>如果当前节点是 <strong>null</strong>，说明没找到，返回 <code>null</code>。</li>
<li>如果当前节点是 <strong>p 或 q</strong>，那么这个节点本身就是答案的一部分，直接返回它。</li>
<li>否则就分别递归左右子树：<ul>
<li>如果左右子树都能找到（返回非空），说明 p 和 q 分别在左右两边，那么当前节点就是最近公共祖先；</li>
<li>如果只有一边找到，说明 p 和 q 都在这一边，直接返回这一边；</li>
<li>如果都没找到，返回 <code>null</code>。</li>
</ul>
</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前节点是 p 或 q，当前节点是公共祖先</span></span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// p 和 q 分别在左右子树，当前节点是公共祖先</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果只有一边非空，返回非空的那一边</span></span><br><span class="line">        <span class="keyword">return</span> left == <span class="literal">null</span> ? right : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是二叉树的节点数。二叉树的所有节点有且只会被访问一次，因此时间复杂度为 O(n)。</p>
<p>空间复杂度：O(n) ，其中 n 是二叉树的节点数。递归调用的栈深度取决于二叉树的高度，二叉树最坏情况下为一条链，此时高度为 n，因此空间复杂度为 O(n)。</p>
<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h2><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;],</span><br><span class="line">  [&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;0&#x27;],</span><br><span class="line">  [&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;],</span><br><span class="line">  [&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;],</span><br><span class="line">  [&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;],</span><br><span class="line">  [&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;],</span><br><span class="line">  [&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;1&#x27;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 300</code></li>
<li><code>grid[i][j]</code> 的值为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li>
</ul>
<p><strong>解题思路</strong></p>
<ul>
<li>遍历整个二维数组；</li>
<li>当遇到 <code>&#39;1&#39;</code>（陆地）时，就从这里开始 <strong>DFS 或 BFS</strong> 把整块岛屿淹没（把相邻的 <code>&#39;1&#39;</code> 都变成 <code>&#39;0&#39;</code>）；</li>
<li>每次淹没完成，说明找到了一座岛屿，计数器 <code>count++</code>；</li>
<li>遍历完成后，<code>count</code> 就是岛屿数量。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    dfs(grid, i, j);  <span class="comment">// 把这一整块岛屿淹没</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 越界 or 水，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || grid[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记为已访问（淹没）</span></span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归访问上下左右</span></span><br><span class="line">        dfs(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(m * n)，其中 m 和 n 分别为行数和列数。</p>
<p>空间复杂度：O(m * n)，在最坏情况下，整个网格均为陆地，深度优先搜索的深度达到 m * n。</p>
<h2 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994. 腐烂的橘子"></a>994. 腐烂的橘子</h2><p>在给定的 <code>m x n</code> 网格 <code>grid</code> 中，每个单元格可以有以下三个值之一：</p>
<ul>
<li>值 <code>0</code> 代表空单元格；</li>
<li>值 <code>1</code> 代表新鲜橘子；</li>
<li>值 <code>2</code> 代表腐烂的橘子。</li>
</ul>
<p>每分钟，腐烂的橘子 <strong>周围 4 个方向上相邻</strong> 的新鲜橘子都会腐烂。</p>
<p>返回 <em>直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 <code>-1</code></em> 。</p>
<p><strong>示例 1：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/oranges.png" alt="img"></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[2,1,1],[1,1,0],[0,1,1]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[2,1,1],[0,1,1],[1,0,1]]</span><br><span class="line">输出：-1</span><br><span class="line">解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个方向上。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[0,2]]</span><br><span class="line">输出：0</span><br><span class="line">解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 10</code></li>
<li><code>grid[i][j]</code> 仅为 <code>0</code>、<code>1</code> 或 <code>2</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>遍历整个 <code>grid</code>：</p>
<ul>
<li>把所有腐烂的橘子（值为 2）放进队列，作为 BFS 的起始点；</li>
<li>统计新鲜橘子的数量。</li>
</ul>
<p>从队列中一层一层地扩散（每一层扩散代表一分钟），将相邻的新鲜橘子变为腐烂，并入队。</p>
<p>BFS 结束后：</p>
<ul>
<li>如果没有剩下新鲜橘子，返回扩散的分钟数；</li>
<li>如果还有新鲜橘子没被腐烂，返回 <code>-1</code>。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">orangesRotting</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fresh</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 初始化，记录所有烂橘子的位置 &amp; 统计新鲜橘子数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;i, j&#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    fresh++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果一开始就没有新鲜橘子，直接返回 0</span></span><br><span class="line">        <span class="keyword">if</span> (fresh == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">minutes</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. BFS 扩散</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            minutes++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; size; k++) &#123;</span><br><span class="line">                <span class="type">int</span>[] curr = queue.poll();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span>[] d : dirs) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">ni</span> <span class="operator">=</span> curr[<span class="number">0</span>] + d[<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">nj</span> <span class="operator">=</span> curr[<span class="number">1</span>] + d[<span class="number">1</span>];</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (ni &gt;= <span class="number">0</span> &amp;&amp; ni &lt; m &amp;&amp; nj &gt;= <span class="number">0</span> &amp;&amp; nj &lt; n &amp;&amp; grid[ni][nj] == <span class="number">1</span>) &#123;</span><br><span class="line">                        grid[ni][nj] = <span class="number">2</span>;  <span class="comment">// 新鲜橘子腐烂</span></span><br><span class="line">                        fresh--;</span><br><span class="line">                        queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;ni, nj&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 检查是否还有新鲜橘子</span></span><br><span class="line">        <span class="keyword">return</span> fresh == <span class="number">0</span> ? minutes : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(m * n)。即进行一次广度优先搜索的时间，其中 m,n 分别为 grid 的行数与列数。</p>
<p>空间复杂度：O(m * n)。需要额外的 dis 数组记录每个新鲜橘子被腐烂的最短时间，大小为 O(nm)，且广度优先搜索中队列里存放的状态最多不会超过 m * n 个，最多需要 O(m * n) 的空间，所以最后的空间复杂度为 O(m * n)。</p>
<h2 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a>207. 课程表</h2><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p>
<p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code> 。</p>
<ul>
<li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li>
</ul>
<p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">输出：true</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0],[0,1]]</span><br><span class="line">输出：false</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= numCourses &lt;= 2000</code></li>
<li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li>
<li><code>prerequisites[i].length == 2</code></li>
<li><code>0 &lt;= ai, bi &lt; numCourses</code></li>
<li><code>prerequisites[i]</code> 中的所有课程对 <strong>互不相同</strong></li>
</ul>
<p><strong>解题思路</strong></p>
<p>BFS, Kahn 算法：</p>
<ul>
<li>用入度数组统计每门课程的依赖数；</li>
<li>将入度为 0 的课程加入队列；</li>
<li>每次出队一门课，就把它指向的课程的入度减一，如果某课程入度为 0，就入队；</li>
<li>如果最终出队的课程数等于总课程数，则说明能完成。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">        <span class="comment">// 建图</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] indegree = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="comment">// prerequisites[i] = [a, b]，表示 b -&gt; a</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] p : prerequisites) &#123;</span><br><span class="line">            graph.get(p[<span class="number">1</span>]).add(p[<span class="number">0</span>]);</span><br><span class="line">            indegree[p[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将入度为 0 的课程加入到队列</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 统计能学完的课程数</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">course</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            count++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i : graph.get(course)) &#123;</span><br><span class="line">                indegree[i]--;</span><br><span class="line">                <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.offer(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度: O(n+m)，其中 n 为课程数，m 为先修课程的要求数。这其实就是对图进行广度优先搜索的时间复杂度。</p>
<p>空间复杂度: O(n+m)。题目中是以列表形式给出的先修课程关系，为了对图进行广度优先搜索，我们需要存储成邻接表的形式，空间复杂度为 O(n+m)。在广度优先搜索的过程中，我们需要最多 O(n) 的队列空间（迭代）进行广度优先搜索。因此总空间复杂度为 O(n+m)。</p>
<h2 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a>208. 实现 Trie (前缀树)</h2><p><strong>Trie</strong>（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。</p>
<p>请你实现 Trie 类：</p>
<ul>
<li><code>Trie()</code> 初始化前缀树对象。</li>
<li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li>
<li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li>
<li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span><br><span class="line">[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span><br><span class="line">输出</span><br><span class="line">[null, null, true, false, true, null, true]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">Trie trie = new Trie();</span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   // 返回 True</span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 False</span><br><span class="line">trie.startsWith(&quot;app&quot;); // 返回 True</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 True</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li>
<li><code>word</code> 和 <code>prefix</code> 仅由小写英文字母组成</li>
<li><code>insert</code>、<code>search</code> 和 <code>startsWith</code> 调用次数 <strong>总计</strong> 不超过 <code>3 * 104</code> 次</li>
</ul>
<p><strong>解题思路</strong></p>
<p>每个节点要保存 <strong>26 个子节点指针</strong>（对应 <code>a-z</code>），也可以用 <code>Map&lt;Character, TrieNode&gt;</code>。</p>
<p>每个节点要有一个标志，表示“是否是某个完整单词的结尾”。</p>
<p>插入时逐字符往下建，搜索时逐字符往下走。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义节点</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">        TrieNode[] children;  <span class="comment">// 存 26 个节点</span></span><br><span class="line">        <span class="type">boolean</span> isEnd;        <span class="comment">// 标记是否为某个单词结尾</span></span><br><span class="line"></span><br><span class="line">        TrieNode() &#123;</span><br><span class="line">            children = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">            isEnd = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();  <span class="comment">// 初始化根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>;  <span class="comment">// 计算子节点索引</span></span><br><span class="line">            <span class="keyword">if</span> (node.children[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.children[i] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            node = node.children[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.isEnd = <span class="literal">true</span>;  <span class="comment">// 单词结束位置打标</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 没路了</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node = node.children[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node.isEnd;  <span class="comment">// 必须到结尾且 isEnd = true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : prefix.toCharArray()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node = node.children[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 只要路径存在即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：初始化为 O(1)，其余操作为 O(∣S∣)，其中 ∣S∣ 是每次插入或查询的字符串的长度。</p>
<p>空间复杂度：O(∣T∣⋅Σ)，其中 ∣T∣ 为所有插入字符串的长度之和，Σ 为字符集的大小，本题 Σ&#x3D;26。</p>
<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1]</span><br><span class="line">输出：[[0,1],[1,0]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 6</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
</ul>
<p><strong>解题思路</strong></p>
<p>使用一个 <code>List&lt;Integer&gt;</code> 保存当前路径（即正在构造的排列）。</p>
<p>用一个 <code>boolean[] used</code> 数组标记 <code>nums[i]</code> 是否已经被选择。</p>
<p>如果路径长度等于 <code>nums.length</code>，就把它加入答案。</p>
<p>否则枚举所有数字，把没用过的数字加入，递归下去，再回溯（撤销选择）。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        backtrack(nums, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), used, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, List&lt;Integer&gt; path, <span class="type">boolean</span>[] used, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));  <span class="comment">// 找到一个序列</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;  <span class="comment">// 已经用过，跳过</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 选择 nums[i]</span></span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line"></span><br><span class="line">            backtrack(nums, path, used, result);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n × n!)，其中 n 为序列的长度。</p>
<p>空间复杂度：O(n)，其中 n 为序列的长度。除答案数组以外，递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，这里可知递归调用深度为 O(n)。</p>
<h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a>78. 子集</h2><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li>
</ul>
<p><strong>解题思路</strong></p>
<p>每个元素都有 <strong>选</strong> 或 <strong>不选</strong> 两种可能。</p>
<p>用回溯（DFS）保证不会生成重复子集。</p>
<p>一开始就把当前 path 加入结果，所以会自然包含 <code>[]</code>（空集）。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtrack(nums, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            path.add(nums[i]);                     <span class="comment">// 选择</span></span><br><span class="line">            backtrack(nums, i + <span class="number">1</span>, path, result);  <span class="comment">// 进入下一层</span></span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);          <span class="comment">// 撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n · 2^n)，其中 n 为数组长度。每个元素都有选或不选两种情况，因此一共会生成 2^n 个子集；而在构造每个子集时需要 O(n) 的时间进行拷贝。</p>
<p>空间复杂度：O(n)，递归调用过程中使用的栈空间与当前路径存储所需的空间，最多为 O(n)。输出结果本身不计入额外空间复杂度。</p>
<h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h2><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="https://pic.leetcode.cn/1752723054-mfIHZs-image.png" alt="img"></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;2&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= digits.length &lt;= 4</code></li>
<li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li>
</ul>
<p><strong>解题思路</strong></p>
<p>先用一个数组或 <code>Map&lt;Character, String&gt;</code> 建立映射</p>
<p>回溯递归</p>
<ul>
<li>从字符串的第 <code>index</code> 个数字开始，取出它对应的所有字母；</li>
<li>把每个字母加入当前组合 <code>path</code>；</li>
<li>然后递归处理下一个数字；</li>
<li>当路径长度等于 <code>digits.length</code> 时，说明形成了一个完整的组合，加入结果。</li>
</ul>
<p>如果输入 <code>digits</code> 为空字符串，直接返回空列表。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] MAPPING = &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>,     <span class="comment">// 0</span></span><br><span class="line">        <span class="string">&quot;&quot;</span>,     <span class="comment">// 1</span></span><br><span class="line">        <span class="string">&quot;abc&quot;</span>,  <span class="comment">// 2</span></span><br><span class="line">        <span class="string">&quot;def&quot;</span>,  <span class="comment">// 3</span></span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>,  <span class="comment">// 4</span></span><br><span class="line">        <span class="string">&quot;jkl&quot;</span>,  <span class="comment">// 5</span></span><br><span class="line">        <span class="string">&quot;mno&quot;</span>,  <span class="comment">// 6</span></span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>, <span class="comment">// 7</span></span><br><span class="line">        <span class="string">&quot;tuv&quot;</span>,  <span class="comment">// 8</span></span><br><span class="line">        <span class="string">&quot;wxyz&quot;</span>  <span class="comment">// 9</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="literal">null</span> || digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        backtrack(digits, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(), result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(String digits, <span class="type">int</span> index, StringBuilder path, List&lt;String&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.length()) &#123;</span><br><span class="line">            result.add(path.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">letters</span> <span class="operator">=</span> MAPPING[digits.charAt(index) - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : letters.toCharArray()) &#123;</span><br><span class="line">            path.append(c);                             <span class="comment">// 选择一个字母</span></span><br><span class="line">            backtrack(digits, index + <span class="number">1</span>, path, result); <span class="comment">// 递归处理下一个数字</span></span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);       <span class="comment">// 撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(3^m * 4^n)，其中 m 是输入中对应 3 个字母的数字个数（包括数字 2、3、4、5、6、8），n 是输入中对应 4 个字母的数字个数（包括数字 7、9），m+n 是输入数字的总个数。当输入包含 m 个对应 3 个字母的数字和 n 个对应 4 个字母的数字时，不同的字母组合一共有 3^m * 4^n 种，需要遍历每一种字母组合。</p>
<p>空间复杂度：O(m+n)，其中 m 是输入中对应 3 个字母的数字个数，n 是输入中对应 4 个字母的数字个数，m+n 是输入数字的总个数。除了返回值以外，空间复杂度主要取决于哈希表以及回溯过程中的递归调用层数，哈希表的大小与输入无关，可以看成常数，递归调用层数最大为 m+n。</p>
<h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h2><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p>
<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: candidates = [2,3,5], target = 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: candidates = [2], target = 1</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= candidates.length &lt;= 30</code></li>
<li><code>2 &lt;= candidates[i] &lt;= 40</code></li>
<li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li>
<li><code>1 &lt;= target &lt;= 40</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>用 <strong>回溯</strong>，在搜索过程中不断累加当前和 <code>sum</code>，直到：</p>
<ul>
<li>如果 <code>sum == target</code> → 收集结果。</li>
<li>如果 <code>sum &gt; target</code> → 直接返回（剪枝）。</li>
</ul>
<p>用一个 <code>start</code> 参数控制搜索范围，保证组合里数字的顺序不会乱（避免重复解）。</p>
<ul>
<li>例如 <code>[2,3]</code> 和 <code>[3,2]</code> 其实是一样的，所以搜索的时候规定只能往后选。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtrack(candidates, target, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), result);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> start, <span class="type">int</span> sum, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));  <span class="comment">// 找到组合</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// 剪枝：超过目标值，直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            path.add(candidates[i]);  <span class="comment">// 选择当前数 </span></span><br><span class="line">            backtrack(candidates, target, i, sum + candidates[i], path, result);  <span class="comment">// 递归时 i 不变，因为可以重复选择同一个数</span></span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);  <span class="comment">// 撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(S)，其中 S 为所有可行解的长度之和。从分析给出的搜索树我们可以看出时间复杂度取决于搜索树所有叶子节点的深度之和，即所有可行解的长度之和。在这题中，我们很难给出一个比较紧的上界，我们知道 O(n * 2^n) 是一个比较松的上界，即在这份代码中，n 个位置每次考虑选或者不选，如果符合条件，就加入答案的时间代价。但是实际运行的时候，因为不可能所有的解都满足条件，递归的时候我们还会用 target−candidates[idx]≥0 进行剪枝，所以实际运行情况是远远小于这个上界的。</p>
<p>空间复杂度：O(target)。除答案数组外，空间复杂度取决于递归的栈深度，在最差情况下需要递归 O(target) 层。</p>
<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[&quot;()&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 8</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>有效括号的组合要求：</p>
<ul>
<li>左括号 <code>(</code> 必须在右括号 <code>)</code> 之前出现。</li>
<li>不能有不匹配的右括号（即右括号不能超过左括号）。</li>
</ul>
<p>递归过程：</p>
<ul>
<li>我们一开始有 <code>n</code> 对括号可以使用。</li>
<li>递归时，我们尝试添加左括号 <code>(</code> 和右括号 <code>)</code>，每次递归的时候需要确保：<ul>
<li>左括号数量不超过 <code>n</code>。</li>
<li>右括号数量不超过左括号数量。</li>
</ul>
</li>
</ul>
<p>回溯的终止条件：</p>
<ul>
<li>当左括号和右括号的数量都达到了 <code>n</code> 时，说明当前组合是一个有效的括号组合。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtrack(n, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> n, String current, <span class="type">int</span> open, <span class="type">int</span> close, List&lt;String&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (open == n &amp;&amp; close == n) &#123;</span><br><span class="line">            result.add(current);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左括号在右括号之前，左括号数不超过 n</span></span><br><span class="line">        <span class="keyword">if</span> (open &lt; n) &#123;</span><br><span class="line">            backtrack(n, current + <span class="string">&quot;(&quot;</span>, open + <span class="number">1</span>, close, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右括号数不超过左括号数</span></span><br><span class="line">        <span class="keyword">if</span> (close &lt; open) &#123;</span><br><span class="line">            backtrack(n, current + <span class="string">&quot;)&quot;</span>, open, close + <span class="number">1</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(4^n &#x2F; sqrt(n))，在回溯过程中，每个答案需要 O(n) 的时间复制到答案数组中。</p>
<p>空间复杂度：O(n)，除了答案数组之外，我们所需要的空间取决于递归栈的深度，每一层递归函数需要 O(1) 的空间，最多递归 2n 层，因此空间复杂度为 O(n)。</p>
<h2 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a>79. 单词搜索</h2><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = [[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;E&#x27;],[&#x27;S&#x27;,&#x27;F&#x27;,&#x27;C&#x27;,&#x27;S&#x27;],[&#x27;A&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;E&#x27;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = [[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;E&#x27;],[&#x27;S&#x27;,&#x27;F&#x27;,&#x27;C&#x27;,&#x27;S&#x27;],[&#x27;A&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;E&#x27;]], word = &quot;SEE&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/15/word3.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = [[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;E&#x27;],[&#x27;S&#x27;,&#x27;F&#x27;,&#x27;C&#x27;,&#x27;S&#x27;],[&#x27;A&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;E&#x27;]], word = &quot;ABCB&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == board.length</code></li>
<li><code>n = board[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 6</code></li>
<li><code>1 &lt;= word.length &lt;= 15</code></li>
<li><code>board</code> 和 <code>word</code> 仅由大小写英文字母组成</li>
</ul>
<p>**进阶：**你可以使用搜索剪枝的技术来优化解决方案，使其在 <code>board</code> 更大的情况下可以更快解决问题？</p>
<p><strong>解题思路</strong></p>
<p>从每个单元格开始：遍历整个 <code>board</code>，从每个位置开始进行搜索。</p>
<p>深度优先搜索：每次移动到相邻的单元格，检查该位置的字符是否匹配目标字符，并继续递归搜索下一个字符。</p>
<p>回溯：如果当前路径无法找到目标单词，则回溯并尝试其他路径。</p>
<p>剪枝：每个单元格只能被使用一次，因此每次进入递归时，需要将当前位置标记为已访问，退出时恢复状态。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (board == <span class="literal">null</span> || m == <span class="number">0</span> || n == <span class="number">0</span> || word == <span class="literal">null</span> || word.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个位置作为起点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(board, word, i, j, <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, String word, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> currLength)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前长度等于 word 长度，说明已经匹配成功</span></span><br><span class="line">        <span class="keyword">if</span> (currLength == word.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边界条件：越界 or 不等于目标字段</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] != word.charAt(currLength)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保留当前字符，标记为已访问</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> board[i][j];</span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试从四个方向 dfs</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isFound</span> <span class="operator">=</span> dfs(board, word, i + <span class="number">1</span>, j, currLength + <span class="number">1</span>) || dfs(board, word, i - <span class="number">1</span>, j, currLength + <span class="number">1</span>) || dfs(board, word, i, j + <span class="number">1</span>, currLength + <span class="number">1</span>) || dfs(board, word, i, j - <span class="number">1</span>, currLength + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        board[i][j] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isFound;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：最坏情况下，我们要遍历每个单元格，进行一次深度优先搜索。递归的深度为单词 word 的长度，假设为 L，每个位置可以有 4 个方向，最坏情况下时间复杂度是 O(m * n * 4^L)，其中 m 和 n 分别是 board 的行数和列数。</p>
<p>空间复杂度：空间复杂度主要来自递归栈的深度，最坏情况下递归深度为 L，因此空间复杂度是 O(L)。</p>
<h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a>131. 分割回文串</h2><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些 子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aab&quot;</span><br><span class="line">输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a&quot;</span><br><span class="line">输出：[[&quot;a&quot;]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 16</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<p><strong>解题思路</strong></p>
<p>回溯：我们从字符串的开头开始，每次选择一个可能的切割点，将字符串分割成多个部分，递归处理剩下的部分。</p>
<p>回文检查：在每次选择分割点时，我们需要判断当前子串是否是回文。如果是回文，就继续进行分割，否则跳过这个分割点。</p>
<p>终止条件：当字符串完全被分割成回文子串时，记录当前的分割方案。回溯回去继续尝试其他分割。</p>
<p>回溯算法步骤：</p>
<ol>
<li>从字符串的开头开始，尝试每一个可能的子串。</li>
<li>判断当前子串是否为回文。如果是回文，则继续递归地处理剩下的部分。</li>
<li>每当找到一种合法的分割方案，就将其加入结果集。</li>
<li>当递归到达字符串的末尾时，表示已经找到了一种合法的分割方案。</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; currentPartition = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtrack(s, <span class="number">0</span>, currentPartition, result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(String s, <span class="type">int</span> start, List&lt;String&gt; currentPartition, List&lt;List&lt;String&gt;&gt; result)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果已经遍历到字符串的末尾，记录当前分割方案</span></span><br><span class="line">        <span class="keyword">if</span> (start == s.length()) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(currentPartition));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从当前位置开始，尝试每个可能的子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> start + <span class="number">1</span>; end &lt;= s.length(); end++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">substring</span> <span class="operator">=</span> s.substring(start, end);</span><br><span class="line">            <span class="comment">// 如果当前子串是回文，则继续递归</span></span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(substring)) &#123;</span><br><span class="line">                currentPartition.add(substring);</span><br><span class="line">                <span class="comment">// 递归处理后续部分</span></span><br><span class="line">                backtrack(s, end, currentPartition, result);</span><br><span class="line">                <span class="comment">// 回溯，移出最后一个子串</span></span><br><span class="line">                currentPartition.remove(currentPartition.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断一个字符串是否是回文</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：对于每一个起始位置，我们可能会检查多个子串，因此总的时间复杂度是 O(2^n * n)，其中 2^n 是最坏情况下的回溯树的大小，n 是每次回文检查的时间。</p>
<p>空间复杂度：递归深度最多为 n，所以空间复杂度为 O(n)。</p>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 为 <strong>无重复元素</strong> 的 <strong>升序</strong> 排列数组</li>
<li><code>-104 &lt;= target &lt;= 104</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>初始化：我们需要设置两个指针：<code>left</code> 和 <code>right</code>，分别表示当前搜索范围的起始和结束位置。最开始时，<code>left = 0</code>，<code>right = nums.length - 1</code>。</p>
<p>查找目标：通过二分查找不断缩小搜索范围：</p>
<ul>
<li>计算中间位置 <code>mid = left + (right - left) / 2</code>。</li>
<li>比较 <code>nums[mid]</code> 与 <code>target</code>：<ul>
<li>如果 <code>nums[mid] == target</code>，说明找到了目标值，直接返回 <code>mid</code>。</li>
<li>如果 <code>nums[mid] &lt; target</code>，说明目标值在右半部分，更新 <code>left = mid + 1</code>。</li>
<li>如果 <code>nums[mid] &gt; target</code>，说明目标值在左半部分，更新 <code>right = mid - 1</code>。</li>
</ul>
</li>
</ul>
<p>插入位置：如果在搜索过程中没有找到目标值，最终 <code>left</code> 就是目标值应该插入的位置。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用二分查找</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;  <span class="comment">// 防止 overflow</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;  <span class="comment">// 找到目标值，返回索引</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;  <span class="comment">// 目标值在右半部分</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;  <span class="comment">// 目标值在左半部分</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有目标值，left 是目标值插入的位置</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(log n)，其中 n 为数组的长度。二分查找所需的时间复杂度为 O(log n)。</li>
<li>空间复杂度：O(1)。我们只需要常数空间存放若干变量。</li>
</ul>
<h2 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74. 搜索二维矩阵"></a>74. 搜索二维矩阵</h2><p>给你一个满足下述两条属性的 <code>m x n</code> 整数矩阵：</p>
<ul>
<li>每行中的整数从左到右按非严格递增顺序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。</li>
</ul>
<p>给你一个整数 <code>target</code> ，如果 <code>target</code> 在矩阵中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li><code>-104 &lt;= matrix[i][j], target &lt;= 104</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>由于矩阵满足特定的排列条件，我们可以使用一种 <strong>二分查找</strong> 的方法来优化搜索，达到 <code>O(log(m * n))</code> 的时间复杂度。</p>
<p>我们可以将这个问题看作是在一个 <strong>一维有序数组</strong> 中查找目标值。具体的做法如下：</p>
<ol>
<li>将二维矩阵看作一个一维的排序数组。例如，第 i 行第 j 列的元素可以通过 <code>matrix[i][j]</code> 来访问。在一维数组的角度上，可以用公式 <code>index = i * n + j</code> 来进行转换，其中 <code>n</code> 是每行的列数。</li>
<li>使用二分查找在矩阵中查找目标值。我们首先设定一个 <code>left</code> 指针指向数组的第一个元素，<code>right</code> 指针指向数组的最后一个元素。通过不断缩小搜索范围，直到找到目标值或者确定目标值不存在。</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> m * n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用二分查找</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;  <span class="comment">// 防止 overflow</span></span><br><span class="line">            <span class="comment">// mid = i * n + j</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">midValue</span> <span class="operator">=</span> matrix[mid / n][mid % n];</span><br><span class="line">            <span class="keyword">if</span> (midValue == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 找到目标值</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midValue &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;  <span class="comment">// 目标值在右半部分</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;  <span class="comment">// 目标值在左半部分</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(log m * n)，其中 m 和 n 分别是矩阵的行数和列数。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h2><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p>
<p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 105</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>nums</code> 是一个非递减数组</li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>二分查找：由于数组是有序的，我们可以使用二分查找来找到目标值的 开始位置 和 结束位置。首先，我们可以使用二分查找找到目标值的任意一个位置，然后从该位置向两边扩展，找到目标值的最左和最右位置。</p>
<p>步骤：</p>
<ul>
<li>首先，我们使用二分查找找到 <code>target</code> 的任意一个出现位置。</li>
<li>然后，在找到的位置基础上，分别进行二分查找：<ul>
<li>向左查找，直到找到最左边的 <code>target</code> 位置。</li>
<li>向右查找，直到找到最右边的 <code>target</code> 位置。</li>
</ul>
</li>
<li>如果数组中没有目标值 <code>target</code>，则返回 <code>[-1, -1]</code>。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        result[<span class="number">0</span>] = findLeft(nums, target);  <span class="comment">// 找到最左边的位置</span></span><br><span class="line">        result[<span class="number">1</span>] = findRight(nums, target);  <span class="comment">// 找到最右边的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找找到最左边的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findLeft</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftIndex</span> <span class="operator">=</span> -<span class="number">1</span>;  <span class="comment">// 默认找不到，返回 -1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                leftIndex = mid;</span><br><span class="line">                right = mid - <span class="number">1</span>;  <span class="comment">// 继续在左边寻找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找找到最右边的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findRight</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightIndex</span> <span class="operator">=</span> -<span class="number">1</span>;  <span class="comment">// 默认找不到，返回 -1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                rightIndex = mid;</span><br><span class="line">                left = mid + <span class="number">1</span>;  <span class="comment">// 继续在右边寻找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rightIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度： O(log n) ，其中 n 为数组的长度。二分查找的时间复杂度为 O(log n)，一共会执行两次，因此总时间复杂度为 O(log n)。</p>
<p>空间复杂度：O(1) 。只需要常数空间存放若干变量。</p>
<h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a>33. 搜索旋转排序数组</h2><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p>
<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>向左旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 下标 <code>3</code> 上向左旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p>
<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1], target = 0</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 5000</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 中的每个值都 <strong>独一无二</strong></li>
<li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li>
<li><code>-104 &lt;= target &lt;= 104</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p><strong>首先</strong>，我们知道数组的两部分是有序的：一部分是从旋转点开始的升序部分，另一部分是从旋转点之前的部分。</p>
<p>在每次二分查找的过程中，我们需要判断当前的中间值 <code>mid</code> 与目标值 <code>target</code> 的关系，以及确定旋转点位置，然后确定在哪一部分继续查找。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果找到目标，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;  <span class="comment">// 左半部分有序</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123;  <span class="comment">// 目标在左半部分</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 目标在右半部分</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 右半部分有序</span></span><br><span class="line">                <span class="keyword">if</span> (target &lt;= nums[right] &amp;&amp; target &gt; nums[mid]) &#123;  <span class="comment">// 目标在右半部分</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 目标在左半部分</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度： O(log n)，其中 n 为 nums 数组的大小。整个算法时间复杂度即为二分查找的时间复杂度 O(log n)。</p>
<p>空间复杂度： O(1) 。我们只需要常数级别的空间存放变量。</p>
<h2 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a>153. 寻找旋转排序数组中的最小值</h2><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p>
<ul>
<li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li>
<li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li>
</ul>
<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p>
<p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2]</span><br><span class="line">输出：0</span><br><span class="line">解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [11,13,15,17]</span><br><span class="line">输出：11</span><br><span class="line">解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 5000</code></li>
<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>
<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
<li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li>
</ul>
<p><strong>解题思路</strong></p>
<p>我们可以利用 二分查找 来缩小搜索范围。</p>
<p>每次比较中间元素 <code>mid</code> 和边界元素 <code>nums[left]</code> 以及 <code>nums[right]</code>，可以通过以下方式来决定移动哪一半：</p>
<ol>
<li>如果 <code>nums[mid] &gt;= nums[left]</code>，说明左半部分是升序的，最小值可能在右半部分。</li>
<li>如果 <code>nums[mid] &lt; nums[left]</code>，说明右半部分是升序的，最小值可能在左半部分。</li>
</ol>
<p>通过这种方式，我们可以在对数时间内找到最小元素。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;  <span class="comment">// 如果中间元素大于右边元素，说明最小值在右半部分</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 如果中间元素小于右边元素，说明最小值在左半部分</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当左指针和右指针重合时，left 即为最小元素的索引</span></span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：时间复杂度为 O(log n)，其中 n 是数组 nums 的长度。在二分查找的过程中，每一步会忽略一半的区间，因此时间复杂度为 O(log n)。</p>
<p>空间复杂度：O(1)。</p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ol>
<p><strong>示例 1：</strong></p>
<p>**输入：**s &#x3D; “()”</p>
<p>**输出：**true</p>
<p><strong>示例 2：</strong></p>
<p>**输入：**s &#x3D; “()[]{}”</p>
<p>**输出：**true</p>
<p><strong>示例 3：</strong></p>
<p>**输入：**s &#x3D; “(]”</p>
<p>**输出：**false</p>
<p><strong>示例 4：</strong></p>
<p>**输入：**s &#x3D; “([])”</p>
<p>**输出：**true</p>
<p><strong>示例 5：</strong></p>
<p>**输入：**s &#x3D; “([)]”</p>
<p>**输出：**false</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li>
</ul>
<p><strong>解题思路</strong></p>
<p>栈的使用：我们遍历字符串中的每个字符：</p>
<ul>
<li>如果是左括号（<code>(</code>, <code>&#123;</code>, <code>[</code>），则将其压入栈中。</li>
<li>如果是右括号（<code>)</code>, <code>&#125;</code>, <code>]</code>），则判断栈顶是否有对应的左括号。如果有，弹出栈顶的左括号；如果没有，则说明括号不匹配，返回 <code>false</code>。</li>
</ul>
<p>最后检查：遍历结束后，如果栈为空，说明所有的括号都成功匹配并闭合，返回 <code>true</code>；否则，返回 <code>false</code>。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span>) &#123;  <span class="comment">// 如果是左括号，压入栈</span></span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 如果是右括号，弹出栈顶并匹配左括号</span></span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> <span class="variable">top</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (top == <span class="string">&#x27;(&#x27;</span> &amp;&amp; c != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (top == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; c != <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (top == <span class="string">&#x27;[&#x27;</span> &amp;&amp; c != <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是字符串 s 的长度。</p>
<p>空间复杂度：O(n+∣Σ∣)，其中 Σ 表示字符集，本题中字符串只包含 6 种括号，∣Σ∣&#x3D;6。栈中的字符数量为 O(n)，而哈希表使用的空间为 O(∣Σ∣)，相加即可得到总空间复杂度。</p>
<h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a>155. 最小栈</h2><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>实现 <code>MinStack</code> 类:</p>
<ul>
<li><code>MinStack()</code> 初始化堆栈对象。</li>
<li><code>void push(int val)</code> 将元素val推入堆栈。</li>
<li><code>void pop()</code> 删除堆栈顶部的元素。</li>
<li><code>int top()</code> 获取堆栈顶部的元素。</li>
<li><code>int getMin()</code> 获取堆栈中的最小元素。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>-231 &lt;= val &lt;= 231 - 1</code></li>
<li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用</li>
<li><code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>最多被调用 <code>3 * 104</code> 次</li>
</ul>
<p><strong>解题思路</strong></p>
<p>主栈：存储栈中的所有元素。</p>
<p>辅助栈：每次 <code>push</code> 一个元素时，如果该元素小于当前最小值（或栈为空），就将它压入辅助栈。否则，将辅助栈当前的最小值再次压入辅助栈。这样，辅助栈的栈顶始终保存当前栈的最小值。</p>
<p><code>getMin</code> 操作：只需要返回辅助栈的栈顶元素，因为它始终保存当前最小值。</p>
<p><code>pop</code> 操作：在弹出主栈的元素时，辅助栈也要弹出对应的元素，保证辅助栈中的最小值与主栈同步。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;  <span class="comment">// 主栈：用于存储所有元素</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack;  <span class="comment">// 辅助栈：用于存储当前最小值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        stack.push(val);</span><br><span class="line">        <span class="keyword">if</span> (minStack.isEmpty() || val &lt; minStack.peek()) &#123;</span><br><span class="line">            minStack.push(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minStack.push(minStack.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(val);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：对于题目中的所有操作，时间复杂度均为 O(1)。因为栈的插入、删除与读取操作都是 O(1)，我们定义的每个操作最多调用栈操作两次。</p>
<p>空间复杂度：O(n)，其中 n 为总操作数。最坏情况下，我们会连续插入 n 个元素，此时两个栈占用的空间为 O(n)。</p>
<h2 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a>394. 字符串解码</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p>
<p>测试用例保证输出的长度不会超过 <code>105</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;3[a]2[bc]&quot;</span><br><span class="line">输出：&quot;aaabcbc&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;3[a2[c]]&quot;</span><br><span class="line">输出：&quot;accaccacc&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;2[abc]3[cd]ef&quot;</span><br><span class="line">输出：&quot;abcabccdcdcdef&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abc3[cd]xyz&quot;</span><br><span class="line">输出：&quot;abccdcdcdxyz&quot;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 30</code></li>
<li><code>s</code> 由小写英文字母、数字和方括号 <code>&#39;[]&#39;</code> 组成</li>
<li><code>s</code> 保证是一个 <strong>有效</strong> 的输入。</li>
<li><code>s</code> 中所有整数的取值范围为 <code>[1, 300]</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>遍历字符串：</p>
<ul>
<li>如果遇到数字（<code>k</code>），那么我们就要记录下来，因为它表示要重复的次数。</li>
<li>如果遇到左括号（<code>[</code>），说明后面开始是需要重复的子字符串，我们将当前已构建的部分（包括数字 <code>k</code>）压入栈。</li>
<li>如果遇到右括号（<code>]</code>），说明一个完整的子字符串已经结束，我们从栈中弹出最近的重复次数和之前的字符串部分，然后将当前字符串按照重复次数进行扩展。</li>
</ul>
<p>关键步骤：</p>
<ul>
<li>使用栈保存数字 <code>k</code> 和已构建的字符串部分。</li>
<li>每次遇到 <code>[</code> 就把当前数字和字符串部分压栈，遇到 <code>]</code> 就弹栈并进行字符串拼接。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decodeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  <span class="comment">// 存储字符串和数字</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">currentString</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;  <span class="comment">// 存储当前处理的字符串</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">currentNum</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 存储重复的次数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(c)) &#123;  <span class="comment">// 如果是数字，积累数字</span></span><br><span class="line">                currentNum = currentNum * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;[&#x27;</span>) &#123;  <span class="comment">// 如果是左括号，将重复次数和字符串入栈</span></span><br><span class="line">                stack.push(Integer.toString(currentNum));</span><br><span class="line">                stack.push(currentString);</span><br><span class="line">                currentNum = <span class="number">0</span>;</span><br><span class="line">                currentString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;]&#x27;</span>) &#123;  <span class="comment">// 如果是右括号，弹出栈中的信息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">preString</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">repeatTimes</span> <span class="operator">=</span> Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(preString);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; repeatTimes; i++) &#123;</span><br><span class="line">                    sb.append(currentString);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                currentString = sb.toString();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 如果是字母，直接添加到当前处理的字符串</span></span><br><span class="line">                currentString += c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> currentString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：记解码后得出的字符串长度为 S，除了遍历一次原字符串 s，我们还需要将解码后的字符串中的每个字符都入栈，并最终拼接进答案中，故渐进时间复杂度为 O(S+∣s∣)，即 O(S)。<br>空间复杂度：记解码后得出的字符串长度为 S，这里用栈维护 TOKEN，栈的总大小最终与 S 相同，故渐进空间复杂度为 O(S)。</p>
<h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h2><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class="line">输出: [1,1,4,2,1,1,0,0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: temperatures = [30,40,50,60]</span><br><span class="line">输出: [1,1,1,0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: temperatures = [30,60,90]</span><br><span class="line">输出: [1,1,0]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= temperatures.length &lt;= 105</code></li>
<li><code>30 &lt;= temperatures[i] &lt;= 100</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>我们遍历温度数组，对于每一天的温度：</p>
<ul>
<li>如果当前温度大于栈顶存储的温度（栈顶的温度对应的是较早的天数），则说明当前天的温度是一个更高的温度，栈顶的天数就找到了一个更高温度的天数。</li>
<li>这时我们可以更新答案数组，并将栈顶元素弹出。</li>
</ul>
<p>将当前温度的索引压入栈中，等待后续的更高温度来更新答案。</p>
<p>最终，当栈为空时，意味着没有更多更高温度，因此答案数组中相应位置的值是 <code>0</code>。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[temperatures.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; temperatures.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                result[preIndex] = i - preIndex;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是温度列表的长度。正向遍历温度列表一遍，对于温度列表中的每个下标，最多有一次进栈和出栈的操作。</p>
<p>空间复杂度：O(n)，其中 n 是温度列表的长度。需要维护一个单调栈存储温度列表中的下标。</p>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a>215. 数组中的第K个最大元素</h2><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>
<p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4], k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6], k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= nums.length &lt;= 105</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
</ul>
<p><strong>方法一：基于堆排序的选择方法</strong></p>
<p><strong>解题思路</strong></p>
<p>遍历数组，把元素依次放入一个最小堆（PriorityQueue）。</p>
<p>如果堆的大小超过 k，就把堆顶（最小值）弹出。</p>
<p>遍历完成后，堆顶就是第 k 大的元素。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">heapSize</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 从最后一个非叶子节点开始往前调整堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> heapSize / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxHeapify(nums, heapSize, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依次将堆顶元素（最大值）交换到数组末尾</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= nums.length - k + <span class="number">1</span>; i--) &#123;</span><br><span class="line">            swap(nums, i, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 缩小堆的范围，重新调整堆</span></span><br><span class="line">            heapSize--;</span><br><span class="line">            maxHeapify(nums, heapSize, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">maxHeapify</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> heapSize, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; nums[left] &gt; nums[largest]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; nums[right] &gt; nums[largest]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(nums, largest, i);</span><br><span class="line">            maxHeapify(nums, heapSize, largest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n log n)，建堆的时间代价是 O(n)，删除的总代价是 O(k log n)，因为 k&lt;n，故渐进时间复杂为 O(n+k log n)&#x3D;O(n log n)。<br>空间复杂度：O(log n)，即递归使用栈空间的空间代价。</p>
<p><strong>方法二：基于快速排序的选择方法</strong></p>
<p><strong>解题思路</strong></p>
<p>快速选择算法是快速排序（Quicksort）的变种：</p>
<ul>
<li>快速排序是递归地对左右子数组排序；</li>
<li>快速选择只需要递归到包含第 k 大元素的那一半数组即可。</li>
</ul>
<p>我们先选一个 <code>pivot</code>（基准值），把数组划分成两部分：</p>
<ul>
<li>左边：比 <code>pivot</code> 小的数；</li>
<li>右边：比 <code>pivot</code> 大的数。</li>
</ul>
<p>根据 <strong>pivot 的位置</strong> 与目标位置 <code>n - k</code>（第 k 大对应的索引）进行比较：</p>
<ul>
<li>如果 <code>pivotIndex == n - k</code>，直接返回结果；</li>
<li>如果 <code>pivotIndex &lt; n - k</code>，递归右边；</li>
<li>如果 <code>pivotIndex &gt; n - k</code>，递归左边。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, nums.length - k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">quickSelect</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> targetIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[targetIndex];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">while</span> (nums[i] &lt;   pivot);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">while</span> (nums[j] &gt; pivot);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (targetIndex &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">return</span> quickSelect(nums, left, j, targetIndex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> quickSelect(nums, j + <span class="number">1</span>, right, targetIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>平均时间复杂度：O(n)</p>
<p>最坏时间复杂度：O(n^2)（当每次划分极端不平衡时）</p>
<p>空间复杂度：O(log n)（递归栈）</p>
<h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a>347. 前 K 个高频元素</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<p>**输入：**nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</p>
<p><strong>输出：</strong>[1,2]</p>
<p><strong>示例 2：</strong></p>
<p>**输入：**nums &#x3D; [1], k &#x3D; 1</p>
<p><strong>输出：</strong>[1]</p>
<p><strong>示例 3：</strong></p>
<p>**输入：**nums &#x3D; [1,2,1,2,1,2,3,1,3,2], k &#x3D; 2</p>
<p><strong>输出：</strong>[1,2]</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li>
<li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li>
</ul>
<p>**进阶：**你所设计算法的时间复杂度 <strong>必须</strong> 优于 <code>O(n log n)</code> ，其中 <code>n</code> 是数组大小。</p>
<p><strong>解题思路</strong></p>
<p>统计频率<br> 用 <code>HashMap&lt;Integer, Integer&gt;</code> 统计每个元素出现的次数。</p>
<p>小顶堆存 K 个最高频率元素</p>
<ul>
<li>使用 <strong>优先队列 PriorityQueue</strong>（小顶堆），按频率从小到大排序。</li>
<li>遍历 <code>map</code>，把元素放入堆中：<ul>
<li>如果堆大小超过 <code>k</code>，就弹出堆顶（频率最小的）。</li>
</ul>
</li>
<li>最终堆里保留的就是前 <code>k</code> 高频元素。</li>
</ul>
<p>取结果<br> 堆中存的就是答案，转换成数组返回即可。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 统计频率</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; occurrences = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            occurrences.put(num, occurrences.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用小顶堆，按频率升序</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">            (a, b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : occurrences.entrySet()) &#123;</span><br><span class="line">            heap.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(), entry.getValue()&#125;);</span><br><span class="line">            <span class="comment">// 保证堆里最多只有 k 个元素</span></span><br><span class="line">            <span class="keyword">if</span> (heap.size() &gt; k) &#123;</span><br><span class="line">                heap.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取结果</span></span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            result[i] = heap.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n log k)，其中 n 为数组的长度。我们首先遍历原数组，并使用哈希表记录出现次数，每个元素需要 O(1) 的时间，共需 O(n) 的时间。随后，我们遍历「出现次数数组」，由于堆的大小至多为 k，因此每次堆操作需要 O(log k) 的时间，共需 O(n log k) 的时间。二者之和为 O(n log k)。<br>空间复杂度：O(n)。哈希表的大小为 O(n)，而堆的大小为 O(k)，共计为 O(n)。</p>
<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h2><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 105</code></li>
<li><code>0 &lt;= prices[i] &lt;= 104</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>我们只需要找到：</p>
<ul>
<li><strong>最便宜的一天买入</strong>（<code>minPrice</code>）</li>
<li><strong>之后某天卖出价格与它的差值最大</strong></li>
</ul>
<p>遍历 <code>prices</code> 数组时：</p>
<ol>
<li>更新最小买入价 <code>minPrice</code></li>
<li>计算当前天卖出的利润 <code>prices[i] - minPrice</code></li>
<li>更新最大利润 <code>maxProfit</code></li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minPrice</span> <span class="operator">=</span> Integer.MAX_VALUE;   <span class="comment">// 初始化最小买入价</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxProfit</span> <span class="operator">=</span> <span class="number">0</span>;                  <span class="comment">// 初始化最大利润</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price : prices) &#123;</span><br><span class="line">            <span class="keyword">if</span> (price &lt; minPrice) &#123;  <span class="comment">// 更新最小买入价</span></span><br><span class="line">                minPrice = price;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (price - minPrice &gt; maxProfit) &#123;  <span class="comment">// 更新最大利润</span></span><br><span class="line">                maxProfit = price - minPrice;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，只需要遍历一次。</li>
<li>空间复杂度：O(1)，只使用了常数个变量。</li>
</ul>
<h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h2><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>0 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>我们维护一个变量 <code>maxReach</code> 表示 <strong>能到达的最远下标</strong>：</p>
<ol>
<li>从头开始遍历数组。</li>
<li>如果当前位置 <code>i</code> 在 <code>maxReach</code> 之外，说明走不到这里 → 返回 <code>false</code>。</li>
<li>否则，更新 <code>maxReach = max(maxReach, i + nums[i])</code>。</li>
<li>遍历过程中如果 <code>maxReach &gt;= nums.length - 1</code>，说明能到达最后一个位置 → 返回 <code>true</code>。</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxRearch</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前位置不可到达，提前返回</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; maxRearch) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新能到达的最远位置</span></span><br><span class="line">            maxRearch = Math.max(maxRearch, i + nums[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果可以到达最后，提前返回</span></span><br><span class="line">            <span class="keyword">if</span> (maxRearch &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 为数组的大小。只需要访问 <code>nums</code> 数组一遍，共 n 个位置。</li>
<li>空间复杂度：O(1)，不需要额外的空间开销。</li>
</ul>
<h2 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a>45. 跳跃游戏 II</h2><p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置在下标 0。</p>
<p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向后跳转的最大长度。换句话说，如果你在索引 <code>i</code> 处，你可以跳转到任意 <code>(i + j)</code> 处：</p>
<ul>
<li><code>0 &lt;= j &lt;= nums[i]</code> 且</li>
<li><code>i + j &lt; n</code></li>
</ul>
<p>返回到达 <code>n - 1</code> 的最小跳跃次数。测试用例保证可以到达 <code>n - 1</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [2,3,0,1,4]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
<li>题目保证可以到达 <code>n - 1</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>我们要找的是<strong>最少跳跃次数</strong>。</p>
<ul>
<li>走到某个位置时，我们关心的是<strong>从当前位置最远能到哪里</strong>。</li>
<li>当我们走完一个“跳跃范围”后，必须进行一次跳跃。</li>
<li>所以我们用两个变量：<ul>
<li><code>end</code>：当前这一步能到的最远范围的边界。</li>
<li><code>farthest</code>：在当前范围内能到的最远位置。</li>
</ul>
</li>
<li>每次遍历到 <code>end</code> 时，说明这一步的范围走完了，就需要进行一次跳跃，然后把 <code>end</code> 更新为 <code>farthest</code>。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">steps</span> <span class="operator">=</span> <span class="number">0</span>;      <span class="comment">// 跳跃次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="comment">// 当前范围的最远位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">farthest</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">// 在当前范围内能到达的最远位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            farthest = Math.max(farthest, i + nums[i]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;  <span class="comment">// 到达当前范围的最远位置，必须跳跃一次</span></span><br><span class="line">                steps++;</span><br><span class="line">                end = farthest;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> steps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 是数组长度。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a>763. 划分字母区间</h2><p>给你一个字符串 <code>s</code> 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 <code>&quot;ababcc&quot;</code> 能够被分为 <code>[&quot;abab&quot;, &quot;cc&quot;]</code>，但类似 <code>[&quot;aba&quot;, &quot;bcc&quot;]</code> 或 <code>[&quot;ab&quot;, &quot;ab&quot;, &quot;cc&quot;]</code> 的划分是非法的。</p>
<p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 <code>s</code> 。</p>
<p>返回一个表示每个字符串片段的长度的列表。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">输出：[9,7,8]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 &quot;ababcbaca&quot;、&quot;defegde&quot;、&quot;hijhklij&quot; 。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 这样的划分是错误的，因为划分的片段数较少。 </span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;eccbbbbdec&quot;</span><br><span class="line">输出：[10]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 500</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<p><strong>解题思路</strong></p>
<p>我们要把字符串划分成尽可能多的片段，并保证每个字母只出现在一个片段中。</p>
<p><strong>关键点</strong>：</p>
<ul>
<li>对于某个片段来说，如果片段中包含某个字母，就必须把这个字母最后一次出现的位置也包括进来。</li>
<li>因此我们可以先扫描一遍字符串，记录每个字母的<strong>最后出现位置</strong>。</li>
<li>然后从头遍历字符串，用一个变量 <code>end</code> 表示当前片段能到的最远位置。<ul>
<li>遍历时不断更新 <code>end = max(end, last[s[i]])</code>。</li>
<li>当 <code>i == end</code> 时，说明一个片段结束，可以记录下来。</li>
</ul>
</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[] last = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录每个字母最后出现的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            last[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分割区间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            end = Math.max(end, last[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                result.add(end - start + <span class="number">1</span>);</span><br><span class="line">                start = end + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是字符串的长度。需要遍历字符串两次，第一次遍历时记录每个字母最后一次出现的下标位置，第二次遍历时进行字符串的划分。</p>
<p>空间复杂度：O(∣Σ∣)，其中 Σ 是字符串中的字符集。这道题中，字符串只包含小写字母，因此 ∣Σ∣&#x3D;26。</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶</span><br><span class="line">2. 2 阶</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶 + 1 阶</span><br><span class="line">2. 1 阶 + 2 阶</span><br><span class="line">3. 2 阶 + 1 阶</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 45</code></li>
</ul>
<p><strong>解题思路</strong></p>
<ul>
<li><p>如果要爬到第 <code>n</code> 阶，可以从：</p>
<ol>
<li><code>n-1</code> 阶走 <strong>1 步</strong>；</li>
<li><code>n-2</code> 阶走 <strong>2 步</strong>。</li>
</ol>
</li>
<li><p>因此有递推关系式：</p>
<p>f(n) &#x3D; f(n − 1) + f(n − 2)</p>
</li>
<li><p>初始条件：</p>
<ul>
<li><code>f(1) = 1</code> （只有一种方式，1 阶）</li>
<li><code>f(2) = 2</code> （两种方式：1+1 或 2）</li>
</ul>
</li>
</ul>
<p>这其实就是 <strong>斐波那契数列</strong>，第 <code>n</code> 项即为答案。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> b + a;  <span class="comment">// f(i) = f(i - 1) + f(i - 2)</span></span><br><span class="line">            a = b;          <span class="comment">// f(i - 2 + 1) -&gt; f(i - 1)</span></span><br><span class="line">            b = c;          <span class="comment">// f(i - 1 + 1) -&gt; f(i - 1) + f(i - 2)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> b;           <span class="comment">// f(n - 1) + f(n - 2)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：循环执行 n 次，每次花费常数的时间代价，故渐进时间复杂度为 O(n)。<br>空间复杂度：这里只用了常数个变量作为辅助空间，故渐进空间复杂度为 O(1)。</p>
<h2 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a>118. 杨辉三角</h2><p>给定一个非负整数 *<code>numRows</code>，*生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p>
<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<p><img src="https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="img"></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: numRows = 5</span><br><span class="line">输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: numRows = 1</span><br><span class="line">输出: [[1]]</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= numRows &lt;= 30</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>杨辉三角的性质：</p>
<ol>
<li><p>每一行的首尾元素都是 <code>1</code>。</p>
</li>
<li><p>其他元素满足：row[j] &#x3D; prev[j − 1] + prev[j]</p>
<p>其中 <code>prev</code> 是上一行。</p>
</li>
</ol>
<p>因此我们可以逐行生成。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">generate</span><span class="params">(<span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 第 i 行有 i + 1 个元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span> || j == i) &#123;</span><br><span class="line">                    row.add(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// row[j] = prev[j - 1] + prev[j]</span></span><br><span class="line">                    row.add(result.get(i - <span class="number">1</span>).get(j - <span class="number">1</span>) + result.get(i - <span class="number">1</span>).get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(numRows^2)，因为总共有 1 + 2 + … + numRows ≈ O(numRows^2) 个元素。</p>
<p>空间复杂度：O(numRows^2)，存储整个三角。</p>
<h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. 打家劫舍</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 400</code></li>
</ul>
<p><strong>解题思路</strong></p>
<ul>
<li>如果我们在第 <code>i</code> 个房子：<ul>
<li>偷它：就不能偷 <code>i-1</code>，所以收益是 <code>dp[i-2] + nums[i]</code></li>
<li>不偷它：那收益是 <code>dp[i-1]</code></li>
</ul>
</li>
<li>状态转移公式：dp[i] &#x3D; max(dp[i], dp[i - 2] + nums[i])</li>
<li><strong>初始条件</strong>：<ul>
<li><code>dp[0] = nums[0]</code></li>
<li><code>dp[1] = max(nums[0], nums[1])</code></li>
</ul>
</li>
<li>最终答案：<code>dp[n-1]</code></li>
</ul>
<p>优化：由于 <code>dp[i]</code> 只依赖 <code>dp[i-1]</code> 和 <code>dp[i-2]</code>，我们可以用两个变量滚动更新，空间降到 <code>O(1)</code>。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 转移方程：dp[i] = max(dp[i], dp[i - 2] + nums[i])</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">prev2</span> <span class="operator">=</span> nums[<span class="number">0</span>];  <span class="comment">// dp[i - 2]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">prev1</span> <span class="operator">=</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);  <span class="comment">// dp[i - 1]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> Math.max(prev1, prev2 + nums[i]);</span><br><span class="line">            prev2 = prev1;</span><br><span class="line">            prev1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是数组长度。只需要对数组遍历一次。</p>
<p>空间复杂度：O(1)。使用滚动数组，可以只存储前两间房屋的最高总金额，而不需要存储整个数组的结果，因此空间复杂度是 O(1)。</p>
<h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a>279. 完全平方数</h2><p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p>
<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 = 4 + 4 + 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 13</span><br><span class="line">输出：2</span><br><span class="line">解释：13 = 4 + 9</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 104</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>我们把 <code>n</code> 看作一个「背包容量」，完全平方数看作「物品」，每个物品可以无限使用，求最少物品数量。</p>
<ul>
<li>定义 <code>dp[i]</code>：表示和为 <code>i</code> 的最少完全平方数数量。</li>
<li>转移方程：dp[i] &#x3D; dp[i - j * j] + 1 (j * j &lt;&#x3D; i)</li>
<li>初始化：<ul>
<li><code>dp[0] = 0</code>（和为 0 不需要数字）</li>
<li>其他初始化为一个较大值</li>
</ul>
</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 转移方程：dp[i] = dp[i - j * j] + 1 (j * j &lt;= i)</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - j * j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n * sqrt(n))，其中 n 为给定的正整数。状态转移方程的时间复杂度为 O(sqrt(n))，共需要计算 n 个状态，因此总时间复杂度为 O(n * sqrt(n))。</p>
<p>空间复杂度：O(n)。我们需要 O(n) 的空间保存状态。</p>
<h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a>322. 零钱兑换</h2><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：coins = [2], amount = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：coins = [1], amount = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= coins.length &lt;= 12</code></li>
<li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li>
<li><code>0 &lt;= amount &lt;= 104</code></li>
</ul>
<p><strong>解题思路</strong></p>
<ul>
<li><p>定义 <code>dp[i]</code> 表示字符串 <code>s[0..i-1]</code> 是否可以由字典中的单词拼接而成。</p>
</li>
<li><p>初始条件：<code>dp[0] = true</code>（空字符串可被拆分）。</p>
</li>
<li><p>状态转移：<br> 对于每个位置 <code>i</code>，遍历所有 <code>j &lt; i</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果 dp[j] == true 且 s[j..i-1] 在字典中出现，则 dp[i] = true</span><br></pre></td></tr></table></figure>
</li>
<li><p>最终答案：<code>dp[n]</code>，其中 <code>n = s.length()</code>。</p>
</li>
</ul>
<p>为了加速判断子串是否在字典中，我们可以用 <strong>HashSet</strong> 存储 <code>wordDict</code>。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="comment">// 转移方程：dp[i] = min(dp[i], dp[i - coin] + 1)</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, amount + <span class="number">1</span>);  <span class="comment">// 最大不会超过 amount 个（全部使用 1 元）</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= coin) &#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount] != amount + <span class="number">1</span> ? dp[amount] : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(Sn)，其中 S 是金额，n 是面额数。我们一共需要计算 O(S) 个状态，S 为题目所给的总金额。对于每个状态，每次需要枚举 n 个面额来转移状态，所以一共需要 O(Sn) 的时间复杂度。<br>空间复杂度：O(S)。数组 dp 需要开长度为总金额 S 的空间。</p>
<h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a>139. 单词拆分</h2><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code> 则返回 <code>true</code>。</p>
<p>**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以由 &quot;apple&quot; &quot;pen&quot; &quot;apple&quot; 拼接成。</span><br><span class="line">     注意，你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 300</code></li>
<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>
<li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li>
<li><code>s</code> 和 <code>wordDict[i]</code> 仅由小写英文字母组成</li>
<li><code>wordDict</code> 中的所有字符串 <strong>互不相同</strong></li>
</ul>
<p><strong>解题思路</strong></p>
<ul>
<li><p>定义 <code>dp[i]</code> 表示字符串 <code>s[0..i-1]</code> 是否可以由字典中的单词拼接而成。</p>
</li>
<li><p>初始条件：<code>dp[0] = true</code>（空字符串可被拆分）。</p>
</li>
<li><p>状态转移：<br> 对于每个位置 <code>i</code>，遍历所有 <code>j &lt; i</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果 dp[j] == true 且 s[j..i-1] 在字典中出现，则 dp[i] = true</span><br></pre></td></tr></table></figure>
</li>
<li><p>最终答案：<code>dp[n]</code>，其中 <code>n = s.length()</code>。</p>
</li>
</ul>
<p>为了加速判断子串是否在字典中，我们可以用 <strong>HashSet</strong> 存储 <code>wordDict</code>。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        <span class="comment">// 转移方程：dp[i] = dp[j] &amp;&amp; s[j...i-1]，dp[i] 表示 s[0...i-1] 是否能由字典拼接</span></span><br><span class="line">        <span class="comment">// 把 wordDict 存在 HashSet中，加速查找</span></span><br><span class="line">        Set&lt;String&gt; wordSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordDict);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;  <span class="comment">// 初始条件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; wordSet.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;  <span class="comment">// 找到一个即可终止</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n^2) ，其中 n 为字符串 s 的长度。我们一共有 O(n) 个状态需要计算，每次计算需要枚举 O(n) 个分割点，哈希表判断一个字符串是否出现在给定的字符串列表需要 O(1) 的时间，因此总时间复杂度为 O(n^2)。</p>
<p>空间复杂度：O(n) ，其中 n 为字符串 s 的长度。我们需要 O(n) 的空间存放 dp 值以及哈希表亦需要 O(n) 的空间复杂度，因此总空间复杂度为 O(n)。</p>
<h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a>300. 最长递增子序列</h2><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2500</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</li>
</ul>
<p><strong>方法一：动态规划</strong></p>
<p><strong>解题思路</strong></p>
<p>定义 <code>dp[i]</code>：表示 <strong>以 <code>nums[i]</code> 结尾的最长递增子序列长度</strong>。</p>
<p>转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i] = max(dp[j] + 1)  for all j &lt; i and nums[j] &lt; nums[i]</span><br></pre></td></tr></table></figure>

<p>初始化：<code>dp[i] = 1</code>（每个数都能单独成为长度为 1 的子序列）。</p>
<p>答案就是 <code>max(dp[i])</code>。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 方法一：动态规划，时间复杂度 O(n^2)，空间复杂度 O(n)</span></span><br><span class="line">        <span class="comment">// 转移方程：dp[i] = max(dp[i], dp[j] + 1) for all j &lt; i and nums[j] &lt; nums[i]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[ny];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLength = Math.max(maxLength, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n^2)，其中 n 为数组 nums 的长度。动态规划的状态数为 n，计算状态 dp[i] 时，需要 O(n) 的时间遍历 dp[0…i−1] 的所有状态，所以总时间复杂度为 O(n^2)。</p>
<p>空间复杂度：O(n)，需要额外使用长度为 n 的 dp 数组。</p>
<p><strong>方法二：贪心 + 二分查找</strong></p>
<p><strong>解题思路</strong></p>
<p>考虑一个简单的贪心，如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。</p>
<p>基于上面的贪心思路，我们维护一个数组 d[i] ，表示长度为 i 的最长上升子序列的末尾元素的最小值，用 len 记录目前最长上升子序列的长度，起始时 len 为 1，d[1]&#x3D;nums[0]。</p>
<p>我们依次遍历数组 nums 中的每个元素，并更新数组 d 和 len 的值。如果 nums[i]&gt;d[len] 则更新 len&#x3D;len+1，否则在 d[1…len]中找满足 d[i−1]&lt;nums[j]&lt;d[i] 的下标 i，并更新 d[i]&#x3D;nums[j]。</p>
<p>根据 d 数组的单调性，我们可以使用二分查找寻找下标 i，优化时间复杂度。</p>
<p>最后整个算法流程为：</p>
<p>设当前已求出的最长上升子序列的长度为 len（初始时为 1），从前往后遍历数组 nums，在遍历到 nums[i] 时：</p>
<p>如果 nums[i]&gt;d[len] ，则直接加入到 d 数组末尾，并更新 len&#x3D;len+1；</p>
<p>否则，在 d 数组中二分查找，找到第一个比 nums[i] 小的数 d[k] ，并更新 d[k+1]&#x3D;nums[i]。</p>
<p>以输入序列 [0,8,4,12,2] 为例：</p>
<p>第一步插入 0，d&#x3D;[0]；</p>
<p>第二步插入 8，d&#x3D;[0,8]；</p>
<p>第三步插入 4，d&#x3D;[0,4]；</p>
<p>第四步插入 12，d&#x3D;[0,4,12]；</p>
<p>第五步插入 2，d&#x3D;[0,2,12]。</p>
<p>最终得到最大递增子序列长度为 3。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 方法二：贪心 + 二分，时间复杂度 O(n log n)，空间复杂度 O(n)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 初始时为 1</span></span><br><span class="line">        <span class="type">int</span>[] d = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        d[len] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; d[len]) &#123;  <span class="comment">// 如果 nums[i] &gt; d[len] ，则直接加入到 d 数组末尾，并更新 len = len+1</span></span><br><span class="line">                d[++len] = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 否则，在 d 数组中二分查找，找到第一个比 nums[i] 小的数 d[k] ，并更新 d[k + 1] = nums[i]</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> len;</span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 k 设为 0</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (d[mid] &lt; nums[i]) &#123;</span><br><span class="line">                        k = mid;</span><br><span class="line">                        left = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        right = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                d[k + <span class="number">1</span>] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n log n)。数组 nums 的长度为 n，我们依次用数组中的元素去更新 d 数组，而更新 d 数组时需要进行 O(log n) 的二分搜索，所以总时间复杂度为 O(n log n)。</p>
<p>空间复杂度：O(n)，需要额外使用长度为 n 的 d 数组。</p>
<h2 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a>152. 乘积最大子数组</h2><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续 子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>测试用例的答案是一个 <strong>32-位</strong> 整数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-2,0,-1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li><code>nums</code> 的任何子数组的乘积都 <strong>保证</strong> 是一个 <strong>32-位</strong> 整数</li>
</ul>
<p><strong>解题思路</strong></p>
<p>定义两个数组（或变量即可优化空间）：</p>
<ul>
<li><code>maxF[i]</code>：以 <code>i</code> 结尾的子数组的最大乘积</li>
<li><code>minF[i]</code>：以 <code>i</code> 结尾的子数组的最小乘积</li>
</ul>
<p>状态转移：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maxF[i] = max(nums[i], maxF[i-1] * nums[i], minF[i-1] * nums[i]);</span><br><span class="line">minF[i] = min(nums[i], maxF[i-1] * nums[i], minF[i-1] * nums[i]);</span><br></pre></td></tr></table></figure>

<p>因为 <code>nums[i]</code> 可能为负数，乘上 <code>minF[i-1]</code> 有可能变大。</p>
<p>答案就是所有 <code>maxF[i]</code> 中的最大值。</p>
<p>空间优化：我们只需要前一状态，所以用两个变量 <code>maxVal</code> 和 <code>minVal</code> 即可。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// maxF[i] = max(nums[i], maxF[i-1] * nums[i], minF[i-1] * nums[i]);</span></span><br><span class="line">        <span class="comment">// minF[i] = min(nums[i], maxF[i-1] * nums[i], minF[i-1] * nums[i]);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span>) &#123;  <span class="comment">// 如果当前数是负数，交换 maxValue 和 minValue</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> maxValue;</span><br><span class="line">                maxValue = minValue;</span><br><span class="line">                minValue = temp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            maxValue = Math.max(nums[i], maxValue * nums[i]);</span><br><span class="line">            minValue = Math.min(nums[i], minValue * nums[i]);</span><br><span class="line">            result = Math.max(result, maxValue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：程序一次循环遍历了 nums，故渐进时间复杂度为 O(n)。</p>
<p>空间复杂度：优化后只使用常数个临时变量作为辅助空间，与 n 无关，故渐进空间复杂度为 O(1)。</p>
<h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a>416. 分割等和子集</h2><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,5,11,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：数组可以分割成 [1, 5, 5] 和 [11] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,5]</span><br><span class="line">输出：false</span><br><span class="line">解释：数组不能分割成两个元素和相等的子集。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 200</code></li>
<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>总和判断</p>
<ul>
<li>先算数组总和 <code>sum</code>。</li>
<li>如果 <code>sum</code> 是奇数，直接返回 <code>false</code>（不可能拆成相等的两份）。</li>
<li>目标就是找到一个子集，和为 <code>target = sum / 2</code>。</li>
</ul>
<p>转化为 0-1 背包问题</p>
<ul>
<li>问题就变成：是否可以从 <code>nums</code> 中选一些数，使得和恰好等于 <code>target</code>。</li>
<li>定义 <code>dp[j]</code>：表示是否可以恰好装满容量为 <code>j</code> 的背包。</li>
</ul>
<p>状态转移<br> 遍历每个 <code>num</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[j] = dp[j] || dp[j - num]   (前提 j &gt;= num)</span><br></pre></td></tr></table></figure>

<p>注意要 <strong>逆序遍历 j</strong>，防止同一个 <code>num</code> 被重复使用。</p>
<p><strong>初始化</strong></p>
<ul>
<li><code>dp[0] = true</code>（不选任何数时，和为 0 是可行的）。</li>
</ul>
<p>答案</p>
<ul>
<li>返回 <code>dp[target]</code>。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 转移方程：dp[i] = dp[i] || dp[i - num] (i &gt;= num)</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum /= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[sum + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sum; i &gt;= num; i--) &#123;</span><br><span class="line">                dp[i] = dp[i] || dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n×target)，其中 n 是数组的长度，target 是整个数组的元素和的一半。需要计算出所有的状态，每个状态在进行转移时的时间复杂度为 O(1)。</p>
<p>空间复杂度：O(target)，其中 target 是整个数组的元素和的一半。空间复杂度取决于 dp 数组，在不进行空间优化的情况下，空间复杂度是 O(n×target)，在进行空间优化的情况下，空间复杂度可以降到 O(target)。</p>
<h1 id="多维动态规划"><a href="#多维动态规划" class="headerlink" title="多维动态规划"></a>多维动态规划</h1><h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a>62. 不同路径</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://pic.leetcode.cn/1697422740-adxmsI-image.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 7</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向下</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 7, n = 3</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li>题目数据保证答案小于等于 <code>2 * 109</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>状态定义</p>
<ul>
<li><code>dp[i][j]</code> 表示从起点 <code>(0,0)</code> 到达 <code>(i,j)</code> 的路径数。</li>
</ul>
<p>状态转移方程</p>
<ul>
<li><p>机器人只能从 <strong>上方</strong> <code>(i-1,j)</code> 或 <strong>左边</strong> <code>(i,j-1)</code> 过来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j] + dp[i][j-1]</span><br></pre></td></tr></table></figure></li>
</ul>
<p>初始化</p>
<ul>
<li>第一行只能一直往右走，所以 <code>dp[0][j] = 1</code>。</li>
<li>第一列只能一直往下走，所以 <code>dp[i][0] = 1</code>。</li>
</ul>
<p>答案</p>
<ul>
<li>最终答案是 <code>dp[m-1][n-1]</code>。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 转移方程：dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(mn)。</p>
<p>空间复杂度：O(min(m,n))，即为存储所有状态需要的空间。注意到 f(i,j) 仅与第 i 行和第 i−1 行的状态有关，因此我们可以使用滚动数组代替代码中的二维数组，使空间复杂度降低为 O(n)。此外，由于我们交换行列的值并不会对答案产生影响，因此我们总可以通过交换 m 和 n 使得 m≤n，这样空间复杂度降低至 O(min(m,n))。</p>
<h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a>64. 最小路径和</h2><p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>**说明：**每次只能向下或者向右移动一步。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">输出：7</span><br><span class="line">解释：因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,2,3],[4,5,6]]</span><br><span class="line">输出：12</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 200</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 200</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>当 i&gt;0 且 j&#x3D;0 时，dp[i][0]&#x3D;dp[i−1][0]+grid[i][0]。</p>
<p>当 i&#x3D;0 且 j&gt;0 时，dp[0][j]&#x3D;dp[0][j−1]+grid[0][j]。</p>
<p>当 i&gt;0 且 j&gt;0 时，dp[i][j]&#x3D;min(dp[i−1][j],dp[i][j−1])+grid[i][j]</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="comment">// 转移方程：dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(mn)，其中 m 和 n 分别是网格的行数和列数。需要对整个网格遍历一次，计算 dp 的每个元素的值。</p>
<p>空间复杂度：O(mn)，其中 m 和 n 分别是网格的行数和列数。创建一个二维数组 dp，和网格大小相同。<br>空间复杂度可以优化，例如每次只存储上一行的 dp 值，则可以将空间复杂度优化到 O(n)。</p>
<h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的 回文 子串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 仅由数字和英文字母组成</li>
</ul>
<p><strong>解题思路</strong></p>
<p>回文串有两种情况：</p>
<ol>
<li>奇数长度回文：中心是一个字符</li>
<li>偶数长度回文：中心是两个字符</li>
</ol>
<p>从每个位置向两边扩展，找到以该点（或该点和下一个点）为中心的最长回文子串。</p>
<p>记录最长的区间。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 转移方程：dp[i][j] = dp[i + 1][j - 1] if (s.charAt(i) == s.charAt(j))</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];  <span class="comment">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class="line">        <span class="comment">// 每个单字符都是回文串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 最长子串头部位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 最长子串的长度</span></span><br><span class="line">        <span class="comment">// 枚举每个子串长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + len - <span class="number">1</span>;  <span class="comment">// 子串右端点</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (j &gt;= n) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (len &lt;= <span class="number">3</span>) &#123;  <span class="comment">// 2 个或 3 个字符，直接就是回文子串</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新最大长度</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; len &gt; maxLen) &#123;</span><br><span class="line">                    maxLen = len;</span><br><span class="line">                    start = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n^2)，其中 n 是字符串的长度。动态规划的状态总数为 O(n^2)，对于每个状态，我们需要转移的时间为 O(1)。</p>
<p>空间复杂度：O(n^2)，即存储动态规划状态需要的空间。</p>
<h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a>1143. 最长公共子序列</h2><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p>
<p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li>
</ul>
<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li>
<li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li>
</ul>
<p><strong>解题思路</strong></p>
<p>定义状态：<br> <code>dp[i][j]</code> 表示 <code>text1[0..i-1]</code> 与 <code>text2[0..j-1]</code> 的最长公共子序列的长度。</p>
<p>状态转移：</p>
<ul>
<li>如果 <code>text1[i-1] == text2[j-1]</code>，则：<code>dp[i][j] = dp[i-1][j-1] + 1</code></li>
<li>否则：<code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code></li>
</ul>
<p>初始化：<br> <code>dp[0][*] = 0</code>, <code>dp[*][0] = 0</code>，即空字符串和任何字符串的 LCS 长度是 0。</p>
<p>答案：<br> <code>dp[m][n]</code>，其中 <code>m = text1.length</code>, <code>n = text2.length</code>。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="comment">// 转移方程：dp[i][j] = dp[i - 1][j - 1] + 1</span></span><br><span class="line">        <span class="comment">// dp[i][j] 表示 text1[0..i-1] 与 text2[0..j-1] 的最长公共子序列的长度</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> text1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> text2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(mn)，其中 m 和 n 分别是字符串 text1 和 text2 的长度。二维数组 dp 有 m+1 行和 n+1 列，需要对 dp 中的每个元素进行计算。</p>
<p>空间复杂度：O(mn)，其中 m 和 n 分别是字符串 text1 和 text2 的长度。创建了 m+1 行 n+1 列的二维数组 dp。</p>
<h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a>72. 编辑距离</h2><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)</span><br><span class="line">rorse -&gt; rose (删除 &#x27;r&#x27;)</span><br><span class="line">rose -&gt; ros (删除 &#x27;e&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 &#x27;t&#x27;)</span><br><span class="line">inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)</span><br><span class="line">enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)</span><br><span class="line">exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)</span><br><span class="line">exection -&gt; execution (插入 &#x27;u&#x27;)</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li>
<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>
</ul>
<p><strong>解题思路</strong></p>
<ul>
<li>定义 <code>dp[i][j]</code> 表示 <strong>将 <code>word1[0..i-1]</code> 转换为 <code>word2[0..j-1]</code> 的最少操作数</strong>。</li>
<li>递推公式：<ol>
<li><strong>如果最后一个字符相同</strong>：<br> <code>dp[i][j] = dp[i-1][j-1]</code></li>
<li><strong>如果最后一个字符不同</strong>，有三种选择，取三者最小值：<ul>
<li>插入：<code>dp[i][j-1] + 1</code></li>
<li>删除：<code>dp[i-1][j] + 1</code></li>
<li>替换：<code>dp[i-1][j-1] + 1</code></li>
</ul>
</li>
</ol>
</li>
<li>边界条件：<ul>
<li><code>dp[0][j] = j</code> （空字符串变成 word2[0..j-1] 需要插入 j 次）</li>
<li><code>dp[i][0] = i</code> （word1[0..i-1] 变成空字符串需要删除 i 次）</li>
</ul>
</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="comment">// 最后一个字符相同：dp[i][j] = dp[i - 1][j - 1]</span></span><br><span class="line">        <span class="comment">// 最后一个字符不同：</span></span><br><span class="line">        <span class="comment">// 插入：dp[i][j - 1] + 1</span></span><br><span class="line">        <span class="comment">// 删除：dp[i - 1][j] + 1</span></span><br><span class="line">        <span class="comment">// 替换: dp[i - 1][j - 1]</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> word1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> word2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i -<span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度 ：O(mn)，其中 m 为 word1 的长度，n 为 word2 的长度。</p>
<p>空间复杂度 ：O(mn)，我们需要大小为 O(mn) 的 D 数组来记录状态值。</p>
<h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a>136. 只出现一次的数字</h2><p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p>
<p><strong>示例 1 ：</strong></p>
<p>**输入：**nums &#x3D; [2,2,1]</p>
<p>**输出：**1</p>
<p><strong>示例 2 ：</strong></p>
<p>**输入：**nums &#x3D; [4,1,2,1,2]</p>
<p>**输出：**4</p>
<p><strong>示例 3 ：</strong></p>
<p>**输入：**nums &#x3D; [1]</p>
<p>**输出：**1</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>
<li><code>-3 * 104 &lt;= nums[i] &lt;= 3 * 104</code></li>
<li>除了某个元素只出现一次以外，其余每个元素均出现两次。</li>
</ul>
<p><strong>解题思路</strong></p>
<p>最巧妙的方法就是 <strong>位运算 - 异或 XOR</strong>。</p>
<p><strong>异或运算的性质</strong>：</p>
<ul>
<li><code>a ^ a = 0</code> （一个数和自己异或等于 0）</li>
<li><code>a ^ 0 = a</code> （一个数和 0 异或等于它本身）</li>
<li><strong>异或满足交换律和结合律</strong>。</li>
</ul>
<p>所以：把所有数字依次异或，<strong>成对出现的数字都会变成 0，被抵消掉</strong>，只剩下那个唯一的数字。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 异或运算 a ^ a = 0, a ^ 0 = a</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            result ^= num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 是数组长度。只需要对数组遍历一次。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a>169. 多数元素</h2><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,2,1,1,1,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 5 * 104</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<p>**进阶：**尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。</p>
<p><strong>解题思路</strong></p>
<p>最优解法是 <strong>Boyer-Moore 投票算法</strong>。</p>
<p>多数元素的出现次数 &gt; ⌊n&#x2F;2⌋。</p>
<p><strong>投票法</strong>：</p>
<ul>
<li>维护一个候选人 candidate 和一个计数器 count。</li>
<li>遍历数组：<ul>
<li>如果 count &#x3D;&#x3D; 0，设置当前数为候选人 candidate。</li>
<li>如果当前数 &#x3D;&#x3D; candidate，count++；否则 count–。</li>
</ul>
</li>
<li>遍历结束，candidate 就是多数元素</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 计数器</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 候选人</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// count 为 0 时，将当前数设置为 candidate</span></span><br><span class="line">        <span class="comment">// 遍历数组，如果当前数为 candidate，count++；否则 count--</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            count += (candidate == num) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)。Boyer-Moore 算法只对数组进行了一次遍历。</p>
<p>空间复杂度：O(1)。Boyer-Moore 算法只需要常数级别的额外空间。</p>
<h2 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a>75. 颜色分类</h2><p>给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组 <code>nums</code> ，<strong>原地</strong> 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p>
<p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p>
<p>**示例 1：**f</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,0,2,1,1,0]</span><br><span class="line">输出：[0,0,1,1,2,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,0,1]</span><br><span class="line">输出：[0,1,2]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 300</code></li>
<li><code>nums[i]</code> 为 <code>0</code>、<code>1</code> 或 <code>2</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li>
</ul>
<p><strong>解题思路</strong></p>
<p>我们用三个指针来维护区间：</p>
<ul>
<li><code>p0</code>：下一个 <code>0</code> 应该放置的位置；</li>
<li><code>p2</code>：下一个 <code>2</code> 应该放置的位置；</li>
<li><code>i</code>：当前扫描的位置。</li>
</ul>
<p>遍历 <code>nums</code>：</p>
<ul>
<li>如果 <code>nums[i] == 0</code>，说明它应该放到最前面：<ul>
<li>与 <code>nums[p0]</code> 交换，并移动 <code>p0++</code> 和 <code>i++</code>。</li>
</ul>
</li>
<li>如果 <code>nums[i] == 2</code>，说明它应该放到最后面：<ul>
<li>与 <code>nums[p2]</code> 交换，并移动 <code>p2--</code>（注意此时不能 <code>i++</code>，因为交换过来的数还没处理）。</li>
</ul>
</li>
<li>如果 <code>nums[i] == 1</code>，就继续 <code>i++</code>。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p0</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 下一个 0 的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;  <span class="comment">// 下一个 2 的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 当前位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= p2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums, i, p0);</span><br><span class="line">                p0++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 还不能移动 i，需要先处理交换过来的数</span></span><br><span class="line">                swap(nums, i, p2);</span><br><span class="line">                p2--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是数组 nums 的长度。</p>
<p>空间复杂度：O(1)。</p>
<h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a>31. 下一个排列</h2><p>整数数组的一个 <strong>排列</strong> 就是将其所有成员以序列或线性顺序排列。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li>
</ul>
<p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li>
<li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li>
<li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li>
</ul>
<p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p>
<p>必须<strong>原地</strong>修改，只允许使用额外常数空间。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,1]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,5]</span><br><span class="line">输出：[1,5,1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<p><strong>解题思路</strong></p>
<p>注意到下一个排列总是比当前排列要大，除非该排列已经是最大的排列。我们希望找到一种方法，能够找到一个大于当前序列的新序列，且变大的幅度尽可能小。</p>
<p>阶段 1：从后往前找到第一个下降点 <code>i</code></p>
<ul>
<li>即满足 <code>nums[i] &lt; nums[i+1]</code> 的最大下标 <code>i</code>。</li>
<li>说明从 <code>i+1</code> 到末尾是一个非升序序列（最大排列）。</li>
<li>如果找不到这样的 <code>i</code>，说明整个数组是非升序（最大排列），直接反转整个数组即可。</li>
</ul>
<p>阶段 2：再从后往前找到第一个比 <code>nums[i]</code> 大的数 <code>j</code></p>
<ul>
<li>因为 <code>i+1..end</code> 是非升序，找到的第一个比 <code>nums[i]</code> 大的数，一定是“刚刚比它大”的数。</li>
</ul>
<p>阶段 3：交换 <code>nums[i]</code> 和 <code>nums[j]</code></p>
<ul>
<li>这样确保 <code>nums[0..i]</code> 变大，并且尽可能小。</li>
</ul>
<p>阶段 4：反转 <code>nums[i+1..end]</code></p>
<ul>
<li>让尾部恢复成最小字典序。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length; </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 1. 找到第一个下降点</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 2. 从后往前找第一个比 nums[i] 大的数 </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3. 交换</span></span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 反转 i+1...end</span></span><br><span class="line">        reverse(nums, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            swap(nums, left, right);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 N 为给定序列的长度。我们至多只需要扫描两次序列，以及进行一次反转操作。</p>
<p>空间复杂度：O(1)，只需要常数的空间存放若干变量。</p>
<h2 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a>287. 寻找重复数</h2><p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code> ，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。</p>
<p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回 <strong>这个重复的数</strong> 。</p>
<p>你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code> 且只用常量级 <code>O(1)</code> 的额外空间</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3,4,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,1,3,4,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 3 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,3,3,3,3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>nums.length == n + 1</code></li>
<li><code>1 &lt;= nums[i] &lt;= n</code></li>
<li><code>nums</code> 中 <strong>只有一个整数</strong> 出现 <strong>两次或多次</strong> ，其余整数均只出现 <strong>一次</strong></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>如何证明 <code>nums</code> 中至少存在一个重复的数字?</li>
<li>你可以设计一个线性级时间复杂度 <code>O(n)</code> 的解决方案吗？</li>
</ul>
<p><strong>解题思路</strong></p>
<p>这其实是 <strong>Floyd 判圈算法（龟兔赛跑算法）</strong> 的应用。</p>
<p>把数组看成一个<strong>链表</strong>：</p>
<ul>
<li>索引是节点，<code>nums[i]</code> 是指针。</li>
<li>由于有重复数，链表中一定会出现“环”。</li>
<li>问题转化为：找出环的入口，就是重复的数字。</li>
</ul>
<p>阶段 1：找环内的相遇点</p>
<ul>
<li>用快慢指针：<ul>
<li>慢指针 <code>slow = nums[slow]</code></li>
<li>快指针 <code>fast = nums[nums[fast]]</code></li>
</ul>
</li>
<li>它们一定会在环中相遇。</li>
</ul>
<p>阶段 2：找到环的入口（即重复数）</p>
<ul>
<li>一个指针从头开始 <code>p1 = 0</code></li>
<li>一个指针从相遇点开始 <code>p2 = slow</code></li>
<li>两个指针一起走，每次 <code>p1 = nums[p1], p2 = nums[p2]</code></li>
<li>相遇点就是重复数。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到相遇点</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到环入口</span></span><br><span class="line">        slow = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)。其中 n 为数组长度。算法分为两步：第一步利用快慢指针寻找相遇点，最坏情况下需要 O(n) 步；第二步从头开始再次移动指针寻找环的入口，同样最多 O(n) 步，因此整体复杂度为 O(n)。</p>
<p>空间复杂度：O(1)。只使用了若干指针变量（slow 和 fast），不依赖额外数据结构。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
